// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"kn9T2":[function(require,module,exports) {
var Refresh = require('react-refresh/runtime');
Refresh.injectIntoGlobalHook(window);
window.$RefreshReg$ = function() {
};
window.$RefreshSig$ = function() {
    return function(type) {
        return type;
    };
};

},{"react-refresh/runtime":"786KC"}],"786KC":[function(require,module,exports) {
'use strict';
module.exports = require('./cjs/react-refresh-runtime.development.js');

},{"./cjs/react-refresh-runtime.development.js":"hdge7"}],"hdge7":[function(require,module,exports) {
/** @license React v0.9.0
 * react-refresh-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE = 60103;
    var REACT_PORTAL_TYPE = 60106;
    var REACT_FRAGMENT_TYPE = 60107;
    var REACT_STRICT_MODE_TYPE = 60108;
    var REACT_PROFILER_TYPE = 60114;
    var REACT_PROVIDER_TYPE = 60109;
    var REACT_CONTEXT_TYPE = 60110;
    var REACT_FORWARD_REF_TYPE = 60112;
    var REACT_SUSPENSE_TYPE = 60113;
    var REACT_SUSPENSE_LIST_TYPE = 60120;
    var REACT_MEMO_TYPE = 60115;
    var REACT_LAZY_TYPE = 60116;
    var REACT_BLOCK_TYPE = 60121;
    var REACT_SERVER_BLOCK_TYPE = 60122;
    var REACT_FUNDAMENTAL_TYPE = 60117;
    var REACT_SCOPE_TYPE = 60119;
    var REACT_OPAQUE_ID_TYPE = 60128;
    var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
    var REACT_OFFSCREEN_TYPE = 60130;
    var REACT_LEGACY_HIDDEN_TYPE = 60131;
    if (typeof Symbol === 'function' && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor('react.element');
        REACT_PORTAL_TYPE = symbolFor('react.portal');
        REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
        REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
        REACT_PROFILER_TYPE = symbolFor('react.profiler');
        REACT_PROVIDER_TYPE = symbolFor('react.provider');
        REACT_CONTEXT_TYPE = symbolFor('react.context');
        REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
        REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
        REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
        REACT_MEMO_TYPE = symbolFor('react.memo');
        REACT_LAZY_TYPE = symbolFor('react.lazy');
        REACT_BLOCK_TYPE = symbolFor('react.block');
        REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
        REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
        REACT_SCOPE_TYPE = symbolFor('react.scope');
        REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
        REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
        REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
        REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
    }
    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.
    // It's OK to reference families, but use WeakMap/Set for types.
    var allFamiliesByID = new Map();
    var allFamiliesByType = new PossiblyWeakMap();
    var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families
    // that have actually been edited here. This keeps checks fast.
    // $FlowIssue
    var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.
    // It is an array of [Family, NextType] tuples.
    var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.
    var helpersByRendererID = new Map();
    var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.
    var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.
    var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.
    // It needs to be weak because we do this even for roots that failed to mount.
    // If there is no WeakMap, we won't attempt to do retrying.
    // $FlowIssue
    var rootElements = typeof WeakMap === 'function' ? new WeakMap() : null;
    var isPerformingRefresh = false;
    function computeFullKey(signature) {
        if (signature.fullKey !== null) return signature.fullKey;
        var fullKey = signature.ownKey;
        var hooks;
        try {
            hooks = signature.getCustomHooks();
        } catch (err) {
            // This can happen in an edge case, e.g. if expression like Foo.useSomething
            // depends on Foo which is lazily initialized during rendering.
            // In that case just assume we'll have to remount.
            signature.forceReset = true;
            signature.fullKey = fullKey;
            return fullKey;
        }
        for(var i = 0; i < hooks.length; i++){
            var hook = hooks[i];
            if (typeof hook !== 'function') {
                // Something's wrong. Assume we need to remount.
                signature.forceReset = true;
                signature.fullKey = fullKey;
                return fullKey;
            }
            var nestedHookSignature = allSignaturesByType.get(hook);
            if (nestedHookSignature === undefined) continue;
            var nestedHookKey = computeFullKey(nestedHookSignature);
            if (nestedHookSignature.forceReset) signature.forceReset = true;
            fullKey += '\n---\n' + nestedHookKey;
        }
        signature.fullKey = fullKey;
        return fullKey;
    }
    function haveEqualSignatures(prevType, nextType) {
        var prevSignature = allSignaturesByType.get(prevType);
        var nextSignature = allSignaturesByType.get(nextType);
        if (prevSignature === undefined && nextSignature === undefined) return true;
        if (prevSignature === undefined || nextSignature === undefined) return false;
        if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) return false;
        if (nextSignature.forceReset) return false;
        return true;
    }
    function isReactClass(type) {
        return type.prototype && type.prototype.isReactComponent;
    }
    function canPreserveStateBetween(prevType, nextType) {
        if (isReactClass(prevType) || isReactClass(nextType)) return false;
        if (haveEqualSignatures(prevType, nextType)) return true;
        return false;
    }
    function resolveFamily(type) {
        // Only check updated types to keep lookups fast.
        return updatedFamiliesByType.get(type);
    } // If we didn't care about IE11, we could use new Map/Set(iterable).
    function cloneMap(map) {
        var clone = new Map();
        map.forEach(function(value, key) {
            clone.set(key, value);
        });
        return clone;
    }
    function cloneSet(set) {
        var clone = new Set();
        set.forEach(function(value) {
            clone.add(value);
        });
        return clone;
    }
    function performReactRefresh() {
        if (pendingUpdates.length === 0) return null;
        if (isPerformingRefresh) return null;
        isPerformingRefresh = true;
        try {
            var staleFamilies = new Set();
            var updatedFamilies = new Set();
            var updates = pendingUpdates;
            pendingUpdates = [];
            updates.forEach(function(_ref) {
                var family = _ref[0], nextType = _ref[1];
                // Now that we got a real edit, we can create associations
                // that will be read by the React reconciler.
                var prevType = family.current;
                updatedFamiliesByType.set(prevType, family);
                updatedFamiliesByType.set(nextType, family);
                family.current = nextType; // Determine whether this should be a re-render or a re-mount.
                if (canPreserveStateBetween(prevType, nextType)) updatedFamilies.add(family);
                else staleFamilies.add(family);
            }); // TODO: rename these fields to something more meaningful.
            var update = {
                updatedFamilies: updatedFamilies,
                // Families that will re-render preserving state
                staleFamilies: staleFamilies // Families that will be remounted
            };
            helpersByRendererID.forEach(function(helpers) {
                // Even if there are no roots, set the handler on first update.
                // This ensures that if *new* roots are mounted, they'll use the resolve handler.
                helpers.setRefreshHandler(resolveFamily);
            });
            var didError = false;
            var firstError = null; // We snapshot maps and sets that are mutated during commits.
            // If we don't do this, there is a risk they will be mutated while
            // we iterate over them. For example, trying to recover a failed root
            // may cause another root to be added to the failed list -- an infinite loop.
            var failedRootsSnapshot = cloneSet(failedRoots);
            var mountedRootsSnapshot = cloneSet(mountedRoots);
            var helpersByRootSnapshot = cloneMap(helpersByRoot);
            failedRootsSnapshot.forEach(function(root) {
                var helpers = helpersByRootSnapshot.get(root);
                if (helpers === undefined) throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
                failedRoots.has(root);
                if (rootElements === null) return;
                if (!rootElements.has(root)) return;
                var element = rootElements.get(root);
                try {
                    helpers.scheduleRoot(root, element);
                } catch (err) {
                    if (!didError) {
                        didError = true;
                        firstError = err;
                    } // Keep trying other roots.
                }
            });
            mountedRootsSnapshot.forEach(function(root) {
                var helpers = helpersByRootSnapshot.get(root);
                if (helpers === undefined) throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
                mountedRoots.has(root);
                try {
                    helpers.scheduleRefresh(root, update);
                } catch (err) {
                    if (!didError) {
                        didError = true;
                        firstError = err;
                    } // Keep trying other roots.
                }
            });
            if (didError) throw firstError;
            return update;
        } finally{
            isPerformingRefresh = false;
        }
    }
    function register(type, id) {
        if (type === null) return;
        if (typeof type !== 'function' && typeof type !== 'object') return;
         // This can happen in an edge case, e.g. if we register
        // return value of a HOC but it returns a cached component.
        // Ignore anything but the first registration for each type.
        if (allFamiliesByType.has(type)) return;
         // Create family or remember to update it.
        // None of this bookkeeping affects reconciliation
        // until the first performReactRefresh() call above.
        var family = allFamiliesByID.get(id);
        if (family === undefined) {
            family = {
                current: type
            };
            allFamiliesByID.set(id, family);
        } else pendingUpdates.push([
            family,
            type
        ]);
        allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.
        if (typeof type === 'object' && type !== null) switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                register(type.render, id + '$render');
                break;
            case REACT_MEMO_TYPE:
                register(type.type, id + '$type');
                break;
        }
    }
    function setSignature(type, key) {
        var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;
        allSignaturesByType.set(type, {
            forceReset: forceReset,
            ownKey: key,
            fullKey: null,
            getCustomHooks: getCustomHooks || function() {
                return [];
            }
        });
    } // This is lazily called during first render for a type.
    // It captures Hook list at that time so inline requires don't break comparisons.
    function collectCustomHooksForSignature(type) {
        var signature = allSignaturesByType.get(type);
        if (signature !== undefined) computeFullKey(signature);
    }
    function getFamilyByID(id) {
        return allFamiliesByID.get(id);
    }
    function getFamilyByType(type) {
        return allFamiliesByType.get(type);
    }
    function findAffectedHostInstances(families) {
        var affectedInstances = new Set();
        mountedRoots.forEach(function(root) {
            var helpers = helpersByRoot.get(root);
            if (helpers === undefined) throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
            var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);
            instancesForRoot.forEach(function(inst) {
                affectedInstances.add(inst);
            });
        });
        return affectedInstances;
    }
    function injectIntoGlobalHook(globalObject) {
        // For React Native, the global hook will be set up by require('react-devtools-core').
        // That code will run before us. So we need to monkeypatch functions on existing hook.
        // For React Web, the global hook will be set up by the extension.
        // This will also run before us.
        var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (hook === undefined) {
            // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.
            // Note that in this case it's important that renderer code runs *after* this method call.
            // Otherwise, the renderer will think that there is no global hook, and won't do the injection.
            var nextID = 0;
            globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {
                renderers: new Map(),
                supportsFiber: true,
                inject: function(injected) {
                    return nextID++;
                },
                onScheduleFiberRoot: function(id, root, children) {
                },
                onCommitFiberRoot: function(id, root, maybePriorityLevel, didError) {
                },
                onCommitFiberUnmount: function() {
                }
            };
        } // Here, we just want to get a reference to scheduleRefresh.
        var oldInject = hook.inject;
        hook.inject = function(injected) {
            var id = oldInject.apply(this, arguments);
            if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') // This version supports React Refresh.
            helpersByRendererID.set(id, injected);
            return id;
        }; // Do the same for any already injected roots.
        // This is useful if ReactDOM has already been initialized.
        // https://github.com/facebook/react/issues/17626
        hook.renderers.forEach(function(injected, id) {
            if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') // This version supports React Refresh.
            helpersByRendererID.set(id, injected);
        }); // We also want to track currently mounted roots.
        var oldOnCommitFiberRoot = hook.onCommitFiberRoot;
        var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function() {
        };
        hook.onScheduleFiberRoot = function(id, root, children) {
            if (!isPerformingRefresh) {
                // If it was intentionally scheduled, don't attempt to restore.
                // This includes intentionally scheduled unmounts.
                failedRoots.delete(root);
                if (rootElements !== null) rootElements.set(root, children);
            }
            return oldOnScheduleFiberRoot.apply(this, arguments);
        };
        hook.onCommitFiberRoot = function(id, root, maybePriorityLevel, didError) {
            var helpers = helpersByRendererID.get(id);
            if (helpers === undefined) return;
            helpersByRoot.set(root, helpers);
            var current = root.current;
            var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.
            // This logic is copy-pasted from similar logic in the DevTools backend.
            // If this breaks with some refactoring, you'll want to update DevTools too.
            if (alternate !== null) {
                var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;
                var isMounted = current.memoizedState != null && current.memoizedState.element != null;
                if (!wasMounted && isMounted) {
                    // Mount a new root.
                    mountedRoots.add(root);
                    failedRoots.delete(root);
                } else if (wasMounted && isMounted) ;
                else if (wasMounted && !isMounted) {
                    // Unmount an existing root.
                    mountedRoots.delete(root);
                    if (didError) // We'll remount it on future edits.
                    failedRoots.add(root);
                    else helpersByRoot.delete(root);
                } else if (!wasMounted && !isMounted) {
                    if (didError) // We'll remount it on future edits.
                    failedRoots.add(root);
                }
            } else // Mount a new root.
            mountedRoots.add(root);
            return oldOnCommitFiberRoot.apply(this, arguments);
        };
    }
    function hasUnrecoverableErrors() {
        // TODO: delete this after removing dependency in RN.
        return false;
    } // Exposed for testing.
    function _getMountedRootCount() {
        return mountedRoots.size;
    } // This is a wrapper over more primitive functions for setting signature.
    // Signatures let us decide whether the Hook order has changed on refresh.
    //
    // This function is intended to be used as a transform target, e.g.:
    // var _s = createSignatureFunctionForTransform()
    //
    // function Hello() {
    //   const [foo, setFoo] = useState(0);
    //   const value = useCustomHook();
    //   _s(); /* Second call triggers collecting the custom Hook list.
    //          * This doesn't happen during the module evaluation because we
    //          * don't want to change the module order with inline requires.
    //          * Next calls are noops. */
    //   return <h1>Hi</h1>;
    // }
    //
    // /* First call specifies the signature: */
    // _s(
    //   Hello,
    //   'useState{[foo, setFoo]}(0)',
    //   () => [useCustomHook], /* Lazy to avoid triggering inline requires */
    // );
    function createSignatureFunctionForTransform() {
        // We'll fill in the signature in two steps.
        // First, we'll know the signature itself. This happens outside the component.
        // Then, we'll know the references to custom Hooks. This happens inside the component.
        // After that, the returned function will be a fast path no-op.
        var status = 'needsSignature';
        var savedType;
        var hasCustomHooks;
        return function(type, key, forceReset, getCustomHooks) {
            switch(status){
                case 'needsSignature':
                    if (type !== undefined) {
                        // If we received an argument, this is the initial registration call.
                        savedType = type;
                        hasCustomHooks = typeof getCustomHooks === 'function';
                        setSignature(type, key, forceReset, getCustomHooks); // The next call we expect is from inside a function, to fill in the custom Hooks.
                        status = 'needsCustomHooks';
                    }
                    break;
                case 'needsCustomHooks':
                    if (hasCustomHooks) collectCustomHooksForSignature(savedType);
                    status = 'resolved';
                    break;
            }
            return type;
        };
    }
    function isLikelyComponentType(type) {
        switch(typeof type){
            case 'function':
                // First, deal with classes.
                if (type.prototype != null) {
                    if (type.prototype.isReactComponent) // React class.
                    return true;
                    var ownNames = Object.getOwnPropertyNames(type.prototype);
                    if (ownNames.length > 1 || ownNames[0] !== 'constructor') // This looks like a class.
                    return false;
                     // eslint-disable-next-line no-proto
                    if (type.prototype.__proto__ !== Object.prototype) // It has a superclass.
                    return false;
                     // Pass through.
                // This looks like a regular function with empty prototype.
                } // For plain functions and arrows, use name as a heuristic.
                var name = type.name || type.displayName;
                return typeof name === 'string' && /^[A-Z]/.test(name);
            case 'object':
                if (type != null) switch(type.$$typeof){
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_MEMO_TYPE:
                        // Definitely React components.
                        return true;
                    default:
                        return false;
                }
                return false;
            default:
                return false;
        }
    }
    exports._getMountedRootCount = _getMountedRootCount;
    exports.collectCustomHooksForSignature = collectCustomHooksForSignature;
    exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;
    exports.findAffectedHostInstances = findAffectedHostInstances;
    exports.getFamilyByID = getFamilyByID;
    exports.getFamilyByType = getFamilyByType;
    exports.hasUnrecoverableErrors = hasUnrecoverableErrors;
    exports.injectIntoGlobalHook = injectIntoGlobalHook;
    exports.isLikelyComponentType = isLikelyComponentType;
    exports.performReactRefresh = performReactRefresh;
    exports.register = register;
    exports.setSignature = setSignature;
})();

},{}],"7nZVA":[function(require,module,exports) {
"use strict";
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "890e741a975ef6c8";
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('ðŸš¨ [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] ðŸš¨ Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] âœ¨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>ðŸ’¡ ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                var oldDeps = modules[asset.id][1];
                for(var dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    var id = oldDeps[dep];
                    var parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    var modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        var deps = modules[id1][1];
        var orphans = [];
        for(var dep in deps){
            var parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach(function(id) {
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    var parents = getParents(module.bundle.root, id);
    var accepted = false;
    while(parents.length > 0){
        var v = parents.shift();
        var a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            var p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push.apply(parents, _toConsumableArray(p));
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"8lqZg":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$20e5 = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$20e5.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _jsxDevRuntime = require("react/jsx-dev-runtime");
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _reactDom = require("react-dom");
var _reactDomDefault = parcelHelpers.interopDefault(_reactDom);
var _appJs = require("./App.js");
var _appJsDefault = parcelHelpers.interopDefault(_appJs);
const app = document.getElementById("app");
_reactDomDefault.default.render(/*#__PURE__*/ _jsxDevRuntime.jsxDEV(_appJsDefault.default, {
}, void 0, false, {
    fileName: "src/index.js",
    lineNumber: 6,
    columnNumber: 17
}, undefined), app);

  $parcel$ReactRefreshHelpers$20e5.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-dev-runtime":"iTorj","react-dom":"j6uA9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"km3Ru","./App.js":"2kQhy","react":"21dqq"}],"iTorj":[function(require,module,exports) {
'use strict';
module.exports = require('./cjs/react-jsx-dev-runtime.development.js');

},{"./cjs/react-jsx-dev-runtime.development.js":"48uCM"}],"48uCM":[function(require,module,exports) {
/** @license React v17.0.2
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    var React = require('react');
    var _assign = require('object-assign');
    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE = 60103;
    var REACT_PORTAL_TYPE = 60106;
    exports.Fragment = 60107;
    var REACT_STRICT_MODE_TYPE = 60108;
    var REACT_PROFILER_TYPE = 60114;
    var REACT_PROVIDER_TYPE = 60109;
    var REACT_CONTEXT_TYPE = 60110;
    var REACT_FORWARD_REF_TYPE = 60112;
    var REACT_SUSPENSE_TYPE = 60113;
    var REACT_SUSPENSE_LIST_TYPE = 60120;
    var REACT_MEMO_TYPE = 60115;
    var REACT_LAZY_TYPE = 60116;
    var REACT_BLOCK_TYPE = 60121;
    var REACT_SERVER_BLOCK_TYPE = 60122;
    var REACT_FUNDAMENTAL_TYPE = 60117;
    var REACT_SCOPE_TYPE = 60119;
    var REACT_OPAQUE_ID_TYPE = 60128;
    var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
    var REACT_OFFSCREEN_TYPE = 60130;
    var REACT_LEGACY_HIDDEN_TYPE = 60131;
    if (typeof Symbol === 'function' && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor('react.element');
        REACT_PORTAL_TYPE = symbolFor('react.portal');
        exports.Fragment = symbolFor('react.fragment');
        REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
        REACT_PROFILER_TYPE = symbolFor('react.profiler');
        REACT_PROVIDER_TYPE = symbolFor('react.provider');
        REACT_CONTEXT_TYPE = symbolFor('react.context');
        REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
        REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
        REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
        REACT_MEMO_TYPE = symbolFor('react.memo');
        REACT_LAZY_TYPE = symbolFor('react.lazy');
        REACT_BLOCK_TYPE = symbolFor('react.block');
        REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
        REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
        REACT_SCOPE_TYPE = symbolFor('react.scope');
        REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
        REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
        REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
        REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
    }
    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';
    function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== 'object') return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === 'function') return maybeIterator;
        return null;
    }
    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function error(format) {
        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)args[_key2 - 1] = arguments[_key2];
        printWarning('error', format, args);
    }
    function printWarning(level, format, args) {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();
        if (stack !== '') {
            format += '%s';
            args = args.concat([
                stack
            ]);
        }
        var argsWithFormat = args.map(function(item) {
            return '' + item;
        }); // Careful: RN currently depends on this prefix
        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging
        Function.prototype.apply.call(console[level], console, argsWithFormat);
    }
    // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.
    var enableScopeAPI = false; // Experimental Create Event Handle API.
    function isValidElementType(type) {
        if (typeof type === 'string' || typeof type === 'function') return true;
         // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).
        if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) return true;
        if (typeof type === 'object' && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) return true;
        }
        return false;
    }
    function getWrappedName(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || '';
        return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
    }
    function getContextName(type) {
        return type.displayName || 'Context';
    }
    function getComponentName(type) {
        if (type == null) // Host root, text node or just invalid type.
        return null;
        if (typeof type.tag === 'number') error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
        if (typeof type === 'function') return type.displayName || type.name || null;
        if (typeof type === 'string') return type;
        switch(type){
            case exports.Fragment:
                return 'Fragment';
            case REACT_PORTAL_TYPE:
                return 'Portal';
            case REACT_PROFILER_TYPE:
                return 'Profiler';
            case REACT_STRICT_MODE_TYPE:
                return 'StrictMode';
            case REACT_SUSPENSE_TYPE:
                return 'Suspense';
            case REACT_SUSPENSE_LIST_TYPE:
                return 'SuspenseList';
        }
        if (typeof type === 'object') switch(type.$$typeof){
            case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + '.Consumer';
            case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + '.Provider';
            case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, 'ForwardRef');
            case REACT_MEMO_TYPE:
                return getComponentName(type.type);
            case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    return getComponentName(init(payload));
                } catch (x) {
                    return null;
                }
        }
        return null;
    }
    // Helpers to patch console.logs to avoid logging during side-effect free
    // replaying on render function. This currently only patches the object
    // lazily which won't cover if the log function was extracted eagerly.
    // We could also eagerly patch the method.
    var disabledDepth = 0;
    var prevLog;
    var prevInfo;
    var prevWarn;
    var prevError;
    var prevGroup;
    var prevGroupCollapsed;
    var prevGroupEnd;
    function disabledLog() {
    }
    disabledLog.__reactDisabledLog = true;
    function disableLogs() {
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099
            var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        /* eslint-enable react-internal/no-production-logging */ }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ var props = {
                configurable: true,
                enumerable: true,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                log: _assign({
                }, props, {
                    value: prevLog
                }),
                info: _assign({
                }, props, {
                    value: prevInfo
                }),
                warn: _assign({
                }, props, {
                    value: prevWarn
                }),
                error: _assign({
                }, props, {
                    value: prevError
                }),
                group: _assign({
                }, props, {
                    value: prevGroup
                }),
                groupCollapsed: _assign({
                }, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: _assign({
                }, props, {
                    value: prevGroupEnd
                })
            });
        /* eslint-enable react-internal/no-production-logging */ }
        if (disabledDepth < 0) error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
    var prefix;
    function describeBuiltInComponentFrame(name, source, ownerFn) {
        if (prefix === undefined) // Extract the VM specific prefix used by each line.
        try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || '';
        }
         // We use the prefix to ensure our stacks line up with native stack frames.
        return '\n' + prefix + name;
    }
    var reentry = false;
    var componentFrameCache;
    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
    componentFrameCache = new PossiblyWeakMap();
    function describeNativeComponentFrame(fn, construct) {
        // If something asked for a stack inside a fake render, it should get ignored.
        if (!fn || reentry) return '';
        var frame = componentFrameCache.get(fn);
        if (frame !== undefined) return frame;
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
        // for warnings.
        ReactCurrentDispatcher.current = null;
        disableLogs();
        try {
            // This should throw.
            if (construct) {
                // Something should be setting the props in the constructor.
                var Fake = function() {
                    throw Error();
                }; // $FlowFixMe
                Object.defineProperty(Fake.prototype, 'props', {
                    set: function() {
                        // We use a throwing setter instead of frozen or non-writable props
                        // because that won't throw in a non-strict mode function.
                        throw Error();
                    }
                });
                if (typeof Reflect === 'object' && Reflect.construct) {
                    // We construct a different control for this case to include any extra
                    // frames added by the construct call.
                    try {
                        Reflect.construct(Fake, []);
                    } catch (x) {
                        control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                } else {
                    try {
                        Fake.call();
                    } catch (x) {
                        control = x;
                    }
                    fn.call(Fake.prototype);
                }
            } else {
                try {
                    throw Error();
                } catch (x) {
                    control = x;
                }
                fn();
            }
        } catch (sample) {
            // This is inlined manually because closure doesn't do it for us.
            if (sample && control && typeof sample.stack === 'string') {
                // This extracts the first frame from the sample that isn't also in the control.
                // Skipping one frame that we assume is the frame that calls the two.
                var sampleLines = sample.stack.split('\n');
                var controlLines = control.stack.split('\n');
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c])// We expect at least one stack frame to be shared.
                // Typically this will be the root most one. However, stack frames may be
                // cut off due to maximum stack limits. In this case, one maybe cut off
                // earlier than the other. We assume that the sample is longer or the same
                // and there for cut off earlier. So we should find the root most frame in
                // the sample somewhere in the control.
                c--;
                for(; s >= 1 && c >= 0; s--, c--)// Next we find the first one that isn't the same which should be the
                // frame that called our sample function and the control.
                if (sampleLines[s] !== controlLines[c]) {
                    // In V8, the first line is describing the message but other VMs don't.
                    // If we're about to return the first line, and the control is also on the same
                    // line, that's a pretty good indicator that our sample threw at same line as
                    // the control. I.e. before we entered the sample frame. So we ignore this result.
                    // This can happen if you passed a class to function component, or non-function.
                    if (s !== 1 || c !== 1) do {
                        s--;
                        c--; // We may still have similar intermediate frames from the construct call.
                        // The next one that isn't the same should be our match though.
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                            // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                            var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                            if (typeof fn === 'function') componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                    }while (s >= 1 && c >= 0)
                    break;
                }
            }
        } finally{
            reentry = false;
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
            Error.prepareStackTrace = previousPrepareStackTrace;
        } // Fallback to just using the name if we couldn't make it throw.
        var name = fn ? fn.displayName || fn.name : '';
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
        if (typeof fn === 'function') componentFrameCache.set(fn, syntheticFrame);
        return syntheticFrame;
    }
    function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, false);
    }
    function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
    }
    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) return '';
        if (typeof type === 'function') return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type === 'string') return describeBuiltInComponentFrame(type);
        switch(type){
            case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame('Suspense');
            case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame('SuspenseList');
        }
        if (typeof type === 'object') switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
                // Memo may contain any component type so we recursively resolve it.
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    // Lazy may contain any component type so we recursively resolve it.
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
        }
        return '';
    }
    var loggedTypeFailures = {
    };
    var ReactDebugCurrentFrame1 = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement(element) {
        if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame1.setExtraStackFrame(stack);
        } else ReactDebugCurrentFrame1.setExtraStackFrame(null);
    }
    function checkPropTypes(typeSpecs, values, location, componentName, element) {
        // $FlowFixMe This is okay but Flow doesn't know it.
        var has = Function.call.bind(Object.prototype.hasOwnProperty);
        for(var typeSpecName in typeSpecs)if (has(typeSpecs, typeSpecName)) {
            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.
            try {
                // This is intentionally an invariant that gets caught. It's the same
                // behavior as without this statement except with a better message.
                if (typeof typeSpecs[typeSpecName] !== 'function') {
                    var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                    err.name = 'Invariant Violation';
                    throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
            } catch (ex) {
                error$1 = ex;
            }
            if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || 'React class', location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
            }
            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                // Only monitor this failure once because there tends to be a lot of the
                // same error.
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error('Failed %s type: %s', location, error$1.message);
                setCurrentlyValidatingElement(null);
            }
        }
    }
    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
    };
    var specialPropKeyWarningShown;
    var specialPropRefWarningShown;
    var didWarnAboutStringRefs;
    didWarnAboutStringRefs = {
    };
    function hasValidRef(config) {
        if (hasOwnProperty.call(config, 'ref')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
            if (getter && getter.isReactWarning) return false;
        }
        return config.ref !== undefined;
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, 'key')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
            if (getter && getter.isReactWarning) return false;
        }
        return config.key !== undefined;
    }
    function warnIfStringRefCannotBeAutoConverted(config, self) {
        if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
            var componentName = getComponentName(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
                error("Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref", getComponentName(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
            }
        }
    }
    function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
        };
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, 'key', {
            get: warnAboutAccessingKey,
            configurable: true
        });
    }
    function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
        };
        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, 'ref', {
            get: warnAboutAccessingRef,
            configurable: true
        });
    }
    /**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */ var ReactElement = function(type, key, ref, self, source, owner, props) {
        var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type: type,
            key: key,
            ref: ref,
            props: props,
            // Record the component responsible for creating this element.
            _owner: owner
        };
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {
        }; // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.
        Object.defineProperty(element._store, 'validated', {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
        }); // self and source are DEV only properties.
        Object.defineProperty(element, '_self', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
        }); // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.
        Object.defineProperty(element, '_source', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
        });
        if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
        }
        return element;
    };
    /**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */ function jsxDEV(type, config, maybeKey, source, self) {
        var propName; // Reserved names are extracted
        var props = {
        };
        var key = null;
        var ref = null; // Currently, key can be spread in as a prop. This causes a potential
        // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
        // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
        // but as an intermediary step, we will use jsxDEV for everything except
        // <div {...props} key="Hi" />, because we aren't currently able to tell if
        // key is explicitly declared to be undefined or not.
        if (maybeKey !== undefined) key = '' + maybeKey;
        if (hasValidKey(config)) key = '' + config.key;
        if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self);
        } // Remaining properties are added to a new props object
        for(propName in config)if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) props[propName] = config[propName];
         // Resolve default props
        if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for(propName in defaultProps)if (props[propName] === undefined) props[propName] = defaultProps[propName];
        }
        if (key || ref) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
            if (key) defineKeyPropWarningGetter(props, displayName);
            if (ref) defineRefPropWarningGetter(props, displayName);
        }
        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }
    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement$1(element) {
        if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
    var propTypesMisspellWarningShown;
    propTypesMisspellWarningShown = false;
    /**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */ function isValidElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner$1.current) {
            var name = getComponentName(ReactCurrentOwner$1.current.type);
            if (name) return '\n\nCheck the render method of `' + name + '`.';
        }
        return '';
    }
    function getSourceInfoErrorAddendum(source) {
        if (source !== undefined) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, '');
            var lineNumber = source.lineNumber;
            return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
        }
        return '';
    }
    /**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */ var ownerHasKeyUseWarning = {
    };
    function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();
        if (!info) {
            var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
            if (parentName) info = "\n\nCheck the top-level render call using <" + parentName + ">.";
        }
        return info;
    }
    /**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */ function validateExplicitKey(element, parentType) {
        if (!element._store || element._store.validated || element.key != null) return;
        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) return;
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
        // property, it may be the creator of the child that's responsible for
        // assigning it a key.
        var childOwner = '';
        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) // Give the component that originally created this child.
        childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
        setCurrentlyValidatingElement$1(element);
        error("Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.", currentComponentErrorInfo, childOwner);
        setCurrentlyValidatingElement$1(null);
    }
    /**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */ function validateChildKeys(node, parentType) {
        if (typeof node !== 'object') return;
        if (Array.isArray(node)) for(var i = 0; i < node.length; i++){
            var child = node[i];
            if (isValidElement(child)) validateExplicitKey(child, parentType);
        }
        else if (isValidElement(node)) // This element was passed in a valid location.
        {
            if (node._store) node._store.validated = true;
        } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === 'function') // Entry iterators used to provide implicit keys,
            // but now we print a separate warning for them later.
            {
                if (iteratorFn !== node.entries) {
                    var iterator = iteratorFn.call(node);
                    var step;
                    while(!(step = iterator.next()).done)if (isValidElement(step.value)) validateExplicitKey(step.value, parentType);
                }
            }
        }
    }
    /**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */ function validatePropTypes(element) {
        var type = element.type;
        if (type === null || type === undefined || typeof type === 'string') return;
        var propTypes;
        if (typeof type === 'function') propTypes = type.propTypes;
        else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Inner props are checked in the reconciler.
        type.$$typeof === REACT_MEMO_TYPE)) propTypes = type.propTypes;
        else return;
        if (propTypes) {
            // Intentionally inside to avoid triggering lazy initializers:
            var name = getComponentName(type);
            checkPropTypes(propTypes, element.props, 'prop', name, element);
        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:
            var _name = getComponentName(type);
            error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
        }
        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
    /**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */ function validateFragmentProps(fragment) {
        var keys = Object.keys(fragment.props);
        for(var i = 0; i < keys.length; i++){
            var key = keys[i];
            if (key !== 'children' && key !== 'key') {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
            }
        }
        if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error('Invalid attribute `ref` supplied to `React.Fragment`.');
            setCurrentlyValidatingElement$1(null);
        }
    }
    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
        // succeed and there will likely be errors in render.
        if (!validType) {
            var info = '';
            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            var sourceInfo = getSourceInfoErrorAddendum(source);
            if (sourceInfo) info += sourceInfo;
            else info += getDeclarationErrorAddendum();
            var typeString;
            if (type === null) typeString = 'null';
            else if (Array.isArray(type)) typeString = 'array';
            else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
                info = ' Did you accidentally export a JSX literal instead of a component?';
            } else typeString = typeof type;
            error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
        }
        var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
        // TODO: Drop this when these are no longer allowed as the type argument.
        if (element == null) return element;
         // Skip key warning if the type isn't valid since our key validation logic
        // doesn't expect a non-string/function type and can throw confusing errors.
        // We don't want exception behavior to differ between dev and prod.
        // (Rendering will throw with a helpful message and as soon as the type is
        // fixed, the key warnings will appear.)
        if (validType) {
            var children = props.children;
            if (children !== undefined) {
                if (isStaticChildren) {
                    if (Array.isArray(children)) {
                        for(var i = 0; i < children.length; i++)validateChildKeys(children[i], type);
                        if (Object.freeze) Object.freeze(children);
                    } else error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                } else validateChildKeys(children, type);
            }
        }
        if (type === exports.Fragment) validateFragmentProps(element);
        else validatePropTypes(element);
        return element;
    } // These two functions exist to still get child warnings in dev
    var jsxDEV$1 = jsxWithValidation;
    exports.jsxDEV = jsxDEV$1;
})();

},{"react":"21dqq","object-assign":"7OXxh"}],"21dqq":[function(require,module,exports) {
'use strict';
module.exports = require('./cjs/react.development.js');

},{"./cjs/react.development.js":"6YvXz"}],"6YvXz":[function(require,module,exports) {
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    var _assign = require('object-assign');
    // TODO: this is special because it gets imported during build.
    var ReactVersion = '17.0.2';
    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE = 60103;
    var REACT_PORTAL_TYPE = 60106;
    exports.Fragment = 60107;
    exports.StrictMode = 60108;
    exports.Profiler = 60114;
    var REACT_PROVIDER_TYPE = 60109;
    var REACT_CONTEXT_TYPE = 60110;
    var REACT_FORWARD_REF_TYPE = 60112;
    exports.Suspense = 60113;
    var REACT_SUSPENSE_LIST_TYPE = 60120;
    var REACT_MEMO_TYPE = 60115;
    var REACT_LAZY_TYPE = 60116;
    var REACT_BLOCK_TYPE = 60121;
    var REACT_SERVER_BLOCK_TYPE = 60122;
    var REACT_FUNDAMENTAL_TYPE = 60117;
    var REACT_SCOPE_TYPE = 60119;
    var REACT_OPAQUE_ID_TYPE = 60128;
    var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
    var REACT_OFFSCREEN_TYPE = 60130;
    var REACT_LEGACY_HIDDEN_TYPE = 60131;
    if (typeof Symbol === 'function' && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor('react.element');
        REACT_PORTAL_TYPE = symbolFor('react.portal');
        exports.Fragment = symbolFor('react.fragment');
        exports.StrictMode = symbolFor('react.strict_mode');
        exports.Profiler = symbolFor('react.profiler');
        REACT_PROVIDER_TYPE = symbolFor('react.provider');
        REACT_CONTEXT_TYPE = symbolFor('react.context');
        REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
        exports.Suspense = symbolFor('react.suspense');
        REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
        REACT_MEMO_TYPE = symbolFor('react.memo');
        REACT_LAZY_TYPE = symbolFor('react.lazy');
        REACT_BLOCK_TYPE = symbolFor('react.block');
        REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
        REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
        REACT_SCOPE_TYPE = symbolFor('react.scope');
        REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
        REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
        REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
        REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
    }
    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';
    function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== 'object') return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === 'function') return maybeIterator;
        return null;
    }
    /**
 * Keeps track of the current dispatcher.
 */ var ReactCurrentDispatcher = {
        /**
   * @internal
   * @type {ReactComponent}
   */ current: null
    };
    /**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */ var ReactCurrentBatchConfig = {
        transition: 0
    };
    /**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */ var ReactCurrentOwner = {
        /**
   * @internal
   * @type {ReactComponent}
   */ current: null
    };
    var ReactDebugCurrentFrame1 = {
    };
    var currentExtraStackFrame = null;
    function setExtraStackFrame(stack) {
        currentExtraStackFrame = stack;
    }
    ReactDebugCurrentFrame1.setExtraStackFrame = function(stack) {
        currentExtraStackFrame = stack;
    }; // Stack implementation injected by the current renderer.
    ReactDebugCurrentFrame1.getCurrentStack = null;
    ReactDebugCurrentFrame1.getStackAddendum = function() {
        var stack = ''; // Add an extra top frame while an element is being validated
        if (currentExtraStackFrame) stack += currentExtraStackFrame;
         // Delegate to the injected renderer-specific implementation
        var impl = ReactDebugCurrentFrame1.getCurrentStack;
        if (impl) stack += impl() || '';
        return stack;
    };
    /**
 * Used by act() to track whether you're inside an act() scope.
 */ var IsSomeRendererActing = {
        current: false
    };
    var ReactSharedInternals = {
        ReactCurrentDispatcher: ReactCurrentDispatcher,
        ReactCurrentBatchConfig: ReactCurrentBatchConfig,
        ReactCurrentOwner: ReactCurrentOwner,
        IsSomeRendererActing: IsSomeRendererActing,
        // Used by renderers to avoid bundling object-assign twice in UMD bundles:
        assign: _assign
    };
    ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame1;
    // by calls to these methods by a Babel plugin.
    //
    // In PROD (or in packages without access to React internals),
    // they are left as they are instead.
    function warn(format) {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
        printWarning('warn', format, args);
    }
    function error1(format) {
        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)args[_key2 - 1] = arguments[_key2];
        printWarning('error', format, args);
    }
    function printWarning(level, format, args) {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();
        if (stack !== '') {
            format += '%s';
            args = args.concat([
                stack
            ]);
        }
        var argsWithFormat = args.map(function(item) {
            return '' + item;
        }); // Careful: RN currently depends on this prefix
        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging
        Function.prototype.apply.call(console[level], console, argsWithFormat);
    }
    var didWarnStateUpdateForUnmountedComponent = {
    };
    function warnNoop(publicInstance, callerName) {
        var _constructor = publicInstance.constructor;
        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
        var warningKey = componentName + "." + callerName;
        if (didWarnStateUpdateForUnmountedComponent[warningKey]) return;
        error1("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
    }
    /**
 * This is the abstract API for an update queue.
 */ var ReactNoopUpdateQueue = {
        /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */ isMounted: function(publicInstance) {
            return false;
        },
        /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */ enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, 'forceUpdate');
        },
        /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */ enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, 'replaceState');
        },
        /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */ enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, 'setState');
        }
    };
    var emptyObject = {
    };
    Object.freeze(emptyObject);
    /**
 * Base class helpers for the updating state of a component.
 */ function Component1(props, context, updater) {
        this.props = props;
        this.context = context; // If a component has string refs, we will assign a different object later.
        this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
        // renderer.
        this.updater = updater || ReactNoopUpdateQueue;
    }
    Component1.prototype.isReactComponent = {
    };
    /**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */ Component1.prototype.setState = function(partialState, callback) {
        if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, partialState, callback, 'setState');
    };
    /**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */ Component1.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
    };
    var deprecatedAPIs = {
        isMounted: [
            'isMounted',
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
            'replaceState',
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
    };
    var defineDeprecationWarning = function(methodName, info) {
        Object.defineProperty(Component1.prototype, methodName, {
            get: function() {
                warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
                return undefined;
            }
        });
    };
    for(var fnName in deprecatedAPIs)if (deprecatedAPIs.hasOwnProperty(fnName)) defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    function ComponentDummy() {
    }
    ComponentDummy.prototype = Component1.prototype;
    /**
 * Convenience component with default shallow equality check for sCU.
 */ function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context; // If a component has string refs, we will assign a different object later.
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
    }
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.
    _assign(pureComponentPrototype, Component1.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    // an immutable object with a single mutable value
    function createRef() {
        var refObject = {
            current: null
        };
        Object.seal(refObject);
        return refObject;
    }
    function getWrappedName(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || '';
        return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
    }
    function getContextName(type) {
        return type.displayName || 'Context';
    }
    function getComponentName(type) {
        if (type == null) // Host root, text node or just invalid type.
        return null;
        if (typeof type.tag === 'number') error1("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
        if (typeof type === 'function') return type.displayName || type.name || null;
        if (typeof type === 'string') return type;
        switch(type){
            case exports.Fragment:
                return 'Fragment';
            case REACT_PORTAL_TYPE:
                return 'Portal';
            case exports.Profiler:
                return 'Profiler';
            case exports.StrictMode:
                return 'StrictMode';
            case exports.Suspense:
                return 'Suspense';
            case REACT_SUSPENSE_LIST_TYPE:
                return 'SuspenseList';
        }
        if (typeof type === 'object') switch(type.$$typeof){
            case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + '.Consumer';
            case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + '.Provider';
            case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, 'ForwardRef');
            case REACT_MEMO_TYPE:
                return getComponentName(type.type);
            case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    return getComponentName(init(payload));
                } catch (x) {
                    return null;
                }
        }
        return null;
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
    };
    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
    didWarnAboutStringRefs = {
    };
    function hasValidRef(config) {
        if (hasOwnProperty.call(config, 'ref')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
            if (getter && getter.isReactWarning) return false;
        }
        return config.ref !== undefined;
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, 'key')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
            if (getter && getter.isReactWarning) return false;
        }
        return config.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error1("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
        };
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, 'key', {
            get: warnAboutAccessingKey,
            configurable: true
        });
    }
    function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error1("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
        };
        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, 'ref', {
            get: warnAboutAccessingRef,
            configurable: true
        });
    }
    function warnIfStringRefCannotBeAutoConverted(config) {
        if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
            var componentName = getComponentName(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
                error1("Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref", componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
            }
        }
    }
    /**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */ var ReactElement = function(type, key, ref, self, source, owner, props) {
        var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type: type,
            key: key,
            ref: ref,
            props: props,
            // Record the component responsible for creating this element.
            _owner: owner
        };
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {
        }; // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.
        Object.defineProperty(element._store, 'validated', {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
        }); // self and source are DEV only properties.
        Object.defineProperty(element, '_self', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
        }); // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.
        Object.defineProperty(element, '_source', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
        });
        if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
        }
        return element;
    };
    /**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */ function createElement(type, config, children) {
        var propName; // Reserved names are extracted
        var props = {
        };
        var key = null;
        var ref = null;
        var self = null;
        var source = null;
        if (config != null) {
            if (hasValidRef(config)) {
                ref = config.ref;
                warnIfStringRefCannotBeAutoConverted(config);
            }
            if (hasValidKey(config)) key = '' + config.key;
            self = config.__self === undefined ? null : config.__self;
            source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object
            for(propName in config)if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) props[propName] = config[propName];
        } // Children can be more than one argument, and those are transferred onto
        // the newly allocated props object.
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) props.children = children;
        else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for(var i = 0; i < childrenLength; i++)childArray[i] = arguments[i + 2];
            if (Object.freeze) Object.freeze(childArray);
            props.children = childArray;
        } // Resolve default props
        if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for(propName in defaultProps)if (props[propName] === undefined) props[propName] = defaultProps[propName];
        }
        if (key || ref) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
            if (key) defineKeyPropWarningGetter(props, displayName);
            if (ref) defineRefPropWarningGetter(props, displayName);
        }
        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }
    function cloneAndReplaceKey(oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
    }
    /**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */ function cloneElement(element, config, children) {
        if (!!(element === null || element === undefined)) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
        var propName; // Original props are copied
        var props = _assign({
        }, element.props); // Reserved names are extracted
        var key = element.key;
        var ref = element.ref; // Self is preserved since the owner is preserved.
        var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
        // transpiler, and the original source is probably a better indicator of the
        // true owner.
        var source = element._source; // Owner will be preserved, unless ref is overridden
        var owner = element._owner;
        if (config != null) {
            if (hasValidRef(config)) {
                // Silently steal the ref from the parent.
                ref = config.ref;
                owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) key = '' + config.key;
             // Remaining properties override existing props
            var defaultProps;
            if (element.type && element.type.defaultProps) defaultProps = element.type.defaultProps;
            for(propName in config)if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === undefined && defaultProps !== undefined) // Resolve default props
                props[propName] = defaultProps[propName];
                else props[propName] = config[propName];
            }
        } // Children can be more than one argument, and those are transferred onto
        // the newly allocated props object.
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) props.children = children;
        else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for(var i = 0; i < childrenLength; i++)childArray[i] = arguments[i + 2];
            props.children = childArray;
        }
        return ReactElement(element.type, key, ref, self, source, owner, props);
    }
    /**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */ function isValidElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';
    /**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */ function escape(key) {
        var escapeRegex = /[=:]/g;
        var escaperLookup = {
            '=': '=0',
            ':': '=2'
        };
        var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
        });
        return '$' + escapedString;
    }
    /**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */ var didWarnAboutMaps = false;
    var userProvidedKeyEscapeRegex = /\/+/g;
    function escapeUserProvidedKey(text) {
        return text.replace(userProvidedKeyEscapeRegex, '$&/');
    }
    /**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */ function getElementKey(element, index) {
        // Do some typechecking here since we call this blindly. We want to ensure
        // that we don't block potential future ES APIs.
        if (typeof element === 'object' && element !== null && element.key != null) // Explicit key
        return escape('' + element.key);
         // Implicit key determined by the index in the set
        return index.toString(36);
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if (type === 'undefined' || type === 'boolean') // All of the above are perceived as null.
        children = null;
        var invokeCallback = false;
        if (children === null) invokeCallback = true;
        else switch(type){
            case 'string':
            case 'number':
                invokeCallback = true;
                break;
            case 'object':
                switch(children.$$typeof){
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                        invokeCallback = true;
                }
        }
        if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
            // so that it's consistent if the number of children grows:
            var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (Array.isArray(mappedChild)) {
                var escapedChildKey = '';
                if (childKey != null) escapedChildKey = escapeUserProvidedKey(childKey) + '/';
                mapIntoArray(mappedChild, array, escapedChildKey, '', function(c) {
                    return c;
                });
            } else if (mappedChild != null) {
                if (isValidElement(mappedChild)) mappedChild = cloneAndReplaceKey(mappedChild, // traverseAllChildren used to do for objects as children
                escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
                array.push(mappedChild);
            }
            return 1;
        }
        var child;
        var nextName;
        var subtreeCount = 0; // Count of children found in the current subtree.
        var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
        if (Array.isArray(children)) for(var i = 0; i < children.length; i++){
            child = children[i];
            nextName = nextNamePrefix + getElementKey(child, i);
            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
        }
        else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === 'function') {
                var iterableChildren = children;
                // Warn about using Maps as children
                if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    didWarnAboutMaps = true;
                }
                var iterator = iteratorFn.call(iterableChildren);
                var step;
                var ii = 0;
                while(!(step = iterator.next()).done){
                    child = step.value;
                    nextName = nextNamePrefix + getElementKey(child, ii++);
                    subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
            } else if (type === 'object') {
                var childrenString = '' + children;
                throw Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
        }
        return subtreeCount;
    }
    /**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */ function mapChildren(children, func, context) {
        if (children == null) return children;
        var result = [];
        var count = 0;
        mapIntoArray(children, result, '', '', function(child) {
            return func.call(context, child, count++);
        });
        return result;
    }
    /**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */ function countChildren(children) {
        var n = 0;
        mapChildren(children, function() {
            n++; // Don't return anything
        });
        return n;
    }
    /**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */ function forEachChildren(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
            forEachFunc.apply(this, arguments); // Don't return anything.
        }, forEachContext);
    }
    /**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */ function toArray(children) {
        return mapChildren(children, function(child) {
            return child;
        }) || [];
    }
    /**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */ function onlyChild(children) {
        if (!isValidElement(children)) throw Error("React.Children.only expected to receive a single React element child.");
        return children;
    }
    function createContext(defaultValue, calculateChangedBits) {
        if (calculateChangedBits === undefined) calculateChangedBits = null;
        else if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') error1("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
        var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null
        };
        context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
        };
        var hasWarnedAboutUsingNestedContextConsumers = false;
        var hasWarnedAboutUsingConsumerProvider = false;
        var hasWarnedAboutDisplayNameOnConsumer = false;
        // A separate object, but proxies back to the original context object for
        // backwards compatibility. It has a different $$typeof, so we can properly
        // warn for the incorrect usage of Context as a Consumer.
        var Consumer = {
            $$typeof: REACT_CONTEXT_TYPE,
            _context: context,
            _calculateChangedBits: context._calculateChangedBits
        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here
        Object.defineProperties(Consumer, {
            Provider: {
                get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                        hasWarnedAboutUsingConsumerProvider = true;
                        error1("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context.Provider;
                },
                set: function(_Provider) {
                    context.Provider = _Provider;
                }
            },
            _currentValue: {
                get: function() {
                    return context._currentValue;
                },
                set: function(_currentValue) {
                    context._currentValue = _currentValue;
                }
            },
            _currentValue2: {
                get: function() {
                    return context._currentValue2;
                },
                set: function(_currentValue2) {
                    context._currentValue2 = _currentValue2;
                }
            },
            _threadCount: {
                get: function() {
                    return context._threadCount;
                },
                set: function(_threadCount) {
                    context._threadCount = _threadCount;
                }
            },
            Consumer: {
                get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                        hasWarnedAboutUsingNestedContextConsumers = true;
                        error1("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context.Consumer;
                }
            },
            displayName: {
                get: function() {
                    return context.displayName;
                },
                set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                        warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                        hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                }
            }
        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty
        context.Consumer = Consumer;
        context._currentRenderer = null;
        context._currentRenderer2 = null;
        return context;
    }
    var Uninitialized = -1;
    var Pending = 0;
    var Resolved = 1;
    var Rejected = 2;
    function lazyInitializer(payload) {
        if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor(); // Transition to the next state.
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
            thenable.then(function(moduleObject) {
                if (payload._status === Pending) {
                    var defaultExport = moduleObject.default;
                    if (defaultExport === undefined) error1("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                    var resolved = payload;
                    resolved._status = Resolved;
                    resolved._result = defaultExport;
                }
            }, function(error) {
                if (payload._status === Pending) {
                    // Transition to the next state.
                    var rejected = payload;
                    rejected._status = Rejected;
                    rejected._result = error;
                }
            });
        }
        if (payload._status === Resolved) return payload._result;
        else throw payload._result;
    }
    function lazy(ctor) {
        var payload = {
            // We use these fields to store the result.
            _status: -1,
            _result: ctor
        };
        var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
        };
        // In production, this would just set it on the object.
        var defaultProps;
        var propTypes; // $FlowFixMe
        Object.defineProperties(lazyType, {
            defaultProps: {
                configurable: true,
                get: function() {
                    return defaultProps;
                },
                set: function(newDefaultProps) {
                    error1("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps = newDefaultProps; // Match production behavior more closely:
                    // $FlowFixMe
                    Object.defineProperty(lazyType, 'defaultProps', {
                        enumerable: true
                    });
                }
            },
            propTypes: {
                configurable: true,
                get: function() {
                    return propTypes;
                },
                set: function(newPropTypes) {
                    error1("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes; // Match production behavior more closely:
                    // $FlowFixMe
                    Object.defineProperty(lazyType, 'propTypes', {
                        enumerable: true
                    });
                }
            }
        });
        return lazyType;
    }
    function forwardRef(render) {
        if (render != null && render.$$typeof === REACT_MEMO_TYPE) error1("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
        else if (typeof render !== 'function') error1('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
        else if (render.length !== 0 && render.length !== 2) error1('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
        if (render != null) {
            if (render.defaultProps != null || render.propTypes != null) error1("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        }
        var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render: render
        };
        var ownName;
        Object.defineProperty(elementType, 'displayName', {
            enumerable: false,
            configurable: true,
            get: function() {
                return ownName;
            },
            set: function(name) {
                ownName = name;
                if (render.displayName == null) render.displayName = name;
            }
        });
        return elementType;
    }
    // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.
    var enableScopeAPI = false; // Experimental Create Event Handle API.
    function isValidElementType(type) {
        if (typeof type === 'string' || typeof type === 'function') return true;
         // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).
        if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) return true;
        if (typeof type === 'object' && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) return true;
        }
        return false;
    }
    function memo(type, compare) {
        if (!isValidElementType(type)) error1("memo: The first argument must be a component. Instead received: %s", type === null ? 'null' : typeof type);
        var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type: type,
            compare: compare === undefined ? null : compare
        };
        var ownName;
        Object.defineProperty(elementType, 'displayName', {
            enumerable: false,
            configurable: true,
            get: function() {
                return ownName;
            },
            set: function(name) {
                ownName = name;
                if (type.displayName == null) type.displayName = name;
            }
        });
        return elementType;
    }
    function resolveDispatcher() {
        var dispatcher = ReactCurrentDispatcher.current;
        if (!(dispatcher !== null)) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        return dispatcher;
    }
    function useContext(Context, unstable_observedBits) {
        var dispatcher = resolveDispatcher();
        if (unstable_observedBits !== undefined) error1("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks" : '');
         // TODO: add a more generic warning for invalid values.
        if (Context._context !== undefined) {
            var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
            // and nobody should be using this in existing code.
            if (realContext.Consumer === Context) error1("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
            else if (realContext.Provider === Context) error1("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return dispatcher.useContext(Context, unstable_observedBits);
    }
    function useState(initialState) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useState(initialState);
    }
    function useReducer(reducer, initialArg, init) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useReducer(reducer, initialArg, init);
    }
    function useRef(initialValue) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useRef(initialValue);
    }
    function useEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useEffect(create, deps);
    }
    function useLayoutEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useLayoutEffect(create, deps);
    }
    function useCallback(callback, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useCallback(callback, deps);
    }
    function useMemo(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useMemo(create, deps);
    }
    function useImperativeHandle(ref, create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useImperativeHandle(ref, create, deps);
    }
    function useDebugValue(value, formatterFn) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useDebugValue(value, formatterFn);
    }
    // Helpers to patch console.logs to avoid logging during side-effect free
    // replaying on render function. This currently only patches the object
    // lazily which won't cover if the log function was extracted eagerly.
    // We could also eagerly patch the method.
    var disabledDepth = 0;
    var prevLog;
    var prevInfo;
    var prevWarn;
    var prevError;
    var prevGroup;
    var prevGroupCollapsed;
    var prevGroupEnd;
    function disabledLog() {
    }
    disabledLog.__reactDisabledLog = true;
    function disableLogs() {
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099
            var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        /* eslint-enable react-internal/no-production-logging */ }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ var props = {
                configurable: true,
                enumerable: true,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                log: _assign({
                }, props, {
                    value: prevLog
                }),
                info: _assign({
                }, props, {
                    value: prevInfo
                }),
                warn: _assign({
                }, props, {
                    value: prevWarn
                }),
                error: _assign({
                }, props, {
                    value: prevError
                }),
                group: _assign({
                }, props, {
                    value: prevGroup
                }),
                groupCollapsed: _assign({
                }, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: _assign({
                }, props, {
                    value: prevGroupEnd
                })
            });
        /* eslint-enable react-internal/no-production-logging */ }
        if (disabledDepth < 0) error1("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
    var prefix;
    function describeBuiltInComponentFrame(name, source, ownerFn) {
        if (prefix === undefined) // Extract the VM specific prefix used by each line.
        try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || '';
        }
         // We use the prefix to ensure our stacks line up with native stack frames.
        return '\n' + prefix + name;
    }
    var reentry = false;
    var componentFrameCache;
    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
    componentFrameCache = new PossiblyWeakMap();
    function describeNativeComponentFrame(fn, construct) {
        // If something asked for a stack inside a fake render, it should get ignored.
        if (!fn || reentry) return '';
        var frame = componentFrameCache.get(fn);
        if (frame !== undefined) return frame;
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
        // for warnings.
        ReactCurrentDispatcher$1.current = null;
        disableLogs();
        try {
            // This should throw.
            if (construct) {
                // Something should be setting the props in the constructor.
                var Fake = function() {
                    throw Error();
                }; // $FlowFixMe
                Object.defineProperty(Fake.prototype, 'props', {
                    set: function() {
                        // We use a throwing setter instead of frozen or non-writable props
                        // because that won't throw in a non-strict mode function.
                        throw Error();
                    }
                });
                if (typeof Reflect === 'object' && Reflect.construct) {
                    // We construct a different control for this case to include any extra
                    // frames added by the construct call.
                    try {
                        Reflect.construct(Fake, []);
                    } catch (x) {
                        control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                } else {
                    try {
                        Fake.call();
                    } catch (x) {
                        control = x;
                    }
                    fn.call(Fake.prototype);
                }
            } else {
                try {
                    throw Error();
                } catch (x) {
                    control = x;
                }
                fn();
            }
        } catch (sample) {
            // This is inlined manually because closure doesn't do it for us.
            if (sample && control && typeof sample.stack === 'string') {
                // This extracts the first frame from the sample that isn't also in the control.
                // Skipping one frame that we assume is the frame that calls the two.
                var sampleLines = sample.stack.split('\n');
                var controlLines = control.stack.split('\n');
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c])// We expect at least one stack frame to be shared.
                // Typically this will be the root most one. However, stack frames may be
                // cut off due to maximum stack limits. In this case, one maybe cut off
                // earlier than the other. We assume that the sample is longer or the same
                // and there for cut off earlier. So we should find the root most frame in
                // the sample somewhere in the control.
                c--;
                for(; s >= 1 && c >= 0; s--, c--)// Next we find the first one that isn't the same which should be the
                // frame that called our sample function and the control.
                if (sampleLines[s] !== controlLines[c]) {
                    // In V8, the first line is describing the message but other VMs don't.
                    // If we're about to return the first line, and the control is also on the same
                    // line, that's a pretty good indicator that our sample threw at same line as
                    // the control. I.e. before we entered the sample frame. So we ignore this result.
                    // This can happen if you passed a class to function component, or non-function.
                    if (s !== 1 || c !== 1) do {
                        s--;
                        c--; // We may still have similar intermediate frames from the construct call.
                        // The next one that isn't the same should be our match though.
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                            // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                            var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                            if (typeof fn === 'function') componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                    }while (s >= 1 && c >= 0)
                    break;
                }
            }
        } finally{
            reentry = false;
            ReactCurrentDispatcher$1.current = previousDispatcher;
            reenableLogs();
            Error.prepareStackTrace = previousPrepareStackTrace;
        } // Fallback to just using the name if we couldn't make it throw.
        var name = fn ? fn.displayName || fn.name : '';
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
        if (typeof fn === 'function') componentFrameCache.set(fn, syntheticFrame);
        return syntheticFrame;
    }
    function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, false);
    }
    function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
    }
    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) return '';
        if (typeof type === 'function') return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type === 'string') return describeBuiltInComponentFrame(type);
        switch(type){
            case exports.Suspense:
                return describeBuiltInComponentFrame('Suspense');
            case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame('SuspenseList');
        }
        if (typeof type === 'object') switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
                // Memo may contain any component type so we recursively resolve it.
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    // Lazy may contain any component type so we recursively resolve it.
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
        }
        return '';
    }
    var loggedTypeFailures = {
    };
    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement(element) {
        if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
    function checkPropTypes(typeSpecs, values, location, componentName, element) {
        // $FlowFixMe This is okay but Flow doesn't know it.
        var has = Function.call.bind(Object.prototype.hasOwnProperty);
        for(var typeSpecName in typeSpecs)if (has(typeSpecs, typeSpecName)) {
            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.
            try {
                // This is intentionally an invariant that gets caught. It's the same
                // behavior as without this statement except with a better message.
                if (typeof typeSpecs[typeSpecName] !== 'function') {
                    var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                    err.name = 'Invariant Violation';
                    throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
            } catch (ex) {
                error$1 = ex;
            }
            if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error1("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || 'React class', location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
            }
            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                // Only monitor this failure once because there tends to be a lot of the
                // same error.
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error1('Failed %s type: %s', location, error$1.message);
                setCurrentlyValidatingElement(null);
            }
        }
    }
    function setCurrentlyValidatingElement$1(element) {
        if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            setExtraStackFrame(stack);
        } else setExtraStackFrame(null);
    }
    var propTypesMisspellWarningShown;
    propTypesMisspellWarningShown = false;
    function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
            var name = getComponentName(ReactCurrentOwner.current.type);
            if (name) return '\n\nCheck the render method of `' + name + '`.';
        }
        return '';
    }
    function getSourceInfoErrorAddendum(source) {
        if (source !== undefined) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, '');
            var lineNumber = source.lineNumber;
            return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
        }
        return '';
    }
    function getSourceInfoErrorAddendumForProps(elementProps) {
        if (elementProps !== null && elementProps !== undefined) return getSourceInfoErrorAddendum(elementProps.__source);
        return '';
    }
    /**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */ var ownerHasKeyUseWarning = {
    };
    function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();
        if (!info) {
            var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
            if (parentName) info = "\n\nCheck the top-level render call using <" + parentName + ">.";
        }
        return info;
    }
    /**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */ function validateExplicitKey(element, parentType) {
        if (!element._store || element._store.validated || element.key != null) return;
        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) return;
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
        // property, it may be the creator of the child that's responsible for
        // assigning it a key.
        var childOwner = '';
        if (element && element._owner && element._owner !== ReactCurrentOwner.current) // Give the component that originally created this child.
        childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
        setCurrentlyValidatingElement$1(element);
        error1("Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.", currentComponentErrorInfo, childOwner);
        setCurrentlyValidatingElement$1(null);
    }
    /**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */ function validateChildKeys(node, parentType) {
        if (typeof node !== 'object') return;
        if (Array.isArray(node)) for(var i = 0; i < node.length; i++){
            var child = node[i];
            if (isValidElement(child)) validateExplicitKey(child, parentType);
        }
        else if (isValidElement(node)) // This element was passed in a valid location.
        {
            if (node._store) node._store.validated = true;
        } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === 'function') // Entry iterators used to provide implicit keys,
            // but now we print a separate warning for them later.
            {
                if (iteratorFn !== node.entries) {
                    var iterator = iteratorFn.call(node);
                    var step;
                    while(!(step = iterator.next()).done)if (isValidElement(step.value)) validateExplicitKey(step.value, parentType);
                }
            }
        }
    }
    /**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */ function validatePropTypes(element) {
        var type = element.type;
        if (type === null || type === undefined || typeof type === 'string') return;
        var propTypes;
        if (typeof type === 'function') propTypes = type.propTypes;
        else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Inner props are checked in the reconciler.
        type.$$typeof === REACT_MEMO_TYPE)) propTypes = type.propTypes;
        else return;
        if (propTypes) {
            // Intentionally inside to avoid triggering lazy initializers:
            var name = getComponentName(type);
            checkPropTypes(propTypes, element.props, 'prop', name, element);
        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:
            var _name = getComponentName(type);
            error1('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
        }
        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) error1("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
    /**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */ function validateFragmentProps(fragment) {
        var keys = Object.keys(fragment.props);
        for(var i = 0; i < keys.length; i++){
            var key = keys[i];
            if (key !== 'children' && key !== 'key') {
                setCurrentlyValidatingElement$1(fragment);
                error1("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
            }
        }
        if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error1('Invalid attribute `ref` supplied to `React.Fragment`.');
            setCurrentlyValidatingElement$1(null);
        }
    }
    function createElementWithValidation(type, props, children) {
        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
        // succeed and there will likely be errors in render.
        if (!validType) {
            var info = '';
            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) info += sourceInfo;
            else info += getDeclarationErrorAddendum();
            var typeString;
            if (type === null) typeString = 'null';
            else if (Array.isArray(type)) typeString = 'array';
            else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
                info = ' Did you accidentally export a JSX literal instead of a component?';
            } else typeString = typeof type;
            error1("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
        }
        var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
        // TODO: Drop this when these are no longer allowed as the type argument.
        if (element == null) return element;
         // Skip key warning if the type isn't valid since our key validation logic
        // doesn't expect a non-string/function type and can throw confusing errors.
        // We don't want exception behavior to differ between dev and prod.
        // (Rendering will throw with a helpful message and as soon as the type is
        // fixed, the key warnings will appear.)
        if (validType) for(var i = 2; i < arguments.length; i++)validateChildKeys(arguments[i], type);
        if (type === exports.Fragment) validateFragmentProps(element);
        else validatePropTypes(element);
        return element;
    }
    var didWarnAboutDeprecatedCreateFactory = false;
    function createFactoryWithValidation(type) {
        var validatedFactory = createElementWithValidation.bind(null, type);
        validatedFactory.type = type;
        if (!didWarnAboutDeprecatedCreateFactory) {
            didWarnAboutDeprecatedCreateFactory = true;
            warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
        } // Legacy hook: remove it
        Object.defineProperty(validatedFactory, 'type', {
            enumerable: false,
            get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, 'type', {
                    value: type
                });
                return type;
            }
        });
        return validatedFactory;
    }
    function cloneElementWithValidation(element, props, children) {
        var newElement = cloneElement.apply(this, arguments);
        for(var i = 2; i < arguments.length; i++)validateChildKeys(arguments[i], newElement.type);
        validatePropTypes(newElement);
        return newElement;
    }
    try {
        var frozenObject = Object.freeze({
        });
        /* eslint-disable no-new */ new Map([
            [
                frozenObject,
                null
            ]
        ]);
        new Set([
            frozenObject
        ]);
    /* eslint-enable no-new */ } catch (e) {
    }
    var createElement$1 = createElementWithValidation;
    var cloneElement$1 = cloneElementWithValidation;
    var createFactory = createFactoryWithValidation;
    var Children = {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray: toArray,
        only: onlyChild
    };
    exports.Children = Children;
    exports.Component = Component1;
    exports.PureComponent = PureComponent;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
    exports.cloneElement = cloneElement$1;
    exports.createContext = createContext;
    exports.createElement = createElement$1;
    exports.createFactory = createFactory;
    exports.createRef = createRef;
    exports.forwardRef = forwardRef;
    exports.isValidElement = isValidElement;
    exports.lazy = lazy;
    exports.memo = memo;
    exports.useCallback = useCallback;
    exports.useContext = useContext;
    exports.useDebugValue = useDebugValue;
    exports.useEffect = useEffect;
    exports.useImperativeHandle = useImperativeHandle;
    exports.useLayoutEffect = useLayoutEffect;
    exports.useMemo = useMemo;
    exports.useReducer = useReducer;
    exports.useRef = useRef;
    exports.useState = useState;
    exports.version = ReactVersion;
})();

},{"object-assign":"7OXxh"}],"7OXxh":[function(require,module,exports) {
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/ 'use strict';
/* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
    if (val === null || val === undefined) throw new TypeError('Object.assign cannot be called with null or undefined');
    return Object(val);
}
function shouldUseNative() {
    try {
        if (!Object.assign) return false;
        // Detect buggy property enumeration order in older V8 versions.
        // https://bugs.chromium.org/p/v8/issues/detail?id=4118
        var test1 = "abc"; // eslint-disable-line no-new-wrappers
        test1[5] = 'de';
        if (Object.getOwnPropertyNames(test1)[0] === '5') return false;
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test2 = {
        };
        for(var i = 0; i < 10; i++)test2['_' + String.fromCharCode(i)] = i;
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
        });
        if (order2.join('') !== '0123456789') return false;
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test3 = {
        };
        'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
            test3[letter] = letter;
        });
        if (Object.keys(Object.assign({
        }, test3)).join('') !== 'abcdefghijklmnopqrst') return false;
        return true;
    } catch (err) {
        // We don't expect any of the above to throw, but better to be safe.
        return false;
    }
}
module.exports = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for(var s = 1; s < arguments.length; s++){
        from = Object(arguments[s]);
        for(var key in from)if (hasOwnProperty.call(from, key)) to[key] = from[key];
        if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for(var i = 0; i < symbols.length; i++)if (propIsEnumerable.call(from, symbols[i])) to[symbols[i]] = from[symbols[i]];
        }
    }
    return to;
};

},{}],"j6uA9":[function(require,module,exports) {
'use strict';
function checkDCE() {
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') return;
    var err;
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
}
module.exports = require('./cjs/react-dom.development.js');

},{"./cjs/react-dom.development.js":"3iA9v"}],"3iA9v":[function(require,module,exports) {
/** @license React v17.0.2
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    var React = require('react');
    var _assign = require('object-assign');
    var Scheduler = require('scheduler');
    var tracing = require('scheduler/tracing');
    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    // by calls to these methods by a Babel plugin.
    //
    // In PROD (or in packages without access to React internals),
    // they are left as they are instead.
    function warn(format) {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
        printWarning('warn', format, args);
    }
    function error1(format) {
        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)args[_key2 - 1] = arguments[_key2];
        printWarning('error', format, args);
    }
    function printWarning(level, format, args) {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();
        if (stack !== '') {
            format += '%s';
            args = args.concat([
                stack
            ]);
        }
        var argsWithFormat = args.map(function(item) {
            return '' + item;
        }); // Careful: RN currently depends on this prefix
        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging
        Function.prototype.apply.call(console[level], console, argsWithFormat);
    }
    if (!React) throw Error("ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.");
    var FunctionComponent = 0;
    var ClassComponent = 1;
    var IndeterminateComponent = 2; // Before we know whether it is function or class
    var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
    var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
    var HostComponent = 5;
    var HostText = 6;
    var Fragment = 7;
    var Mode = 8;
    var ContextConsumer = 9;
    var ContextProvider = 10;
    var ForwardRef = 11;
    var Profiler = 12;
    var SuspenseComponent = 13;
    var MemoComponent = 14;
    var SimpleMemoComponent = 15;
    var LazyComponent = 16;
    var IncompleteClassComponent = 17;
    var DehydratedFragment = 18;
    var SuspenseListComponent = 19;
    var FundamentalComponent = 20;
    var ScopeComponent = 21;
    var Block = 22;
    var OffscreenComponent = 23;
    var LegacyHiddenComponent = 24;
    // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.
    var enableProfilerTimer = true; // Record durations for commit and passive effects phases.
    var enableFundamentalAPI = false; // Experimental Scope support.
    var enableNewReconciler = false; // Errors that are thrown while unmounting (or after in the case of passive effects)
    var warnAboutStringRefs = false;
    var allNativeEvents = new Set();
    /**
 * Mapping from registration name to event name
 */ var registrationNameDependencies1 = {
    };
    /**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */ var possibleRegistrationNames1 = {
    }; // Trust the developer to only use possibleRegistrationNames in true
    function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + 'Capture', dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
        if (registrationNameDependencies1[registrationName]) error1("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
        registrationNameDependencies1[registrationName] = dependencies;
        var lowerCasedName = registrationName.toLowerCase();
        possibleRegistrationNames1[lowerCasedName] = registrationName;
        if (registrationName === 'onDoubleClick') possibleRegistrationNames1.ondblclick = registrationName;
        for(var i = 0; i < dependencies.length; i++)allNativeEvents.add(dependencies[i]);
    }
    var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');
    // A reserved attribute.
    // It is handled by React separately and shouldn't be written to the DOM.
    var RESERVED = 0; // A simple string attribute.
    // Attributes that aren't in the filter are presumed to have this type.
    var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
    // "enumerated" attributes with "true" and "false" as possible values.
    // When true, it should be set to a "true" string.
    // When false, it should be set to a "false" string.
    var BOOLEANISH_STRING = 2; // A real boolean attribute.
    // When true, it should be present (set either to an empty string or its name).
    // When false, it should be omitted.
    var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
    // When true, it should be present (set either to an empty string or its name).
    // When false, it should be omitted.
    // For any other value, should be present with that value.
    var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
    // When falsy, it should be removed.
    var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
    // When falsy, it should be removed.
    var POSITIVE_NUMERIC = 6;
    /* eslint-disable max-len */ var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    /* eslint-enable max-len */ var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var ROOT_ATTRIBUTE_NAME = 'data-reactroot';
    var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var illegalAttributeNameCache = {
    };
    var validatedAttributeNameCache = {
    };
    function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        error1('Invalid attribute name: `%s`', attributeName);
        return false;
    }
    function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null) return propertyInfo.type === RESERVED;
        if (isCustomComponentTag) return false;
        if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) return true;
        return false;
    }
    function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) return false;
        switch(typeof value){
            case 'function':
            case 'symbol':
                // eslint-disable-line
                return true;
            case 'boolean':
                if (isCustomComponentTag) return false;
                if (propertyInfo !== null) return !propertyInfo.acceptsBooleans;
                else {
                    var prefix = name.toLowerCase().slice(0, 5);
                    return prefix !== 'data-' && prefix !== 'aria-';
                }
            default:
                return false;
        }
    }
    function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
        if (value === null || typeof value === 'undefined') return true;
        if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) return true;
        if (isCustomComponentTag) return false;
        if (propertyInfo !== null) switch(propertyInfo.type){
            case BOOLEAN:
                return !value;
            case OVERLOADED_BOOLEAN:
                return value === false;
            case NUMERIC:
                return isNaN(value);
            case POSITIVE_NUMERIC:
                return isNaN(value) || value < 1;
        }
        return false;
    }
    function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null;
    }
    function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
        this.attributeName = attributeName;
        this.attributeNamespace = attributeNamespace;
        this.mustUseProperty = mustUseProperty;
        this.propertyName = name;
        this.type = type;
        this.sanitizeURL = sanitizeURL;
        this.removeEmptyString = removeEmptyString;
    } // When adding attributes to this list, be sure to also add them to
    // the `possibleStandardNames` module to ensure casing and incorrect
    // name warnings.
    var properties = {
    }; // These props are reserved by React. They shouldn't be written to the DOM.
    var reservedProps = [
        'children',
        'dangerouslySetInnerHTML',
        // elements (not just inputs). Now that ReactDOMInput assigns to the
        // defaultValue property -- do we need this?
        'defaultValue',
        'defaultChecked',
        'innerHTML',
        'suppressContentEditableWarning',
        'suppressHydrationWarning',
        'style'
    ];
    reservedProps.forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
    }); // A few React string attributes have a different name.
    // This is a mapping from React prop names to the attribute names.
    [
        [
            'acceptCharset',
            'accept-charset'
        ],
        [
            'className',
            'class'
        ],
        [
            'htmlFor',
            'for'
        ],
        [
            'httpEquiv',
            'http-equiv'
        ]
    ].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
    }); // These are "enumerated" HTML attributes that accept "true" and "false".
    // In React, we let users pass `true` and `false` even though technically
    // these aren't boolean attributes (they are coerced to strings).
    [
        'contentEditable',
        'draggable',
        'spellCheck',
        'value'
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
    }); // These are "enumerated" SVG attributes that accept "true" and "false".
    // In React, we let users pass `true` and `false` even though technically
    // these aren't boolean attributes (they are coerced to strings).
    // Since these are SVG attributes, their attribute names are case-sensitive.
    [
        'autoReverse',
        'externalResourcesRequired',
        'focusable',
        'preserveAlpha'
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
    }); // These are HTML boolean attributes.
    [
        'allowFullScreen',
        'async',
        // on the client side because the browsers are inconsistent. Instead we call focus().
        'autoFocus',
        'autoPlay',
        'controls',
        'default',
        'defer',
        'disabled',
        'disablePictureInPicture',
        'disableRemotePlayback',
        'formNoValidate',
        'hidden',
        'loop',
        'noModule',
        'noValidate',
        'open',
        'playsInline',
        'readOnly',
        'required',
        'reversed',
        'scoped',
        'seamless',
        'itemScope'
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
    }); // These are the few React props that we set as DOM properties
    // rather than attributes. These are all booleans.
    [
        'checked',
        // disabled with `removeAttribute`. We have special logic for handling this.
        'multiple',
        'muted',
        'selected' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
    }); // These are HTML attributes that are "overloaded booleans": they behave like
    // booleans, but can also accept a string value.
    [
        'capture',
        'download' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
    }); // These are HTML attributes that must be positive numbers.
    [
        'cols',
        'rows',
        'size',
        'span' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
    }); // These are HTML attributes that must be numbers.
    [
        'rowSpan',
        'start'
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
    });
    var CAMELIZE = /[\-\:]([a-z])/g;
    var capitalize = function(token) {
        return token[1].toUpperCase();
    }; // This is a list of all SVG attributes that need special casing, namespacing,
    // or boolean value assignment. Regular attributes that just accept strings
    // and have the same names are omitted, just like in the HTML attribute filter.
    // Some of these attributes can be hard to find. This list was created by
    // scraping the MDN documentation.
    [
        'accent-height',
        'alignment-baseline',
        'arabic-form',
        'baseline-shift',
        'cap-height',
        'clip-path',
        'clip-rule',
        'color-interpolation',
        'color-interpolation-filters',
        'color-profile',
        'color-rendering',
        'dominant-baseline',
        'enable-background',
        'fill-opacity',
        'fill-rule',
        'flood-color',
        'flood-opacity',
        'font-family',
        'font-size',
        'font-size-adjust',
        'font-stretch',
        'font-style',
        'font-variant',
        'font-weight',
        'glyph-name',
        'glyph-orientation-horizontal',
        'glyph-orientation-vertical',
        'horiz-adv-x',
        'horiz-origin-x',
        'image-rendering',
        'letter-spacing',
        'lighting-color',
        'marker-end',
        'marker-mid',
        'marker-start',
        'overline-position',
        'overline-thickness',
        'paint-order',
        'panose-1',
        'pointer-events',
        'rendering-intent',
        'shape-rendering',
        'stop-color',
        'stop-opacity',
        'strikethrough-position',
        'strikethrough-thickness',
        'stroke-dasharray',
        'stroke-dashoffset',
        'stroke-linecap',
        'stroke-linejoin',
        'stroke-miterlimit',
        'stroke-opacity',
        'stroke-width',
        'text-anchor',
        'text-decoration',
        'text-rendering',
        'underline-position',
        'underline-thickness',
        'unicode-bidi',
        'unicode-range',
        'units-per-em',
        'v-alphabetic',
        'v-hanging',
        'v-ideographic',
        'v-mathematical',
        'vector-effect',
        'vert-adv-y',
        'vert-origin-x',
        'vert-origin-y',
        'word-spacing',
        'writing-mode',
        'xmlns:xlink',
        'x-height' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
    }); // String SVG attributes with the xlink namespace.
    [
        'xlink:actuate',
        'xlink:arcrole',
        'xlink:role',
        'xlink:show',
        'xlink:title',
        'xlink:type' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, 'http://www.w3.org/1999/xlink', false, false);
    }); // String SVG attributes with the xml namespace.
    [
        'xml:base',
        'xml:lang',
        'xml:space' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, 'http://www.w3.org/XML/1998/namespace', false, false);
    }); // These attribute exists both in HTML and SVG.
    // The attribute name is case-sensitive in SVG so we can't just use
    // the React name like we do for attributes that exist only in HTML.
    [
        'tabIndex',
        'crossOrigin'
    ].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
    }); // These attributes accept URLs. These must not allow javascript: URLS.
    // These will also need to accept Trusted Types object in the future.
    var xlinkHref = 'xlinkHref';
    properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, 'xlink:href', 'http://www.w3.org/1999/xlink', true, false);
    [
        'src',
        'href',
        'action',
        'formAction'
    ].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
    });
    // and any newline or tab are filtered out as if they're not part of the URL.
    // https://url.spec.whatwg.org/#url-parsing
    // Tab or newline are defined as \r\n\t:
    // https://infra.spec.whatwg.org/#ascii-tab-or-newline
    // A C0 control is a code point in the range \u0000 NULL to \u001F
    // INFORMATION SEPARATOR ONE, inclusive:
    // https://infra.spec.whatwg.org/#c0-control-or-space
    /* eslint-disable max-len */ var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
    var didWarn = false;
    function sanitizeURL1(url) {
        if (!didWarn && isJavaScriptProtocol.test(url)) {
            didWarn = true;
            error1("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
        }
    }
    /**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */ function getValueForProperty(node, name, expected, propertyInfo) {
        if (propertyInfo.mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            return node[propertyName];
        } else {
            if (propertyInfo.sanitizeURL) // If we haven't fully disabled javascript: URLs, and if
            // the hydration is successful of a javascript: URL, we
            // still want to warn on the client.
            sanitizeURL1('' + expected);
            var attributeName = propertyInfo.attributeName;
            var stringValue = null;
            if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                if (node.hasAttribute(attributeName)) {
                    var value = node.getAttribute(attributeName);
                    if (value === '') return true;
                    if (shouldRemoveAttribute(name, expected, propertyInfo, false)) return value;
                    if (value === '' + expected) return expected;
                    return value;
                }
            } else if (node.hasAttribute(attributeName)) {
                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) // We had an attribute but shouldn't have had one, so read it
                // for the error message.
                return node.getAttribute(attributeName);
                if (propertyInfo.type === BOOLEAN) // If this was a boolean, it doesn't matter what the value is
                // the fact that we have it is the same as the expected.
                return expected;
                 // Even if this property uses a namespace we use getAttribute
                // because we assume its namespaced name is the same as our config.
                // To use getAttributeNS we need the local name which we don't have
                // in our config atm.
                stringValue = node.getAttribute(attributeName);
            }
            if (shouldRemoveAttribute(name, expected, propertyInfo, false)) return stringValue === null ? expected : stringValue;
            else if (stringValue === '' + expected) return expected;
            else return stringValue;
        }
    }
    /**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */ function getValueForAttribute(node, name, expected) {
        if (!isAttributeNameSafe(name)) return;
         // If the object is an opaque reference ID, it's expected that
        // the next prop is different than the server value, so just return
        // expected
        if (isOpaqueHydratingObject(expected)) return expected;
        if (!node.hasAttribute(name)) return expected === undefined ? undefined : null;
        var value = node.getAttribute(name);
        if (value === '' + expected) return expected;
        return value;
    }
    /**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */ function setValueForProperty(node, name, value, isCustomComponentTag) {
        var propertyInfo = getPropertyInfo(name);
        if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) return;
        if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) value = null;
         // If the prop isn't in the special list, treat it as a simple attribute.
        if (isCustomComponentTag || propertyInfo === null) {
            if (isAttributeNameSafe(name)) {
                var _attributeName = name;
                if (value === null) node.removeAttribute(_attributeName);
                else node.setAttribute(_attributeName, '' + value);
            }
            return;
        }
        var mustUseProperty = propertyInfo.mustUseProperty;
        if (mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            if (value === null) {
                var type = propertyInfo.type;
                node[propertyName] = type === BOOLEAN ? false : '';
            } else // Contrary to `setAttribute`, object properties are properly
            // `toString`ed by IE8/9.
            node[propertyName] = value;
            return;
        } // The rest are treated as attributes with special cases.
        var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
        if (value === null) node.removeAttribute(attributeName);
        else {
            var _type = propertyInfo.type;
            var attributeValue;
            if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) // If attribute type is boolean, we know for sure it won't be an execution sink
            // and we won't require Trusted Type here.
            attributeValue = '';
            else {
                attributeValue = '' + value;
                if (propertyInfo.sanitizeURL) sanitizeURL1(attributeValue.toString());
            }
            if (attributeNamespace) node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
            else node.setAttribute(attributeName, attributeValue);
        }
    }
    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE = 60103;
    var REACT_PORTAL_TYPE = 60106;
    var REACT_FRAGMENT_TYPE = 60107;
    var REACT_STRICT_MODE_TYPE = 60108;
    var REACT_PROFILER_TYPE = 60114;
    var REACT_PROVIDER_TYPE = 60109;
    var REACT_CONTEXT_TYPE = 60110;
    var REACT_FORWARD_REF_TYPE = 60112;
    var REACT_SUSPENSE_TYPE = 60113;
    var REACT_SUSPENSE_LIST_TYPE = 60120;
    var REACT_MEMO_TYPE = 60115;
    var REACT_LAZY_TYPE = 60116;
    var REACT_BLOCK_TYPE = 60121;
    var REACT_SERVER_BLOCK_TYPE = 60122;
    var REACT_FUNDAMENTAL_TYPE = 60117;
    var REACT_SCOPE_TYPE = 60119;
    var REACT_OPAQUE_ID_TYPE = 60128;
    var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
    var REACT_OFFSCREEN_TYPE = 60130;
    var REACT_LEGACY_HIDDEN_TYPE = 60131;
    if (typeof Symbol === 'function' && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor('react.element');
        REACT_PORTAL_TYPE = symbolFor('react.portal');
        REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
        REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
        REACT_PROFILER_TYPE = symbolFor('react.profiler');
        REACT_PROVIDER_TYPE = symbolFor('react.provider');
        REACT_CONTEXT_TYPE = symbolFor('react.context');
        REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
        REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
        REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
        REACT_MEMO_TYPE = symbolFor('react.memo');
        REACT_LAZY_TYPE = symbolFor('react.lazy');
        REACT_BLOCK_TYPE = symbolFor('react.block');
        REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
        REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
        REACT_SCOPE_TYPE = symbolFor('react.scope');
        REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
        REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
        REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
        REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
    }
    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';
    function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== 'object') return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === 'function') return maybeIterator;
        return null;
    }
    // Helpers to patch console.logs to avoid logging during side-effect free
    // replaying on render function. This currently only patches the object
    // lazily which won't cover if the log function was extracted eagerly.
    // We could also eagerly patch the method.
    var disabledDepth = 0;
    var prevLog;
    var prevInfo;
    var prevWarn;
    var prevError;
    var prevGroup;
    var prevGroupCollapsed;
    var prevGroupEnd;
    function disabledLog() {
    }
    disabledLog.__reactDisabledLog = true;
    function disableLogs() {
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099
            var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        /* eslint-enable react-internal/no-production-logging */ }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ var props = {
                configurable: true,
                enumerable: true,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                log: _assign({
                }, props, {
                    value: prevLog
                }),
                info: _assign({
                }, props, {
                    value: prevInfo
                }),
                warn: _assign({
                }, props, {
                    value: prevWarn
                }),
                error: _assign({
                }, props, {
                    value: prevError
                }),
                group: _assign({
                }, props, {
                    value: prevGroup
                }),
                groupCollapsed: _assign({
                }, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: _assign({
                }, props, {
                    value: prevGroupEnd
                })
            });
        /* eslint-enable react-internal/no-production-logging */ }
        if (disabledDepth < 0) error1("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    var ReactCurrentDispatcher1 = ReactSharedInternals.ReactCurrentDispatcher;
    var prefix1;
    function describeBuiltInComponentFrame(name, source, ownerFn) {
        if (prefix1 === undefined) // Extract the VM specific prefix used by each line.
        try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix1 = match && match[1] || '';
        }
         // We use the prefix to ensure our stacks line up with native stack frames.
        return '\n' + prefix1 + name;
    }
    var reentry = false;
    var componentFrameCache;
    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
    componentFrameCache = new PossiblyWeakMap();
    function describeNativeComponentFrame(fn, construct) {
        // If something asked for a stack inside a fake render, it should get ignored.
        if (!fn || reentry) return '';
        var frame = componentFrameCache.get(fn);
        if (frame !== undefined) return frame;
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher1.current; // Set the dispatcher in DEV because this might be call in the render function
        // for warnings.
        ReactCurrentDispatcher1.current = null;
        disableLogs();
        try {
            // This should throw.
            if (construct) {
                // Something should be setting the props in the constructor.
                var Fake = function() {
                    throw Error();
                }; // $FlowFixMe
                Object.defineProperty(Fake.prototype, 'props', {
                    set: function() {
                        // We use a throwing setter instead of frozen or non-writable props
                        // because that won't throw in a non-strict mode function.
                        throw Error();
                    }
                });
                if (typeof Reflect === 'object' && Reflect.construct) {
                    // We construct a different control for this case to include any extra
                    // frames added by the construct call.
                    try {
                        Reflect.construct(Fake, []);
                    } catch (x) {
                        control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                } else {
                    try {
                        Fake.call();
                    } catch (x) {
                        control = x;
                    }
                    fn.call(Fake.prototype);
                }
            } else {
                try {
                    throw Error();
                } catch (x) {
                    control = x;
                }
                fn();
            }
        } catch (sample) {
            // This is inlined manually because closure doesn't do it for us.
            if (sample && control && typeof sample.stack === 'string') {
                // This extracts the first frame from the sample that isn't also in the control.
                // Skipping one frame that we assume is the frame that calls the two.
                var sampleLines = sample.stack.split('\n');
                var controlLines = control.stack.split('\n');
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c])// We expect at least one stack frame to be shared.
                // Typically this will be the root most one. However, stack frames may be
                // cut off due to maximum stack limits. In this case, one maybe cut off
                // earlier than the other. We assume that the sample is longer or the same
                // and there for cut off earlier. So we should find the root most frame in
                // the sample somewhere in the control.
                c--;
                for(; s >= 1 && c >= 0; s--, c--)// Next we find the first one that isn't the same which should be the
                // frame that called our sample function and the control.
                if (sampleLines[s] !== controlLines[c]) {
                    // In V8, the first line is describing the message but other VMs don't.
                    // If we're about to return the first line, and the control is also on the same
                    // line, that's a pretty good indicator that our sample threw at same line as
                    // the control. I.e. before we entered the sample frame. So we ignore this result.
                    // This can happen if you passed a class to function component, or non-function.
                    if (s !== 1 || c !== 1) do {
                        s--;
                        c--; // We may still have similar intermediate frames from the construct call.
                        // The next one that isn't the same should be our match though.
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                            // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                            var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                            if (typeof fn === 'function') componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                    }while (s >= 1 && c >= 0)
                    break;
                }
            }
        } finally{
            reentry = false;
            ReactCurrentDispatcher1.current = previousDispatcher;
            reenableLogs();
            Error.prepareStackTrace = previousPrepareStackTrace;
        } // Fallback to just using the name if we couldn't make it throw.
        var name = fn ? fn.displayName || fn.name : '';
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
        if (typeof fn === 'function') componentFrameCache.set(fn, syntheticFrame);
        return syntheticFrame;
    }
    function describeClassComponentFrame(ctor, source, ownerFn) {
        return describeNativeComponentFrame(ctor, true);
    }
    function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, false);
    }
    function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
    }
    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) return '';
        if (typeof type === 'function') return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type === 'string') return describeBuiltInComponentFrame(type);
        switch(type){
            case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame('Suspense');
            case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame('SuspenseList');
        }
        if (typeof type === 'object') switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
                // Memo may contain any component type so we recursively resolve it.
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    // Lazy may contain any component type so we recursively resolve it.
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
        }
        return '';
    }
    function describeFiber(fiber) {
        var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
        var source = fiber._debugSource;
        switch(fiber.tag){
            case HostComponent:
                return describeBuiltInComponentFrame(fiber.type);
            case LazyComponent:
                return describeBuiltInComponentFrame('Lazy');
            case SuspenseComponent:
                return describeBuiltInComponentFrame('Suspense');
            case SuspenseListComponent:
                return describeBuiltInComponentFrame('SuspenseList');
            case FunctionComponent:
            case IndeterminateComponent:
            case SimpleMemoComponent:
                return describeFunctionComponentFrame(fiber.type);
            case ForwardRef:
                return describeFunctionComponentFrame(fiber.type.render);
            case Block:
                return describeFunctionComponentFrame(fiber.type._render);
            case ClassComponent:
                return describeClassComponentFrame(fiber.type);
            default:
                return '';
        }
    }
    function getStackByFiberInDevAndProd(workInProgress) {
        try {
            var info = '';
            var node = workInProgress;
            do {
                info += describeFiber(node);
                node = node.return;
            }while (node)
            return info;
        } catch (x) {
            return '\nError generating stack: ' + x.message + '\n' + x.stack;
        }
    }
    function getWrappedName(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || '';
        return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
    }
    function getContextName(type) {
        return type.displayName || 'Context';
    }
    function getComponentName(type) {
        if (type == null) // Host root, text node or just invalid type.
        return null;
        if (typeof type.tag === 'number') error1("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
        if (typeof type === 'function') return type.displayName || type.name || null;
        if (typeof type === 'string') return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return 'Fragment';
            case REACT_PORTAL_TYPE:
                return 'Portal';
            case REACT_PROFILER_TYPE:
                return 'Profiler';
            case REACT_STRICT_MODE_TYPE:
                return 'StrictMode';
            case REACT_SUSPENSE_TYPE:
                return 'Suspense';
            case REACT_SUSPENSE_LIST_TYPE:
                return 'SuspenseList';
        }
        if (typeof type === 'object') switch(type.$$typeof){
            case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + '.Consumer';
            case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + '.Provider';
            case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, 'ForwardRef');
            case REACT_MEMO_TYPE:
                return getComponentName(type.type);
            case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    return getComponentName(init(payload));
                } catch (x) {
                    return null;
                }
        }
        return null;
    }
    var ReactDebugCurrentFrame1 = ReactSharedInternals.ReactDebugCurrentFrame;
    var current1 = null;
    var isRendering = false;
    function getCurrentFiberOwnerNameInDevOrNull() {
        if (current1 === null) return null;
        var owner = current1._debugOwner;
        if (owner !== null && typeof owner !== 'undefined') return getComponentName(owner.type);
        return null;
    }
    function getCurrentFiberStackInDev() {
        if (current1 === null) return '';
         // Safe because if current fiber exists, we are reconciling,
        // and it is guaranteed to be the work-in-progress version.
        return getStackByFiberInDevAndProd(current1);
    }
    function resetCurrentFiber() {
        ReactDebugCurrentFrame1.getCurrentStack = null;
        current1 = null;
        isRendering = false;
    }
    function setCurrentFiber(fiber) {
        ReactDebugCurrentFrame1.getCurrentStack = getCurrentFiberStackInDev;
        current1 = fiber;
        isRendering = false;
    }
    function setIsRendering(rendering) {
        isRendering = rendering;
    }
    function getIsRendering() {
        return isRendering;
    }
    // Flow does not allow string concatenation of most non-string types. To work
    // around this limitation, we use an opaque type that can only be obtained by
    // passing the value through getToStringValue first.
    function toString(value) {
        return '' + value;
    }
    function getToStringValue(value) {
        switch(typeof value){
            case 'boolean':
            case 'number':
            case 'object':
            case 'string':
            case 'undefined':
                return value;
            default:
                // function, symbol are assigned as empty strings
                return '';
        }
    }
    var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
    };
    function checkControlledValueProps(tagName, props) {
        if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) error1("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
        if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) error1("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function isCheckable(elem) {
        var type = elem.type;
        var nodeName = elem.nodeName;
        return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
    }
    function getTracker(node) {
        return node._valueTracker;
    }
    function detachTracker(node) {
        node._valueTracker = null;
    }
    function getValueFromNode(node) {
        var value = '';
        if (!node) return value;
        if (isCheckable(node)) value = node.checked ? 'true' : 'false';
        else value = node.value;
        return value;
    }
    function trackValueOnNode(node) {
        var valueField = isCheckable(node) ? 'checked' : 'value';
        var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
        var currentValue = '' + node[valueField]; // if someone has already defined a value or Safari, then bail
        // and don't track value will cause over reporting of changes,
        // but it's better then a hard failure
        // (needed for certain tests that spyOn input values and Safari)
        if (node.hasOwnProperty(valueField) || typeof descriptor === 'undefined' || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') return;
        var get = descriptor.get, set = descriptor.set;
        Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
                return get.call(this);
            },
            set: function(value) {
                currentValue = '' + value;
                set.call(this, value);
            }
        }); // We could've passed this the first time
        // but it triggers a bug in IE11 and Edge 14/15.
        // Calling defineProperty() again should be equivalent.
        // https://github.com/facebook/react/issues/11768
        Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
        });
        var tracker = {
            getValue: function() {
                return currentValue;
            },
            setValue: function(value) {
                currentValue = '' + value;
            },
            stopTracking: function() {
                detachTracker(node);
                delete node[valueField];
            }
        };
        return tracker;
    }
    function track(node) {
        if (getTracker(node)) return;
         // TODO: Once it's just Fiber we can move this to node._wrapperState
        node._valueTracker = trackValueOnNode(node);
    }
    function updateValueIfChanged(node) {
        if (!node) return false;
        var tracker = getTracker(node); // if there is no tracker at this point it's unlikely
        // that trying again will succeed
        if (!tracker) return true;
        var lastValue = tracker.getValue();
        var nextValue = getValueFromNode(node);
        if (nextValue !== lastValue) {
            tracker.setValue(nextValue);
            return true;
        }
        return false;
    }
    function getActiveElement(doc) {
        doc = doc || (typeof document !== 'undefined' ? document : undefined);
        if (typeof doc === 'undefined') return null;
        try {
            return doc.activeElement || doc.body;
        } catch (e) {
            return doc.body;
        }
    }
    var didWarnValueDefaultValue = false;
    var didWarnCheckedDefaultChecked = false;
    var didWarnControlledToUncontrolled = false;
    var didWarnUncontrolledToControlled = false;
    function isControlled(props) {
        var usesChecked = props.type === 'checkbox' || props.type === 'radio';
        return usesChecked ? props.checked != null : props.value != null;
    }
    /**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */ function getHostProps(element, props) {
        var node = element;
        var checked = props.checked;
        var hostProps = _assign({
        }, props, {
            defaultChecked: undefined,
            defaultValue: undefined,
            value: undefined,
            checked: checked != null ? checked : node._wrapperState.initialChecked
        });
        return hostProps;
    }
    function initWrapperState(element, props) {
        checkControlledValueProps('input', props);
        if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
            error1("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);
            didWarnCheckedDefaultChecked = true;
        }
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
            error1("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);
            didWarnValueDefaultValue = true;
        }
        var node = element;
        var defaultValue = props.defaultValue == null ? '' : props.defaultValue;
        node._wrapperState = {
            initialChecked: props.checked != null ? props.checked : props.defaultChecked,
            initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
            controlled: isControlled(props)
        };
    }
    function updateChecked(element, props) {
        var node = element;
        var checked = props.checked;
        if (checked != null) setValueForProperty(node, 'checked', checked, false);
    }
    function updateWrapper(element, props) {
        var node = element;
        var controlled = isControlled(props);
        if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
            error1("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
            didWarnUncontrolledToControlled = true;
        }
        if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
            error1("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
            didWarnControlledToUncontrolled = true;
        }
        updateChecked(element, props);
        var value = getToStringValue(props.value);
        var type = props.type;
        if (value != null) {
            if (type === 'number') {
                if (value === 0 && node.value === '' || // eslint-disable-next-line
                node.value != value) node.value = toString(value);
            } else if (node.value !== toString(value)) node.value = toString(value);
        } else if (type === 'submit' || type === 'reset') {
            // Submit/reset inputs need the attribute removed completely to avoid
            // blank-text buttons.
            node.removeAttribute('value');
            return;
        }
        // When syncing the value attribute, the value comes from a cascade of
        // properties:
        //  1. The value React property
        //  2. The defaultValue React property
        //  3. Otherwise there should be no change
        if (props.hasOwnProperty('value')) setDefaultValue(node, props.type, value);
        else if (props.hasOwnProperty('defaultValue')) setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
        // When syncing the checked attribute, it only changes when it needs
        // to be removed, such as transitioning from a checkbox into a text input
        if (props.checked == null && props.defaultChecked != null) node.defaultChecked = !!props.defaultChecked;
    }
    function postMountWrapper(element, props, isHydrating) {
        var node = element; // Do not assign value if it is already set. This prevents user text input
        // from being lost during SSR hydration.
        if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {
            var type = props.type;
            var isButton = type === 'submit' || type === 'reset'; // Avoid setting value attribute on submit/reset inputs as it overrides the
            // default value provided by the browser. See: #12872
            if (isButton && (props.value === undefined || props.value === null)) return;
            var initialValue = toString(node._wrapperState.initialValue); // Do not assign value if it is already set. This prevents user text input
            // from being lost during SSR hydration.
            if (!isHydrating) // When syncing the value attribute, the value property should use
            // the wrapperState._initialValue property. This uses:
            //
            //   1. The value React property when present
            //   2. The defaultValue React property when present
            //   3. An empty string
            {
                if (initialValue !== node.value) node.value = initialValue;
            }
            // Otherwise, the value attribute is synchronized to the property,
            // so we assign defaultValue to the same thing as the value property
            // assignment step above.
            node.defaultValue = initialValue;
        } // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
        // this is needed to work around a chrome bug where setting defaultChecked
        // will sometimes influence the value of checked (even after detachment).
        // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
        // We need to temporarily unset name to avoid disrupting radio button groups.
        var name = node.name;
        if (name !== '') node.name = '';
        // When syncing the checked attribute, both the checked property and
        // attribute are assigned at the same time using defaultChecked. This uses:
        //
        //   1. The checked React property when present
        //   2. The defaultChecked React property when present
        //   3. Otherwise, false
        node.defaultChecked = !node.defaultChecked;
        node.defaultChecked = !!node._wrapperState.initialChecked;
        if (name !== '') node.name = name;
    }
    function restoreControlledState(element, props) {
        var node = element;
        updateWrapper(node, props);
        updateNamedCousins(node, props);
    }
    function updateNamedCousins(rootNode, props) {
        var name = props.name;
        if (props.type === 'radio' && name != null) {
            var queryRoot = rootNode;
            while(queryRoot.parentNode)queryRoot = queryRoot.parentNode;
             // If `rootNode.form` was non-null, then we could try `form.elements`,
            // but that sometimes behaves strangely in IE8. We could also try using
            // `form.getElementsByName`, but that will only return direct children
            // and won't include inputs that use the HTML5 `form=` attribute. Since
            // the input might not even be in a form. It might not even be in the
            // document. Let's just use the local `querySelectorAll` to ensure we don't
            // miss anything.
            var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
            for(var i = 0; i < group.length; i++){
                var otherNode = group[i];
                if (otherNode === rootNode || otherNode.form !== rootNode.form) continue;
                 // This will throw if radio buttons rendered by different copies of React
                // and the same name are rendered into the same form (same as #1939).
                // That's probably okay; we don't support it just as we don't support
                // mixing React radio buttons with non-React ones.
                var otherProps = getFiberCurrentPropsFromNode(otherNode);
                if (!otherProps) throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                 // We need update the tracked value on the named cousin since the value
                // was changed but the input saw no event or value set
                updateValueIfChanged(otherNode); // If this is a controlled radio button group, forcing the input that
                // was previously checked to update will cause it to be come re-checked
                // as appropriate.
                updateWrapper(otherNode, otherProps);
            }
        }
    } // In Chrome, assigning defaultValue to certain input types triggers input validation.
    // For number inputs, the display value loses trailing decimal points. For email inputs,
    // Chrome raises "The specified value <x> is not a valid email address".
    //
    // Here we check to see if the defaultValue has actually changed, avoiding these problems
    // when the user is inputting text
    //
    // https://github.com/facebook/react/issues/7253
    function setDefaultValue(node, type, value) {
        if (type !== 'number' || getActiveElement(node.ownerDocument) !== node) {
            if (value == null) node.defaultValue = toString(node._wrapperState.initialValue);
            else if (node.defaultValue !== toString(value)) node.defaultValue = toString(value);
        }
    }
    var didWarnSelectedSetOnOption = false;
    var didWarnInvalidChild = false;
    function flattenChildren(children) {
        var content = ''; // Flatten children. We'll warn if they are invalid
        // during validateProps() which runs for hydration too.
        // Note that this would throw on non-element objects.
        // Elements are stringified (which is normally irrelevant
        // but matters for <fbt>).
        React.Children.forEach(children, function(child) {
            if (child == null) return;
            content += child; // Note: we don't warn about invalid children here.
        // Instead, this is done separately below so that
        // it happens during the hydration code path too.
        });
        return content;
    }
    /**
 * Implements an <option> host component that warns when `selected` is set.
 */ function validateProps(element, props) {
        // This mirrors the code path above, but runs for hydration too.
        // Warn about invalid children here so that client and hydration are consistent.
        // TODO: this seems like it could cause a DEV-only throw for hydration
        // if children contains a non-element object. We should try to avoid that.
        if (typeof props.children === 'object' && props.children !== null) React.Children.forEach(props.children, function(child) {
            if (child == null) return;
            if (typeof child === 'string' || typeof child === 'number') return;
            if (typeof child.type !== 'string') return;
            if (!didWarnInvalidChild) {
                didWarnInvalidChild = true;
                error1('Only strings and numbers are supported as <option> children.');
            }
        });
         // TODO: Remove support for `selected` in <option>.
        if (props.selected != null && !didWarnSelectedSetOnOption) {
            error1("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
            didWarnSelectedSetOnOption = true;
        }
    }
    function postMountWrapper$1(element, props) {
        // value="" should make a value attribute (#6219)
        if (props.value != null) element.setAttribute('value', toString(getToStringValue(props.value)));
    }
    function getHostProps$1(element, props) {
        var hostProps = _assign({
            children: undefined
        }, props);
        var content = flattenChildren(props.children);
        if (content) hostProps.children = content;
        return hostProps;
    }
    var didWarnValueDefaultValue$1;
    didWarnValueDefaultValue$1 = false;
    function getDeclarationErrorAddendum() {
        var ownerName = getCurrentFiberOwnerNameInDevOrNull();
        if (ownerName) return '\n\nCheck the render method of `' + ownerName + '`.';
        return '';
    }
    var valuePropNames = [
        'value',
        'defaultValue'
    ];
    /**
 * Validation function for `value` and `defaultValue`.
 */ function checkSelectPropTypes(props) {
        checkControlledValueProps('select', props);
        for(var i = 0; i < valuePropNames.length; i++){
            var propName = valuePropNames[i];
            if (props[propName] == null) continue;
            var isArray = Array.isArray(props[propName]);
            if (props.multiple && !isArray) error1("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
            else if (!props.multiple && isArray) error1("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
        }
    }
    function updateOptions(node, multiple, propValue, setDefaultSelected) {
        var options = node.options;
        if (multiple) {
            var selectedValues = propValue;
            var selectedValue = {
            };
            for(var i = 0; i < selectedValues.length; i++)// Prefix to avoid chaos with special keys.
            selectedValue['$' + selectedValues[i]] = true;
            for(var _i = 0; _i < options.length; _i++){
                var selected = selectedValue.hasOwnProperty('$' + options[_i].value);
                if (options[_i].selected !== selected) options[_i].selected = selected;
                if (selected && setDefaultSelected) options[_i].defaultSelected = true;
            }
        } else {
            // Do not set `select.value` as exact behavior isn't consistent across all
            // browsers for all cases.
            var _selectedValue = toString(getToStringValue(propValue));
            var defaultSelected = null;
            for(var _i2 = 0; _i2 < options.length; _i2++){
                if (options[_i2].value === _selectedValue) {
                    options[_i2].selected = true;
                    if (setDefaultSelected) options[_i2].defaultSelected = true;
                    return;
                }
                if (defaultSelected === null && !options[_i2].disabled) defaultSelected = options[_i2];
            }
            if (defaultSelected !== null) defaultSelected.selected = true;
        }
    }
    /**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */ function getHostProps$2(element, props) {
        return _assign({
        }, props, {
            value: undefined
        });
    }
    function initWrapperState$1(element, props) {
        var node = element;
        checkSelectPropTypes(props);
        node._wrapperState = {
            wasMultiple: !!props.multiple
        };
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
            error1("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnValueDefaultValue$1 = true;
        }
    }
    function postMountWrapper$2(element, props) {
        var node = element;
        node.multiple = !!props.multiple;
        var value = props.value;
        if (value != null) updateOptions(node, !!props.multiple, value, false);
        else if (props.defaultValue != null) updateOptions(node, !!props.multiple, props.defaultValue, true);
    }
    function postUpdateWrapper(element, props) {
        var node = element;
        var wasMultiple = node._wrapperState.wasMultiple;
        node._wrapperState.wasMultiple = !!props.multiple;
        var value = props.value;
        if (value != null) updateOptions(node, !!props.multiple, value, false);
        else if (wasMultiple !== !!props.multiple) {
            // For simplicity, reapply `defaultValue` if `multiple` is toggled.
            if (props.defaultValue != null) updateOptions(node, !!props.multiple, props.defaultValue, true);
            else // Revert the select back to its default unselected state.
            updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
        }
    }
    function restoreControlledState$1(element, props) {
        var node = element;
        var value = props.value;
        if (value != null) updateOptions(node, !!props.multiple, value, false);
    }
    var didWarnValDefaultVal = false;
    /**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */ function getHostProps$3(element, props) {
        var node = element;
        if (!(props.dangerouslySetInnerHTML == null)) throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
         // Always set children to the same thing. In IE9, the selection range will
        // get reset if `textContent` is mutated.  We could add a check in setTextContent
        // to only set the value if/when the value differs from the node value (which would
        // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
        // solution. The value can be a boolean or object so that's why it's forced
        // to be a string.
        var hostProps = _assign({
        }, props, {
            value: undefined,
            defaultValue: undefined,
            children: toString(node._wrapperState.initialValue)
        });
        return hostProps;
    }
    function initWrapperState$2(element, props) {
        var node = element;
        checkControlledValueProps('textarea', props);
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
            error1("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || 'A component');
            didWarnValDefaultVal = true;
        }
        var initialValue = props.value; // Only bother fetching default value if we're going to use it
        if (initialValue == null) {
            var children = props.children, defaultValue = props.defaultValue;
            if (children != null) {
                error1("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                if (!(defaultValue == null)) throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                if (Array.isArray(children)) {
                    if (!(children.length <= 1)) throw Error("<textarea> can only have at most one child.");
                    children = children[0];
                }
                defaultValue = children;
            }
            if (defaultValue == null) defaultValue = '';
            initialValue = defaultValue;
        }
        node._wrapperState = {
            initialValue: getToStringValue(initialValue)
        };
    }
    function updateWrapper$1(element, props) {
        var node = element;
        var value = getToStringValue(props.value);
        var defaultValue = getToStringValue(props.defaultValue);
        if (value != null) {
            // Cast `value` to a string to ensure the value is set correctly. While
            // browsers typically do this as necessary, jsdom doesn't.
            var newValue = toString(value); // To avoid side effects (such as losing text selection), only set value if changed
            if (newValue !== node.value) node.value = newValue;
            if (props.defaultValue == null && node.defaultValue !== newValue) node.defaultValue = newValue;
        }
        if (defaultValue != null) node.defaultValue = toString(defaultValue);
    }
    function postMountWrapper$3(element, props) {
        var node = element; // This is in postMount because we need access to the DOM node, which is not
        // available until after the component has mounted.
        var textContent = node.textContent; // Only set node.value if textContent is equal to the expected
        // initial value. In IE10/IE11 there is a bug where the placeholder attribute
        // will populate textContent as well.
        // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
        if (textContent === node._wrapperState.initialValue) {
            if (textContent !== '' && textContent !== null) node.value = textContent;
        }
    }
    function restoreControlledState$2(element, props) {
        // DOM component is still mounted; update
        updateWrapper$1(element, props);
    }
    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    var Namespaces = {
        html: HTML_NAMESPACE,
        mathml: MATH_NAMESPACE,
        svg: SVG_NAMESPACE
    }; // Assumes there is no parent namespace.
    function getIntrinsicNamespace(type) {
        switch(type){
            case 'svg':
                return SVG_NAMESPACE;
            case 'math':
                return MATH_NAMESPACE;
            default:
                return HTML_NAMESPACE;
        }
    }
    function getChildNamespace(parentNamespace, type) {
        if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) // No (or default) parent namespace: potential entry point.
        return getIntrinsicNamespace(type);
        if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') // We're leaving SVG.
        return HTML_NAMESPACE;
         // By default, pass namespace below.
        return parentNamespace;
    }
    /* globals MSApp */ /**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */ var createMicrosoftUnsafeLocalFunction = function(func) {
        if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) return function(arg0, arg1, arg2, arg3) {
            MSApp.execUnsafeLocalFunction(function() {
                return func(arg0, arg1, arg2, arg3);
            });
        };
        else return func;
    };
    var reusableSVGContainer;
    /**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */ var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
        if (node.namespaceURI === Namespaces.svg) {
            if (!('innerHTML' in node)) {
                // IE does not have innerHTML for SVG nodes, so instead we inject the
                // new markup in a temp node and then move the child nodes across into
                // the target node
                reusableSVGContainer = reusableSVGContainer || document.createElement('div');
                reusableSVGContainer.innerHTML = '<svg>' + html.valueOf().toString() + '</svg>';
                var svgNode = reusableSVGContainer.firstChild;
                while(node.firstChild)node.removeChild(node.firstChild);
                while(svgNode.firstChild)node.appendChild(svgNode.firstChild);
                return;
            }
        }
        node.innerHTML = html;
    });
    /**
 * HTML nodeType values that represent the type of the node
 */ var ELEMENT_NODE = 1;
    var TEXT_NODE = 3;
    var COMMENT_NODE = 8;
    var DOCUMENT_NODE = 9;
    var DOCUMENT_FRAGMENT_NODE = 11;
    /**
 * Set the textContent property of a node. For text updates, it's faster
 * to set the `nodeValue` of the Text node directly instead of using
 * `.textContent` which will remove the existing node and create a new one.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */ var setTextContent = function(node, text) {
        if (text) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
                firstChild.nodeValue = text;
                return;
            }
        }
        node.textContent = text;
    };
    // List derived from Gecko source code:
    // https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js
    var shorthandToLonghand = {
        animation: [
            'animationDelay',
            'animationDirection',
            'animationDuration',
            'animationFillMode',
            'animationIterationCount',
            'animationName',
            'animationPlayState',
            'animationTimingFunction'
        ],
        background: [
            'backgroundAttachment',
            'backgroundClip',
            'backgroundColor',
            'backgroundImage',
            'backgroundOrigin',
            'backgroundPositionX',
            'backgroundPositionY',
            'backgroundRepeat',
            'backgroundSize'
        ],
        backgroundPosition: [
            'backgroundPositionX',
            'backgroundPositionY'
        ],
        border: [
            'borderBottomColor',
            'borderBottomStyle',
            'borderBottomWidth',
            'borderImageOutset',
            'borderImageRepeat',
            'borderImageSlice',
            'borderImageSource',
            'borderImageWidth',
            'borderLeftColor',
            'borderLeftStyle',
            'borderLeftWidth',
            'borderRightColor',
            'borderRightStyle',
            'borderRightWidth',
            'borderTopColor',
            'borderTopStyle',
            'borderTopWidth'
        ],
        borderBlockEnd: [
            'borderBlockEndColor',
            'borderBlockEndStyle',
            'borderBlockEndWidth'
        ],
        borderBlockStart: [
            'borderBlockStartColor',
            'borderBlockStartStyle',
            'borderBlockStartWidth'
        ],
        borderBottom: [
            'borderBottomColor',
            'borderBottomStyle',
            'borderBottomWidth'
        ],
        borderColor: [
            'borderBottomColor',
            'borderLeftColor',
            'borderRightColor',
            'borderTopColor'
        ],
        borderImage: [
            'borderImageOutset',
            'borderImageRepeat',
            'borderImageSlice',
            'borderImageSource',
            'borderImageWidth'
        ],
        borderInlineEnd: [
            'borderInlineEndColor',
            'borderInlineEndStyle',
            'borderInlineEndWidth'
        ],
        borderInlineStart: [
            'borderInlineStartColor',
            'borderInlineStartStyle',
            'borderInlineStartWidth'
        ],
        borderLeft: [
            'borderLeftColor',
            'borderLeftStyle',
            'borderLeftWidth'
        ],
        borderRadius: [
            'borderBottomLeftRadius',
            'borderBottomRightRadius',
            'borderTopLeftRadius',
            'borderTopRightRadius'
        ],
        borderRight: [
            'borderRightColor',
            'borderRightStyle',
            'borderRightWidth'
        ],
        borderStyle: [
            'borderBottomStyle',
            'borderLeftStyle',
            'borderRightStyle',
            'borderTopStyle'
        ],
        borderTop: [
            'borderTopColor',
            'borderTopStyle',
            'borderTopWidth'
        ],
        borderWidth: [
            'borderBottomWidth',
            'borderLeftWidth',
            'borderRightWidth',
            'borderTopWidth'
        ],
        columnRule: [
            'columnRuleColor',
            'columnRuleStyle',
            'columnRuleWidth'
        ],
        columns: [
            'columnCount',
            'columnWidth'
        ],
        flex: [
            'flexBasis',
            'flexGrow',
            'flexShrink'
        ],
        flexFlow: [
            'flexDirection',
            'flexWrap'
        ],
        font: [
            'fontFamily',
            'fontFeatureSettings',
            'fontKerning',
            'fontLanguageOverride',
            'fontSize',
            'fontSizeAdjust',
            'fontStretch',
            'fontStyle',
            'fontVariant',
            'fontVariantAlternates',
            'fontVariantCaps',
            'fontVariantEastAsian',
            'fontVariantLigatures',
            'fontVariantNumeric',
            'fontVariantPosition',
            'fontWeight',
            'lineHeight'
        ],
        fontVariant: [
            'fontVariantAlternates',
            'fontVariantCaps',
            'fontVariantEastAsian',
            'fontVariantLigatures',
            'fontVariantNumeric',
            'fontVariantPosition'
        ],
        gap: [
            'columnGap',
            'rowGap'
        ],
        grid: [
            'gridAutoColumns',
            'gridAutoFlow',
            'gridAutoRows',
            'gridTemplateAreas',
            'gridTemplateColumns',
            'gridTemplateRows'
        ],
        gridArea: [
            'gridColumnEnd',
            'gridColumnStart',
            'gridRowEnd',
            'gridRowStart'
        ],
        gridColumn: [
            'gridColumnEnd',
            'gridColumnStart'
        ],
        gridColumnGap: [
            'columnGap'
        ],
        gridGap: [
            'columnGap',
            'rowGap'
        ],
        gridRow: [
            'gridRowEnd',
            'gridRowStart'
        ],
        gridRowGap: [
            'rowGap'
        ],
        gridTemplate: [
            'gridTemplateAreas',
            'gridTemplateColumns',
            'gridTemplateRows'
        ],
        listStyle: [
            'listStyleImage',
            'listStylePosition',
            'listStyleType'
        ],
        margin: [
            'marginBottom',
            'marginLeft',
            'marginRight',
            'marginTop'
        ],
        marker: [
            'markerEnd',
            'markerMid',
            'markerStart'
        ],
        mask: [
            'maskClip',
            'maskComposite',
            'maskImage',
            'maskMode',
            'maskOrigin',
            'maskPositionX',
            'maskPositionY',
            'maskRepeat',
            'maskSize'
        ],
        maskPosition: [
            'maskPositionX',
            'maskPositionY'
        ],
        outline: [
            'outlineColor',
            'outlineStyle',
            'outlineWidth'
        ],
        overflow: [
            'overflowX',
            'overflowY'
        ],
        padding: [
            'paddingBottom',
            'paddingLeft',
            'paddingRight',
            'paddingTop'
        ],
        placeContent: [
            'alignContent',
            'justifyContent'
        ],
        placeItems: [
            'alignItems',
            'justifyItems'
        ],
        placeSelf: [
            'alignSelf',
            'justifySelf'
        ],
        textDecoration: [
            'textDecorationColor',
            'textDecorationLine',
            'textDecorationStyle'
        ],
        textEmphasis: [
            'textEmphasisColor',
            'textEmphasisStyle'
        ],
        transition: [
            'transitionDelay',
            'transitionDuration',
            'transitionProperty',
            'transitionTimingFunction'
        ],
        wordWrap: [
            'overflowWrap'
        ]
    };
    /**
 * CSS properties which accept numbers but are not in units of "px".
 */ var isUnitlessNumber = {
        animationIterationCount: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        // SVG-related properties
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
    };
    /**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */ function prefixKey(prefix, key) {
        return prefix + key.charAt(0).toUpperCase() + key.substring(1);
    }
    /**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */ var prefixes1 = [
        'Webkit',
        'ms',
        'Moz',
        'O'
    ]; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
    // infinite loop, because it iterates over the newly added props too.
    Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes1.forEach(function(prefix) {
            isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
        });
    });
    /**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */ function dangerousStyleValue(name, value, isCustomProperty) {
        // Note that we've removed escapeTextForBrowser() calls here since the
        // whole string will be escaped when the attribute is injected into
        // the markup. If you provide unsafe user data here they can inject
        // arbitrary CSS which may be problematic (I couldn't repro this):
        // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
        // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
        // This is not an XSS hole but instead a potential CSS injection issue
        // which has lead to a greater discussion about how we're going to
        // trust URLs moving forward. See #2115901
        var isEmpty = value == null || typeof value === 'boolean' || value === '';
        if (isEmpty) return '';
        if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
        return ('' + value).trim();
    }
    var uppercasePattern = /([A-Z])/g;
    var msPattern = /^ms-/;
    /**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */ function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
    }
    var warnValidStyle = function() {
    };
    // 'msTransform' is correct, but the other prefixes should be capitalized
    var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
    var msPattern$1 = /^-ms-/;
    var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon
    var badStyleValueWithSemicolonPattern = /;\s*$/;
    var warnedStyleNames = {
    };
    var warnedStyleValues = {
    };
    var warnedForNaNValue = false;
    var warnedForInfinityValue = false;
    var camelize = function(string) {
        return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
        });
    };
    var warnHyphenatedStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) return;
        warnedStyleNames[name] = true;
        error1('Unsupported style property %s. Did you mean %s?', name, // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
        // is converted to lowercase `ms`.
        camelize(name.replace(msPattern$1, 'ms-')));
    };
    var warnBadVendoredStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) return;
        warnedStyleNames[name] = true;
        error1('Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
    };
    var warnStyleValueWithSemicolon = function(name, value) {
        if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) return;
        warnedStyleValues[value] = true;
        error1("Style property values shouldn't contain a semicolon. Try \"%s: %s\" instead.", name, value.replace(badStyleValueWithSemicolonPattern, ''));
    };
    var warnStyleValueIsNaN = function(name, value) {
        if (warnedForNaNValue) return;
        warnedForNaNValue = true;
        error1('`NaN` is an invalid value for the `%s` css style property.', name);
    };
    var warnStyleValueIsInfinity = function(name, value) {
        if (warnedForInfinityValue) return;
        warnedForInfinityValue = true;
        error1('`Infinity` is an invalid value for the `%s` css style property.', name);
    };
    warnValidStyle = function(name, value) {
        if (name.indexOf('-') > -1) warnHyphenatedStyleName(name);
        else if (badVendoredStyleNamePattern.test(name)) warnBadVendoredStyleName(name);
        else if (badStyleValueWithSemicolonPattern.test(value)) warnStyleValueWithSemicolon(name, value);
        if (typeof value === 'number') {
            if (isNaN(value)) warnStyleValueIsNaN(name, value);
            else if (!isFinite(value)) warnStyleValueIsInfinity(name, value);
        }
    };
    var warnValidStyle$1 = warnValidStyle;
    /**
 * Operations for dealing with CSS properties.
 */ /**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */ function createDangerousStringForStyles(styles) {
        var serialized = '';
        var delimiter = '';
        for(var styleName in styles){
            if (!styles.hasOwnProperty(styleName)) continue;
            var styleValue = styles[styleName];
            if (styleValue != null) {
                var isCustomProperty = styleName.indexOf('--') === 0;
                serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ':';
                serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                delimiter = ';';
            }
        }
        return serialized || null;
    }
    /**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */ function setValueForStyles(node, styles) {
        var style = node.style;
        for(var styleName in styles){
            if (!styles.hasOwnProperty(styleName)) continue;
            var isCustomProperty = styleName.indexOf('--') === 0;
            if (!isCustomProperty) warnValidStyle$1(styleName, styles[styleName]);
            var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
            if (styleName === 'float') styleName = 'cssFloat';
            if (isCustomProperty) style.setProperty(styleName, styleValue);
            else style[styleName] = styleValue;
        }
    }
    function isValueEmpty(value) {
        return value == null || typeof value === 'boolean' || value === '';
    }
    /**
 * Given {color: 'red', overflow: 'hidden'} returns {
 *   color: 'color',
 *   overflowX: 'overflow',
 *   overflowY: 'overflow',
 * }. This can be read as "the overflowY property was set by the overflow
 * shorthand". That is, the values are the property that each was derived from.
 */ function expandShorthandMap(styles) {
        var expanded = {
        };
        for(var key in styles){
            var longhands = shorthandToLonghand[key] || [
                key
            ];
            for(var i = 0; i < longhands.length; i++)expanded[longhands[i]] = key;
        }
        return expanded;
    }
    /**
 * When mixing shorthand and longhand property names, we warn during updates if
 * we expect an incorrect result to occur. In particular, we warn for:
 *
 * Updating a shorthand property (longhand gets overwritten):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}
 *   becomes .style.font = 'baz'
 * Removing a shorthand property (longhand gets lost too):
 *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}
 *   becomes .style.font = ''
 * Removing a longhand property (should revert to shorthand; doesn't):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}
 *   becomes .style.fontVariant = ''
 */ function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
        if (!nextStyles) return;
        var expandedUpdates = expandShorthandMap(styleUpdates);
        var expandedStyles = expandShorthandMap(nextStyles);
        var warnedAbout = {
        };
        for(var key in expandedUpdates){
            var originalKey = expandedUpdates[key];
            var correctOriginalKey = expandedStyles[key];
            if (correctOriginalKey && originalKey !== correctOriginalKey) {
                var warningKey = originalKey + ',' + correctOriginalKey;
                if (warnedAbout[warningKey]) continue;
                warnedAbout[warningKey] = true;
                error1("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? 'Removing' : 'Updating', originalKey, correctOriginalKey);
            }
        }
    }
    // For HTML, certain tags should omit their close tag. We keep a list for
    // those special-case tags.
    var omittedCloseTags = {
        area: true,
        base: true,
        br: true,
        col: true,
        embed: true,
        hr: true,
        img: true,
        input: true,
        keygen: true,
        link: true,
        meta: true,
        param: true,
        source: true,
        track: true,
        wbr: true // NOTE: menuitem's close tag should be omitted, but that causes problems.
    };
    // `omittedCloseTags` except that `menuitem` should still have its closing tag.
    var voidElementTags = _assign({
        menuitem: true
    }, omittedCloseTags);
    var HTML = '__html';
    function assertValidProps(tag, props) {
        if (!props) return;
         // Note the use of `==` which checks for null or undefined.
        if (voidElementTags[tag]) {
            if (!(props.children == null && props.dangerouslySetInnerHTML == null)) throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        }
        if (props.dangerouslySetInnerHTML != null) {
            if (!(props.children == null)) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            if (!(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) error1("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
        if (!(props.style == null || typeof props.style === 'object')) throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
    }
    function isCustomComponent(tagName, props) {
        if (tagName.indexOf('-') === -1) return typeof props.is === 'string';
        switch(tagName){
            // These are reserved SVG and MathML elements.
            // We don't mind this list too much because we expect it to never grow.
            // The alternative is to track the namespace in a few places which is convoluted.
            // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
            case 'annotation-xml':
            case 'color-profile':
            case 'font-face':
            case 'font-face-src':
            case 'font-face-uri':
            case 'font-face-format':
            case 'font-face-name':
            case 'missing-glyph':
                return false;
            default:
                return true;
        }
    }
    // When adding attributes to the HTML or SVG allowed attribute list, be sure to
    // also add them to this module to ensure casing and incorrect name
    // warnings.
    var possibleStandardNames = {
        // HTML
        accept: 'accept',
        acceptcharset: 'acceptCharset',
        'accept-charset': 'acceptCharset',
        accesskey: 'accessKey',
        action: 'action',
        allowfullscreen: 'allowFullScreen',
        alt: 'alt',
        as: 'as',
        async: 'async',
        autocapitalize: 'autoCapitalize',
        autocomplete: 'autoComplete',
        autocorrect: 'autoCorrect',
        autofocus: 'autoFocus',
        autoplay: 'autoPlay',
        autosave: 'autoSave',
        capture: 'capture',
        cellpadding: 'cellPadding',
        cellspacing: 'cellSpacing',
        challenge: 'challenge',
        charset: 'charSet',
        checked: 'checked',
        children: 'children',
        cite: 'cite',
        class: 'className',
        classid: 'classID',
        classname: 'className',
        cols: 'cols',
        colspan: 'colSpan',
        content: 'content',
        contenteditable: 'contentEditable',
        contextmenu: 'contextMenu',
        controls: 'controls',
        controlslist: 'controlsList',
        coords: 'coords',
        crossorigin: 'crossOrigin',
        dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
        data: 'data',
        datetime: 'dateTime',
        default: 'default',
        defaultchecked: 'defaultChecked',
        defaultvalue: 'defaultValue',
        defer: 'defer',
        dir: 'dir',
        disabled: 'disabled',
        disablepictureinpicture: 'disablePictureInPicture',
        disableremoteplayback: 'disableRemotePlayback',
        download: 'download',
        draggable: 'draggable',
        enctype: 'encType',
        enterkeyhint: 'enterKeyHint',
        for: 'htmlFor',
        form: 'form',
        formmethod: 'formMethod',
        formaction: 'formAction',
        formenctype: 'formEncType',
        formnovalidate: 'formNoValidate',
        formtarget: 'formTarget',
        frameborder: 'frameBorder',
        headers: 'headers',
        height: 'height',
        hidden: 'hidden',
        high: 'high',
        href: 'href',
        hreflang: 'hrefLang',
        htmlfor: 'htmlFor',
        httpequiv: 'httpEquiv',
        'http-equiv': 'httpEquiv',
        icon: 'icon',
        id: 'id',
        innerhtml: 'innerHTML',
        inputmode: 'inputMode',
        integrity: 'integrity',
        is: 'is',
        itemid: 'itemID',
        itemprop: 'itemProp',
        itemref: 'itemRef',
        itemscope: 'itemScope',
        itemtype: 'itemType',
        keyparams: 'keyParams',
        keytype: 'keyType',
        kind: 'kind',
        label: 'label',
        lang: 'lang',
        list: 'list',
        loop: 'loop',
        low: 'low',
        manifest: 'manifest',
        marginwidth: 'marginWidth',
        marginheight: 'marginHeight',
        max: 'max',
        maxlength: 'maxLength',
        media: 'media',
        mediagroup: 'mediaGroup',
        method: 'method',
        min: 'min',
        minlength: 'minLength',
        multiple: 'multiple',
        muted: 'muted',
        name: 'name',
        nomodule: 'noModule',
        nonce: 'nonce',
        novalidate: 'noValidate',
        open: 'open',
        optimum: 'optimum',
        pattern: 'pattern',
        placeholder: 'placeholder',
        playsinline: 'playsInline',
        poster: 'poster',
        preload: 'preload',
        profile: 'profile',
        radiogroup: 'radioGroup',
        readonly: 'readOnly',
        referrerpolicy: 'referrerPolicy',
        rel: 'rel',
        required: 'required',
        reversed: 'reversed',
        role: 'role',
        rows: 'rows',
        rowspan: 'rowSpan',
        sandbox: 'sandbox',
        scope: 'scope',
        scoped: 'scoped',
        scrolling: 'scrolling',
        seamless: 'seamless',
        selected: 'selected',
        shape: 'shape',
        size: 'size',
        sizes: 'sizes',
        span: 'span',
        spellcheck: 'spellCheck',
        src: 'src',
        srcdoc: 'srcDoc',
        srclang: 'srcLang',
        srcset: 'srcSet',
        start: 'start',
        step: 'step',
        style: 'style',
        summary: 'summary',
        tabindex: 'tabIndex',
        target: 'target',
        title: 'title',
        type: 'type',
        usemap: 'useMap',
        value: 'value',
        width: 'width',
        wmode: 'wmode',
        wrap: 'wrap',
        // SVG
        about: 'about',
        accentheight: 'accentHeight',
        'accent-height': 'accentHeight',
        accumulate: 'accumulate',
        additive: 'additive',
        alignmentbaseline: 'alignmentBaseline',
        'alignment-baseline': 'alignmentBaseline',
        allowreorder: 'allowReorder',
        alphabetic: 'alphabetic',
        amplitude: 'amplitude',
        arabicform: 'arabicForm',
        'arabic-form': 'arabicForm',
        ascent: 'ascent',
        attributename: 'attributeName',
        attributetype: 'attributeType',
        autoreverse: 'autoReverse',
        azimuth: 'azimuth',
        basefrequency: 'baseFrequency',
        baselineshift: 'baselineShift',
        'baseline-shift': 'baselineShift',
        baseprofile: 'baseProfile',
        bbox: 'bbox',
        begin: 'begin',
        bias: 'bias',
        by: 'by',
        calcmode: 'calcMode',
        capheight: 'capHeight',
        'cap-height': 'capHeight',
        clip: 'clip',
        clippath: 'clipPath',
        'clip-path': 'clipPath',
        clippathunits: 'clipPathUnits',
        cliprule: 'clipRule',
        'clip-rule': 'clipRule',
        color: 'color',
        colorinterpolation: 'colorInterpolation',
        'color-interpolation': 'colorInterpolation',
        colorinterpolationfilters: 'colorInterpolationFilters',
        'color-interpolation-filters': 'colorInterpolationFilters',
        colorprofile: 'colorProfile',
        'color-profile': 'colorProfile',
        colorrendering: 'colorRendering',
        'color-rendering': 'colorRendering',
        contentscripttype: 'contentScriptType',
        contentstyletype: 'contentStyleType',
        cursor: 'cursor',
        cx: 'cx',
        cy: 'cy',
        d: 'd',
        datatype: 'datatype',
        decelerate: 'decelerate',
        descent: 'descent',
        diffuseconstant: 'diffuseConstant',
        direction: 'direction',
        display: 'display',
        divisor: 'divisor',
        dominantbaseline: 'dominantBaseline',
        'dominant-baseline': 'dominantBaseline',
        dur: 'dur',
        dx: 'dx',
        dy: 'dy',
        edgemode: 'edgeMode',
        elevation: 'elevation',
        enablebackground: 'enableBackground',
        'enable-background': 'enableBackground',
        end: 'end',
        exponent: 'exponent',
        externalresourcesrequired: 'externalResourcesRequired',
        fill: 'fill',
        fillopacity: 'fillOpacity',
        'fill-opacity': 'fillOpacity',
        fillrule: 'fillRule',
        'fill-rule': 'fillRule',
        filter: 'filter',
        filterres: 'filterRes',
        filterunits: 'filterUnits',
        floodopacity: 'floodOpacity',
        'flood-opacity': 'floodOpacity',
        floodcolor: 'floodColor',
        'flood-color': 'floodColor',
        focusable: 'focusable',
        fontfamily: 'fontFamily',
        'font-family': 'fontFamily',
        fontsize: 'fontSize',
        'font-size': 'fontSize',
        fontsizeadjust: 'fontSizeAdjust',
        'font-size-adjust': 'fontSizeAdjust',
        fontstretch: 'fontStretch',
        'font-stretch': 'fontStretch',
        fontstyle: 'fontStyle',
        'font-style': 'fontStyle',
        fontvariant: 'fontVariant',
        'font-variant': 'fontVariant',
        fontweight: 'fontWeight',
        'font-weight': 'fontWeight',
        format: 'format',
        from: 'from',
        fx: 'fx',
        fy: 'fy',
        g1: 'g1',
        g2: 'g2',
        glyphname: 'glyphName',
        'glyph-name': 'glyphName',
        glyphorientationhorizontal: 'glyphOrientationHorizontal',
        'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
        glyphorientationvertical: 'glyphOrientationVertical',
        'glyph-orientation-vertical': 'glyphOrientationVertical',
        glyphref: 'glyphRef',
        gradienttransform: 'gradientTransform',
        gradientunits: 'gradientUnits',
        hanging: 'hanging',
        horizadvx: 'horizAdvX',
        'horiz-adv-x': 'horizAdvX',
        horizoriginx: 'horizOriginX',
        'horiz-origin-x': 'horizOriginX',
        ideographic: 'ideographic',
        imagerendering: 'imageRendering',
        'image-rendering': 'imageRendering',
        in2: 'in2',
        in: 'in',
        inlist: 'inlist',
        intercept: 'intercept',
        k1: 'k1',
        k2: 'k2',
        k3: 'k3',
        k4: 'k4',
        k: 'k',
        kernelmatrix: 'kernelMatrix',
        kernelunitlength: 'kernelUnitLength',
        kerning: 'kerning',
        keypoints: 'keyPoints',
        keysplines: 'keySplines',
        keytimes: 'keyTimes',
        lengthadjust: 'lengthAdjust',
        letterspacing: 'letterSpacing',
        'letter-spacing': 'letterSpacing',
        lightingcolor: 'lightingColor',
        'lighting-color': 'lightingColor',
        limitingconeangle: 'limitingConeAngle',
        local: 'local',
        markerend: 'markerEnd',
        'marker-end': 'markerEnd',
        markerheight: 'markerHeight',
        markermid: 'markerMid',
        'marker-mid': 'markerMid',
        markerstart: 'markerStart',
        'marker-start': 'markerStart',
        markerunits: 'markerUnits',
        markerwidth: 'markerWidth',
        mask: 'mask',
        maskcontentunits: 'maskContentUnits',
        maskunits: 'maskUnits',
        mathematical: 'mathematical',
        mode: 'mode',
        numoctaves: 'numOctaves',
        offset: 'offset',
        opacity: 'opacity',
        operator: 'operator',
        order: 'order',
        orient: 'orient',
        orientation: 'orientation',
        origin: 'origin',
        overflow: 'overflow',
        overlineposition: 'overlinePosition',
        'overline-position': 'overlinePosition',
        overlinethickness: 'overlineThickness',
        'overline-thickness': 'overlineThickness',
        paintorder: 'paintOrder',
        'paint-order': 'paintOrder',
        panose1: 'panose1',
        'panose-1': 'panose1',
        pathlength: 'pathLength',
        patterncontentunits: 'patternContentUnits',
        patterntransform: 'patternTransform',
        patternunits: 'patternUnits',
        pointerevents: 'pointerEvents',
        'pointer-events': 'pointerEvents',
        points: 'points',
        pointsatx: 'pointsAtX',
        pointsaty: 'pointsAtY',
        pointsatz: 'pointsAtZ',
        prefix: 'prefix',
        preservealpha: 'preserveAlpha',
        preserveaspectratio: 'preserveAspectRatio',
        primitiveunits: 'primitiveUnits',
        property: 'property',
        r: 'r',
        radius: 'radius',
        refx: 'refX',
        refy: 'refY',
        renderingintent: 'renderingIntent',
        'rendering-intent': 'renderingIntent',
        repeatcount: 'repeatCount',
        repeatdur: 'repeatDur',
        requiredextensions: 'requiredExtensions',
        requiredfeatures: 'requiredFeatures',
        resource: 'resource',
        restart: 'restart',
        result: 'result',
        results: 'results',
        rotate: 'rotate',
        rx: 'rx',
        ry: 'ry',
        scale: 'scale',
        security: 'security',
        seed: 'seed',
        shaperendering: 'shapeRendering',
        'shape-rendering': 'shapeRendering',
        slope: 'slope',
        spacing: 'spacing',
        specularconstant: 'specularConstant',
        specularexponent: 'specularExponent',
        speed: 'speed',
        spreadmethod: 'spreadMethod',
        startoffset: 'startOffset',
        stddeviation: 'stdDeviation',
        stemh: 'stemh',
        stemv: 'stemv',
        stitchtiles: 'stitchTiles',
        stopcolor: 'stopColor',
        'stop-color': 'stopColor',
        stopopacity: 'stopOpacity',
        'stop-opacity': 'stopOpacity',
        strikethroughposition: 'strikethroughPosition',
        'strikethrough-position': 'strikethroughPosition',
        strikethroughthickness: 'strikethroughThickness',
        'strikethrough-thickness': 'strikethroughThickness',
        string: 'string',
        stroke: 'stroke',
        strokedasharray: 'strokeDasharray',
        'stroke-dasharray': 'strokeDasharray',
        strokedashoffset: 'strokeDashoffset',
        'stroke-dashoffset': 'strokeDashoffset',
        strokelinecap: 'strokeLinecap',
        'stroke-linecap': 'strokeLinecap',
        strokelinejoin: 'strokeLinejoin',
        'stroke-linejoin': 'strokeLinejoin',
        strokemiterlimit: 'strokeMiterlimit',
        'stroke-miterlimit': 'strokeMiterlimit',
        strokewidth: 'strokeWidth',
        'stroke-width': 'strokeWidth',
        strokeopacity: 'strokeOpacity',
        'stroke-opacity': 'strokeOpacity',
        suppresscontenteditablewarning: 'suppressContentEditableWarning',
        suppresshydrationwarning: 'suppressHydrationWarning',
        surfacescale: 'surfaceScale',
        systemlanguage: 'systemLanguage',
        tablevalues: 'tableValues',
        targetx: 'targetX',
        targety: 'targetY',
        textanchor: 'textAnchor',
        'text-anchor': 'textAnchor',
        textdecoration: 'textDecoration',
        'text-decoration': 'textDecoration',
        textlength: 'textLength',
        textrendering: 'textRendering',
        'text-rendering': 'textRendering',
        to: 'to',
        transform: 'transform',
        typeof: 'typeof',
        u1: 'u1',
        u2: 'u2',
        underlineposition: 'underlinePosition',
        'underline-position': 'underlinePosition',
        underlinethickness: 'underlineThickness',
        'underline-thickness': 'underlineThickness',
        unicode: 'unicode',
        unicodebidi: 'unicodeBidi',
        'unicode-bidi': 'unicodeBidi',
        unicoderange: 'unicodeRange',
        'unicode-range': 'unicodeRange',
        unitsperem: 'unitsPerEm',
        'units-per-em': 'unitsPerEm',
        unselectable: 'unselectable',
        valphabetic: 'vAlphabetic',
        'v-alphabetic': 'vAlphabetic',
        values: 'values',
        vectoreffect: 'vectorEffect',
        'vector-effect': 'vectorEffect',
        version: 'version',
        vertadvy: 'vertAdvY',
        'vert-adv-y': 'vertAdvY',
        vertoriginx: 'vertOriginX',
        'vert-origin-x': 'vertOriginX',
        vertoriginy: 'vertOriginY',
        'vert-origin-y': 'vertOriginY',
        vhanging: 'vHanging',
        'v-hanging': 'vHanging',
        videographic: 'vIdeographic',
        'v-ideographic': 'vIdeographic',
        viewbox: 'viewBox',
        viewtarget: 'viewTarget',
        visibility: 'visibility',
        vmathematical: 'vMathematical',
        'v-mathematical': 'vMathematical',
        vocab: 'vocab',
        widths: 'widths',
        wordspacing: 'wordSpacing',
        'word-spacing': 'wordSpacing',
        writingmode: 'writingMode',
        'writing-mode': 'writingMode',
        x1: 'x1',
        x2: 'x2',
        x: 'x',
        xchannelselector: 'xChannelSelector',
        xheight: 'xHeight',
        'x-height': 'xHeight',
        xlinkactuate: 'xlinkActuate',
        'xlink:actuate': 'xlinkActuate',
        xlinkarcrole: 'xlinkArcrole',
        'xlink:arcrole': 'xlinkArcrole',
        xlinkhref: 'xlinkHref',
        'xlink:href': 'xlinkHref',
        xlinkrole: 'xlinkRole',
        'xlink:role': 'xlinkRole',
        xlinkshow: 'xlinkShow',
        'xlink:show': 'xlinkShow',
        xlinktitle: 'xlinkTitle',
        'xlink:title': 'xlinkTitle',
        xlinktype: 'xlinkType',
        'xlink:type': 'xlinkType',
        xmlbase: 'xmlBase',
        'xml:base': 'xmlBase',
        xmllang: 'xmlLang',
        'xml:lang': 'xmlLang',
        xmlns: 'xmlns',
        'xml:space': 'xmlSpace',
        xmlnsxlink: 'xmlnsXlink',
        'xmlns:xlink': 'xmlnsXlink',
        xmlspace: 'xmlSpace',
        y1: 'y1',
        y2: 'y2',
        y: 'y',
        ychannelselector: 'yChannelSelector',
        z: 'z',
        zoomandpan: 'zoomAndPan'
    };
    var ariaProperties = {
        'aria-current': 0,
        // state
        'aria-details': 0,
        'aria-disabled': 0,
        // state
        'aria-hidden': 0,
        // state
        'aria-invalid': 0,
        // state
        'aria-keyshortcuts': 0,
        'aria-label': 0,
        'aria-roledescription': 0,
        // Widget Attributes
        'aria-autocomplete': 0,
        'aria-checked': 0,
        'aria-expanded': 0,
        'aria-haspopup': 0,
        'aria-level': 0,
        'aria-modal': 0,
        'aria-multiline': 0,
        'aria-multiselectable': 0,
        'aria-orientation': 0,
        'aria-placeholder': 0,
        'aria-pressed': 0,
        'aria-readonly': 0,
        'aria-required': 0,
        'aria-selected': 0,
        'aria-sort': 0,
        'aria-valuemax': 0,
        'aria-valuemin': 0,
        'aria-valuenow': 0,
        'aria-valuetext': 0,
        // Live Region Attributes
        'aria-atomic': 0,
        'aria-busy': 0,
        'aria-live': 0,
        'aria-relevant': 0,
        // Drag-and-Drop Attributes
        'aria-dropeffect': 0,
        'aria-grabbed': 0,
        // Relationship Attributes
        'aria-activedescendant': 0,
        'aria-colcount': 0,
        'aria-colindex': 0,
        'aria-colspan': 0,
        'aria-controls': 0,
        'aria-describedby': 0,
        'aria-errormessage': 0,
        'aria-flowto': 0,
        'aria-labelledby': 0,
        'aria-owns': 0,
        'aria-posinset': 0,
        'aria-rowcount': 0,
        'aria-rowindex': 0,
        'aria-rowspan': 0,
        'aria-setsize': 0
    };
    var warnedProperties = {
    };
    var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
    var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
    var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    function validateProperty(tagName, name) {
        if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) return true;
        if (rARIACamel.test(name)) {
            var ariaName = 'aria-' + name.slice(4).toLowerCase();
            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM
            // DOM properties, then it is an invalid aria-* attribute.
            if (correctName == null) {
                error1('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);
                warnedProperties[name] = true;
                return true;
            } // aria-* attributes should be lowercase; suggest the lowercase version.
            if (name !== correctName) {
                error1('Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);
                warnedProperties[name] = true;
                return true;
            }
        }
        if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase();
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM
            // DOM properties, then it is an invalid aria-* attribute.
            if (standardName == null) {
                warnedProperties[name] = true;
                return false;
            } // aria-* attributes should be lowercase; suggest the lowercase version.
            if (name !== standardName) {
                error1('Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);
                warnedProperties[name] = true;
                return true;
            }
        }
        return true;
    }
    function warnInvalidARIAProps(type, props) {
        var invalidProps = [];
        for(var key in props){
            var isValid = validateProperty(type, key);
            if (!isValid) invalidProps.push(key);
        }
        var unknownPropString = invalidProps.map(function(prop) {
            return '`' + prop + '`';
        }).join(', ');
        if (invalidProps.length === 1) error1("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
        else if (invalidProps.length > 1) error1("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
    }
    function validateProperties(type, props) {
        if (isCustomComponent(type, props)) return;
        warnInvalidARIAProps(type, props);
    }
    var didWarnValueNull = false;
    function validateProperties$1(type, props) {
        if (type !== 'input' && type !== 'textarea' && type !== 'select') return;
        if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true;
            if (type === 'select' && props.multiple) error1("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
            else error1("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
        }
    }
    var validateProperty$1 = function() {
    };
    var warnedProperties$1 = {
    };
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var EVENT_NAME_REGEX = /^on./;
    var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
    var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
    var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
    validateProperty$1 = function(tagName, name, value, eventRegistry) {
        if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) return true;
        var lowerCasedName = name.toLowerCase();
        if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
            error1("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
            warnedProperties$1[name] = true;
            return true;
        } // We can't rely on the event system being injected on the server.
        if (eventRegistry != null) {
            var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
            if (registrationNameDependencies.hasOwnProperty(name)) return true;
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
            if (registrationName != null) {
                error1('Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);
                warnedProperties$1[name] = true;
                return true;
            }
            if (EVENT_NAME_REGEX.test(name)) {
                error1('Unknown event handler property `%s`. It will be ignored.', name);
                warnedProperties$1[name] = true;
                return true;
            }
        } else if (EVENT_NAME_REGEX.test(name)) {
            // If no event plugins have been injected, we are in a server environment.
            // So we can't tell if the event name is correct for sure, but we can filter
            // out known bad ones like `onclick`. We can't suggest a specific replacement though.
            if (INVALID_EVENT_NAME_REGEX.test(name)) error1("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
            warnedProperties$1[name] = true;
            return true;
        } // Let the ARIA attribute hook validate ARIA attributes
        if (rARIA$1.test(name) || rARIACamel$1.test(name)) return true;
        if (lowerCasedName === 'innerhtml') {
            error1("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
            warnedProperties$1[name] = true;
            return true;
        }
        if (lowerCasedName === 'aria') {
            error1("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
            warnedProperties$1[name] = true;
            return true;
        }
        if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
            error1("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
            warnedProperties$1[name] = true;
            return true;
        }
        if (typeof value === 'number' && isNaN(value)) {
            error1("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
            warnedProperties$1[name] = true;
            return true;
        }
        var propertyInfo = getPropertyInfo(name);
        var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED; // Known attributes should match the casing specified in the property config.
        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name) {
                error1('Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);
                warnedProperties$1[name] = true;
                return true;
            }
        } else if (!isReserved && name !== lowerCasedName) {
            // Unknown attributes should have lowercase casing since that's how they
            // will be cased anyway with server rendering.
            error1("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
            warnedProperties$1[name] = true;
            return true;
        }
        if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
            if (value) error1("Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.", value, name, name, value, name);
            else error1("Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", value, name, name, value, name, name, name);
            warnedProperties$1[name] = true;
            return true;
        } // Now that we've validated casing, do not validate
        // data types for reserved props
        if (isReserved) return true;
         // Warn when a known attribute is a bad type
        if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
            warnedProperties$1[name] = true;
            return false;
        } // Warn when passing the strings 'false' or 'true' into a boolean prop
        if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
            error1("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
            warnedProperties$1[name] = true;
            return true;
        }
        return true;
    };
    var warnUnknownProperties = function(type, props, eventRegistry) {
        var unknownProps = [];
        for(var key in props){
            var isValid = validateProperty$1(type, key, props[key], eventRegistry);
            if (!isValid) unknownProps.push(key);
        }
        var unknownPropString = unknownProps.map(function(prop) {
            return '`' + prop + '`';
        }).join(', ');
        if (unknownProps.length === 1) error1("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
        else if (unknownProps.length > 1) error1("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
    };
    function validateProperties$2(type, props, eventRegistry) {
        if (isCustomComponent(type, props)) return;
        warnUnknownProperties(type, props, eventRegistry);
    }
    var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
    var IS_NON_DELEGATED = 2;
    var IS_CAPTURE_PHASE = 4;
    var IS_REPLAYED = 16;
    // set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when
    // we call willDeferLaterForLegacyFBSupport, thus not bailing out
    // will result in endless cycles like an infinite loop.
    // We also don't want to defer during event replaying.
    var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
    /**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */ function getEventTarget(nativeEvent) {
        // Fallback to nativeEvent.srcElement for IE9
        // https://github.com/facebook/react/issues/12506
        var target = nativeEvent.target || nativeEvent.srcElement || window; // Normalize SVG <use> element events #4963
        if (target.correspondingUseElement) target = target.correspondingUseElement;
         // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
        // @see http://www.quirksmode.org/js/events_properties.html
        return target.nodeType === TEXT_NODE ? target.parentNode : target;
    }
    var restoreImpl = null;
    var restoreTarget = null;
    var restoreQueue = null;
    function restoreStateOfTarget(target) {
        // We perform this translation at the end of the event loop so that we
        // always receive the correct fiber here
        var internalInstance = getInstanceFromNode(target);
        if (!internalInstance) // Unmounted
        return;
        if (!(typeof restoreImpl === 'function')) throw Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var stateNode = internalInstance.stateNode; // Guard against Fiber being unmounted.
        if (stateNode) {
            var _props = getFiberCurrentPropsFromNode(stateNode);
            restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
        }
    }
    function setRestoreImplementation(impl) {
        restoreImpl = impl;
    }
    function enqueueStateRestore(target) {
        if (restoreTarget) {
            if (restoreQueue) restoreQueue.push(target);
            else restoreQueue = [
                target
            ];
        } else restoreTarget = target;
    }
    function needsStateRestore() {
        return restoreTarget !== null || restoreQueue !== null;
    }
    function restoreStateIfNeeded() {
        if (!restoreTarget) return;
        var target = restoreTarget;
        var queuedTargets = restoreQueue;
        restoreTarget = null;
        restoreQueue = null;
        restoreStateOfTarget(target);
        if (queuedTargets) for(var i = 0; i < queuedTargets.length; i++)restoreStateOfTarget(queuedTargets[i]);
    }
    // the renderer. Such as when we're dispatching events or if third party
    // libraries need to call batchedUpdates. Eventually, this API will go away when
    // everything is batched by default. We'll then have a similar API to opt-out of
    // scheduled work and instead do synchronous work.
    // Defaults
    var batchedUpdatesImpl = function(fn, bookkeeping) {
        return fn(bookkeeping);
    };
    var discreteUpdatesImpl = function(fn, a, b, c, d) {
        return fn(a, b, c, d);
    };
    var flushDiscreteUpdatesImpl = function() {
    };
    var batchedEventUpdatesImpl = batchedUpdatesImpl;
    var isInsideEventHandler = false;
    var isBatchingEventUpdates = false;
    function finishEventHandler() {
        // Here we wait until all updates have propagated, which is important
        // when using controlled components within layers:
        // https://github.com/facebook/react/issues/1698
        // Then we restore state of any controlled component.
        var controlledComponentsHavePendingUpdates = needsStateRestore();
        if (controlledComponentsHavePendingUpdates) {
            // If a controlled event was fired, we may need to restore the state of
            // the DOM node back to the controlled value. This is necessary when React
            // bails out of the update without touching the DOM.
            flushDiscreteUpdatesImpl();
            restoreStateIfNeeded();
        }
    }
    function batchedUpdates(fn, bookkeeping) {
        if (isInsideEventHandler) // If we are currently inside another batch, we need to wait until it
        // fully completes before restoring state.
        return fn(bookkeeping);
        isInsideEventHandler = true;
        try {
            return batchedUpdatesImpl(fn, bookkeeping);
        } finally{
            isInsideEventHandler = false;
            finishEventHandler();
        }
    }
    function batchedEventUpdates(fn, a, b) {
        if (isBatchingEventUpdates) // If we are currently inside another batch, we need to wait until it
        // fully completes before restoring state.
        return fn(a, b);
        isBatchingEventUpdates = true;
        try {
            return batchedEventUpdatesImpl(fn, a, b);
        } finally{
            isBatchingEventUpdates = false;
            finishEventHandler();
        }
    }
    function discreteUpdates(fn, a, b, c, d) {
        var prevIsInsideEventHandler = isInsideEventHandler;
        isInsideEventHandler = true;
        try {
            return discreteUpdatesImpl(fn, a, b, c, d);
        } finally{
            isInsideEventHandler = prevIsInsideEventHandler;
            if (!isInsideEventHandler) finishEventHandler();
        }
    }
    function flushDiscreteUpdatesIfNeeded(timeStamp) {
        if (!isInsideEventHandler) flushDiscreteUpdatesImpl();
    }
    function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushDiscreteUpdatesImpl, _batchedEventUpdatesImpl) {
        batchedUpdatesImpl = _batchedUpdatesImpl;
        discreteUpdatesImpl = _discreteUpdatesImpl;
        flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;
        batchedEventUpdatesImpl = _batchedEventUpdatesImpl;
    }
    function isInteractive(tag) {
        return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
    }
    function shouldPreventMouseEvent(name, type, props) {
        switch(name){
            case 'onClick':
            case 'onClickCapture':
            case 'onDoubleClick':
            case 'onDoubleClickCapture':
            case 'onMouseDown':
            case 'onMouseDownCapture':
            case 'onMouseMove':
            case 'onMouseMoveCapture':
            case 'onMouseUp':
            case 'onMouseUpCapture':
            case 'onMouseEnter':
                return !!(props.disabled && isInteractive(type));
            default:
                return false;
        }
    }
    /**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */ function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (stateNode === null) // Work in progress (ex: onload events in incremental mode).
        return null;
        var props = getFiberCurrentPropsFromNode(stateNode);
        if (props === null) // Work in progress.
        return null;
        var listener = props[registrationName];
        if (shouldPreventMouseEvent(registrationName, inst.type, props)) return null;
        if (!(!listener || typeof listener === 'function')) throw Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
        return listener;
    }
    var passiveBrowserEventsSupported = false; // Check if browser support events with passive listeners
    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
    if (canUseDOM) try {
        var options1 = {
        }; // $FlowFixMe: Ignore Flow complaining about needing a value
        Object.defineProperty(options1, 'passive', {
            get: function() {
                passiveBrowserEventsSupported = true;
            }
        });
        window.addEventListener('test', options1, options1);
        window.removeEventListener('test', options1, options1);
    } catch (e1) {
        passiveBrowserEventsSupported = false;
    }
    function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
        var funcArgs = Array.prototype.slice.call(arguments, 3);
        try {
            func.apply(context, funcArgs);
        } catch (error) {
            this.onError(error);
        }
    }
    var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
    // In DEV mode, we swap out invokeGuardedCallback for a special version
    // that plays more nicely with the browser's DevTools. The idea is to preserve
    // "Pause on exceptions" behavior. Because React wraps all user-provided
    // functions in invokeGuardedCallback, and the production version of
    // invokeGuardedCallback uses a try-catch, all user exceptions are treated
    // like caught exceptions, and the DevTools won't pause unless the developer
    // takes the extra step of enabling pause on caught exceptions. This is
    // unintuitive, though, because even though React has caught the error, from
    // the developer's perspective, the error is uncaught.
    //
    // To preserve the expected "Pause on exceptions" behavior, we don't use a
    // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
    // DOM node, and call the user-provided callback from inside an event handler
    // for that fake event. If the callback throws, the error is "captured" using
    // a global event handler. But because the error happens in a different
    // event loop context, it does not interrupt the normal program flow.
    // Effectively, this gives us try-catch behavior without actually using
    // try-catch. Neat!
    // Check that the browser supports the APIs we need to implement our special
    // DEV version of invokeGuardedCallback
    if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
        var fakeNode = document.createElement('react');
        invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
            // If document doesn't exist we know for sure we will crash in this method
            // when we call document.createEvent(). However this can cause confusing
            // errors: https://github.com/facebookincubator/create-react-app/issues/3482
            // So we preemptively throw with a better message instead.
            if (!(typeof document !== 'undefined')) throw Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
            var evt = document.createEvent('Event');
            var didCall = false; // Keeps track of whether the user-provided callback threw an error. We
            // set this to true at the beginning, then set it to false right after
            // calling the function. If the function errors, `didError` will never be
            // set to false. This strategy works even if the browser is flaky and
            // fails to call our global error handler, because it doesn't rely on
            // the error event at all.
            var didError = true; // Keeps track of the value of window.event so that we can reset it
            // during the callback to let user code access window.event in the
            // browsers that support it.
            var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event
            // dispatching: https://github.com/facebook/react/issues/13688
            var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');
            function restoreAfterDispatch() {
                // We immediately remove the callback from event listeners so that
                // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
                // nested call would trigger the fake event handlers of any call higher
                // in the stack.
                fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the
                // window.event assignment in both IE <= 10 as they throw an error
                // "Member not found" in strict mode, and in Firefox which does not
                // support window.event.
                if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) window.event = windowEvent;
            } // Create an event handler for our fake event. We will synchronously
            // dispatch our fake event using `dispatchEvent`. Inside the handler, we
            // call the user-provided callback.
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            function callCallback() {
                didCall = true;
                restoreAfterDispatch();
                func.apply(context, funcArgs);
                didError = false;
            } // Create a global error event handler. We use this to capture the value
            // that was thrown. It's possible that this error handler will fire more
            // than once; for example, if non-React code also calls `dispatchEvent`
            // and a handler for that event throws. We should be resilient to most of
            // those cases. Even if our error event handler fires more than once, the
            // last error event is always used. If the callback actually does error,
            // we know that the last error event is the correct one, because it's not
            // possible for anything else to have happened in between our callback
            // erroring and the code that follows the `dispatchEvent` call below. If
            // the callback doesn't error, but the error event was fired, we know to
            // ignore it because `didError` will be false, as described above.
            var error; // Use this to track whether the error event is ever called.
            var didSetError = false;
            var isCrossOriginError = false;
            function handleWindowError(event) {
                error = event.error;
                didSetError = true;
                if (error === null && event.colno === 0 && event.lineno === 0) isCrossOriginError = true;
                if (event.defaultPrevented) {
                    // Some other error handler has prevented default.
                    // Browsers silence the error report if this happens.
                    // We'll remember this to later decide whether to log it or not.
                    if (error != null && typeof error === 'object') try {
                        error._suppressLogging = true;
                    } catch (inner) {
                    }
                }
            } // Create a fake event type.
            var evtType = "react-" + (name ? name : 'invokeguardedcallback'); // Attach our event handlers
            window.addEventListener('error', handleWindowError);
            fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function
            // errors, it will trigger our global error handler.
            evt.initEvent(evtType, false, false);
            fakeNode.dispatchEvent(evt);
            if (windowEventDescriptor) Object.defineProperty(window, 'event', windowEventDescriptor);
            if (didCall && didError) {
                if (!didSetError) // The callback errored, but the error event never fired.
                error = new Error("An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the \"Pause on exceptions\" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.");
                else if (isCrossOriginError) error = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                this.onError(error);
            } // Remove our event listeners
            window.removeEventListener('error', handleWindowError);
            if (!didCall) {
                // Something went really wrong, and our event was not dispatched.
                // https://github.com/facebook/react/issues/16734
                // https://github.com/facebook/react/issues/16585
                // Fall back to the production implementation.
                restoreAfterDispatch();
                return invokeGuardedCallbackProd.apply(this, arguments);
            }
        };
    }
    var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
    var hasError = false;
    var caughtError = null; // Used by event system to capture/rethrow the first error.
    var hasRethrowError = false;
    var rethrowError = null;
    var reporter = {
        onError: function(error) {
            hasError = true;
            caughtError = error;
        }
    };
    /**
 * Call a function while guarding against errors that happens within it.
 * Returns an error if it throws, otherwise null.
 *
 * In production, this is implemented using a try-catch. The reason we don't
 * use a try-catch directly is so that we can swap out a different
 * implementation in DEV mode.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */ function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
        hasError = false;
        caughtError = null;
        invokeGuardedCallbackImpl$1.apply(reporter, arguments);
    }
    /**
 * Same as invokeGuardedCallback, but instead of returning an error, it stores
 * it in a global so it can be rethrown by `rethrowCaughtError` later.
 * TODO: See if caughtError and rethrowError can be unified.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */ function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
        invokeGuardedCallback.apply(this, arguments);
        if (hasError) {
            var error = clearCaughtError();
            if (!hasRethrowError) {
                hasRethrowError = true;
                rethrowError = error;
            }
        }
    }
    /**
 * During execution of guarded functions we will capture the first error which
 * we will rethrow to be handled by the top level error handler.
 */ function rethrowCaughtError() {
        if (hasRethrowError) {
            var error = rethrowError;
            hasRethrowError = false;
            rethrowError = null;
            throw error;
        }
    }
    function hasCaughtError() {
        return hasError;
    }
    function clearCaughtError() {
        if (hasError) {
            var error = caughtError;
            hasError = false;
            caughtError = null;
            return error;
        } else throw Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    /**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */ function get1(key) {
        return key._reactInternals;
    }
    function has1(key) {
        return key._reactInternals !== undefined;
    }
    function set1(key, value) {
        key._reactInternals = value;
    }
    // Don't change these two values. They're used by React Dev Tools.
    var NoFlags = /*                      */ 0;
    var PerformedWork = /*                */ 1; // You can change the rest (and add more).
    var Placement = /*                    */ 2;
    var Update = /*                       */ 4;
    var PlacementAndUpdate = /*           */ 6;
    var Deletion = /*                     */ 8;
    var ContentReset = /*                 */ 16;
    var Callback = /*                     */ 32;
    var DidCapture = /*                   */ 64;
    var Ref = /*                          */ 128;
    var Snapshot = /*                     */ 256;
    var Passive = /*                      */ 512; // TODO (effects) Remove this bit once the new reconciler is synced to the old.
    var PassiveUnmountPendingDev = /*     */ 8192;
    var Hydrating = /*                    */ 1024;
    var HydratingAndUpdate = /*           */ 1028; // Passive & Update & Callback & Ref & Snapshot
    var LifecycleEffectMask = /*          */ 932; // Union of all host effects
    var HostEffectMask = /*               */ 2047; // These are not really side effects, but we still reuse this field.
    var Incomplete = /*                   */ 2048;
    var ShouldCapture = /*                */ 4096;
    var ForceUpdateForLegacySuspense = /* */ 16384; // Static tags describe aspects of a fiber that are not specific to a render,
    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
    function getNearestMountedFiber(fiber) {
        var node = fiber;
        var nearestMounted = fiber;
        if (!fiber.alternate) {
            // If there is no alternate, this might be a new tree that isn't inserted
            // yet. If it is, then it will have a pending insertion effect on it.
            var nextNode = node;
            do {
                node = nextNode;
                if ((node.flags & (Placement | Hydrating)) !== NoFlags) // This is an insertion or in-progress hydration. The nearest possible
                // mounted fiber is the parent but we need to continue to figure out
                // if that one is still mounted.
                nearestMounted = node.return;
                nextNode = node.return;
            }while (nextNode)
        } else while(node.return)node = node.return;
        if (node.tag === HostRoot) // TODO: Check if this was a nested HostRoot when used with
        // renderContainerIntoSubtree.
        return nearestMounted;
         // If we didn't hit the root, that means that we're in an disconnected tree
        // that has been unmounted.
        return null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
        if (fiber.tag === SuspenseComponent) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState === null) {
                var current = fiber.alternate;
                if (current !== null) suspenseState = current.memoizedState;
            }
            if (suspenseState !== null) return suspenseState.dehydrated;
        }
        return null;
    }
    function getContainerFromFiber(fiber) {
        return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
    }
    function isFiberMounted(fiber) {
        return getNearestMountedFiber(fiber) === fiber;
    }
    function isMounted(component) {
        var owner = ReactCurrentOwner.current;
        if (owner !== null && owner.tag === ClassComponent) {
            var ownerFiber = owner;
            var instance = ownerFiber.stateNode;
            if (!instance._warnedAboutRefsInRender) error1("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentName(ownerFiber.type) || 'A component');
            instance._warnedAboutRefsInRender = true;
        }
        var fiber = get1(component);
        if (!fiber) return false;
        return getNearestMountedFiber(fiber) === fiber;
    }
    function assertIsMounted(fiber) {
        if (!(getNearestMountedFiber(fiber) === fiber)) throw Error("Unable to find node on an unmounted component.");
    }
    function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
            // If there is no alternate, then we only need to check if it is mounted.
            var nearestMounted = getNearestMountedFiber(fiber);
            if (!(nearestMounted !== null)) throw Error("Unable to find node on an unmounted component.");
            if (nearestMounted !== fiber) return null;
            return fiber;
        } // If we have two possible branches, we'll walk backwards up to the root
        // to see what path the root points to. On the way we may hit one of the
        // special cases and we'll deal with them.
        var a = fiber;
        var b = alternate;
        while(true){
            var parentA = a.return;
            if (parentA === null) break;
            var parentB = parentA.alternate;
            if (parentB === null) {
                // There is no alternate. This is an unusual case. Currently, it only
                // happens when a Suspense component is hidden. An extra fragment fiber
                // is inserted in between the Suspense fiber and its children. Skip
                // over this extra fragment fiber and proceed to the next parent.
                var nextParent = parentA.return;
                if (nextParent !== null) {
                    a = b = nextParent;
                    continue;
                } // If there's no parent, we're at the root.
                break;
            } // If both copies of the parent fiber point to the same child, we can
            // assume that the child is current. This happens when we bailout on low
            // priority: the bailed out fiber's child reuses the current child.
            if (parentA.child === parentB.child) {
                var child = parentA.child;
                while(child){
                    if (child === a) {
                        // We've determined that A is the current branch.
                        assertIsMounted(parentA);
                        return fiber;
                    }
                    if (child === b) {
                        // We've determined that B is the current branch.
                        assertIsMounted(parentA);
                        return alternate;
                    }
                    child = child.sibling;
                } // We should never have an alternate for any mounting node. So the only
                throw Error("Unable to find node on an unmounted component.");
            }
            if (a.return !== b.return) {
                // The return pointer of A and the return pointer of B point to different
                // fibers. We assume that return pointers never criss-cross, so A must
                // belong to the child set of A.return, and B must belong to the child
                // set of B.return.
                a = parentA;
                b = parentB;
            } else {
                // The return pointers point to the same fiber. We'll have to use the
                // default, slow path: scan the child sets of each parent alternate to see
                // which child belongs to which set.
                //
                // Search parent A's child set
                var didFindChild = false;
                var _child = parentA.child;
                while(_child){
                    if (_child === a) {
                        didFindChild = true;
                        a = parentA;
                        b = parentB;
                        break;
                    }
                    if (_child === b) {
                        didFindChild = true;
                        b = parentA;
                        a = parentB;
                        break;
                    }
                    _child = _child.sibling;
                }
                if (!didFindChild) {
                    // Search parent B's child set
                    _child = parentB.child;
                    while(_child){
                        if (_child === a) {
                            didFindChild = true;
                            a = parentB;
                            b = parentA;
                            break;
                        }
                        if (_child === b) {
                            didFindChild = true;
                            b = parentB;
                            a = parentA;
                            break;
                        }
                        _child = _child.sibling;
                    }
                    if (!didFindChild) throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                }
            }
            if (!(a.alternate === b)) throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
        } // If the root is not a host container, we're in a disconnected tree. I.e.
        // unmounted.
        if (!(a.tag === HostRoot)) throw Error("Unable to find node on an unmounted component.");
        if (a.stateNode.current === a) // We've determined that A is the current branch.
        return fiber;
         // Otherwise B has to be current branch.
        return alternate;
    }
    function findCurrentHostFiber(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);
        if (!currentParent) return null;
         // Next we'll drill down this component to find the first HostComponent/Text.
        var node = currentParent;
        while(true){
            if (node.tag === HostComponent || node.tag === HostText) return node;
            else if (node.child) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === currentParent) return null;
            while(!node.sibling){
                if (!node.return || node.return === currentParent) return null;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        } // Flow needs the return null here, but ESLint complains about it.
        // eslint-disable-next-line no-unreachable
        return null;
    }
    function findCurrentHostFiberWithNoPortals(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);
        if (!currentParent) return null;
         // Next we'll drill down this component to find the first HostComponent/Text.
        var node = currentParent;
        while(true){
            if (node.tag === HostComponent || node.tag === HostText || enableFundamentalAPI) return node;
            else if (node.child && node.tag !== HostPortal) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === currentParent) return null;
            while(!node.sibling){
                if (!node.return || node.return === currentParent) return null;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        } // Flow needs the return null here, but ESLint complains about it.
        // eslint-disable-next-line no-unreachable
        return null;
    }
    function doesFiberContain(parentFiber, childFiber) {
        var node = childFiber;
        var parentFiberAlternate = parentFiber.alternate;
        while(node !== null){
            if (node === parentFiber || node === parentFiberAlternate) return true;
            node = node.return;
        }
        return false;
    }
    var attemptUserBlockingHydration;
    function setAttemptUserBlockingHydration(fn) {
        attemptUserBlockingHydration = fn;
    }
    var attemptContinuousHydration;
    function setAttemptContinuousHydration(fn) {
        attemptContinuousHydration = fn;
    }
    var attemptHydrationAtCurrentPriority;
    function setAttemptHydrationAtCurrentPriority(fn) {
        attemptHydrationAtCurrentPriority = fn;
    }
    var attemptHydrationAtPriority;
    function setAttemptHydrationAtPriority(fn) {
        attemptHydrationAtPriority = fn;
    } // TODO: Upgrade this definition once we're on a newer version of Flow that
    var hasScheduledReplayAttempt = false; // The queue of discrete events to be replayed.
    var queuedDiscreteEvents = []; // Indicates if any continuous event targets are non-null for early bailout.
    // if the last target was dehydrated.
    var queuedFocus = null;
    var queuedDrag = null;
    var queuedMouse = null; // For pointer events there can be one latest event per pointerId.
    var queuedPointers = new Map();
    var queuedPointerCaptures = new Map(); // We could consider replaying selectionchange and touchmoves too.
    var queuedExplicitHydrationTargets = [];
    function hasQueuedDiscreteEvents() {
        return queuedDiscreteEvents.length > 0;
    }
    var discreteReplayableEvents = [
        'mousedown',
        'mouseup',
        'touchcancel',
        'touchend',
        'touchstart',
        'auxclick',
        'dblclick',
        'pointercancel',
        'pointerdown',
        'pointerup',
        'dragend',
        'dragstart',
        'drop',
        'compositionend',
        'compositionstart',
        'keydown',
        'keypress',
        'keyup',
        'input',
        'textInput',
        'copy',
        'cut',
        'paste',
        'click',
        'change',
        'contextmenu',
        'reset',
        'submit'
    ];
    function isReplayableDiscreteEvent(eventType) {
        return discreteReplayableEvents.indexOf(eventType) > -1;
    }
    function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        return {
            blockedOn: blockedOn,
            domEventName: domEventName,
            eventSystemFlags: eventSystemFlags | IS_REPLAYED,
            nativeEvent: nativeEvent,
            targetContainers: [
                targetContainer
            ]
        };
    }
    function queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
        queuedDiscreteEvents.push(queuedEvent);
    } // Resets the replaying for this type of continuous event to no event.
    function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch(domEventName){
            case 'focusin':
            case 'focusout':
                queuedFocus = null;
                break;
            case 'dragenter':
            case 'dragleave':
                queuedDrag = null;
                break;
            case 'mouseover':
            case 'mouseout':
                queuedMouse = null;
                break;
            case 'pointerover':
            case 'pointerout':
                var pointerId = nativeEvent.pointerId;
                queuedPointers.delete(pointerId);
                break;
            case 'gotpointercapture':
            case 'lostpointercapture':
                var _pointerId = nativeEvent.pointerId;
                queuedPointerCaptures.delete(_pointerId);
                break;
        }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
            var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn !== null) {
                var _fiber2 = getInstanceFromNode(blockedOn);
                if (_fiber2 !== null) // Attempt to increase the priority of this target.
                attemptContinuousHydration(_fiber2);
            }
            return queuedEvent;
        } // If we have already queued this exact event, then it's because
        // the different event systems have different DOM event listeners.
        // We can accumulate the flags, and the targetContainers, and
        // store a single event to be replayed.
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        var targetContainers = existingQueuedEvent.targetContainers;
        if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) targetContainers.push(targetContainer);
        return existingQueuedEvent;
    }
    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        // These set relatedTarget to null because the replayed event will be treated as if we
        // moved from outside the window (no target) onto the target once it hydrates.
        // Instead of mutating we could clone the event.
        switch(domEventName){
            case 'focusin':
                var focusEvent = nativeEvent;
                queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
                return true;
            case 'dragenter':
                var dragEvent = nativeEvent;
                queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
                return true;
            case 'mouseover':
                var mouseEvent = nativeEvent;
                queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
                return true;
            case 'pointerover':
                var pointerEvent = nativeEvent;
                var pointerId = pointerEvent.pointerId;
                queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
                return true;
            case 'gotpointercapture':
                var _pointerEvent = nativeEvent;
                var _pointerId2 = _pointerEvent.pointerId;
                queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
                return true;
        }
        return false;
    } // Check if this target is unblocked. Returns true if it's unblocked.
    function attemptExplicitHydrationTarget(queuedTarget) {
        // TODO: This function shares a lot of logic with attemptToDispatchEvent.
        // Try to unify them. It's a bit tricky since it would require two return
        // values.
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted !== null) {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                    var instance = getSuspenseInstanceFromFiber(nearestMounted);
                    if (instance !== null) {
                        // We're blocked on hydrating this boundary.
                        // Increase its priority.
                        queuedTarget.blockedOn = instance;
                        attemptHydrationAtPriority(queuedTarget.lanePriority, function() {
                            Scheduler.unstable_runWithPriority(queuedTarget.priority, function() {
                                attemptHydrationAtCurrentPriority(nearestMounted);
                            });
                        });
                        return;
                    }
                } else if (tag === HostRoot) {
                    var root = nearestMounted.stateNode;
                    if (root.hydrate) {
                        queuedTarget.blockedOn = getContainerFromFiber(nearestMounted); // We don't currently have a way to increase the priority of
                        // a root other than sync.
                        return;
                    }
                }
            }
        }
        queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (queuedEvent.blockedOn !== null) return false;
        var targetContainers = queuedEvent.targetContainers;
        while(targetContainers.length > 0){
            var targetContainer = targetContainers[0];
            var nextBlockedOn = attemptToDispatchEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
            if (nextBlockedOn !== null) {
                // We're still blocked. Try again later.
                var _fiber3 = getInstanceFromNode(nextBlockedOn);
                if (_fiber3 !== null) attemptContinuousHydration(_fiber3);
                queuedEvent.blockedOn = nextBlockedOn;
                return false;
            } // This target container was successfully dispatched. Try the next.
            targetContainers.shift();
        }
        return true;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
        if (attemptReplayContinuousQueuedEvent(queuedEvent)) map.delete(key);
    }
    function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false; // First replay discrete events.
        while(queuedDiscreteEvents.length > 0){
            var nextDiscreteEvent = queuedDiscreteEvents[0];
            if (nextDiscreteEvent.blockedOn !== null) {
                // We're still blocked.
                // Increase the priority of this boundary to unblock
                // the next discrete event.
                var _fiber4 = getInstanceFromNode(nextDiscreteEvent.blockedOn);
                if (_fiber4 !== null) attemptUserBlockingHydration(_fiber4);
                break;
            }
            var targetContainers = nextDiscreteEvent.targetContainers;
            while(targetContainers.length > 0){
                var targetContainer = targetContainers[0];
                var nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.domEventName, nextDiscreteEvent.eventSystemFlags, targetContainer, nextDiscreteEvent.nativeEvent);
                if (nextBlockedOn !== null) {
                    // We're still blocked. Try again later.
                    nextDiscreteEvent.blockedOn = nextBlockedOn;
                    break;
                } // This target container was successfully dispatched. Try the next.
                targetContainers.shift();
            }
            if (nextDiscreteEvent.blockedOn === null) // We've successfully replayed the first event. Let's try the next one.
            queuedDiscreteEvents.shift();
        } // Next replay any continuous events.
        if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) queuedFocus = null;
        if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) queuedDrag = null;
        if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) queuedMouse = null;
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        if (queuedEvent.blockedOn === unblocked) {
            queuedEvent.blockedOn = null;
            if (!hasScheduledReplayAttempt) {
                hasScheduledReplayAttempt = true; // Schedule a callback to attempt replaying as many events as are
                // now unblocked. This first might not actually be unblocked yet.
                // We could check it early to avoid scheduling an unnecessary callback.
                Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
            }
        }
    }
    function retryIfBlockedOn(unblocked) {
        // Mark anything that was blocked on this as no longer blocked
        // and eligible for a replay.
        if (queuedDiscreteEvents.length > 0) {
            scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked); // This is a exponential search for each boundary that commits. I think it's
            // worth it because we expect very few discrete events to queue up and once
            // we are actually fully unblocked it will be fast to replay them.
            for(var i = 1; i < queuedDiscreteEvents.length; i++){
                var queuedEvent = queuedDiscreteEvents[i];
                if (queuedEvent.blockedOn === unblocked) queuedEvent.blockedOn = null;
            }
        }
        if (queuedFocus !== null) scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        if (queuedDrag !== null) scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        if (queuedMouse !== null) scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        var unblock = function(queuedEvent) {
            return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
        };
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for(var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++){
            var queuedTarget = queuedExplicitHydrationTargets[_i];
            if (queuedTarget.blockedOn === unblocked) queuedTarget.blockedOn = null;
        }
        while(queuedExplicitHydrationTargets.length > 0){
            var nextExplicitTarget = queuedExplicitHydrationTargets[0];
            if (nextExplicitTarget.blockedOn !== null) break;
            else {
                attemptExplicitHydrationTarget(nextExplicitTarget);
                if (nextExplicitTarget.blockedOn === null) // We're unblocked.
                queuedExplicitHydrationTargets.shift();
            }
        }
    }
    var DiscreteEvent = 0;
    var UserBlockingEvent = 1;
    var ContinuousEvent = 2;
    /**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */ function makePrefixMap(styleProp, eventName) {
        var prefixes = {
        };
        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes['Webkit' + styleProp] = 'webkit' + eventName;
        prefixes['Moz' + styleProp] = 'moz' + eventName;
        return prefixes;
    }
    /**
 * A list of event names to a configurable list of vendor prefixes.
 */ var vendorPrefixes = {
        animationend: makePrefixMap('Animation', 'AnimationEnd'),
        animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
        animationstart: makePrefixMap('Animation', 'AnimationStart'),
        transitionend: makePrefixMap('Transition', 'TransitionEnd')
    };
    /**
 * Event names that have already been detected and prefixed (if applicable).
 */ var prefixedEventNames = {
    };
    /**
 * Element to check for prefixes on.
 */ var style1 = {
    };
    /**
 * Bootstrap if a DOM exists.
 */ if (canUseDOM) {
        style1 = document.createElement('div').style; // On some platforms, in particular some releases of Android 4.x,
        // the un-prefixed "animation" and "transition" properties are defined on the
        // style object but the events that fire will still be prefixed, so we need
        // to check if the un-prefixed events are usable, and if not remove them from the map.
        if (!('AnimationEvent' in window)) {
            delete vendorPrefixes.animationend.animation;
            delete vendorPrefixes.animationiteration.animation;
            delete vendorPrefixes.animationstart.animation;
        } // Same as above
        if (!('TransitionEvent' in window)) delete vendorPrefixes.transitionend.transition;
    }
    /**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */ function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
        else if (!vendorPrefixes[eventName]) return eventName;
        var prefixMap = vendorPrefixes[eventName];
        for(var styleProp in prefixMap){
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style1) return prefixedEventNames[eventName] = prefixMap[styleProp];
        }
        return eventName;
    }
    var ANIMATION_END = getVendorPrefixedEventName('animationend');
    var ANIMATION_ITERATION = getVendorPrefixedEventName('animationiteration');
    var ANIMATION_START = getVendorPrefixedEventName('animationstart');
    var TRANSITION_END = getVendorPrefixedEventName('transitionend');
    var topLevelEventsToReactNames = new Map();
    var eventPriorities = new Map(); // We store most of the events in this module in pairs of two strings so we can re-use
    // the code required to apply the same logic for event prioritization and that of the
    // SimpleEventPlugin. This complicates things slightly, but the aim is to reduce code
    // duplication (for which there would be quite a bit). For the events that are not needed
    // for the SimpleEventPlugin (otherDiscreteEvents) we process them separately as an
    // array of top level events.
    // Lastly, we ignore prettier so we can keep the formatting sane.
    // prettier-ignore
    var discreteEventPairsForSimpleEventPlugin = [
        'cancel',
        'cancel',
        'click',
        'click',
        'close',
        'close',
        'contextmenu',
        'contextMenu',
        'copy',
        'copy',
        'cut',
        'cut',
        'auxclick',
        'auxClick',
        'dblclick',
        'doubleClick',
        'dragend',
        'dragEnd',
        'dragstart',
        'dragStart',
        'drop',
        'drop',
        'focusin',
        'focus',
        'focusout',
        'blur',
        'input',
        'input',
        'invalid',
        'invalid',
        'keydown',
        'keyDown',
        'keypress',
        'keyPress',
        'keyup',
        'keyUp',
        'mousedown',
        'mouseDown',
        'mouseup',
        'mouseUp',
        'paste',
        'paste',
        'pause',
        'pause',
        'play',
        'play',
        'pointercancel',
        'pointerCancel',
        'pointerdown',
        'pointerDown',
        'pointerup',
        'pointerUp',
        'ratechange',
        'rateChange',
        'reset',
        'reset',
        'seeked',
        'seeked',
        'submit',
        'submit',
        'touchcancel',
        'touchCancel',
        'touchend',
        'touchEnd',
        'touchstart',
        'touchStart',
        'volumechange',
        'volumeChange'
    ];
    var otherDiscreteEvents = [
        'change',
        'selectionchange',
        'textInput',
        'compositionstart',
        'compositionend',
        'compositionupdate'
    ];
    var userBlockingPairsForSimpleEventPlugin = [
        'drag',
        'drag',
        'dragenter',
        'dragEnter',
        'dragexit',
        'dragExit',
        'dragleave',
        'dragLeave',
        'dragover',
        'dragOver',
        'mousemove',
        'mouseMove',
        'mouseout',
        'mouseOut',
        'mouseover',
        'mouseOver',
        'pointermove',
        'pointerMove',
        'pointerout',
        'pointerOut',
        'pointerover',
        'pointerOver',
        'scroll',
        'scroll',
        'toggle',
        'toggle',
        'touchmove',
        'touchMove',
        'wheel',
        'wheel'
    ]; // prettier-ignore
    var continuousPairsForSimpleEventPlugin = [
        'abort',
        'abort',
        ANIMATION_END,
        'animationEnd',
        ANIMATION_ITERATION,
        'animationIteration',
        ANIMATION_START,
        'animationStart',
        'canplay',
        'canPlay',
        'canplaythrough',
        'canPlayThrough',
        'durationchange',
        'durationChange',
        'emptied',
        'emptied',
        'encrypted',
        'encrypted',
        'ended',
        'ended',
        'error',
        'error',
        'gotpointercapture',
        'gotPointerCapture',
        'load',
        'load',
        'loadeddata',
        'loadedData',
        'loadedmetadata',
        'loadedMetadata',
        'loadstart',
        'loadStart',
        'lostpointercapture',
        'lostPointerCapture',
        'playing',
        'playing',
        'progress',
        'progress',
        'seeking',
        'seeking',
        'stalled',
        'stalled',
        'suspend',
        'suspend',
        'timeupdate',
        'timeUpdate',
        TRANSITION_END,
        'transitionEnd',
        'waiting',
        'waiting'
    ];
    /**
 * Turns
 * ['abort', ...]
 *
 * into
 *
 * topLevelEventsToReactNames = new Map([
 *   ['abort', 'onAbort'],
 * ]);
 *
 * and registers them.
 */ function registerSimplePluginEventsAndSetTheirPriorities(eventTypes, priority) {
        // As the event types are in pairs of two, we need to iterate
        // through in twos. The events are in pairs of two to save code
        // and improve init perf of processing this array, as it will
        // result in far fewer object allocations and property accesses
        // if we only use three arrays to process all the categories of
        // instead of tuples.
        for(var i = 0; i < eventTypes.length; i += 2){
            var topEvent = eventTypes[i];
            var event = eventTypes[i + 1];
            var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
            var reactName = 'on' + capitalizedEvent;
            eventPriorities.set(topEvent, priority);
            topLevelEventsToReactNames.set(topEvent, reactName);
            registerTwoPhaseEvent(reactName, [
                topEvent
            ]);
        }
    }
    function setEventPriorities(eventTypes, priority) {
        for(var i = 0; i < eventTypes.length; i++)eventPriorities.set(eventTypes[i], priority);
    }
    function getEventPriorityForPluginSystem(domEventName) {
        var priority = eventPriorities.get(domEventName); // Default to a ContinuousEvent. Note: we might
        // want to warn if we can't detect the priority
        // for the event.
        return priority === undefined ? ContinuousEvent : priority;
    }
    function registerSimpleEvents() {
        registerSimplePluginEventsAndSetTheirPriorities(discreteEventPairsForSimpleEventPlugin, DiscreteEvent);
        registerSimplePluginEventsAndSetTheirPriorities(userBlockingPairsForSimpleEventPlugin, UserBlockingEvent);
        registerSimplePluginEventsAndSetTheirPriorities(continuousPairsForSimpleEventPlugin, ContinuousEvent);
        setEventPriorities(otherDiscreteEvents, DiscreteEvent);
    }
    var Scheduler_now = Scheduler.unstable_now;
    // Provide explicit error message when production+profiling bundle of e.g.
    // react-dom is used with production (non-profiling) bundle of
    // scheduler/tracing
    if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");
    // ascending numbers so we can compare them like numbers. They start at 90 to
    // avoid clashing with Scheduler's priorities.
    var ImmediatePriority = 99;
    var UserBlockingPriority = 98;
    var NormalPriority = 97;
    var LowPriority = 96;
    var IdlePriority = 95; // NoPriority is the absence of priority. Also React-only.
    var NoPriority = 90;
    var initialTimeMs = Scheduler_now(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.
    var SyncLanePriority = 15;
    var SyncBatchedLanePriority = 14;
    var InputDiscreteHydrationLanePriority = 13;
    var InputDiscreteLanePriority = 12;
    var InputContinuousHydrationLanePriority = 11;
    var InputContinuousLanePriority = 10;
    var DefaultHydrationLanePriority = 9;
    var DefaultLanePriority = 8;
    var TransitionHydrationPriority = 7;
    var TransitionPriority = 6;
    var RetryLanePriority = 5;
    var SelectiveHydrationLanePriority = 4;
    var IdleHydrationLanePriority = 3;
    var IdleLanePriority = 2;
    var OffscreenLanePriority = 1;
    var NoLanePriority = 0;
    var TotalLanes = 31;
    var NoLanes = /*                        */ 0;
    var NoLane = /*                          */ 0;
    var SyncLane = /*                        */ 1;
    var SyncBatchedLane = /*                 */ 2;
    var InputDiscreteHydrationLane = /*      */ 4;
    var InputDiscreteLanes = /*                    */ 24;
    var InputContinuousHydrationLane = /*           */ 32;
    var InputContinuousLanes = /*                  */ 192;
    var DefaultHydrationLane = /*            */ 256;
    var DefaultLanes = /*                   */ 3584;
    var TransitionHydrationLane = /*                */ 4096;
    var TransitionLanes = /*                       */ 4186112;
    var RetryLanes = /*                            */ 62914560;
    var SomeRetryLane = /*                  */ 33554432;
    var SelectiveHydrationLane = /*          */ 67108864;
    var NonIdleLanes = /*                                 */ 134217727;
    var IdleHydrationLane = /*               */ 134217728;
    var IdleLanes = /*                             */ 805306368;
    var OffscreenLane = /*                   */ 1073741824;
    var NoTimestamp = -1;
    function setCurrentUpdateLanePriority(newLanePriority) {
    } // "Registers" used to "return" multiple values
    // Used by getHighestPriorityLanes and getNextLanes:
    var return_highestLanePriority = DefaultLanePriority;
    function getHighestPriorityLanes(lanes) {
        if ((SyncLane & lanes) !== NoLanes) {
            return_highestLanePriority = SyncLanePriority;
            return SyncLane;
        }
        if ((SyncBatchedLane & lanes) !== NoLanes) {
            return_highestLanePriority = SyncBatchedLanePriority;
            return SyncBatchedLane;
        }
        if ((InputDiscreteHydrationLane & lanes) !== NoLanes) {
            return_highestLanePriority = InputDiscreteHydrationLanePriority;
            return InputDiscreteHydrationLane;
        }
        var inputDiscreteLanes = InputDiscreteLanes & lanes;
        if (inputDiscreteLanes !== NoLanes) {
            return_highestLanePriority = InputDiscreteLanePriority;
            return inputDiscreteLanes;
        }
        if ((lanes & InputContinuousHydrationLane) !== NoLanes) {
            return_highestLanePriority = InputContinuousHydrationLanePriority;
            return InputContinuousHydrationLane;
        }
        var inputContinuousLanes = InputContinuousLanes & lanes;
        if (inputContinuousLanes !== NoLanes) {
            return_highestLanePriority = InputContinuousLanePriority;
            return inputContinuousLanes;
        }
        if ((lanes & DefaultHydrationLane) !== NoLanes) {
            return_highestLanePriority = DefaultHydrationLanePriority;
            return DefaultHydrationLane;
        }
        var defaultLanes = DefaultLanes & lanes;
        if (defaultLanes !== NoLanes) {
            return_highestLanePriority = DefaultLanePriority;
            return defaultLanes;
        }
        if ((lanes & TransitionHydrationLane) !== NoLanes) {
            return_highestLanePriority = TransitionHydrationPriority;
            return TransitionHydrationLane;
        }
        var transitionLanes = TransitionLanes & lanes;
        if (transitionLanes !== NoLanes) {
            return_highestLanePriority = TransitionPriority;
            return transitionLanes;
        }
        var retryLanes = RetryLanes & lanes;
        if (retryLanes !== NoLanes) {
            return_highestLanePriority = RetryLanePriority;
            return retryLanes;
        }
        if (lanes & SelectiveHydrationLane) {
            return_highestLanePriority = SelectiveHydrationLanePriority;
            return SelectiveHydrationLane;
        }
        if ((lanes & IdleHydrationLane) !== NoLanes) {
            return_highestLanePriority = IdleHydrationLanePriority;
            return IdleHydrationLane;
        }
        var idleLanes = IdleLanes & lanes;
        if (idleLanes !== NoLanes) {
            return_highestLanePriority = IdleLanePriority;
            return idleLanes;
        }
        if ((OffscreenLane & lanes) !== NoLanes) {
            return_highestLanePriority = OffscreenLanePriority;
            return OffscreenLane;
        }
        error1('Should have found matching lanes. This is a bug in React.');
        return_highestLanePriority = DefaultLanePriority;
        return lanes;
    }
    function schedulerPriorityToLanePriority(schedulerPriorityLevel) {
        switch(schedulerPriorityLevel){
            case ImmediatePriority:
                return SyncLanePriority;
            case UserBlockingPriority:
                return InputContinuousLanePriority;
            case NormalPriority:
            case LowPriority:
                // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.
                return DefaultLanePriority;
            case IdlePriority:
                return IdleLanePriority;
            default:
                return NoLanePriority;
        }
    }
    function lanePriorityToSchedulerPriority(lanePriority) {
        switch(lanePriority){
            case SyncLanePriority:
            case SyncBatchedLanePriority:
                return ImmediatePriority;
            case InputDiscreteHydrationLanePriority:
            case InputDiscreteLanePriority:
            case InputContinuousHydrationLanePriority:
            case InputContinuousLanePriority:
                return UserBlockingPriority;
            case DefaultHydrationLanePriority:
            case DefaultLanePriority:
            case TransitionHydrationPriority:
            case TransitionPriority:
            case SelectiveHydrationLanePriority:
            case RetryLanePriority:
                return NormalPriority;
            case IdleHydrationLanePriority:
            case IdleLanePriority:
            case OffscreenLanePriority:
                return IdlePriority;
            case NoLanePriority:
                return NoPriority;
            default:
                throw Error("Invalid update priority: " + lanePriority + ". This is a bug in React.");
        }
    }
    function getNextLanes(root, wipLanes) {
        // Early bailout if there's no pending work left.
        var pendingLanes = root.pendingLanes;
        if (pendingLanes === NoLanes) {
            return_highestLanePriority = NoLanePriority;
            return NoLanes;
        }
        var nextLanes = NoLanes;
        var nextLanePriority = NoLanePriority;
        var expiredLanes = root.expiredLanes;
        var suspendedLanes = root.suspendedLanes;
        var pingedLanes = root.pingedLanes; // Check if any work has expired.
        if (expiredLanes !== NoLanes) {
            nextLanes = expiredLanes;
            nextLanePriority = return_highestLanePriority = SyncLanePriority;
        } else {
            // Do not work on any idle work until all the non-idle work has finished,
            // even if the work is suspended.
            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
            if (nonIdlePendingLanes !== NoLanes) {
                var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
                if (nonIdleUnblockedLanes !== NoLanes) {
                    nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
                    nextLanePriority = return_highestLanePriority;
                } else {
                    var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                    if (nonIdlePingedLanes !== NoLanes) {
                        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                        nextLanePriority = return_highestLanePriority;
                    }
                }
            } else {
                // The only remaining work is Idle.
                var unblockedLanes = pendingLanes & ~suspendedLanes;
                if (unblockedLanes !== NoLanes) {
                    nextLanes = getHighestPriorityLanes(unblockedLanes);
                    nextLanePriority = return_highestLanePriority;
                } else if (pingedLanes !== NoLanes) {
                    nextLanes = getHighestPriorityLanes(pingedLanes);
                    nextLanePriority = return_highestLanePriority;
                }
            }
        }
        if (nextLanes === NoLanes) // This should only be reachable if we're suspended
        // TODO: Consider warning in this path if a fallback timer is not scheduled.
        return NoLanes;
         // If there are higher priority lanes, we'll include them even if they
        // are suspended.
        nextLanes = pendingLanes & getEqualOrHigherPriorityLanes(nextLanes); // If we're already in the middle of a render, switching lanes will interrupt
        // it and we'll lose our progress. We should only do this if the new lanes are
        // higher priority.
        if (wipLanes !== NoLanes && wipLanes !== nextLanes && // bother waiting until the root is complete.
        (wipLanes & suspendedLanes) === NoLanes) {
            getHighestPriorityLanes(wipLanes);
            var wipLanePriority = return_highestLanePriority;
            if (nextLanePriority <= wipLanePriority) return wipLanes;
            else return_highestLanePriority = nextLanePriority;
        } // Check for entangled lanes and add them to the batch.
        //
        // A lane is said to be entangled with another when it's not allowed to render
        // in a batch that does not also include the other lane. Typically we do this
        // when multiple updates have the same source, and we only want to respond to
        // the most recent event from that source.
        //
        // Note that we apply entanglements *after* checking for partial work above.
        // This means that if a lane is entangled during an interleaved event while
        // it's already rendering, we won't interrupt it. This is intentional, since
        // entanglement is usually "best effort": we'll try our best to render the
        // lanes in the same batch, but it's not worth throwing out partially
        // completed work in order to do it.
        //
        // For those exceptions where entanglement is semantically important, like
        // useMutableSource, we should ensure that there is no partial work at the
        // time we apply the entanglement.
        var entangledLanes = root.entangledLanes;
        if (entangledLanes !== NoLanes) {
            var entanglements = root.entanglements;
            var lanes = nextLanes & entangledLanes;
            while(lanes > 0){
                var index = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index;
                nextLanes |= entanglements[index];
                lanes &= ~lane;
            }
        }
        return nextLanes;
    }
    function getMostRecentEventTime(root, lanes) {
        var eventTimes = root.eventTimes;
        var mostRecentEventTime = NoTimestamp;
        while(lanes > 0){
            var index = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index;
            var eventTime = eventTimes[index];
            if (eventTime > mostRecentEventTime) mostRecentEventTime = eventTime;
            lanes &= ~lane;
        }
        return mostRecentEventTime;
    }
    function computeExpirationTime(lane, currentTime) {
        // TODO: Expiration heuristic is constant per lane, so could use a map.
        getHighestPriorityLanes(lane);
        var priority = return_highestLanePriority;
        if (priority >= InputContinuousLanePriority) // User interactions should expire slightly more quickly.
        //
        // NOTE: This is set to the corresponding constant as in Scheduler.js. When
        // we made it larger, a product metric in www regressed, suggesting there's
        // a user interaction that's being starved by a series of synchronous
        // updates. If that theory is correct, the proper solution is to fix the
        // starvation. However, this scenario supports the idea that expiration
        // times are an important safeguard when starvation does happen.
        //
        // Also note that, in the case of user input specifically, this will soon no
        // longer be an issue because we plan to make user input synchronous by
        // default (until you enter `startTransition`, of course.)
        //
        // If weren't planning to make these updates synchronous soon anyway, I
        // would probably make this number a configurable parameter.
        return currentTime + 250;
        else if (priority >= TransitionPriority) return currentTime + 5000;
        else // Anything idle priority or lower should never expire.
        return NoTimestamp;
    }
    function markStarvedLanesAsExpired(root, currentTime) {
        // TODO: This gets called every time we yield. We can optimize by storing
        // the earliest expiration time on the root. Then use that to quickly bail out
        // of this function.
        var pendingLanes = root.pendingLanes;
        var suspendedLanes = root.suspendedLanes;
        var pingedLanes = root.pingedLanes;
        var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their
        // expiration time. If so, we'll assume the update is being starved and mark
        // it as expired to force it to finish.
        var lanes = pendingLanes;
        while(lanes > 0){
            var index = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index;
            var expirationTime = expirationTimes[index];
            if (expirationTime === NoTimestamp) // Found a pending lane with no expiration time. If it's not suspended, or
            // if it's pinged, assume it's CPU-bound. Compute a new expiration time
            // using the current time.
            {
                if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) // Assumes timestamps are monotonically increasing.
                expirationTimes[index] = computeExpirationTime(lane, currentTime);
            } else if (expirationTime <= currentTime) // This lane expired
            root.expiredLanes |= lane;
            lanes &= ~lane;
        }
    } // This returns the highest priority pending lanes regardless of whether they
    function getLanesToRetrySynchronouslyOnError(root) {
        var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;
        if (everythingButOffscreen !== NoLanes) return everythingButOffscreen;
        if (everythingButOffscreen & OffscreenLane) return OffscreenLane;
        return NoLanes;
    }
    function returnNextLanesPriority() {
        return return_highestLanePriority;
    }
    function includesNonIdleWork(lanes) {
        return (lanes & NonIdleLanes) !== NoLanes;
    }
    function includesOnlyRetries(lanes) {
        return (lanes & RetryLanes) === lanes;
    }
    function includesOnlyTransitions(lanes) {
        return (lanes & TransitionLanes) === lanes;
    } // To ensure consistency across multiple updates in the same event, this should
    // be a pure function, so that it always returns the same lane for given inputs.
    function findUpdateLane(lanePriority, wipLanes) {
        switch(lanePriority){
            case NoLanePriority:
                break;
            case SyncLanePriority:
                return SyncLane;
            case SyncBatchedLanePriority:
                return SyncBatchedLane;
            case InputDiscreteLanePriority:
                var _lane = pickArbitraryLane(InputDiscreteLanes & ~wipLanes);
                if (_lane === NoLane) // Shift to the next priority level
                return findUpdateLane(InputContinuousLanePriority, wipLanes);
                return _lane;
            case InputContinuousLanePriority:
                var _lane2 = pickArbitraryLane(InputContinuousLanes & ~wipLanes);
                if (_lane2 === NoLane) // Shift to the next priority level
                return findUpdateLane(DefaultLanePriority, wipLanes);
                return _lane2;
            case DefaultLanePriority:
                var _lane3 = pickArbitraryLane(DefaultLanes & ~wipLanes);
                if (_lane3 === NoLane) {
                    // If all the default lanes are already being worked on, look for a
                    // lane in the transition range.
                    _lane3 = pickArbitraryLane(TransitionLanes & ~wipLanes);
                    if (_lane3 === NoLane) // All the transition lanes are taken, too. This should be very
                    // rare, but as a last resort, pick a default lane. This will have
                    // the effect of interrupting the current work-in-progress render.
                    _lane3 = pickArbitraryLane(DefaultLanes);
                }
                return _lane3;
            case TransitionPriority:
            case RetryLanePriority:
                break;
            case IdleLanePriority:
                var lane = pickArbitraryLane(IdleLanes & ~wipLanes);
                if (lane === NoLane) lane = pickArbitraryLane(IdleLanes);
                return lane;
        }
        throw Error("Invalid update priority: " + lanePriority + ". This is a bug in React.");
    } // To ensure consistency across multiple updates in the same event, this should
    // be pure function, so that it always returns the same lane for given inputs.
    function findTransitionLane(wipLanes, pendingLanes) {
        // First look for lanes that are completely unclaimed, i.e. have no
        // pending work.
        var lane = pickArbitraryLane(TransitionLanes & ~pendingLanes);
        if (lane === NoLane) {
            // If all lanes have pending work, look for a lane that isn't currently
            // being worked on.
            lane = pickArbitraryLane(TransitionLanes & ~wipLanes);
            if (lane === NoLane) // If everything is being worked on, pick any lane. This has the
            // effect of interrupting the current work-in-progress.
            lane = pickArbitraryLane(TransitionLanes);
        }
        return lane;
    } // To ensure consistency across multiple updates in the same event, this should
    // be pure function, so that it always returns the same lane for given inputs.
    function findRetryLane(wipLanes) {
        // This is a fork of `findUpdateLane` designed specifically for Suspense
        // "retries" â€” a special update that attempts to flip a Suspense boundary
        // from its placeholder state to its primary/resolved state.
        var lane = pickArbitraryLane(RetryLanes & ~wipLanes);
        if (lane === NoLane) lane = pickArbitraryLane(RetryLanes);
        return lane;
    }
    function getHighestPriorityLane(lanes) {
        return lanes & -lanes;
    }
    function getLowestPriorityLane(lanes) {
        // This finds the most significant non-zero bit.
        var index = 31 - clz32(lanes);
        return index < 0 ? NoLanes : 1 << index;
    }
    function getEqualOrHigherPriorityLanes(lanes) {
        return (getLowestPriorityLane(lanes) << 1) - 1;
    }
    function pickArbitraryLane(lanes) {
        // This wrapper function gets inlined. Only exists so to communicate that it
        // doesn't matter which bit is selected; you can pick any bit without
        // affecting the algorithms where its used. Here I'm using
        // getHighestPriorityLane because it requires the fewest operations.
        return getHighestPriorityLane(lanes);
    }
    function pickArbitraryLaneIndex(lanes) {
        return 31 - clz32(lanes);
    }
    function laneToIndex(lane) {
        return pickArbitraryLaneIndex(lane);
    }
    function includesSomeLane(a, b) {
        return (a & b) !== NoLanes;
    }
    function isSubsetOfLanes(set, subset) {
        return (set & subset) === subset;
    }
    function mergeLanes(a, b) {
        return a | b;
    }
    function removeLanes(set, subset) {
        return set & ~subset;
    } // Seems redundant, but it changes the type from a single lane (used for
    // updates) to a group of lanes (used for flushing work).
    function laneToLanes(lane) {
        return lane;
    }
    function higherPriorityLane(a, b) {
        // This works because the bit ranges decrease in priority as you go left.
        return a !== NoLane && a < b ? a : b;
    }
    function createLaneMap(initial) {
        // Intentionally pushing one by one.
        // https://v8.dev/blog/elements-kinds#avoid-creating-holes
        var laneMap = [];
        for(var i = 0; i < TotalLanes; i++)laneMap.push(initial);
        return laneMap;
    }
    function markRootUpdated(root, updateLane, eventTime) {
        root.pendingLanes |= updateLane; // TODO: Theoretically, any update to any lane can unblock any other lane. But
        // it's not practical to try every single possible combination. We need a
        // heuristic to decide which lanes to attempt to render, and in which batches.
        // For now, we use the same heuristic as in the old ExpirationTimes model:
        // retry any lane at equal or lower priority, but don't try updates at higher
        // priority without also including the lower priority updates. This works well
        // when considering updates across different priority levels, but isn't
        // sufficient for updates within the same priority, since we want to treat
        // those updates as parallel.
        // Unsuspend any update at equal or lower priority.
        var higherPriorityLanes = updateLane - 1; // Turns 0b1000 into 0b0111
        root.suspendedLanes &= higherPriorityLanes;
        root.pingedLanes &= higherPriorityLanes;
        var eventTimes = root.eventTimes;
        var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most
        // recent event, and we assume time is monotonically increasing.
        eventTimes[index] = eventTime;
    }
    function markRootSuspended(root, suspendedLanes) {
        root.suspendedLanes |= suspendedLanes;
        root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.
        var expirationTimes = root.expirationTimes;
        var lanes = suspendedLanes;
        while(lanes > 0){
            var index = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index;
            expirationTimes[index] = NoTimestamp;
            lanes &= ~lane;
        }
    }
    function markRootPinged(root, pingedLanes, eventTime) {
        root.pingedLanes |= root.suspendedLanes & pingedLanes;
    }
    function markDiscreteUpdatesExpired(root) {
        root.expiredLanes |= InputDiscreteLanes & root.pendingLanes;
    }
    function hasDiscreteLanes(lanes) {
        return (lanes & InputDiscreteLanes) !== NoLanes;
    }
    function markRootMutableRead(root, updateLane) {
        root.mutableReadLanes |= updateLane & root.pendingLanes;
    }
    function markRootFinished(root, remainingLanes) {
        var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
        root.pendingLanes = remainingLanes; // Let's try everything again
        root.suspendedLanes = 0;
        root.pingedLanes = 0;
        root.expiredLanes &= remainingLanes;
        root.mutableReadLanes &= remainingLanes;
        root.entangledLanes &= remainingLanes;
        var entanglements = root.entanglements;
        var eventTimes = root.eventTimes;
        var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work
        var lanes = noLongerPendingLanes;
        while(lanes > 0){
            var index = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index;
            entanglements[index] = NoLanes;
            eventTimes[index] = NoTimestamp;
            expirationTimes[index] = NoTimestamp;
            lanes &= ~lane;
        }
    }
    function markRootEntangled(root, entangledLanes) {
        root.entangledLanes |= entangledLanes;
        var entanglements = root.entanglements;
        var lanes = entangledLanes;
        while(lanes > 0){
            var index = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index;
            entanglements[index] |= entangledLanes;
            lanes &= ~lane;
        }
    }
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros. Only used on lanes, so assume input is an integer.
    // Based on:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
    var log = Math.log;
    var LN2 = Math.LN2;
    function clz32Fallback(lanes) {
        if (lanes === 0) return 32;
        return 31 - (log(lanes) / LN2 | 0) | 0;
    }
    // Intentionally not named imports because Rollup would use dynamic dispatch for
    var UserBlockingPriority$1 = Scheduler.unstable_UserBlockingPriority, runWithPriority = Scheduler.unstable_runWithPriority; // TODO: can we stop exporting these?
    var _enabled = true; // This is exported in FB builds for use by legacy FB layer infra.
    // We'd like to remove this but it's not clear if this is safe.
    function setEnabled(enabled) {
        _enabled = !!enabled;
    }
    function isEnabled() {
        return _enabled;
    }
    function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
        var eventPriority = getEventPriorityForPluginSystem(domEventName);
        var listenerWrapper;
        switch(eventPriority){
            case DiscreteEvent:
                listenerWrapper = dispatchDiscreteEvent;
                break;
            case UserBlockingEvent:
                listenerWrapper = dispatchUserBlockingUpdate;
                break;
            case ContinuousEvent:
            default:
                listenerWrapper = dispatchEvent;
                break;
        }
        return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
    }
    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);
        discreteUpdates(dispatchEvent, domEventName, eventSystemFlags, container, nativeEvent);
    }
    function dispatchUserBlockingUpdate(domEventName, eventSystemFlags, container, nativeEvent) {
        runWithPriority(UserBlockingPriority$1, dispatchEvent.bind(null, domEventName, eventSystemFlags, container, nativeEvent));
    }
    function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (!_enabled) return;
        var allowReplay = true;
        // TODO: replaying capture phase events is currently broken
        // because we used to do it during top-level native bubble handlers
        // but now we use different bubble and capture handlers.
        // In eager mode, we attach capture listeners early, so we need
        // to filter them out until we fix the logic to handle them correctly.
        // This could've been outside the flag but I put it inside to reduce risk.
        allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;
        if (allowReplay && hasQueuedDiscreteEvents() && isReplayableDiscreteEvent(domEventName)) {
            // If we already have a queue of discrete events, and this is another discrete
            // event, then we can't dispatch it regardless of its target, since they
            // need to dispatch in order.
            queueDiscreteEvent(null, domEventName, eventSystemFlags, targetContainer, nativeEvent);
            return;
        }
        var blockedOn = attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
        if (blockedOn === null) {
            // We successfully dispatched this event.
            if (allowReplay) clearIfContinuousEvent(domEventName, nativeEvent);
            return;
        }
        if (allowReplay) {
            if (isReplayableDiscreteEvent(domEventName)) {
                // This this to be replayed later once the target is available.
                queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
                return;
            }
            if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) return;
             // We need to clear only if we didn't queue because
            // queueing is accummulative.
            clearIfContinuousEvent(domEventName, nativeEvent);
        } // This is not replayable so we'll invoke it but without a target,
        // in case the event system needs to trace it.
        dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
    } // Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.
    function attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        // TODO: Warn if _enabled is false.
        var nativeEventTarget = getEventTarget(nativeEvent);
        var targetInst = getClosestInstanceFromNode(nativeEventTarget);
        if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted === null) // This tree has been unmounted already. Dispatch without a target.
            targetInst = null;
            else {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                    var instance = getSuspenseInstanceFromFiber(nearestMounted);
                    if (instance !== null) // Queue the event to be replayed later. Abort dispatching since we
                    // don't want this event dispatched twice through the event system.
                    // TODO: If this is the first discrete event in the queue. Schedule an increased
                    // priority for this boundary.
                    return instance;
                     // This shouldn't happen, something went wrong but to avoid blocking
                    // the whole system, dispatch the event without a target.
                    // TODO: Warn.
                    targetInst = null;
                } else if (tag === HostRoot) {
                    var root = nearestMounted.stateNode;
                    if (root.hydrate) // If this happens during a replay something went wrong and it might block
                    // the whole system.
                    return getContainerFromFiber(nearestMounted);
                    targetInst = null;
                } else if (nearestMounted !== targetInst) // If we get an event (ex: img onload) before committing that
                // component's mount, ignore it for now (that is, treat it as if it was an
                // event on a non-React tree). We might also consider queueing events and
                // dispatching them after the mount.
                targetInst = null;
            }
        }
        dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer); // We're not blocked on anything.
        return null;
    }
    function addEventBubbleListener(target, eventType, listener) {
        target.addEventListener(eventType, listener, false);
        return listener;
    }
    function addEventCaptureListener(target, eventType, listener) {
        target.addEventListener(eventType, listener, true);
        return listener;
    }
    function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
        target.addEventListener(eventType, listener, {
            capture: true,
            passive: passive
        });
        return listener;
    }
    function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
        target.addEventListener(eventType, listener, {
            passive: passive
        });
        return listener;
    }
    /**
 * These variables store information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */ var root1 = null;
    var startText = null;
    var fallbackText = null;
    function initialize(nativeEventTarget) {
        root1 = nativeEventTarget;
        startText = getText();
        return true;
    }
    function reset() {
        root1 = null;
        startText = null;
        fallbackText = null;
    }
    function getData() {
        if (fallbackText) return fallbackText;
        var start;
        var startValue = startText;
        var startLength = startValue.length;
        var end;
        var endValue = getText();
        var endLength = endValue.length;
        for(start = 0; start < startLength; start++){
            if (startValue[start] !== endValue[start]) break;
        }
        var minEnd = startLength - start;
        for(end = 1; end <= minEnd; end++){
            if (startValue[startLength - end] !== endValue[endLength - end]) break;
        }
        var sliceTail = end > 1 ? 1 - end : undefined;
        fallbackText = endValue.slice(start, sliceTail);
        return fallbackText;
    }
    function getText() {
        if ('value' in root1) return root1.value;
        return root1.textContent;
    }
    /**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */ function getEventCharCode(nativeEvent) {
        var charCode;
        var keyCode = nativeEvent.keyCode;
        if ('charCode' in nativeEvent) {
            charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`.
            if (charCode === 0 && keyCode === 13) charCode = 13;
        } else // IE8 does not implement `charCode`, but `keyCode` has the correct value.
        charCode = keyCode;
         // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
        // report Enter as charCode 10 when ctrl is pressed.
        if (charCode === 10) charCode = 13;
         // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
        // Must not discard the (non-)printable Enter-key.
        if (charCode >= 32 || charCode === 13) return charCode;
        return 0;
    }
    function functionThatReturnsTrue() {
        return true;
    }
    function functionThatReturnsFalse() {
        return false;
    } // This is intentionally a factory so that we have different returned constructors.
    // If we had a single constructor, it would be megamorphic and engines would deopt.
    function createSyntheticEvent(Interface) {
        /**
   * Synthetic events are dispatched by event plugins, typically in response to a
   * top-level event delegation handler.
   *
   * These systems should generally use pooling to reduce the frequency of garbage
   * collection. The system should check `isPersistent` to determine whether the
   * event should be released into the pool after being dispatched. Users that
   * need a persisted event should invoke `persist`.
   *
   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
   * normalizing browser quirks. Subclasses do not necessarily have to implement a
   * DOM interface; custom application-specific events can also subclass this.
   */ function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for(var _propName in Interface){
                if (!Interface.hasOwnProperty(_propName)) continue;
                var normalize = Interface[_propName];
                if (normalize) this[_propName] = normalize(nativeEvent);
                else this[_propName] = nativeEvent[_propName];
            }
            var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
            if (defaultPrevented) this.isDefaultPrevented = functionThatReturnsTrue;
            else this.isDefaultPrevented = functionThatReturnsFalse;
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
        }
        _assign(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
                this.defaultPrevented = true;
                var event = this.nativeEvent;
                if (!event) return;
                if (event.preventDefault) event.preventDefault(); // $FlowFixMe - flow is not aware of `unknown` in IE
                else if (typeof event.returnValue !== 'unknown') event.returnValue = false;
                this.isDefaultPrevented = functionThatReturnsTrue;
            },
            stopPropagation: function() {
                var event = this.nativeEvent;
                if (!event) return;
                if (event.stopPropagation) event.stopPropagation(); // $FlowFixMe - flow is not aware of `unknown` in IE
                else if (typeof event.cancelBubble !== 'unknown') // The ChangeEventPlugin registers a "propertychange" event for
                // IE. This event does not support bubbling or cancelling, and
                // any references to cancelBubble throw "Member not found".  A
                // typeof check of "unknown" circumvents this issue (and is also
                // IE specific).
                event.cancelBubble = true;
                this.isPropagationStopped = functionThatReturnsTrue;
            },
            /**
     * We release all dispatched `SyntheticEvent`s after each event loop, adding
     * them back into the pool. This allows a way to hold onto a reference that
     * won't be added back into the pool.
     */ persist: function() {
            },
            /**
     * Checks if this event should be released back into the pool.
     *
     * @return {boolean} True if this should not be released, false otherwise.
     */ isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
    }
    /**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
            return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
    };
    var SyntheticEvent = createSyntheticEvent(EventInterface);
    var UIEventInterface = _assign({
    }, EventInterface, {
        view: 0,
        detail: 0
    });
    var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
    var lastMovementX;
    var lastMovementY;
    var lastMouseEvent;
    function updateMouseMovementPolyfillState(event) {
        if (event !== lastMouseEvent) {
            if (lastMouseEvent && event.type === 'mousemove') {
                lastMovementX = event.screenX - lastMouseEvent.screenX;
                lastMovementY = event.screenY - lastMouseEvent.screenY;
            } else {
                lastMovementX = 0;
                lastMovementY = 0;
            }
            lastMouseEvent = event;
        }
    }
    /**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var MouseEventInterface = _assign({
    }, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
            if (event.relatedTarget === undefined) return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
            return event.relatedTarget;
        },
        movementX: function(event) {
            if ('movementX' in event) return event.movementX;
            updateMouseMovementPolyfillState(event);
            return lastMovementX;
        },
        movementY: function(event) {
            if ('movementY' in event) return event.movementY;
             // Don't need to call updateMouseMovementPolyfillState() here
            // because it's guaranteed to have already run when movementX
            // was copied.
            return lastMovementY;
        }
    });
    var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
    /**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var DragEventInterface = _assign({
    }, MouseEventInterface, {
        dataTransfer: 0
    });
    var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
    /**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var FocusEventInterface = _assign({
    }, UIEventInterface, {
        relatedTarget: 0
    });
    var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
    /**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */ var AnimationEventInterface = _assign({
    }, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    });
    var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
    /**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */ var ClipboardEventInterface = _assign({
    }, EventInterface, {
        clipboardData: function(event) {
            return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
        }
    });
    var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
    /**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */ var CompositionEventInterface = _assign({
    }, EventInterface, {
        data: 0
    });
    var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
    /**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */ // Happens to share the same list for now.
    var SyntheticInputEvent = SyntheticCompositionEvent;
    /**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */ var normalizeKey = {
        Esc: 'Escape',
        Spacebar: ' ',
        Left: 'ArrowLeft',
        Up: 'ArrowUp',
        Right: 'ArrowRight',
        Down: 'ArrowDown',
        Del: 'Delete',
        Win: 'OS',
        Menu: 'ContextMenu',
        Apps: 'ContextMenu',
        Scroll: 'ScrollLock',
        MozPrintableKey: 'Unidentified'
    };
    /**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */ var translateToKey = {
        '8': 'Backspace',
        '9': 'Tab',
        '12': 'Clear',
        '13': 'Enter',
        '16': 'Shift',
        '17': 'Control',
        '18': 'Alt',
        '19': 'Pause',
        '20': 'CapsLock',
        '27': 'Escape',
        '32': ' ',
        '33': 'PageUp',
        '34': 'PageDown',
        '35': 'End',
        '36': 'Home',
        '37': 'ArrowLeft',
        '38': 'ArrowUp',
        '39': 'ArrowRight',
        '40': 'ArrowDown',
        '45': 'Insert',
        '46': 'Delete',
        '112': 'F1',
        '113': 'F2',
        '114': 'F3',
        '115': 'F4',
        '116': 'F5',
        '117': 'F6',
        '118': 'F7',
        '119': 'F8',
        '120': 'F9',
        '121': 'F10',
        '122': 'F11',
        '123': 'F12',
        '144': 'NumLock',
        '145': 'ScrollLock',
        '224': 'Meta'
    };
    /**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */ function getEventKey(nativeEvent) {
        if (nativeEvent.key) {
            // Normalize inconsistent values reported by browsers due to
            // implementations of a working draft specification.
            // FireFox implements `key` but returns `MozPrintableKey` for all
            // printable characters (normalized to `Unidentified`), ignore it.
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if (key !== 'Unidentified') return key;
        } // Browser does not implement `key`, polyfill as much of it as we can.
        if (nativeEvent.type === 'keypress') {
            var charCode = getEventCharCode(nativeEvent); // The enter-key is technically both printable and non-printable and can
            // thus be captured by `keypress`, no other non-printable key should.
            return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
        }
        if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') // While user keyboard layout determines the actual meaning of each
        // `keyCode` value, almost all function keys have a universal value.
        return translateToKey[nativeEvent.keyCode] || 'Unidentified';
        return '';
    }
    /**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */ var modifierKeyToProp = {
        Alt: 'altKey',
        Control: 'ctrlKey',
        Meta: 'metaKey',
        Shift: 'shiftKey'
    }; // Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support
    // getModifierState. If getModifierState is not supported, we map it to a set of
    // modifier keys exposed by the event. In this case, Lock-keys are not supported.
    function modifierStateGetter(keyArg) {
        var syntheticEvent = this;
        var nativeEvent = syntheticEvent.nativeEvent;
        if (nativeEvent.getModifierState) return nativeEvent.getModifierState(keyArg);
        var keyProp = modifierKeyToProp[keyArg];
        return keyProp ? !!nativeEvent[keyProp] : false;
    }
    function getEventModifierState(nativeEvent) {
        return modifierStateGetter;
    }
    /**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var KeyboardEventInterface = _assign({
    }, UIEventInterface, {
        key: getEventKey,
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        // Legacy Interface
        charCode: function(event) {
            // `charCode` is the result of a KeyPress event and represents the value of
            // the actual printable character.
            // KeyPress is deprecated, but its replacement is not yet final and not
            // implemented in any major browser. Only KeyPress has charCode.
            if (event.type === 'keypress') return getEventCharCode(event);
            return 0;
        },
        keyCode: function(event) {
            // `keyCode` is the result of a KeyDown/Up event and represents the value of
            // physical keyboard key.
            // The actual meaning of the value depends on the users' keyboard layout
            // which cannot be detected. Assuming that it is a US keyboard layout
            // provides a surprisingly accurate mapping for US and European users.
            // Due to this, it is left to the user to implement at this time.
            if (event.type === 'keydown' || event.type === 'keyup') return event.keyCode;
            return 0;
        },
        which: function(event) {
            // `which` is an alias for either `keyCode` or `charCode` depending on the
            // type of the event.
            if (event.type === 'keypress') return getEventCharCode(event);
            if (event.type === 'keydown' || event.type === 'keyup') return event.keyCode;
            return 0;
        }
    });
    var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
    /**
 * @interface PointerEvent
 * @see http://www.w3.org/TR/pointerevents/
 */ var PointerEventInterface = _assign({
    }, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    });
    var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
    /**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */ var TouchEventInterface = _assign({
    }, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
    });
    var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
    /**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */ var TransitionEventInterface = _assign({
    }, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    });
    var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
    /**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var WheelEventInterface = _assign({
    }, MouseEventInterface, {
        deltaX: function(event) {
            return 'deltaX' in event ? event.deltaX : 'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function(event) {
            return 'deltaY' in event ? event.deltaY : 'wheelDeltaY' in event ? -event.wheelDeltaY : 'wheelDelta' in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        // Browsers without "deltaMode" is reporting in raw wheel delta where one
        // notch on the scroll is always +/- 120, roughly equivalent to pixels.
        // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
        // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
        deltaMode: 0
    });
    var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
    var END_KEYCODES = [
        9,
        13,
        27,
        32
    ]; // Tab, Return, Esc, Space
    var START_KEYCODE = 229;
    var canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;
    var documentMode = null;
    if (canUseDOM && 'documentMode' in document) documentMode = document.documentMode;
     // Webkit offers a very useful `textInput` event that can be used to
    // directly represent `beforeInput`. The IE `textinput` event is not as
    // useful, so we don't use it.
    var canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode; // In IE9+, we have access to composition events, but the data supplied
    // by the native compositionend event may be incorrect. Japanese ideographic
    // spaces, for instance (\u3000) are not recorded correctly.
    var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
    var SPACEBAR_CODE = 32;
    var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
    function registerEvents() {
        registerTwoPhaseEvent('onBeforeInput', [
            'compositionend',
            'keypress',
            'textInput',
            'paste'
        ]);
        registerTwoPhaseEvent('onCompositionEnd', [
            'compositionend',
            'focusout',
            'keydown',
            'keypress',
            'keyup',
            'mousedown'
        ]);
        registerTwoPhaseEvent('onCompositionStart', [
            'compositionstart',
            'focusout',
            'keydown',
            'keypress',
            'keyup',
            'mousedown'
        ]);
        registerTwoPhaseEvent('onCompositionUpdate', [
            'compositionupdate',
            'focusout',
            'keydown',
            'keypress',
            'keyup',
            'mousedown'
        ]);
    } // Track whether we've ever handled a keypress on the space key.
    var hasSpaceKeypress = false;
    /**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */ function isKeypressCommand(nativeEvent) {
        return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
    }
    /**
 * Translate native top level events into event types.
 */ function getCompositionEventType(domEventName) {
        switch(domEventName){
            case 'compositionstart':
                return 'onCompositionStart';
            case 'compositionend':
                return 'onCompositionEnd';
            case 'compositionupdate':
                return 'onCompositionUpdate';
        }
    }
    /**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 */ function isFallbackCompositionStart(domEventName, nativeEvent) {
        return domEventName === 'keydown' && nativeEvent.keyCode === START_KEYCODE;
    }
    /**
 * Does our fallback mode think that this event is the end of composition?
 */ function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch(domEventName){
            case 'keyup':
                // Command keys insert or clear IME input.
                return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
            case 'keydown':
                // Expect IME keyCode on each keydown. If we get any other
                // code we must have exited earlier.
                return nativeEvent.keyCode !== START_KEYCODE;
            case 'keypress':
            case 'mousedown':
            case 'focusout':
                // Events are not possible without cancelling IME.
                return true;
            default:
                return false;
        }
    }
    /**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */ function getDataFromCustomEvent(nativeEvent) {
        var detail = nativeEvent.detail;
        if (typeof detail === 'object' && 'data' in detail) return detail.data;
        return null;
    }
    /**
 * Check if a composition event was triggered by Korean IME.
 * Our fallback mode does not work well with IE's Korean IME,
 * so just use native composition events when Korean IME is used.
 * Although CompositionEvent.locale property is deprecated,
 * it is available in IE, where our fallback mode is enabled.
 *
 * @param {object} nativeEvent
 * @return {boolean}
 */ function isUsingKoreanIME(nativeEvent) {
        return nativeEvent.locale === 'ko';
    } // Track the current IME composition status, if any.
    var isComposing = false;
    /**
 * @return {?object} A SyntheticCompositionEvent.
 */ function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
        var eventType;
        var fallbackData;
        if (canUseCompositionEvent) eventType = getCompositionEventType(domEventName);
        else if (!isComposing) {
            if (isFallbackCompositionStart(domEventName, nativeEvent)) eventType = 'onCompositionStart';
        } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) eventType = 'onCompositionEnd';
        if (!eventType) return null;
        if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
            // The current composition is stored statically and must not be
            // overwritten while composition continues.
            if (!isComposing && eventType === 'onCompositionStart') isComposing = initialize(nativeEventTarget);
            else if (eventType === 'onCompositionEnd') {
                if (isComposing) fallbackData = getData();
            }
        }
        var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
        if (listeners.length > 0) {
            var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
                event: event,
                listeners: listeners
            });
            if (fallbackData) // Inject data generated from fallback path into the synthetic event.
            // This matches the property of native CompositionEventInterface.
            event.data = fallbackData;
            else {
                var customData = getDataFromCustomEvent(nativeEvent);
                if (customData !== null) event.data = customData;
            }
        }
    }
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch(domEventName){
            case 'compositionend':
                return getDataFromCustomEvent(nativeEvent);
            case 'keypress':
                /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */ var which = nativeEvent.which;
                if (which !== SPACEBAR_CODE) return null;
                hasSpaceKeypress = true;
                return SPACEBAR_CHAR;
            case 'textInput':
                // Record the characters to be added to the DOM.
                var chars = nativeEvent.data; // If it's a spacebar character, assume that we have already handled
                // it at the keypress level and bail immediately. Android Chrome
                // doesn't give us keycodes, so we need to ignore it.
                if (chars === SPACEBAR_CHAR && hasSpaceKeypress) return null;
                return chars;
            default:
                // For other native event types, do nothing.
                return null;
        }
    }
    /**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 */ function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        // If we are currently composing (IME) and using a fallback to do so,
        // try to extract the composed characters from the fallback object.
        // If composition event is available, we extract a string only at
        // compositionevent, otherwise extract it at fallback events.
        if (isComposing) {
            if (domEventName === 'compositionend' || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
                var chars = getData();
                reset();
                isComposing = false;
                return chars;
            }
            return null;
        }
        switch(domEventName){
            case 'paste':
                // If a paste event occurs after a keypress, throw out the input
                // chars. Paste events should not lead to BeforeInput events.
                return null;
            case 'keypress':
                /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */ if (!isKeypressCommand(nativeEvent)) {
                    // IE fires the `keypress` event when a user types an emoji via
                    // Touch keyboard of Windows.  In such a case, the `char` property
                    // holds an emoji character like `\uD83D\uDE0A`.  Because its length
                    // is 2, the property `which` does not represent an emoji correctly.
                    // In such a case, we directly return the `char` property instead of
                    // using `which`.
                    if (nativeEvent.char && nativeEvent.char.length > 1) return nativeEvent.char;
                    else if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
                }
                return null;
            case 'compositionend':
                return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
            default:
                return null;
        }
    }
    /**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */ function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
        var chars;
        if (canUseTextInputEvent) chars = getNativeBeforeInputChars(domEventName, nativeEvent);
        else chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
         // If no characters are being inserted, no BeforeInput event should
        // be fired.
        if (!chars) return null;
        var listeners = accumulateTwoPhaseListeners(targetInst, 'onBeforeInput');
        if (listeners.length > 0) {
            var event = new SyntheticInputEvent('onBeforeInput', 'beforeinput', null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
                event: event,
                listeners: listeners
            });
            event.data = chars;
        }
    }
    /**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */ function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
    }
    /**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */ var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        'datetime-local': true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
    };
    function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        if (nodeName === 'input') return !!supportedInputTypes[elem.type];
        if (nodeName === 'textarea') return true;
        return false;
    }
    /**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */ function isEventSupported(eventNameSuffix) {
        if (!canUseDOM) return false;
        var eventName = 'on' + eventNameSuffix;
        var isSupported = eventName in document;
        if (!isSupported) {
            var element = document.createElement('div');
            element.setAttribute(eventName, 'return;');
            isSupported = typeof element[eventName] === 'function';
        }
        return isSupported;
    }
    function registerEvents$1() {
        registerTwoPhaseEvent('onChange', [
            'change',
            'click',
            'focusin',
            'focusout',
            'input',
            'keydown',
            'keyup',
            'selectionchange'
        ]);
    }
    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        // Flag this event loop as needing state restore.
        enqueueStateRestore(target);
        var listeners = accumulateTwoPhaseListeners(inst, 'onChange');
        if (listeners.length > 0) {
            var event = new SyntheticEvent('onChange', 'change', null, nativeEvent, target);
            dispatchQueue.push({
                event: event,
                listeners: listeners
            });
        }
    }
    /**
 * For IE shims
 */ var activeElement = null;
    var activeElementInst = null;
    /**
 * SECTION: handle `change` event
 */ function shouldUseChangeEvent(elem) {
        var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
    }
    function manualDispatchChangeEvent(nativeEvent) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent)); // If change and propertychange bubbled, we'd just bind to it like all the
        // other events and have it go through ReactBrowserEventEmitter. Since it
        // doesn't, we manually listen for the events and so we have to enqueue and
        // process the abstract event manually.
        //
        // Batching is necessary here in order to ensure that all event handlers run
        // before the next rerender (including event handlers attached to ancestor
        // elements instead of directly on the input). Without this, controlled
        // components don't work properly in conjunction with event bubbling because
        // the component is rerendered and the value reverted before all the event
        // handlers can run. See https://github.com/facebook/react/issues/708.
        batchedUpdates(runEventInBatch, dispatchQueue);
    }
    function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
        if (domEventName === 'change') return targetInst;
    }
    /**
 * SECTION: handle `input` event
 */ var isInputEventSupported = false;
    if (canUseDOM) // IE9 claims to support the input event but fails to trigger it when
    // deleting text, so we ignore its input events.
    isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
    /**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */ function startWatchingForValueChange(target, targetInst) {
        activeElement = target;
        activeElementInst = targetInst;
        activeElement.attachEvent('onpropertychange', handlePropertyChange);
    }
    /**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */ function stopWatchingForValueChange() {
        if (!activeElement) return;
        activeElement.detachEvent('onpropertychange', handlePropertyChange);
        activeElement = null;
        activeElementInst = null;
    }
    /**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */ function handlePropertyChange(nativeEvent) {
        if (nativeEvent.propertyName !== 'value') return;
        if (getInstIfValueChanged(activeElementInst)) manualDispatchChangeEvent(nativeEvent);
    }
    function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        if (domEventName === 'focusin') {
            // In IE9, propertychange fires for most input events but is buggy and
            // doesn't fire when text is deleted, but conveniently, selectionchange
            // appears to fire in all of the remaining cases so we catch those and
            // forward the event if the value has changed
            // In either case, we don't want to call the event handler if the value
            // is changed from JS so we redefine a setter for `.value` that updates
            // our activeElementValue variable, allowing us to ignore those changes
            //
            // stopWatching() should be a noop here but we call it just in case we
            // missed a blur event somehow.
            stopWatchingForValueChange();
            startWatchingForValueChange(target, targetInst);
        } else if (domEventName === 'focusout') stopWatchingForValueChange();
    } // For IE8 and IE9.
    function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
        if (domEventName === 'selectionchange' || domEventName === 'keyup' || domEventName === 'keydown') // On the selectionchange event, the target is just document which isn't
        // helpful for us so just check activeElement instead.
        //
        // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
        // propertychange on the first input event after setting `value` from a
        // script and fires only keydown, keypress, keyup. Catching keyup usually
        // gets it and catching keydown lets us fire an event for the first
        // keystroke if user does a key repeat (it'll be a little delayed: right
        // before the second keystroke). Other input methods (e.g., paste) seem to
        // fire selectionchange normally.
        return getInstIfValueChanged(activeElementInst);
    }
    /**
 * SECTION: handle `click` event
 */ function shouldUseClickEvent(elem) {
        // Use the `click` event to detect changes to checkbox and radio inputs.
        // This approach works across all browsers, whereas `change` does not fire
        // until `blur` in IE8.
        var nodeName = elem.nodeName;
        return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
        if (domEventName === 'click') return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if (domEventName === 'input' || domEventName === 'change') return getInstIfValueChanged(targetInst);
    }
    function handleControlledInputBlur(node) {
        var state = node._wrapperState;
        if (!state || !state.controlled || node.type !== 'number') return;
        // If controlled, assign the value attribute to the current value on blur
        setDefaultValue(node, 'number', node.value);
    }
    /**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */ function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
        var getTargetInstFunc, handleEventFunc;
        if (shouldUseChangeEvent(targetNode)) getTargetInstFunc = getTargetInstForChangeEvent;
        else if (isTextInputElement(targetNode)) {
            if (isInputEventSupported) getTargetInstFunc = getTargetInstForInputOrChangeEvent;
            else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                handleEventFunc = handleEventsForInputEventPolyfill;
            }
        } else if (shouldUseClickEvent(targetNode)) getTargetInstFunc = getTargetInstForClickEvent;
        if (getTargetInstFunc) {
            var inst = getTargetInstFunc(domEventName, targetInst);
            if (inst) {
                createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
                return;
            }
        }
        if (handleEventFunc) handleEventFunc(domEventName, targetNode, targetInst);
         // When blurring, set the value attribute for number inputs
        if (domEventName === 'focusout') handleControlledInputBlur(targetNode);
    }
    function registerEvents$2() {
        registerDirectEvent('onMouseEnter', [
            'mouseout',
            'mouseover'
        ]);
        registerDirectEvent('onMouseLeave', [
            'mouseout',
            'mouseover'
        ]);
        registerDirectEvent('onPointerEnter', [
            'pointerout',
            'pointerover'
        ]);
        registerDirectEvent('onPointerLeave', [
            'pointerout',
            'pointerover'
        ]);
    }
    /**
 * For almost every interaction we care about, there will be both a top-level
 * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
 * we do not extract duplicate events. However, moving the mouse into the
 * browser from outside will not fire a `mouseout` event. In this case, we use
 * the `mouseover` top-level event.
 */ function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var isOverEvent = domEventName === 'mouseover' || domEventName === 'pointerover';
        var isOutEvent = domEventName === 'mouseout' || domEventName === 'pointerout';
        if (isOverEvent && (eventSystemFlags & IS_REPLAYED) === 0) {
            // If this is an over event with a target, we might have already dispatched
            // the event in the out event of the other target. If this is replayed,
            // then it's because we couldn't dispatch against this target previously
            // so we have to do it now instead.
            var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
            if (related) {
                // If the related node is managed by React, we can assume that we have
                // already dispatched the corresponding events during its mouseout.
                if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) return;
            }
        }
        if (!isOutEvent && !isOverEvent) // Must not be a mouse or pointer in or out - ignoring.
        return;
        var win; // TODO: why is this nullable in the types but we read from it?
        if (nativeEventTarget.window === nativeEventTarget) // `nativeEventTarget` is probably a window object.
        win = nativeEventTarget;
        else {
            // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
            var doc = nativeEventTarget.ownerDocument;
            if (doc) win = doc.defaultView || doc.parentWindow;
            else win = window;
        }
        var from;
        var to;
        if (isOutEvent) {
            var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
            from = targetInst;
            to = _related ? getClosestInstanceFromNode(_related) : null;
            if (to !== null) {
                var nearestMounted = getNearestMountedFiber(to);
                if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) to = null;
            }
        } else {
            // Moving to a node from outside the window.
            from = null;
            to = targetInst;
        }
        if (from === to) // Nothing pertains to our managed components.
        return;
        var SyntheticEventCtor = SyntheticMouseEvent;
        var leaveEventType = 'onMouseLeave';
        var enterEventType = 'onMouseEnter';
        var eventTypePrefix = 'mouse';
        if (domEventName === 'pointerout' || domEventName === 'pointerover') {
            SyntheticEventCtor = SyntheticPointerEvent;
            leaveEventType = 'onPointerLeave';
            enterEventType = 'onPointerEnter';
            eventTypePrefix = 'pointer';
        }
        var fromNode = from == null ? win : getNodeFromInstance(from);
        var toNode = to == null ? win : getNodeFromInstance(to);
        var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + 'leave', from, nativeEvent, nativeEventTarget);
        leave.target = fromNode;
        leave.relatedTarget = toNode;
        var enter = null; // We should only process this nativeEvent if we are processing
        // the first ancestor. Next time, we will ignore the event.
        var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
        if (nativeTargetInst === targetInst) {
            var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + 'enter', to, nativeEvent, nativeEventTarget);
            enterEvent.target = toNode;
            enterEvent.relatedTarget = fromNode;
            enter = enterEvent;
        }
        accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
    }
    /**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */ function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
        ;
    }
    var objectIs = typeof Object.is === 'function' ? Object.is : is;
    var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    /**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */ function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) return true;
        if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) return false;
        var keysA = Object.keys(objA);
        var keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return false;
         // Test for A's keys different from B.
        for(var i = 0; i < keysA.length; i++){
            if (!hasOwnProperty$2.call(objB, keysA[i]) || !objectIs(objA[keysA[i]], objB[keysA[i]])) return false;
        }
        return true;
    }
    /**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */ function getLeafNode(node) {
        while(node && node.firstChild)node = node.firstChild;
        return node;
    }
    /**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */ function getSiblingNode(node) {
        while(node){
            if (node.nextSibling) return node.nextSibling;
            node = node.parentNode;
        }
    }
    /**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */ function getNodeForCharacterOffset(root, offset) {
        var node = getLeafNode(root);
        var nodeStart = 0;
        var nodeEnd = 0;
        while(node){
            if (node.nodeType === TEXT_NODE) {
                nodeEnd = nodeStart + node.textContent.length;
                if (nodeStart <= offset && nodeEnd >= offset) return {
                    node: node,
                    offset: offset - nodeStart
                };
                nodeStart = nodeEnd;
            }
            node = getLeafNode(getSiblingNode(node));
        }
    }
    /**
 * @param {DOMElement} outerNode
 * @return {?object}
 */ function getOffsets(outerNode) {
        var ownerDocument = outerNode.ownerDocument;
        var win = ownerDocument && ownerDocument.defaultView || window;
        var selection = win.getSelection && win.getSelection();
        if (!selection || selection.rangeCount === 0) return null;
        var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset; // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
        // up/down buttons on an <input type="number">. Anonymous divs do not seem to
        // expose properties, triggering a "Permission denied error" if any of its
        // properties are accessed. The only seemingly possible way to avoid erroring
        // is to access a property that typically works for non-anonymous divs and
        // catch any error that may otherwise arise. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
        try {
            /* eslint-disable no-unused-expressions */ anchorNode.nodeType;
            focusNode.nodeType;
        /* eslint-enable no-unused-expressions */ } catch (e) {
            return null;
        }
        return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
    }
    /**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */ function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
        var length = 0;
        var start = -1;
        var end = -1;
        var indexWithinAnchor = 0;
        var indexWithinFocus = 0;
        var node = outerNode;
        var parentNode = null;
        outer: while(true){
            var next = null;
            while(true){
                if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) start = length + anchorOffset;
                if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) end = length + focusOffset;
                if (node.nodeType === TEXT_NODE) length += node.nodeValue.length;
                if ((next = node.firstChild) === null) break;
                 // Moving from `node` to its first child `next`.
                parentNode = node;
                node = next;
            }
            while(true){
                if (node === outerNode) break outer;
                if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) start = length;
                if (parentNode === focusNode && ++indexWithinFocus === focusOffset) end = length;
                if ((next = node.nextSibling) !== null) break;
                node = parentNode;
                parentNode = node.parentNode;
            } // Moving from `node` to its next sibling `next`.
            node = next;
        }
        if (start === -1 || end === -1) // This should never happen. (Would happen if the anchor/focus nodes aren't
        // actually inside the passed-in node.)
        return null;
        return {
            start: start,
            end: end
        };
    }
    /**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */ function setOffsets(node, offsets) {
        var doc = node.ownerDocument || document;
        var win = doc && doc.defaultView || window; // Edge fails with "Object expected" in some scenarios.
        // (For instance: TinyMCE editor used in a list component that supports pasting to add more,
        // fails when pasting 100+ items)
        if (!win.getSelection) return;
        var selection = win.getSelection();
        var length = node.textContent.length;
        var start = Math.min(offsets.start, length);
        var end = offsets.end === undefined ? start : Math.min(offsets.end, length); // IE 11 uses modern selection, but doesn't support the extend method.
        // Flip backward selections, so we can set with a single range.
        if (!selection.extend && start > end) {
            var temp = end;
            end = start;
            start = temp;
        }
        var startMarker = getNodeForCharacterOffset(node, start);
        var endMarker = getNodeForCharacterOffset(node, end);
        if (startMarker && endMarker) {
            if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) return;
            var range = doc.createRange();
            range.setStart(startMarker.node, startMarker.offset);
            selection.removeAllRanges();
            if (start > end) {
                selection.addRange(range);
                selection.extend(endMarker.node, endMarker.offset);
            } else {
                range.setEnd(endMarker.node, endMarker.offset);
                selection.addRange(range);
            }
        }
    }
    function isTextNode(node) {
        return node && node.nodeType === TEXT_NODE;
    }
    function containsNode(outerNode, innerNode) {
        if (!outerNode || !innerNode) return false;
        else if (outerNode === innerNode) return true;
        else if (isTextNode(outerNode)) return false;
        else if (isTextNode(innerNode)) return containsNode(outerNode, innerNode.parentNode);
        else if ('contains' in outerNode) return outerNode.contains(innerNode);
        else if (outerNode.compareDocumentPosition) return !!(outerNode.compareDocumentPosition(innerNode) & 16);
        else return false;
    }
    function isInDocument(node) {
        return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
    }
    function isSameOriginFrame(iframe) {
        try {
            // Accessing the contentDocument of a HTMLIframeElement can cause the browser
            // to throw, e.g. if it has a cross-origin src attribute.
            // Safari will show an error in the console when the access results in "Blocked a frame with origin". e.g:
            // iframe.contentDocument.defaultView;
            // A safety way is to access one of the cross origin properties: Window or Location
            // Which might result in "SecurityError" DOM Exception and it is compatible to Safari.
            // https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl
            return typeof iframe.contentWindow.location.href === 'string';
        } catch (err) {
            return false;
        }
    }
    function getActiveElementDeep() {
        var win = window;
        var element = getActiveElement();
        while(element instanceof win.HTMLIFrameElement){
            if (isSameOriginFrame(element)) win = element.contentWindow;
            else return element;
            element = getActiveElement(win.document);
        }
        return element;
    }
    /**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */ /**
 * @hasSelectionCapabilities: we get the element types that support selection
 * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
 * and `selectionEnd` rows.
 */ function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && (nodeName === 'input' && (elem.type === 'text' || elem.type === 'search' || elem.type === 'tel' || elem.type === 'url' || elem.type === 'password') || nodeName === 'textarea' || elem.contentEditable === 'true');
    }
    function getSelectionInformation() {
        var focusedElem = getActiveElementDeep();
        return {
            focusedElem: focusedElem,
            selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
        };
    }
    /**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */ function restoreSelection(priorSelectionInformation) {
        var curFocusedElem = getActiveElementDeep();
        var priorFocusedElem = priorSelectionInformation.focusedElem;
        var priorSelectionRange = priorSelectionInformation.selectionRange;
        if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
            if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) setSelection(priorFocusedElem, priorSelectionRange);
             // Focusing a node can change the scroll position, which is undesirable
            var ancestors = [];
            var ancestor = priorFocusedElem;
            while(ancestor = ancestor.parentNode)if (ancestor.nodeType === ELEMENT_NODE) ancestors.push({
                element: ancestor,
                left: ancestor.scrollLeft,
                top: ancestor.scrollTop
            });
            if (typeof priorFocusedElem.focus === 'function') priorFocusedElem.focus();
            for(var i = 0; i < ancestors.length; i++){
                var info = ancestors[i];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
            }
        }
    }
    /**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */ function getSelection(input) {
        var selection;
        if ('selectionStart' in input) // Modern browser with input or textarea.
        selection = {
            start: input.selectionStart,
            end: input.selectionEnd
        };
        else // Content editable or old IE textarea.
        selection = getOffsets(input);
        return selection || {
            start: 0,
            end: 0
        };
    }
    /**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */ function setSelection(input, offsets) {
        var start = offsets.start;
        var end = offsets.end;
        if (end === undefined) end = start;
        if ('selectionStart' in input) {
            input.selectionStart = start;
            input.selectionEnd = Math.min(end, input.value.length);
        } else setOffsets(input, offsets);
    }
    var skipSelectionChangeEvent = canUseDOM && 'documentMode' in document && document.documentMode <= 11;
    function registerEvents$3() {
        registerTwoPhaseEvent('onSelect', [
            'focusout',
            'contextmenu',
            'dragend',
            'focusin',
            'keydown',
            'keyup',
            'mousedown',
            'mouseup',
            'selectionchange'
        ]);
    }
    var activeElement$1 = null;
    var activeElementInst$1 = null;
    var lastSelection = null;
    var mouseDown = false;
    /**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 */ function getSelection$1(node) {
        if ('selectionStart' in node && hasSelectionCapabilities(node)) return {
            start: node.selectionStart,
            end: node.selectionEnd
        };
        else {
            var win = node.ownerDocument && node.ownerDocument.defaultView || window;
            var selection = win.getSelection();
            return {
                anchorNode: selection.anchorNode,
                anchorOffset: selection.anchorOffset,
                focusNode: selection.focusNode,
                focusOffset: selection.focusOffset
            };
        }
    }
    /**
 * Get document associated with the event target.
 */ function getEventTargetDocument(eventTarget) {
        return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
    }
    /**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @param {object} nativeEventTarget
 * @return {?SyntheticEvent}
 */ function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        // Ensure we have the right element, and that the user is not dragging a
        // selection (this matches native `select` event behavior). In HTML5, select
        // fires only on input and textarea thus if there's no focused element we
        // won't dispatch.
        var doc = getEventTargetDocument(nativeEventTarget);
        if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) return;
         // Only fire when selection has actually changed.
        var currentSelection = getSelection$1(activeElement$1);
        if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
            lastSelection = currentSelection;
            var listeners = accumulateTwoPhaseListeners(activeElementInst$1, 'onSelect');
            if (listeners.length > 0) {
                var event = new SyntheticEvent('onSelect', 'select', null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                    event: event,
                    listeners: listeners
                });
                event.target = activeElement$1;
            }
        }
    }
    /**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */ function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
        switch(domEventName){
            // Track the input node that has focus.
            case 'focusin':
                if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
                    activeElement$1 = targetNode;
                    activeElementInst$1 = targetInst;
                    lastSelection = null;
                }
                break;
            case 'focusout':
                activeElement$1 = null;
                activeElementInst$1 = null;
                lastSelection = null;
                break;
            // Don't fire the event while the user is dragging. This matches the
            // semantics of the native select event.
            case 'mousedown':
                mouseDown = true;
                break;
            case 'contextmenu':
            case 'mouseup':
            case 'dragend':
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
            // Chrome and IE fire non-standard event when selection is changed (and
            // sometimes when it hasn't). IE's event fires out of order with respect
            // to key and input events on deletion, so we discard it.
            //
            // Firefox doesn't support selectionchange, so check selection status
            // after each key entry. The selection changes after keydown and before
            // keyup, but we check on keydown as well in the case of holding down a
            // key, when multiple keydown events are fired but only one keyup is.
            // This is also our approach for IE handling, for the reason above.
            case 'selectionchange':
                if (skipSelectionChangeEvent) break;
            // falls through
            case 'keydown':
            case 'keyup':
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
        }
    }
    function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var reactName = topLevelEventsToReactNames.get(domEventName);
        if (reactName === undefined) return;
        var SyntheticEventCtor = SyntheticEvent;
        var reactEventType = domEventName;
        switch(domEventName){
            case 'keypress':
                // Firefox creates a keypress event for function keys too. This removes
                // the unwanted keypress events. Enter is however both printable and
                // non-printable. One would expect Tab to be as well (but it isn't).
                if (getEventCharCode(nativeEvent) === 0) return;
            /* falls through */ case 'keydown':
            case 'keyup':
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
            case 'focusin':
                reactEventType = 'focus';
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
            case 'focusout':
                reactEventType = 'blur';
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
            case 'beforeblur':
            case 'afterblur':
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
            case 'click':
                // Firefox creates a click event on right mouse clicks. This removes the
                // unwanted click events.
                if (nativeEvent.button === 2) return;
            /* falls through */ case 'auxclick':
            case 'dblclick':
            case 'mousedown':
            case 'mousemove':
            case 'mouseup':
            /* falls through */ case 'mouseout':
            case 'mouseover':
            case 'contextmenu':
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
            case 'drag':
            case 'dragend':
            case 'dragenter':
            case 'dragexit':
            case 'dragleave':
            case 'dragover':
            case 'dragstart':
            case 'drop':
                SyntheticEventCtor = SyntheticDragEvent;
                break;
            case 'touchcancel':
            case 'touchend':
            case 'touchmove':
            case 'touchstart':
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
            case ANIMATION_END:
            case ANIMATION_ITERATION:
            case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
            case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
            case 'scroll':
                SyntheticEventCtor = SyntheticUIEvent;
                break;
            case 'wheel':
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
            case 'copy':
            case 'cut':
            case 'paste':
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
            case 'gotpointercapture':
            case 'lostpointercapture':
            case 'pointercancel':
            case 'pointerdown':
            case 'pointermove':
            case 'pointerout':
            case 'pointerover':
            case 'pointerup':
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
        }
        var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
        // Some events don't bubble in the browser.
        // In the past, React has always bubbled them, but this can be surprising.
        // We're going to try aligning closer to the browser behavior by not bubbling
        // them in React either. We'll start by not bubbling onScroll, and then expand.
        var accumulateTargetOnly = !inCapturePhase && // nonDelegatedEvents list in DOMPluginEventSystem.
        // Then we can remove this special list.
        // This is a breaking change that can wait until React 18.
        domEventName === 'scroll';
        var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
        if (_listeners.length > 0) {
            // Intentionally create event lazily.
            var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
                event: _event,
                listeners: _listeners
            });
        }
    }
    // TODO: remove top-level side effect.
    registerSimpleEvents();
    registerEvents$2();
    registerEvents$1();
    registerEvents$3();
    registerEvents();
    function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        // TODO: we should remove the concept of a "SimpleEventPlugin".
        // This is the basic functionality of the event system. All
        // the other plugins are essentially polyfills. So the plugin
        // should probably be inlined somewhere and have its logic
        // be core the to event system. This would potentially allow
        // us to ship builds of React without the polyfilled plugins below.
        extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
        var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0; // We don't process these events unless we are in the
        // event's native "bubble" phase, which means that we're
        // not in the capture phase. That's because we emulate
        // the capture phase here still. This is a trade-off,
        // because in an ideal world we would not emulate and use
        // the phases properly, like we do with the SimpleEvent
        // plugin. However, the plugins below either expect
        // emulation (EnterLeave) or use state localized to that
        // plugin (BeforeInput, Change, Select). The state in
        // these modules complicates things, as you'll essentially
        // get the case where the capture phase event might change
        // state, only for the following bubble event to come in
        // later and not trigger anything as the state now
        // invalidates the heuristics of the event plugin. We
        // could alter all these plugins to work in such ways, but
        // that might cause other unknown side-effects that we
        // can't forsee right now.
        if (shouldProcessPolyfillPlugins) {
            extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
    } // List of events that need to be individually attached to media elements.
    var mediaEventTypes = [
        'abort',
        'canplay',
        'canplaythrough',
        'durationchange',
        'emptied',
        'encrypted',
        'ended',
        'error',
        'loadeddata',
        'loadedmetadata',
        'loadstart',
        'pause',
        'play',
        'playing',
        'progress',
        'ratechange',
        'seeked',
        'seeking',
        'stalled',
        'suspend',
        'timeupdate',
        'volumechange',
        'waiting'
    ]; // We should not delegate these events to the container, but rather
    // set them on the actual target element itself. This is primarily
    // because these events do not consistently bubble in the DOM.
    var nonDelegatedEvents = new Set([
        'cancel',
        'close',
        'invalid',
        'load',
        'scroll',
        'toggle'
    ].concat(mediaEventTypes));
    function executeDispatch(event, listener, currentTarget) {
        var type = event.type || 'unknown-event';
        event.currentTarget = currentTarget;
        invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
        event.currentTarget = null;
    }
    function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
        var previousInstance;
        if (inCapturePhase) for(var i = dispatchListeners.length - 1; i >= 0; i--){
            var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
            if (instance !== previousInstance && event.isPropagationStopped()) return;
            executeDispatch(event, listener, currentTarget);
            previousInstance = instance;
        }
        else for(var _i = 0; _i < dispatchListeners.length; _i++){
            var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
            if (_instance !== previousInstance && event.isPropagationStopped()) return;
            executeDispatch(event, _listener, _currentTarget);
            previousInstance = _instance;
        }
    }
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
        for(var i = 0; i < dispatchQueue.length; i++){
            var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
            processDispatchQueueItemsInOrder(event, listeners, inCapturePhase); //  event system doesn't use pooling.
        } // This would be a good time to rethrow if any of the event handlers threw.
        rethrowCaughtError();
    }
    function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
        var nativeEventTarget = getEventTarget(nativeEvent);
        var dispatchQueue = [];
        extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
        processDispatchQueue(dispatchQueue, eventSystemFlags);
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
        var isCapturePhaseListener = false;
        var listenerSet = getEventListenerSet(targetElement);
        var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
        if (!listenerSet.has(listenerSetKey)) {
            addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
            listenerSet.add(listenerSetKey);
        }
    }
    var listeningMarker = '_reactListening' + Math.random().toString(36).slice(2);
    function listenToAllSupportedEvents(rootContainerElement) {
        if (rootContainerElement[listeningMarker]) // Performance optimization: don't iterate through events
        // for the same portal container or root node more than once.
        // TODO: once we remove the flag, we may be able to also
        // remove some of the bookkeeping maps used for laziness.
        return;
        rootContainerElement[listeningMarker] = true;
        allNativeEvents.forEach(function(domEventName) {
            if (!nonDelegatedEvents.has(domEventName)) listenToNativeEvent(domEventName, false, rootContainerElement, null);
            listenToNativeEvent(domEventName, true, rootContainerElement, null);
        });
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, rootContainerElement, targetElement) {
        var eventSystemFlags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var target = rootContainerElement; // selectionchange needs to be attached to the document
        // otherwise it won't capture incoming events that are only
        // triggered on the document directly.
        if (domEventName === 'selectionchange' && rootContainerElement.nodeType !== DOCUMENT_NODE) target = rootContainerElement.ownerDocument;
         // If the event can be delegated (or is capture phase), we can
        // register it to the root container. Otherwise, we should
        // register the event to the target element and mark it as
        // a non-delegated event.
        if (targetElement !== null && !isCapturePhaseListener && nonDelegatedEvents.has(domEventName)) {
            // For all non-delegated events, apart from scroll, we attach
            // their event listeners to the respective elements that their
            // events fire on. That means we can skip this step, as event
            // listener has already been added previously. However, we
            // special case the scroll event because the reality is that any
            // element can scroll.
            // TODO: ideally, we'd eventually apply the same logic to all
            // events from the nonDelegatedEvents list. Then we can remove
            // this special case and use the same logic for all events.
            if (domEventName !== 'scroll') return;
            eventSystemFlags |= IS_NON_DELEGATED;
            target = targetElement;
        }
        var listenerSet = getEventListenerSet(target);
        var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener); // If the listener entry is empty or we should upgrade, then
        // we need to trap an event listener onto the target.
        if (!listenerSet.has(listenerSetKey)) {
            if (isCapturePhaseListener) eventSystemFlags |= IS_CAPTURE_PHASE;
            addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
            listenerSet.add(listenerSetKey);
        }
    }
    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
        var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags); // If passive option is not supported, then the event will be
        // active and not passive.
        var isPassiveListener = undefined;
        if (passiveBrowserEventsSupported) // Browsers introduced an intervention, making these events
        // passive by default on document. React doesn't bind them
        // to document anymore, but changing this now would undo
        // the performance wins from the change. So we emulate
        // the existing behavior manually on the roots now.
        // https://github.com/facebook/react/issues/19651
        {
            if (domEventName === 'touchstart' || domEventName === 'touchmove' || domEventName === 'wheel') isPassiveListener = true;
        }
        var unsubscribeListener; // When legacyFBSupport is enabled, it's for when we
        if (isCapturePhaseListener) {
            if (isPassiveListener !== undefined) unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
            else unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
        } else if (isPassiveListener !== undefined) unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
        else unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
    }
    function isMatchingRootContainer(grandContainer, targetContainer) {
        return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
    }
    function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
        var ancestorInst = targetInst;
        if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
            var targetContainerNode = targetContainer; // If we are using the legacy FB support flag, we
            if (targetInst !== null) {
                // The below logic attempts to work out if we need to change
                // the target fiber to a different ancestor. We had similar logic
                // in the legacy event system, except the big difference between
                // systems is that the modern event system now has an event listener
                // attached to each React Root and React Portal Root. Together,
                // the DOM nodes representing these roots are the "rootContainer".
                // To figure out which ancestor instance we should use, we traverse
                // up the fiber tree from the target instance and attempt to find
                // root boundaries that match that of our current "rootContainer".
                // If we find that "rootContainer", we find the parent fiber
                // sub-tree for that root and make that our ancestor instance.
                var node = targetInst;
                mainLoop: while(true){
                    if (node === null) return;
                    var nodeTag = node.tag;
                    if (nodeTag === HostRoot || nodeTag === HostPortal) {
                        var container = node.stateNode.containerInfo;
                        if (isMatchingRootContainer(container, targetContainerNode)) break;
                        if (nodeTag === HostPortal) {
                            // The target is a portal, but it's not the rootContainer we're looking for.
                            // Normally portals handle their own events all the way down to the root.
                            // So we should be able to stop now. However, we don't know if this portal
                            // was part of *our* root.
                            var grandNode = node.return;
                            while(grandNode !== null){
                                var grandTag = grandNode.tag;
                                if (grandTag === HostRoot || grandTag === HostPortal) {
                                    var grandContainer = grandNode.stateNode.containerInfo;
                                    if (isMatchingRootContainer(grandContainer, targetContainerNode)) // This is the rootContainer we're looking for and we found it as
                                    // a parent of the Portal. That means we can ignore it because the
                                    // Portal will bubble through to us.
                                    return;
                                }
                                grandNode = grandNode.return;
                            }
                        } // Now we need to find it's corresponding host fiber in the other
                        // tree. To do this we can use getClosestInstanceFromNode, but we
                        // need to validate that the fiber is a host instance, otherwise
                        // we need to traverse up through the DOM till we find the correct
                        // node that is from the other tree.
                        while(container !== null){
                            var parentNode = getClosestInstanceFromNode(container);
                            if (parentNode === null) return;
                            var parentTag = parentNode.tag;
                            if (parentTag === HostComponent || parentTag === HostText) {
                                node = ancestorInst = parentNode;
                                continue mainLoop;
                            }
                            container = container.parentNode;
                        }
                    }
                    node = node.return;
                }
            }
        }
        batchedEventUpdates(function() {
            return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
        });
    }
    function createDispatchListener(instance, listener, currentTarget) {
        return {
            instance: instance,
            listener: listener,
            currentTarget: currentTarget
        };
    }
    function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly) {
        var captureName = reactName !== null ? reactName + 'Capture' : null;
        var reactEventName = inCapturePhase ? captureName : reactName;
        var listeners = [];
        var instance = targetFiber;
        var lastHostComponent = null; // Accumulate all instances and listeners via the target -> root path.
        while(instance !== null){
            var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag; // Handle listeners that are on HostComponents (i.e. <div>)
            if (tag === HostComponent && stateNode !== null) {
                lastHostComponent = stateNode; // createEventHandle listeners
                if (reactEventName !== null) {
                    var listener = getListener(instance, reactEventName);
                    if (listener != null) listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                }
            } // If we are only accumulating events for the target, then we don't
            // continue to propagate through the React fiber tree to find other
            // listeners.
            if (accumulateTargetOnly) break;
            instance = instance.return;
        }
        return listeners;
    } // We should only use this function for:
    // - BeforeInputEventPlugin
    // - ChangeEventPlugin
    // - SelectEventPlugin
    // This is because we only process these plugins
    // in the bubble phase, so we need to accumulate two
    // phase event listeners (via emulation).
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
        var captureName = reactName + 'Capture';
        var listeners = [];
        var instance = targetFiber; // Accumulate all instances and listeners via the target -> root path.
        while(instance !== null){
            var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag; // Handle listeners that are on HostComponents (i.e. <div>)
            if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                var captureListener = getListener(instance, captureName);
                if (captureListener != null) listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                var bubbleListener = getListener(instance, reactName);
                if (bubbleListener != null) listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
            }
            instance = instance.return;
        }
        return listeners;
    }
    function getParent(inst) {
        if (inst === null) return null;
        do inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.
        while (inst && inst.tag !== HostComponent)
        if (inst) return inst;
        return null;
    }
    /**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */ function getLowestCommonAncestor(instA, instB) {
        var nodeA = instA;
        var nodeB = instB;
        var depthA = 0;
        for(var tempA = nodeA; tempA; tempA = getParent(tempA))depthA++;
        var depthB = 0;
        for(var tempB = nodeB; tempB; tempB = getParent(tempB))depthB++;
         // If A is deeper, crawl up.
        while(depthA - depthB > 0){
            nodeA = getParent(nodeA);
            depthA--;
        } // If B is deeper, crawl up.
        while(depthB - depthA > 0){
            nodeB = getParent(nodeB);
            depthB--;
        } // Walk in lockstep until we find a match.
        var depth = depthA;
        while(depth--){
            if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) return nodeA;
            nodeA = getParent(nodeA);
            nodeB = getParent(nodeB);
        }
        return null;
    }
    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
        var registrationName = event._reactName;
        var listeners = [];
        var instance = target;
        while(instance !== null){
            if (instance === common) break;
            var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
            if (alternate !== null && alternate === common) break;
            if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                if (inCapturePhase) {
                    var captureListener = getListener(instance, registrationName);
                    if (captureListener != null) listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                } else if (!inCapturePhase) {
                    var bubbleListener = getListener(instance, registrationName);
                    if (bubbleListener != null) listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
            }
            instance = instance.return;
        }
        if (listeners.length !== 0) dispatchQueue.push({
            event: event,
            listeners: listeners
        });
    } // We should only use this function for:
    // - EnterLeaveEventPlugin
    // This is because we only process this plugin
    // in the bubble phase, so we need to accumulate two
    // phase event listeners.
    function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
        var common = from && to ? getLowestCommonAncestor(from, to) : null;
        if (from !== null) accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
        if (to !== null && enterEvent !== null) accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
    }
    function getListenerSetKey(domEventName, capture) {
        return domEventName + "__" + (capture ? 'capture' : 'bubble');
    }
    var didWarnInvalidHydration = false;
    var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
    var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
    var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
    var AUTOFOCUS = 'autoFocus';
    var CHILDREN = 'children';
    var STYLE = 'style';
    var HTML$1 = '__html';
    var HTML_NAMESPACE$1 = Namespaces.html;
    var warnedUnknownTags;
    var suppressHydrationWarning;
    var validatePropertiesInDevelopment;
    var warnForTextDifference;
    var warnForPropDifference;
    var warnForExtraAttributes;
    var warnForInvalidEventListener;
    var canDiffStyleForHydrationWarning;
    var normalizeMarkupForTextOrAttribute;
    var normalizeHTML;
    warnedUnknownTags = {
        // There are working polyfills for <dialog>. Let people use it.
        dialog: true,
        // Electron ships a custom <webview> tag to display external web content in
        // an isolated frame and process.
        // This tag is not present in non Electron environments such as JSDom which
        // is often used for testing purposes.
        // @see https://electronjs.org/docs/api/webview-tag
        webview: true
    };
    validatePropertiesInDevelopment = function(type, props) {
        validateProperties(type, props);
        validateProperties$1(type, props);
        validateProperties$2(type, props, {
            registrationNameDependencies: registrationNameDependencies1,
            possibleRegistrationNames: possibleRegistrationNames1
        });
    }; // IE 11 parses & normalizes the style attribute as opposed to other
    // browsers. It adds spaces and sorts the properties in some
    // non-alphabetical order. Handling that would require sorting CSS
    // properties in the client & server versions or applying
    // `expectedStyle` to a temporary DOM node to read its `style` attribute
    // normalized. Since it only affects IE, we're skipping style warnings
    // in that browser completely in favor of doing all that work.
    // See https://github.com/facebook/react/issues/11807
    canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode; // HTML parsing normalizes CR and CRLF to LF.
    // It also can turn \u0000 into \uFFFD inside attributes.
    // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
    // If we have a mismatch, it might be caused by that.
    // We will still patch up in this case but not fire the warning.
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
    var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
    normalizeMarkupForTextOrAttribute = function(markup) {
        var markupString = typeof markup === 'string' ? markup : '' + markup;
        return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
    };
    warnForTextDifference = function(serverText, clientText) {
        if (didWarnInvalidHydration) return;
        var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
        var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
        if (normalizedServerText === normalizedClientText) return;
        didWarnInvalidHydration = true;
        error1('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
    };
    warnForPropDifference = function(propName, serverValue, clientValue) {
        if (didWarnInvalidHydration) return;
        var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
        var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
        if (normalizedServerValue === normalizedClientValue) return;
        didWarnInvalidHydration = true;
        error1('Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
    };
    warnForExtraAttributes = function(attributeNames) {
        if (didWarnInvalidHydration) return;
        didWarnInvalidHydration = true;
        var names = [];
        attributeNames.forEach(function(name) {
            names.push(name);
        });
        error1('Extra attributes from the server: %s', names);
    };
    warnForInvalidEventListener = function(registrationName, listener) {
        if (listener === false) error1("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
        else error1('Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener);
    }; // Parse the HTML and read it back to normalize the HTML string so that it
    // can be used for comparison.
    normalizeHTML = function(parent, html) {
        // We could have created a separate document here to avoid
        // re-initializing custom elements if they exist. But this breaks
        // how <noscript> is being handled. So we use the same document.
        // See the discussion in https://github.com/facebook/react/pull/11157.
        var testElement = parent.namespaceURI === HTML_NAMESPACE$1 ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
        testElement.innerHTML = html;
        return testElement.innerHTML;
    };
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
    }
    function noop() {
    }
    function trapClickOnNonInteractiveElement(node) {
        // Mobile Safari does not fire properly bubble click events on
        // non-interactive elements, which means delegated click listeners do not
        // fire. The workaround for this bug involves attaching an empty click
        // listener on the target node.
        // https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
        // Just set it using the onclick property so that we don't have to manage any
        // bookkeeping for it. Not sure if we need to clear it when the listener is
        // removed.
        // TODO: Only do this for the relevant Safaris maybe?
        node.onclick = noop;
    }
    function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
        for(var propKey in nextProps){
            if (!nextProps.hasOwnProperty(propKey)) continue;
            var nextProp = nextProps[propKey];
            if (propKey === STYLE) {
                if (nextProp) // Freeze the next style object so that we can assume it won't be
                // mutated. We have already warned for this in the past.
                Object.freeze(nextProp);
                setValueForStyles(domElement, nextProp);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : undefined;
                if (nextHtml != null) setInnerHTML(domElement, nextHtml);
            } else if (propKey === CHILDREN) {
                if (typeof nextProp === 'string') {
                    // Avoid setting initial textContent when the text is empty. In IE11 setting
                    // textContent on a <textarea> will cause the placeholder to not
                    // show within the <textarea> until it has been focused and blurred again.
                    // https://github.com/facebook/react/issues/6731#issuecomment-254874553
                    var canSetTextContent = tag !== 'textarea' || nextProp !== '';
                    if (canSetTextContent) setTextContent(domElement, nextProp);
                } else if (typeof nextProp === 'number') setTextContent(domElement, '' + nextProp);
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
            else if (propKey === AUTOFOCUS) ;
            else if (registrationNameDependencies1.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                    if (typeof nextProp !== 'function') warnForInvalidEventListener(propKey, nextProp);
                    if (propKey === 'onScroll') listenToNonDelegatedEvent('scroll', domElement);
                }
            } else if (nextProp != null) setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
        }
    }
    function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
        // TODO: Handle wasCustomComponentTag
        for(var i = 0; i < updatePayload.length; i += 2){
            var propKey = updatePayload[i];
            var propValue = updatePayload[i + 1];
            if (propKey === STYLE) setValueForStyles(domElement, propValue);
            else if (propKey === DANGEROUSLY_SET_INNER_HTML) setInnerHTML(domElement, propValue);
            else if (propKey === CHILDREN) setTextContent(domElement, propValue);
            else setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
        }
    }
    function createElement(type, props, rootContainerElement, parentNamespace) {
        var isCustomComponentTag; // We create tags in the namespace of their parent container, except HTML
        // tags get no namespace.
        var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
        var domElement;
        var namespaceURI = parentNamespace;
        if (namespaceURI === HTML_NAMESPACE$1) namespaceURI = getIntrinsicNamespace(type);
        if (namespaceURI === HTML_NAMESPACE$1) {
            isCustomComponentTag = isCustomComponent(type, props); // Should this check be gated by parent namespace? Not sure we want to
            // allow <SVG> or <mATH>.
            if (!isCustomComponentTag && type !== type.toLowerCase()) error1("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
            if (type === 'script') {
                // Create the script via .innerHTML so its "parser-inserted" flag is
                // set to true and it does not execute
                var div = ownerDocument.createElement('div');
                div.innerHTML = "<script></script>"; // eslint-disable-line
                // This is guaranteed to yield a script element.
                var firstChild = div.firstChild;
                domElement = div.removeChild(firstChild);
            } else if (typeof props.is === 'string') // $FlowIssue `createElement` should be updated for Web Components
            domElement = ownerDocument.createElement(type, {
                is: props.is
            });
            else {
                // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
                // See discussion in https://github.com/facebook/react/pull/6896
                // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
                domElement = ownerDocument.createElement(type); // Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`
                // attributes on `select`s needs to be added before `option`s are inserted.
                // This prevents:
                // - a bug where the `select` does not scroll to the correct option because singular
                //  `select` elements automatically pick the first item #13222
                // - a bug where the `select` set the first item as selected despite the `size` attribute #14239
                // See https://github.com/facebook/react/issues/13222
                // and https://github.com/facebook/react/issues/14239
                if (type === 'select') {
                    var node = domElement;
                    if (props.multiple) node.multiple = true;
                    else if (props.size) // Setting a size greater than 1 causes a select to behave like `multiple=true`, where
                    // it is possible that no option is selected.
                    //
                    // This is only necessary when a select in "single selection mode".
                    node.size = props.size;
                }
            }
        } else domElement = ownerDocument.createElementNS(namespaceURI, type);
        if (namespaceURI === HTML_NAMESPACE$1) {
            if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
                warnedUnknownTags[type] = true;
                error1("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
            }
        }
        return domElement;
    }
    function createTextNode(text, rootContainerElement) {
        return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
    }
    function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
        var isCustomComponentTag = isCustomComponent(tag, rawProps);
        validatePropertiesInDevelopment(tag, rawProps);
        var props;
        switch(tag){
            case 'dialog':
                listenToNonDelegatedEvent('cancel', domElement);
                listenToNonDelegatedEvent('close', domElement);
                props = rawProps;
                break;
            case 'iframe':
            case 'object':
            case 'embed':
                // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the load event.
                listenToNonDelegatedEvent('load', domElement);
                props = rawProps;
                break;
            case 'video':
            case 'audio':
                // We listen to these events in case to ensure emulated bubble
                // listeners still fire for all the media events.
                for(var i = 0; i < mediaEventTypes.length; i++)listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                props = rawProps;
                break;
            case 'source':
                // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the error event.
                listenToNonDelegatedEvent('error', domElement);
                props = rawProps;
                break;
            case 'img':
            case 'image':
            case 'link':
                // We listen to these events in case to ensure emulated bubble
                // listeners still fire for error and load events.
                listenToNonDelegatedEvent('error', domElement);
                listenToNonDelegatedEvent('load', domElement);
                props = rawProps;
                break;
            case 'details':
                // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the toggle event.
                listenToNonDelegatedEvent('toggle', domElement);
                props = rawProps;
                break;
            case 'input':
                initWrapperState(domElement, rawProps);
                props = getHostProps(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the invalid event.
                listenToNonDelegatedEvent('invalid', domElement);
                break;
            case 'option':
                validateProps(domElement, rawProps);
                props = getHostProps$1(domElement, rawProps);
                break;
            case 'select':
                initWrapperState$1(domElement, rawProps);
                props = getHostProps$2(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the invalid event.
                listenToNonDelegatedEvent('invalid', domElement);
                break;
            case 'textarea':
                initWrapperState$2(domElement, rawProps);
                props = getHostProps$3(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the invalid event.
                listenToNonDelegatedEvent('invalid', domElement);
                break;
            default:
                props = rawProps;
        }
        assertValidProps(tag, props);
        setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
        switch(tag){
            case 'input':
                // TODO: Make sure we check if this is still unmounted or do any clean
                // up necessary since we never stop tracking anymore.
                track(domElement);
                postMountWrapper(domElement, rawProps, false);
                break;
            case 'textarea':
                // TODO: Make sure we check if this is still unmounted or do any clean
                // up necessary since we never stop tracking anymore.
                track(domElement);
                postMountWrapper$3(domElement);
                break;
            case 'option':
                postMountWrapper$1(domElement, rawProps);
                break;
            case 'select':
                postMountWrapper$2(domElement, rawProps);
                break;
            default:
                if (typeof props.onClick === 'function') // TODO: This cast may not be sound for SVG, MathML or custom elements.
                trapClickOnNonInteractiveElement(domElement);
                break;
        }
    } // Calculate the diff between the two objects.
    function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
        validatePropertiesInDevelopment(tag, nextRawProps);
        var updatePayload = null;
        var lastProps;
        var nextProps;
        switch(tag){
            case 'input':
                lastProps = getHostProps(domElement, lastRawProps);
                nextProps = getHostProps(domElement, nextRawProps);
                updatePayload = [];
                break;
            case 'option':
                lastProps = getHostProps$1(domElement, lastRawProps);
                nextProps = getHostProps$1(domElement, nextRawProps);
                updatePayload = [];
                break;
            case 'select':
                lastProps = getHostProps$2(domElement, lastRawProps);
                nextProps = getHostProps$2(domElement, nextRawProps);
                updatePayload = [];
                break;
            case 'textarea':
                lastProps = getHostProps$3(domElement, lastRawProps);
                nextProps = getHostProps$3(domElement, nextRawProps);
                updatePayload = [];
                break;
            default:
                lastProps = lastRawProps;
                nextProps = nextRawProps;
                if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') // TODO: This cast may not be sound for SVG, MathML or custom elements.
                trapClickOnNonInteractiveElement(domElement);
                break;
        }
        assertValidProps(tag, nextProps);
        var propKey;
        var styleName;
        var styleUpdates = null;
        for(propKey in lastProps){
            if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) continue;
            if (propKey === STYLE) {
                var lastStyle = lastProps[propKey];
                for(styleName in lastStyle)if (lastStyle.hasOwnProperty(styleName)) {
                    if (!styleUpdates) styleUpdates = {
                    };
                    styleUpdates[styleName] = '';
                }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ;
            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
            else if (propKey === AUTOFOCUS) ;
            else if (registrationNameDependencies1.hasOwnProperty(propKey)) // This is a special case. If any listener updates we need to ensure
            // that the "current" fiber pointer gets updated so we need a commit
            // to update this element.
            {
                if (!updatePayload) updatePayload = [];
            } else // For all other deleted properties we add it to the queue. We use
            // the allowed property list in the commit phase instead.
            (updatePayload = updatePayload || []).push(propKey, null);
        }
        for(propKey in nextProps){
            var nextProp = nextProps[propKey];
            var lastProp = lastProps != null ? lastProps[propKey] : undefined;
            if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) continue;
            if (propKey === STYLE) {
                if (nextProp) // Freeze the next style object so that we can assume it won't be
                // mutated. We have already warned for this in the past.
                Object.freeze(nextProp);
                if (lastProp) {
                    // Unset styles on `lastProp` but not on `nextProp`.
                    for(styleName in lastProp)if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                        if (!styleUpdates) styleUpdates = {
                        };
                        styleUpdates[styleName] = '';
                    }
                     // Update styles that changed since `lastProp`.
                    for(styleName in nextProp)if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                        if (!styleUpdates) styleUpdates = {
                        };
                        styleUpdates[styleName] = nextProp[styleName];
                    }
                } else {
                    // Relies on `updateStylesByID` not mutating `styleUpdates`.
                    if (!styleUpdates) {
                        if (!updatePayload) updatePayload = [];
                        updatePayload.push(propKey, styleUpdates);
                    }
                    styleUpdates = nextProp;
                }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : undefined;
                var lastHtml = lastProp ? lastProp[HTML$1] : undefined;
                if (nextHtml != null) {
                    if (lastHtml !== nextHtml) (updatePayload = updatePayload || []).push(propKey, nextHtml);
                }
            } else if (propKey === CHILDREN) {
                if (typeof nextProp === 'string' || typeof nextProp === 'number') (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
            else if (registrationNameDependencies1.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                    // We eagerly listen to this even though we haven't committed yet.
                    if (typeof nextProp !== 'function') warnForInvalidEventListener(propKey, nextProp);
                    if (propKey === 'onScroll') listenToNonDelegatedEvent('scroll', domElement);
                }
                if (!updatePayload && lastProp !== nextProp) // This is a special case. If any listener updates we need to ensure
                // that the "current" props pointer gets updated so we need a commit
                // to update this element.
                updatePayload = [];
            } else if (typeof nextProp === 'object' && nextProp !== null && nextProp.$$typeof === REACT_OPAQUE_ID_TYPE) // If we encounter useOpaqueReference's opaque object, this means we are hydrating.
            // In this case, call the opaque object's toString function which generates a new client
            // ID so client and server IDs match and throws to rerender.
            nextProp.toString();
            else // For any other property we always add it to the queue and then we
            // filter it out using the allowed property list during the commit.
            (updatePayload = updatePayload || []).push(propKey, nextProp);
        }
        if (styleUpdates) {
            validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
            (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
        }
        return updatePayload;
    } // Apply the diff.
    function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
        // Update checked *before* name.
        // In the middle of an update, it is possible to have multiple checked.
        // When a checked radio tries to change name, browser makes another radio's checked false.
        if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) updateChecked(domElement, nextRawProps);
        var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
        var isCustomComponentTag = isCustomComponent(tag, nextRawProps); // Apply the diff.
        updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag); // TODO: Ensure that an update gets scheduled if any of the special props
        // changed.
        switch(tag){
            case 'input':
                // Update the wrapper around inputs *after* updating props. This has to
                // happen after `updateDOMProperties`. Otherwise HTML5 input validations
                // raise warnings and prevent the new value from being assigned.
                updateWrapper(domElement, nextRawProps);
                break;
            case 'textarea':
                updateWrapper$1(domElement, nextRawProps);
                break;
            case 'select':
                // <select> value update needs to occur after <option> children
                // reconciliation
                postUpdateWrapper(domElement, nextRawProps);
                break;
        }
    }
    function getPossibleStandardName(propName) {
        var lowerCasedName = propName.toLowerCase();
        if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) return null;
        return possibleStandardNames[lowerCasedName] || null;
    }
    function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
        var isCustomComponentTag;
        var extraAttributeNames;
        suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING] === true;
        isCustomComponentTag = isCustomComponent(tag, rawProps);
        validatePropertiesInDevelopment(tag, rawProps);
        switch(tag){
            case 'dialog':
                listenToNonDelegatedEvent('cancel', domElement);
                listenToNonDelegatedEvent('close', domElement);
                break;
            case 'iframe':
            case 'object':
            case 'embed':
                // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the load event.
                listenToNonDelegatedEvent('load', domElement);
                break;
            case 'video':
            case 'audio':
                // We listen to these events in case to ensure emulated bubble
                // listeners still fire for all the media events.
                for(var i = 0; i < mediaEventTypes.length; i++)listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                break;
            case 'source':
                // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the error event.
                listenToNonDelegatedEvent('error', domElement);
                break;
            case 'img':
            case 'image':
            case 'link':
                // We listen to these events in case to ensure emulated bubble
                // listeners still fire for error and load events.
                listenToNonDelegatedEvent('error', domElement);
                listenToNonDelegatedEvent('load', domElement);
                break;
            case 'details':
                // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the toggle event.
                listenToNonDelegatedEvent('toggle', domElement);
                break;
            case 'input':
                initWrapperState(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the invalid event.
                listenToNonDelegatedEvent('invalid', domElement);
                break;
            case 'option':
                validateProps(domElement, rawProps);
                break;
            case 'select':
                initWrapperState$1(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the invalid event.
                listenToNonDelegatedEvent('invalid', domElement);
                break;
            case 'textarea':
                initWrapperState$2(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the invalid event.
                listenToNonDelegatedEvent('invalid', domElement);
                break;
        }
        assertValidProps(tag, rawProps);
        extraAttributeNames = new Set();
        var attributes = domElement.attributes;
        for(var _i = 0; _i < attributes.length; _i++){
            var name = attributes[_i].name.toLowerCase();
            switch(name){
                // Built-in SSR attribute is allowed
                case 'data-reactroot':
                    break;
                // Controlled attributes are not validated
                // TODO: Only ignore them on controlled tags.
                case 'value':
                    break;
                case 'checked':
                    break;
                case 'selected':
                    break;
                default:
                    // Intentionally use the original name.
                    // See discussion in https://github.com/facebook/react/pull/10676.
                    extraAttributeNames.add(attributes[_i].name);
            }
        }
        var updatePayload = null;
        for(var propKey in rawProps){
            if (!rawProps.hasOwnProperty(propKey)) continue;
            var nextProp = rawProps[propKey];
            if (propKey === CHILDREN) {
                // For text content children we compare against textContent. This
                // might match additional HTML that is hidden when we read it using
                // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
                // satisfies our requirement. Our requirement is not to produce perfect
                // HTML and attributes. Ideally we should preserve structure but it's
                // ok not to if the visible content is still enough to indicate what
                // even listeners these nodes might be wired up to.
                // TODO: Warn if there is more than a single textNode as a child.
                // TODO: Should we use domElement.firstChild.nodeValue to compare?
                if (typeof nextProp === 'string') {
                    if (domElement.textContent !== nextProp) {
                        if (!suppressHydrationWarning) warnForTextDifference(domElement.textContent, nextProp);
                        updatePayload = [
                            CHILDREN,
                            nextProp
                        ];
                    }
                } else if (typeof nextProp === 'number') {
                    if (domElement.textContent !== '' + nextProp) {
                        if (!suppressHydrationWarning) warnForTextDifference(domElement.textContent, nextProp);
                        updatePayload = [
                            CHILDREN,
                            '' + nextProp
                        ];
                    }
                }
            } else if (registrationNameDependencies1.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                    if (typeof nextProp !== 'function') warnForInvalidEventListener(propKey, nextProp);
                    if (propKey === 'onScroll') listenToNonDelegatedEvent('scroll', domElement);
                }
            } else if (typeof isCustomComponentTag === 'boolean') {
                // Validate that the properties correspond to their expected values.
                var serverValue = void 0;
                var propertyInfo = getPropertyInfo(propKey);
                if (suppressHydrationWarning) ;
                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // TODO: Only ignore them on controlled tags.
                propKey === 'value' || propKey === 'checked' || propKey === 'selected') ;
                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                    var serverHTML = domElement.innerHTML;
                    var nextHtml = nextProp ? nextProp[HTML$1] : undefined;
                    if (nextHtml != null) {
                        var expectedHTML = normalizeHTML(domElement, nextHtml);
                        if (expectedHTML !== serverHTML) warnForPropDifference(propKey, serverHTML, expectedHTML);
                    }
                } else if (propKey === STYLE) {
                    // $FlowFixMe - Should be inferred as not undefined.
                    extraAttributeNames.delete(propKey);
                    if (canDiffStyleForHydrationWarning) {
                        var expectedStyle = createDangerousStringForStyles(nextProp);
                        serverValue = domElement.getAttribute('style');
                        if (expectedStyle !== serverValue) warnForPropDifference(propKey, serverValue, expectedStyle);
                    }
                } else if (isCustomComponentTag) {
                    // $FlowFixMe - Should be inferred as not undefined.
                    extraAttributeNames.delete(propKey.toLowerCase());
                    serverValue = getValueForAttribute(domElement, propKey, nextProp);
                    if (nextProp !== serverValue) warnForPropDifference(propKey, serverValue, nextProp);
                } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                    var isMismatchDueToBadCasing = false;
                    if (propertyInfo !== null) {
                        // $FlowFixMe - Should be inferred as not undefined.
                        extraAttributeNames.delete(propertyInfo.attributeName);
                        serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                    } else {
                        var ownNamespace = parentNamespace;
                        if (ownNamespace === HTML_NAMESPACE$1) ownNamespace = getIntrinsicNamespace(tag);
                        if (ownNamespace === HTML_NAMESPACE$1) // $FlowFixMe - Should be inferred as not undefined.
                        extraAttributeNames.delete(propKey.toLowerCase());
                        else {
                            var standardName = getPossibleStandardName(propKey);
                            if (standardName !== null && standardName !== propKey) {
                                // If an SVG prop is supplied with bad casing, it will
                                // be successfully parsed from HTML, but will produce a mismatch
                                // (and would be incorrectly rendered on the client).
                                // However, we already warn about bad casing elsewhere.
                                // So we'll skip the misleading extra mismatch warning in this case.
                                isMismatchDueToBadCasing = true; // $FlowFixMe - Should be inferred as not undefined.
                                extraAttributeNames.delete(standardName);
                            } // $FlowFixMe - Should be inferred as not undefined.
                            extraAttributeNames.delete(propKey);
                        }
                        serverValue = getValueForAttribute(domElement, propKey, nextProp);
                    }
                    if (nextProp !== serverValue && !isMismatchDueToBadCasing) warnForPropDifference(propKey, serverValue, nextProp);
                }
            }
        }
        // $FlowFixMe - Should be inferred as not undefined.
        if (extraAttributeNames.size > 0 && !suppressHydrationWarning) // $FlowFixMe - Should be inferred as not undefined.
        warnForExtraAttributes(extraAttributeNames);
        switch(tag){
            case 'input':
                // TODO: Make sure we check if this is still unmounted or do any clean
                // up necessary since we never stop tracking anymore.
                track(domElement);
                postMountWrapper(domElement, rawProps, true);
                break;
            case 'textarea':
                // TODO: Make sure we check if this is still unmounted or do any clean
                // up necessary since we never stop tracking anymore.
                track(domElement);
                postMountWrapper$3(domElement);
                break;
            case 'select':
            case 'option':
                break;
            default:
                if (typeof rawProps.onClick === 'function') // TODO: This cast may not be sound for SVG, MathML or custom elements.
                trapClickOnNonInteractiveElement(domElement);
                break;
        }
        return updatePayload;
    }
    function diffHydratedText(textNode, text) {
        var isDifferent = textNode.nodeValue !== text;
        return isDifferent;
    }
    function warnForUnmatchedText(textNode, text) {
        warnForTextDifference(textNode.nodeValue, text);
    }
    function warnForDeletedHydratableElement(parentNode, child) {
        if (didWarnInvalidHydration) return;
        didWarnInvalidHydration = true;
        error1('Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
    }
    function warnForDeletedHydratableText(parentNode, child) {
        if (didWarnInvalidHydration) return;
        didWarnInvalidHydration = true;
        error1('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
    }
    function warnForInsertedHydratedElement(parentNode, tag, props) {
        if (didWarnInvalidHydration) return;
        didWarnInvalidHydration = true;
        error1('Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
    }
    function warnForInsertedHydratedText(parentNode, text) {
        if (text === '') // We expect to insert empty text nodes since they're not represented in
        // the HTML.
        // TODO: Remove this special case if we can just avoid inserting empty
        // text nodes.
        return;
        if (didWarnInvalidHydration) return;
        didWarnInvalidHydration = true;
        error1('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
    }
    function restoreControlledState$3(domElement, tag, props) {
        switch(tag){
            case 'input':
                restoreControlledState(domElement, props);
                return;
            case 'textarea':
                restoreControlledState$2(domElement, props);
                return;
            case 'select':
                restoreControlledState$1(domElement, props);
                return;
        }
    }
    var validateDOMNesting = function() {
    };
    var updatedAncestorInfo = function() {
    };
    // This validation code was written based on the HTML5 parsing spec:
    // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
    //
    // Note: this does not catch all invalid nesting, nor does it try to (as it's
    // not clear what practical benefit doing so provides); instead, we warn only
    // for cases where the parser will give a parse tree differing from what React
    // intended. For example, <b><div></div></b> is invalid but we don't warn
    // because it still parses correctly; we do warn for other cases like nested
    // <p> tags where the beginning of the second element implicitly closes the
    // first, causing a confusing mess.
    // https://html.spec.whatwg.org/multipage/syntax.html#special
    var specialTags = [
        'address',
        'applet',
        'area',
        'article',
        'aside',
        'base',
        'basefont',
        'bgsound',
        'blockquote',
        'body',
        'br',
        'button',
        'caption',
        'center',
        'col',
        'colgroup',
        'dd',
        'details',
        'dir',
        'div',
        'dl',
        'dt',
        'embed',
        'fieldset',
        'figcaption',
        'figure',
        'footer',
        'form',
        'frame',
        'frameset',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'head',
        'header',
        'hgroup',
        'hr',
        'html',
        'iframe',
        'img',
        'input',
        'isindex',
        'li',
        'link',
        'listing',
        'main',
        'marquee',
        'menu',
        'menuitem',
        'meta',
        'nav',
        'noembed',
        'noframes',
        'noscript',
        'object',
        'ol',
        'p',
        'param',
        'plaintext',
        'pre',
        'script',
        'section',
        'select',
        'source',
        'style',
        'summary',
        'table',
        'tbody',
        'td',
        'template',
        'textarea',
        'tfoot',
        'th',
        'thead',
        'title',
        'tr',
        'track',
        'ul',
        'wbr',
        'xmp'
    ]; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
    var inScopeTags = [
        'applet',
        'caption',
        'html',
        'table',
        'td',
        'th',
        'marquee',
        'object',
        'template',
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        'foreignObject',
        'desc',
        'title'
    ]; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
    var buttonScopeTags = inScopeTags.concat([
        'button'
    ]); // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
    var impliedEndTags = [
        'dd',
        'dt',
        'li',
        'option',
        'optgroup',
        'p',
        'rp',
        'rt'
    ];
    var emptyAncestorInfo = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
    };
    updatedAncestorInfo = function(oldInfo, tag) {
        var ancestorInfo = _assign({
        }, oldInfo || emptyAncestorInfo);
        var info = {
            tag: tag
        };
        if (inScopeTags.indexOf(tag) !== -1) {
            ancestorInfo.aTagInScope = null;
            ancestorInfo.buttonTagInScope = null;
            ancestorInfo.nobrTagInScope = null;
        }
        if (buttonScopeTags.indexOf(tag) !== -1) ancestorInfo.pTagInButtonScope = null;
         // See rules for 'li', 'dd', 'dt' start tags in
        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
        if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
            ancestorInfo.listItemTagAutoclosing = null;
            ancestorInfo.dlItemTagAutoclosing = null;
        }
        ancestorInfo.current = info;
        if (tag === 'form') ancestorInfo.formTag = info;
        if (tag === 'a') ancestorInfo.aTagInScope = info;
        if (tag === 'button') ancestorInfo.buttonTagInScope = info;
        if (tag === 'nobr') ancestorInfo.nobrTagInScope = info;
        if (tag === 'p') ancestorInfo.pTagInButtonScope = info;
        if (tag === 'li') ancestorInfo.listItemTagAutoclosing = info;
        if (tag === 'dd' || tag === 'dt') ancestorInfo.dlItemTagAutoclosing = info;
        return ancestorInfo;
    };
    /**
   * Returns whether
   */ var isTagValidWithParent = function(tag, parentTag) {
        // First, let's check if we're in an unusual parsing mode...
        switch(parentTag){
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
            case 'select':
                return tag === 'option' || tag === 'optgroup' || tag === '#text';
            case 'optgroup':
                return tag === 'option' || tag === '#text';
            // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
            // but
            case 'option':
                return tag === '#text';
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
            // No special behavior since these rules fall back to "in body" mode for
            // all except special table nodes which cause bad parsing behavior anyway.
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
            case 'tr':
                return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
            case 'tbody':
            case 'thead':
            case 'tfoot':
                return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
            case 'colgroup':
                return tag === 'col' || tag === 'template';
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
            case 'table':
                return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
            case 'head':
                return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
            // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
            case 'html':
                return tag === 'head' || tag === 'body' || tag === 'frameset';
            case 'frameset':
                return tag === 'frame';
            case '#document':
                return tag === 'html';
        } // Probably in the "in body" parsing mode, so we outlaw only tag combos
        // where the parsing rules cause implicit opens or closes to be added.
        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
        switch(tag){
            case 'h1':
            case 'h2':
            case 'h3':
            case 'h4':
            case 'h5':
            case 'h6':
                return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
            case 'rp':
            case 'rt':
                return impliedEndTags.indexOf(parentTag) === -1;
            case 'body':
            case 'caption':
            case 'col':
            case 'colgroup':
            case 'frameset':
            case 'frame':
            case 'head':
            case 'html':
            case 'tbody':
            case 'td':
            case 'tfoot':
            case 'th':
            case 'thead':
            case 'tr':
                // These tags are only valid with a few parents that have special child
                // parsing rules -- if we're down here, then none of those matched and
                // so we allow it only if we don't know what the parent is, as all other
                // cases are invalid.
                return parentTag == null;
        }
        return true;
    };
    /**
   * Returns whether
   */ var findInvalidAncestorForTag = function(tag, ancestorInfo) {
        switch(tag){
            case 'address':
            case 'article':
            case 'aside':
            case 'blockquote':
            case 'center':
            case 'details':
            case 'dialog':
            case 'dir':
            case 'div':
            case 'dl':
            case 'fieldset':
            case 'figcaption':
            case 'figure':
            case 'footer':
            case 'header':
            case 'hgroup':
            case 'main':
            case 'menu':
            case 'nav':
            case 'ol':
            case 'p':
            case 'section':
            case 'summary':
            case 'ul':
            case 'pre':
            case 'listing':
            case 'table':
            case 'hr':
            case 'xmp':
            case 'h1':
            case 'h2':
            case 'h3':
            case 'h4':
            case 'h5':
            case 'h6':
                return ancestorInfo.pTagInButtonScope;
            case 'form':
                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case 'li':
                return ancestorInfo.listItemTagAutoclosing;
            case 'dd':
            case 'dt':
                return ancestorInfo.dlItemTagAutoclosing;
            case 'button':
                return ancestorInfo.buttonTagInScope;
            case 'a':
                // Spec says something about storing a list of markers, but it sounds
                // equivalent to this check.
                return ancestorInfo.aTagInScope;
            case 'nobr':
                return ancestorInfo.nobrTagInScope;
        }
        return null;
    };
    var didWarn$1 = {
    };
    validateDOMNesting = function(childTag, childText, ancestorInfo) {
        ancestorInfo = ancestorInfo || emptyAncestorInfo;
        var parentInfo = ancestorInfo.current;
        var parentTag = parentInfo && parentInfo.tag;
        if (childText != null) {
            if (childTag != null) error1('validateDOMNesting: when childText is passed, childTag should be null');
            childTag = '#text';
        }
        var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
        var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
        var invalidParentOrAncestor = invalidParent || invalidAncestor;
        if (!invalidParentOrAncestor) return;
        var ancestorTag = invalidParentOrAncestor.tag;
        var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag;
        if (didWarn$1[warnKey]) return;
        didWarn$1[warnKey] = true;
        var tagDisplayName = childTag;
        var whitespaceInfo = '';
        if (childTag === '#text') {
            if (/\S/.test(childText)) tagDisplayName = 'Text nodes';
            else {
                tagDisplayName = 'Whitespace text nodes';
                whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
            }
        } else tagDisplayName = '<' + childTag + '>';
        if (invalidParent) {
            var info = '';
            if (ancestorTag === 'table' && childTag === 'tr') info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
            error1('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info);
        } else error1("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
    };
    var SUPPRESS_HYDRATION_WARNING$1;
    SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
    var SUSPENSE_START_DATA = '$';
    var SUSPENSE_END_DATA = '/$';
    var SUSPENSE_PENDING_START_DATA = '$?';
    var SUSPENSE_FALLBACK_START_DATA = '$!';
    var STYLE$1 = 'style';
    var eventsEnabled = null;
    var selectionInformation = null;
    function shouldAutoFocusHostComponent(type, props) {
        switch(type){
            case 'button':
            case 'input':
            case 'select':
            case 'textarea':
                return !!props.autoFocus;
        }
        return false;
    }
    function getRootHostContext(rootContainerInstance) {
        var type;
        var namespace;
        var nodeType = rootContainerInstance.nodeType;
        switch(nodeType){
            case DOCUMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
                type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
                var root = rootContainerInstance.documentElement;
                namespace = root ? root.namespaceURI : getChildNamespace(null, '');
                break;
            default:
                var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
                var ownNamespace = container.namespaceURI || null;
                type = container.tagName;
                namespace = getChildNamespace(ownNamespace, type);
                break;
        }
        var validatedTag = type.toLowerCase();
        var ancestorInfo = updatedAncestorInfo(null, validatedTag);
        return {
            namespace: namespace,
            ancestorInfo: ancestorInfo
        };
    }
    function getChildHostContext(parentHostContext, type, rootContainerInstance) {
        var parentHostContextDev = parentHostContext;
        var namespace = getChildNamespace(parentHostContextDev.namespace, type);
        var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
        return {
            namespace: namespace,
            ancestorInfo: ancestorInfo
        };
    }
    function getPublicInstance(instance) {
        return instance;
    }
    function prepareForCommit(containerInfo) {
        eventsEnabled = isEnabled();
        selectionInformation = getSelectionInformation();
        var activeInstance = null;
        setEnabled(false);
        return activeInstance;
    }
    function resetAfterCommit(containerInfo) {
        restoreSelection(selectionInformation);
        setEnabled(eventsEnabled);
        eventsEnabled = null;
        selectionInformation = null;
    }
    function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        var parentNamespace;
        // TODO: take namespace into account when validating.
        var hostContextDev = hostContext;
        validateDOMNesting(type, null, hostContextDev.ancestorInfo);
        if (typeof props.children === 'string' || typeof props.children === 'number') {
            var string = '' + props.children;
            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
            validateDOMNesting(null, string, ownAncestorInfo);
        }
        parentNamespace = hostContextDev.namespace;
        var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
        precacheFiberNode(internalInstanceHandle, domElement);
        updateFiberProps(domElement, props);
        return domElement;
    }
    function appendInitialChild(parentInstance, child) {
        parentInstance.appendChild(child);
    }
    function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
        setInitialProperties(domElement, type, props, rootContainerInstance);
        return shouldAutoFocusHostComponent(type, props);
    }
    function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
        var hostContextDev = hostContext;
        if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
            var string = '' + newProps.children;
            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
            validateDOMNesting(null, string, ownAncestorInfo);
        }
        return diffProperties(domElement, type, oldProps, newProps);
    }
    function shouldSetTextContent(type, props) {
        return type === 'textarea' || type === 'option' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
    }
    function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
        var hostContextDev = hostContext;
        validateDOMNesting(null, text, hostContextDev.ancestorInfo);
        var textNode = createTextNode(text, rootContainerInstance);
        precacheFiberNode(internalInstanceHandle, textNode);
        return textNode;
    }
    // if a component just imports ReactDOM (e.g. for findDOMNode).
    // Some environments might not have setTimeout or clearTimeout.
    var scheduleTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;
    var cancelTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;
    var noTimeout = -1; // -------------------
    function commitMount(domElement, type, newProps, internalInstanceHandle) {
        // Despite the naming that might imply otherwise, this method only
        // fires if there is an `Update` effect scheduled during mounting.
        // This happens if `finalizeInitialChildren` returns `true` (which it
        // does to implement the `autoFocus` attribute on the client). But
        // there are also other cases when this might happen (such as patching
        // up text content during hydration mismatch). So we'll check this again.
        if (shouldAutoFocusHostComponent(type, newProps)) domElement.focus();
    }
    function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
        // Update the props handle so that we know which props are the ones with
        // with current event handlers.
        updateFiberProps(domElement, newProps); // Apply the diff to the DOM node.
        updateProperties(domElement, updatePayload, type, oldProps, newProps);
    }
    function resetTextContent(domElement) {
        setTextContent(domElement, '');
    }
    function commitTextUpdate(textInstance, oldText, newText) {
        textInstance.nodeValue = newText;
    }
    function appendChild(parentInstance, child) {
        parentInstance.appendChild(child);
    }
    function appendChildToContainer(container, child) {
        var parentNode;
        if (container.nodeType === COMMENT_NODE) {
            parentNode = container.parentNode;
            parentNode.insertBefore(child, container);
        } else {
            parentNode = container;
            parentNode.appendChild(child);
        } // This container might be used for a portal.
        // If something inside a portal is clicked, that click should bubble
        // through the React tree. However, on Mobile Safari the click would
        // never bubble through the *DOM* tree unless an ancestor with onclick
        // event exists. So we wouldn't see it and dispatch it.
        // This is why we ensure that non React root containers have inline onclick
        // defined.
        // https://github.com/facebook/react/issues/11918
        var reactRootContainer = container._reactRootContainer;
        if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(parentNode);
    }
    function insertBefore(parentInstance, child, beforeChild) {
        parentInstance.insertBefore(child, beforeChild);
    }
    function insertInContainerBefore(container, child, beforeChild) {
        if (container.nodeType === COMMENT_NODE) container.parentNode.insertBefore(child, beforeChild);
        else container.insertBefore(child, beforeChild);
    }
    function removeChild(parentInstance, child) {
        parentInstance.removeChild(child);
    }
    function removeChildFromContainer(container, child) {
        if (container.nodeType === COMMENT_NODE) container.parentNode.removeChild(child);
        else container.removeChild(child);
    }
    function hideInstance(instance) {
        var style = instance.style;
        if (typeof style.setProperty === 'function') style.setProperty('display', 'none', 'important');
        else style.display = 'none';
    }
    function hideTextInstance(textInstance) {
        textInstance.nodeValue = '';
    }
    function unhideInstance(instance, props) {
        var styleProp = props[STYLE$1];
        var display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty('display') ? styleProp.display : null;
        instance.style.display = dangerousStyleValue('display', display);
    }
    function unhideTextInstance(textInstance, text) {
        textInstance.nodeValue = text;
    }
    function clearContainer(container) {
        if (container.nodeType === ELEMENT_NODE) container.textContent = '';
        else if (container.nodeType === DOCUMENT_NODE) {
            var body = container.body;
            if (body != null) body.textContent = '';
        }
    } // -------------------
    function canHydrateInstance(instance, type, props) {
        if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) return null;
         // This has now been refined to an element node.
        return instance;
    }
    function canHydrateTextInstance(instance, text) {
        if (text === '' || instance.nodeType !== TEXT_NODE) // Empty strings are not parsed by HTML so there won't be a correct match here.
        return null;
         // This has now been refined to a text node.
        return instance;
    }
    function isSuspenseInstancePending(instance) {
        return instance.data === SUSPENSE_PENDING_START_DATA;
    }
    function isSuspenseInstanceFallback(instance) {
        return instance.data === SUSPENSE_FALLBACK_START_DATA;
    }
    function getNextHydratable(node) {
        // Skip non-hydratable nodes.
        for(; node != null; node = node.nextSibling){
            var nodeType = node.nodeType;
            if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) break;
        }
        return node;
    }
    function getNextHydratableSibling(instance) {
        return getNextHydratable(instance.nextSibling);
    }
    function getFirstHydratableChild(parentInstance) {
        return getNextHydratable(parentInstance.firstChild);
    }
    function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        precacheFiberNode(internalInstanceHandle, instance); // TODO: Possibly defer this until the commit phase where all the events
        // get attached.
        updateFiberProps(instance, props);
        var parentNamespace;
        var hostContextDev = hostContext;
        parentNamespace = hostContextDev.namespace;
        return diffHydratedProperties(instance, type, props, parentNamespace);
    }
    function hydrateTextInstance(textInstance, text, internalInstanceHandle) {
        precacheFiberNode(internalInstanceHandle, textInstance);
        return diffHydratedText(textInstance, text);
    }
    function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
        var node = suspenseInstance.nextSibling; // Skip past all nodes within this suspense boundary.
        // There might be nested nodes so we need to keep track of how
        // deep we are and only break out when we're back on top.
        var depth = 0;
        while(node){
            if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_END_DATA) {
                    if (depth === 0) return getNextHydratableSibling(node);
                    else depth--;
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) depth++;
            }
            node = node.nextSibling;
        } // TODO: Warn, we didn't find the end comment boundary.
        return null;
    } // Returns the SuspenseInstance if this node is a direct child of a
    // SuspenseInstance. I.e. if its previous sibling is a Comment with
    // SUSPENSE_x_START_DATA. Otherwise, null.
    function getParentSuspenseInstance(targetInstance) {
        var node = targetInstance.previousSibling; // Skip past all nodes within this suspense boundary.
        // There might be nested nodes so we need to keep track of how
        // deep we are and only break out when we're back on top.
        var depth = 0;
        while(node){
            if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                    if (depth === 0) return node;
                    else depth--;
                } else if (data === SUSPENSE_END_DATA) depth++;
            }
            node = node.previousSibling;
        }
        return null;
    }
    function commitHydratedContainer(container) {
        // Retry if any event replaying was blocked on this.
        retryIfBlockedOn(container);
    }
    function commitHydratedSuspenseInstance(suspenseInstance) {
        // Retry if any event replaying was blocked on this.
        retryIfBlockedOn(suspenseInstance);
    }
    function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {
        warnForUnmatchedText(textInstance, text);
    }
    function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {
        if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) warnForUnmatchedText(textInstance, text);
    }
    function didNotHydrateContainerInstance(parentContainer, instance) {
        if (instance.nodeType === ELEMENT_NODE) warnForDeletedHydratableElement(parentContainer, instance);
        else if (instance.nodeType === COMMENT_NODE) ;
        else warnForDeletedHydratableText(parentContainer, instance);
    }
    function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {
        if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            if (instance.nodeType === ELEMENT_NODE) warnForDeletedHydratableElement(parentInstance, instance);
            else if (instance.nodeType === COMMENT_NODE) ;
            else warnForDeletedHydratableText(parentInstance, instance);
        }
    }
    function didNotFindHydratableContainerInstance(parentContainer, type, props) {
        warnForInsertedHydratedElement(parentContainer, type);
    }
    function didNotFindHydratableContainerTextInstance(parentContainer, text) {
        warnForInsertedHydratedText(parentContainer, text);
    }
    function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {
        if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) warnForInsertedHydratedElement(parentInstance, type);
    }
    function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {
        if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) warnForInsertedHydratedText(parentInstance, text);
    }
    function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {
        parentProps[SUPPRESS_HYDRATION_WARNING$1];
    }
    var clientId = 0;
    function makeClientIdInDEV(warnOnAccessInDEV) {
        var id = 'r:' + (clientId++).toString(36);
        return {
            toString: function() {
                warnOnAccessInDEV();
                return id;
            },
            valueOf: function() {
                warnOnAccessInDEV();
                return id;
            }
        };
    }
    function isOpaqueHydratingObject(value) {
        return value !== null && typeof value === 'object' && value.$$typeof === REACT_OPAQUE_ID_TYPE;
    }
    function makeOpaqueHydratingObject(attemptToReadValue) {
        return {
            $$typeof: REACT_OPAQUE_ID_TYPE,
            toString: attemptToReadValue,
            valueOf: attemptToReadValue
        };
    }
    function preparePortalMount(portalInstance) {
        listenToAllSupportedEvents(portalInstance);
    }
    var randomKey = Math.random().toString(36).slice(2);
    var internalInstanceKey = '__reactFiber$' + randomKey;
    var internalPropsKey = '__reactProps$' + randomKey;
    var internalContainerInstanceKey = '__reactContainer$' + randomKey;
    var internalEventHandlersKey = '__reactEvents$' + randomKey;
    function precacheFiberNode(hostInst, node) {
        node[internalInstanceKey] = hostInst;
    }
    function markContainerAsRoot(hostRoot, node) {
        node[internalContainerInstanceKey] = hostRoot;
    }
    function unmarkContainerAsRoot(node) {
        node[internalContainerInstanceKey] = null;
    }
    function isContainerMarkedAsRoot(node) {
        return !!node[internalContainerInstanceKey];
    } // Given a DOM node, return the closest HostComponent or HostText fiber ancestor.
    // If the target node is part of a hydrated or not yet rendered subtree, then
    // this may also return a SuspenseComponent or HostRoot to indicate that.
    // Conceptually the HostRoot fiber is a child of the Container node. So if you
    // pass the Container node as the targetNode, you will not actually get the
    // HostRoot back. To get to the HostRoot, you need to pass a child of it.
    // The same thing applies to Suspense boundaries.
    function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) // Don't return HostRoot or SuspenseComponent here.
        return targetInst;
         // If the direct event target isn't a React owned DOM node, we need to look
        // to see if one of its parents is a React owned DOM node.
        var parentNode = targetNode.parentNode;
        while(parentNode){
            // We'll check if this is a container root that could include
            // React nodes in the future. We need to check this first because
            // if we're a child of a dehydrated container, we need to first
            // find that inner container before moving on to finding the parent
            // instance. Note that we don't check this field on  the targetNode
            // itself because the fibers are conceptually between the container
            // node and the first child. It isn't surrounding the container node.
            // If it's not a container, we check if it's an instance.
            targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
            if (targetInst) {
                // Since this wasn't the direct target of the event, we might have
                // stepped past dehydrated DOM nodes to get here. However they could
                // also have been non-React nodes. We need to answer which one.
                // If we the instance doesn't have any children, then there can't be
                // a nested suspense boundary within it. So we can use this as a fast
                // bailout. Most of the time, when people add non-React children to
                // the tree, it is using a ref to a child-less DOM node.
                // Normally we'd only need to check one of the fibers because if it
                // has ever gone from having children to deleting them or vice versa
                // it would have deleted the dehydrated boundary nested inside already.
                // However, since the HostRoot starts out with an alternate it might
                // have one on the alternate so we need to check in case this was a
                // root.
                var alternate = targetInst.alternate;
                if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                    // Next we need to figure out if the node that skipped past is
                    // nested within a dehydrated boundary and if so, which one.
                    var suspenseInstance = getParentSuspenseInstance(targetNode);
                    while(suspenseInstance !== null){
                        // We found a suspense instance. That means that we haven't
                        // hydrated it yet. Even though we leave the comments in the
                        // DOM after hydrating, and there are boundaries in the DOM
                        // that could already be hydrated, we wouldn't have found them
                        // through this pass since if the target is hydrated it would
                        // have had an internalInstanceKey on it.
                        // Let's get the fiber associated with the SuspenseComponent
                        // as the deepest instance.
                        var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                        if (targetSuspenseInst) return targetSuspenseInst;
                         // If we don't find a Fiber on the comment, it might be because
                        // we haven't gotten to hydrate it yet. There might still be a
                        // parent boundary that hasn't above this one so we need to find
                        // the outer most that is known.
                        suspenseInstance = getParentSuspenseInstance(suspenseInstance); // If we don't find one, then that should mean that the parent
                    // host component also hasn't hydrated yet. We can return it
                    // below since it will bail out on the isMounted check later.
                    }
                }
                return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
        }
        return null;
    }
    /**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */ function getInstanceFromNode(node) {
        var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
        if (inst) {
            if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) return inst;
            else return null;
        }
        return null;
    }
    /**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */ function getNodeFromInstance(inst) {
        if (inst.tag === HostComponent || inst.tag === HostText) // In Fiber this, is just the state node right now. We assume it will be
        // a host component or host text.
        return inst.stateNode;
         // Without this first invariant, passing a non-DOM-component triggers the next
        throw Error("getNodeFromInstance: Invalid argument.");
    }
    function getFiberCurrentPropsFromNode(node) {
        return node[internalPropsKey] || null;
    }
    function updateFiberProps(node, props) {
        node[internalPropsKey] = props;
    }
    function getEventListenerSet(node) {
        var elementListenerSet = node[internalEventHandlersKey];
        if (elementListenerSet === undefined) elementListenerSet = node[internalEventHandlersKey] = new Set();
        return elementListenerSet;
    }
    var loggedTypeFailures = {
    };
    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement(element) {
        if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
    function checkPropTypes(typeSpecs, values, location, componentName, element) {
        // $FlowFixMe This is okay but Flow doesn't know it.
        var has = Function.call.bind(Object.prototype.hasOwnProperty);
        for(var typeSpecName in typeSpecs)if (has(typeSpecs, typeSpecName)) {
            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.
            try {
                // This is intentionally an invariant that gets caught. It's the same
                // behavior as without this statement except with a better message.
                if (typeof typeSpecs[typeSpecName] !== 'function') {
                    var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                    err.name = 'Invariant Violation';
                    throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
            } catch (ex) {
                error$1 = ex;
            }
            if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error1("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || 'React class', location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
            }
            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                // Only monitor this failure once because there tends to be a lot of the
                // same error.
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error1('Failed %s type: %s', location, error$1.message);
                setCurrentlyValidatingElement(null);
            }
        }
    }
    var valueStack = [];
    var fiberStack;
    fiberStack = [];
    var index1 = -1;
    function createCursor(defaultValue) {
        return {
            current: defaultValue
        };
    }
    function pop(cursor, fiber) {
        if (index1 < 0) {
            error1('Unexpected pop.');
            return;
        }
        if (fiber !== fiberStack[index1]) error1('Unexpected Fiber popped.');
        cursor.current = valueStack[index1];
        valueStack[index1] = null;
        fiberStack[index1] = null;
        index1--;
    }
    function push(cursor, value, fiber) {
        index1++;
        valueStack[index1] = cursor.current;
        fiberStack[index1] = fiber;
        cursor.current = value;
    }
    var warnedAboutMissingGetChildContext;
    warnedAboutMissingGetChildContext = {
    };
    var emptyContextObject = {
    };
    Object.freeze(emptyContextObject);
    var contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.
    var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.
    // We use this to get access to the parent context after we have already
    // pushed the next context provider, and now need to merge their contexts.
    var previousContext = emptyContextObject;
    function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
        if (didPushOwnContextIfProvider && isContextProvider(Component)) // If the fiber is a context provider itself, when we read its context
        // we may have already pushed its own child context on the stack. A context
        // provider should not "see" its own child context. Therefore we read the
        // previous (parent) context instead for a context provider.
        return previousContext;
        return contextStackCursor.current;
    }
    function cacheContext(workInProgress, unmaskedContext, maskedContext) {
        var instance = workInProgress.stateNode;
        instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
        instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
    }
    function getMaskedContext(workInProgress, unmaskedContext) {
        var type = workInProgress.type;
        var contextTypes = type.contextTypes;
        if (!contextTypes) return emptyContextObject;
         // Avoid recreating masked context unless unmasked context has changed.
        // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
        // This may trigger infinite loops if componentWillReceiveProps calls setState.
        var instance = workInProgress.stateNode;
        if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) return instance.__reactInternalMemoizedMaskedChildContext;
        var context = {
        };
        for(var key in contextTypes)context[key] = unmaskedContext[key];
        var name = getComponentName(type) || 'Unknown';
        checkPropTypes(contextTypes, context, 'context', name);
        // Context is created before the class component is instantiated so check for instance.
        if (instance) cacheContext(workInProgress, unmaskedContext, context);
        return context;
    }
    function hasContextChanged() {
        return didPerformWorkStackCursor.current;
    }
    function isContextProvider(type) {
        var childContextTypes = type.childContextTypes;
        return childContextTypes !== null && childContextTypes !== undefined;
    }
    function popContext(fiber) {
        pop(didPerformWorkStackCursor, fiber);
        pop(contextStackCursor, fiber);
    }
    function popTopLevelContextObject(fiber) {
        pop(didPerformWorkStackCursor, fiber);
        pop(contextStackCursor, fiber);
    }
    function pushTopLevelContextObject(fiber, context, didChange) {
        if (!(contextStackCursor.current === emptyContextObject)) throw Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        push(contextStackCursor, context, fiber);
        push(didPerformWorkStackCursor, didChange, fiber);
    }
    function processChildContext(fiber, type, parentContext) {
        var instance = fiber.stateNode;
        var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.
        // It has only been added in Fiber to match the (unintentional) behavior in Stack.
        if (typeof instance.getChildContext !== 'function') {
            var componentName = getComponentName(type) || 'Unknown';
            if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true;
                error1("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
            }
            return parentContext;
        }
        var childContext = instance.getChildContext();
        for(var contextKey in childContext){
            if (!(contextKey in childContextTypes)) throw Error((getComponentName(type) || 'Unknown') + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes.");
        }
        var name = getComponentName(type) || 'Unknown';
        checkPropTypes(childContextTypes, childContext, 'child context', name);
        return _assign({
        }, parentContext, childContext);
    }
    function pushContextProvider(workInProgress) {
        var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.
        // If the instance does not exist yet, we will push null at first,
        // and replace it on the stack later when invalidating the context.
        var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.
        // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
        previousContext = contextStackCursor.current;
        push(contextStackCursor, memoizedMergedChildContext, workInProgress);
        push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
        return true;
    }
    function invalidateContextProvider(workInProgress, type, didChange) {
        var instance = workInProgress.stateNode;
        if (!instance) throw Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (didChange) {
            // Merge parent and own context.
            // Skip this if we're not updating due to sCU.
            // This avoids unnecessarily recomputing memoized values.
            var mergedContext = processChildContext(workInProgress, type, previousContext);
            instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.
            // It is important to unwind the context in the reverse order.
            pop(didPerformWorkStackCursor, workInProgress);
            pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.
            push(contextStackCursor, mergedContext, workInProgress);
            push(didPerformWorkStackCursor, didChange, workInProgress);
        } else {
            pop(didPerformWorkStackCursor, workInProgress);
            push(didPerformWorkStackCursor, didChange, workInProgress);
        }
    }
    function findCurrentUnmaskedContext(fiber) {
        // Currently this is only used with renderSubtreeIntoContainer; not sure if it
        // makes sense elsewhere
        if (!(isFiberMounted(fiber) && fiber.tag === ClassComponent)) throw Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var node = fiber;
        do {
            switch(node.tag){
                case HostRoot:
                    return node.stateNode.context;
                case ClassComponent:
                    var Component = node.type;
                    if (isContextProvider(Component)) return node.stateNode.__reactInternalMemoizedMergedChildContext;
                    break;
            }
            node = node.return;
        }while (node !== null)
        throw Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    var LegacyRoot = 0;
    var BlockingRoot = 1;
    var ConcurrentRoot = 2;
    var rendererID = null;
    var injectedHook = null;
    var hasLoggedError = false;
    var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';
    function injectInternals(internals) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') // No DevTools
        return false;
        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (hook.isDisabled) // This isn't a real property on the hook, but it can be set to opt out
        // of DevTools integration and associated warnings and logs.
        // https://github.com/facebook/react/issues/3877
        return true;
        if (!hook.supportsFiber) {
            error1("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
            return true;
        }
        try {
            rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.
            injectedHook = hook;
        } catch (err) {
            error1('React instrumentation encountered an error: %s.', err);
        } // DevTools exists
        return true;
    }
    function onScheduleRoot(root, children) {
        if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') try {
            injectedHook.onScheduleFiberRoot(rendererID, root, children);
        } catch (err) {
            if (!hasLoggedError) {
                hasLoggedError = true;
                error1('React instrumentation encountered an error: %s', err);
            }
        }
    }
    function onCommitRoot(root, priorityLevel) {
        if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') try {
            var didError = (root.current.flags & DidCapture) === DidCapture;
            if (enableProfilerTimer) injectedHook.onCommitFiberRoot(rendererID, root, priorityLevel, didError);
            else injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);
        } catch (err) {
            if (!hasLoggedError) {
                hasLoggedError = true;
                error1('React instrumentation encountered an error: %s', err);
            }
        }
    }
    function onCommitUnmount(fiber) {
        if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') try {
            injectedHook.onCommitFiberUnmount(rendererID, fiber);
        } catch (err) {
            if (!hasLoggedError) {
                hasLoggedError = true;
                error1('React instrumentation encountered an error: %s', err);
            }
        }
    }
    var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority, Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback, Scheduler_cancelCallback = Scheduler.unstable_cancelCallback, Scheduler_shouldYield = Scheduler.unstable_shouldYield, Scheduler_requestPaint = Scheduler.unstable_requestPaint, Scheduler_now$1 = Scheduler.unstable_now, Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority, Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, Scheduler_NormalPriority = Scheduler.unstable_NormalPriority, Scheduler_LowPriority = Scheduler.unstable_LowPriority, Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;
    // Provide explicit error message when production+profiling bundle of e.g.
    // react-dom is used with production (non-profiling) bundle of
    // scheduler/tracing
    if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");
    var fakeCallbackNode = {
    }; // Except for NoPriority, these correspond to Scheduler priorities. We use
    // ascending numbers so we can compare them like numbers. They start at 90 to
    // avoid clashing with Scheduler's priorities.
    var ImmediatePriority$1 = 99;
    var UserBlockingPriority$2 = 98;
    var NormalPriority$1 = 97;
    var LowPriority$1 = 96;
    var IdlePriority$1 = 95; // NoPriority is the absence of priority. Also React-only.
    var NoPriority$1 = 90;
    var shouldYield = Scheduler_shouldYield;
    var requestPaint = Scheduler_requestPaint !== undefined ? Scheduler_requestPaint : function() {
    };
    var syncQueue = null;
    var immediateQueueCallbackNode = null;
    var isFlushingSyncQueue = false;
    var initialTimeMs$1 = Scheduler_now$1(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.
    // This will be the case for modern browsers that support `performance.now`. In
    // older browsers, Scheduler falls back to `Date.now`, which returns a Unix
    // timestamp. In that case, subtract the module initialization time to simulate
    // the behavior of performance.now and keep our times small enough to fit
    // within 32 bits.
    // TODO: Consider lifting this into Scheduler.
    var now = initialTimeMs$1 < 10000 ? Scheduler_now$1 : function() {
        return Scheduler_now$1() - initialTimeMs$1;
    };
    function getCurrentPriorityLevel() {
        switch(Scheduler_getCurrentPriorityLevel()){
            case Scheduler_ImmediatePriority:
                return ImmediatePriority$1;
            case Scheduler_UserBlockingPriority:
                return UserBlockingPriority$2;
            case Scheduler_NormalPriority:
                return NormalPriority$1;
            case Scheduler_LowPriority:
                return LowPriority$1;
            case Scheduler_IdlePriority:
                return IdlePriority$1;
            default:
                throw Error("Unknown priority level.");
        }
    }
    function reactPriorityToSchedulerPriority(reactPriorityLevel) {
        switch(reactPriorityLevel){
            case ImmediatePriority$1:
                return Scheduler_ImmediatePriority;
            case UserBlockingPriority$2:
                return Scheduler_UserBlockingPriority;
            case NormalPriority$1:
                return Scheduler_NormalPriority;
            case LowPriority$1:
                return Scheduler_LowPriority;
            case IdlePriority$1:
                return Scheduler_IdlePriority;
            default:
                throw Error("Unknown priority level.");
        }
    }
    function runWithPriority$1(reactPriorityLevel, fn) {
        var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
        return Scheduler_runWithPriority(priorityLevel, fn);
    }
    function scheduleCallback(reactPriorityLevel, callback, options) {
        var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
        return Scheduler_scheduleCallback(priorityLevel, callback, options);
    }
    function scheduleSyncCallback(callback) {
        // Push this callback into an internal queue. We'll flush these either in
        // the next tick, or earlier if something calls `flushSyncCallbackQueue`.
        if (syncQueue === null) {
            syncQueue = [
                callback
            ]; // Flush the queue in the next tick, at the earliest.
            immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);
        } else // Push onto existing queue. Don't need to schedule a callback because
        // we already scheduled one when we created the queue.
        syncQueue.push(callback);
        return fakeCallbackNode;
    }
    function cancelCallback(callbackNode) {
        if (callbackNode !== fakeCallbackNode) Scheduler_cancelCallback(callbackNode);
    }
    function flushSyncCallbackQueue() {
        if (immediateQueueCallbackNode !== null) {
            var node = immediateQueueCallbackNode;
            immediateQueueCallbackNode = null;
            Scheduler_cancelCallback(node);
        }
        flushSyncCallbackQueueImpl();
    }
    function flushSyncCallbackQueueImpl() {
        if (!isFlushingSyncQueue && syncQueue !== null) {
            // Prevent re-entrancy.
            isFlushingSyncQueue = true;
            var i = 0;
            try {
                var _isSync2 = true;
                var _queue = syncQueue;
                runWithPriority$1(ImmediatePriority$1, function() {
                    for(; i < _queue.length; i++){
                        var callback = _queue[i];
                        do callback = callback(_isSync2);
                        while (callback !== null)
                    }
                });
                syncQueue = null;
            } catch (error) {
                // If something throws, leave the remaining callbacks on the queue.
                if (syncQueue !== null) syncQueue = syncQueue.slice(i + 1);
                 // Resume flushing in the next tick
                Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue);
                throw error;
            } finally{
                isFlushingSyncQueue = false;
            }
        }
    }
    // TODO: this is special because it gets imported during build.
    var ReactVersion = '17.0.2';
    var NoMode = 0;
    var StrictMode = 1; // TODO: Remove BlockingMode and ConcurrentMode by reading from the root
    // tag instead
    var BlockingMode = 2;
    var ConcurrentMode = 4;
    var ProfileMode = 8;
    var DebugTracingMode = 16;
    var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
    var NoTransition = 0;
    function requestCurrentTransition() {
        return ReactCurrentBatchConfig.transition;
    }
    var ReactStrictModeWarnings = {
        recordUnsafeLifecycleWarnings: function(fiber, instance) {
        },
        flushPendingUnsafeLifecycleWarnings: function() {
        },
        recordLegacyContextWarning: function(fiber, instance) {
        },
        flushLegacyContextWarning: function() {
        },
        discardPendingWarnings: function() {
        }
    };
    var findStrictRoot = function(fiber) {
        var maybeStrictRoot = null;
        var node = fiber;
        while(node !== null){
            if (node.mode & StrictMode) maybeStrictRoot = node;
            node = node.return;
        }
        return maybeStrictRoot;
    };
    var setToSortedString = function(set) {
        var array = [];
        set.forEach(function(value) {
            array.push(value);
        });
        return array.sort().join(', ');
    };
    var pendingComponentWillMountWarnings = [];
    var pendingUNSAFE_ComponentWillMountWarnings = [];
    var pendingComponentWillReceivePropsWarnings = [];
    var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
    var pendingComponentWillUpdateWarnings = [];
    var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.
    var didWarnAboutUnsafeLifecycles = new Set();
    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
        // Dedup strategy: Warn once per component.
        if (didWarnAboutUnsafeLifecycles.has(fiber.type)) return;
        if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) pendingComponentWillMountWarnings.push(fiber);
        if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillMount === 'function') pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
        if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) pendingComponentWillReceivePropsWarnings.push(fiber);
        if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
        if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) pendingComponentWillUpdateWarnings.push(fiber);
        if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillUpdate === 'function') pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
    };
    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
        // We do an initial pass to gather component names
        var componentWillMountUniqueNames = new Set();
        if (pendingComponentWillMountWarnings.length > 0) {
            pendingComponentWillMountWarnings.forEach(function(fiber) {
                componentWillMountUniqueNames.add(getComponentName(fiber.type) || 'Component');
                didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillMountWarnings = [];
        }
        var UNSAFE_componentWillMountUniqueNames = new Set();
        if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
            pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type) || 'Component');
                didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillMountWarnings = [];
        }
        var componentWillReceivePropsUniqueNames = new Set();
        if (pendingComponentWillReceivePropsWarnings.length > 0) {
            pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || 'Component');
                didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillReceivePropsWarnings = [];
        }
        var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
        if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
            pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || 'Component');
                didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
        }
        var componentWillUpdateUniqueNames = new Set();
        if (pendingComponentWillUpdateWarnings.length > 0) {
            pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || 'Component');
                didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillUpdateWarnings = [];
        }
        var UNSAFE_componentWillUpdateUniqueNames = new Set();
        if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
            pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || 'Component');
                didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillUpdateWarnings = [];
        } // Finally, we flush all the warnings
        // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'
        if (UNSAFE_componentWillMountUniqueNames.size > 0) {
            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
            error1("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
        }
        if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
            var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
            error1("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
        }
        if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
            var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
            error1("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
        }
        if (componentWillMountUniqueNames.size > 0) {
            var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
            warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
        }
        if (componentWillReceivePropsUniqueNames.size > 0) {
            var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
            warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
        }
        if (componentWillUpdateUniqueNames.size > 0) {
            var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
            warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
        }
    };
    var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.
    var didWarnAboutLegacyContext = new Set();
    ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
        var strictRoot = findStrictRoot(fiber);
        if (strictRoot === null) {
            error1("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
            return;
        } // Dedup strategy: Warn once per component.
        if (didWarnAboutLegacyContext.has(fiber.type)) return;
        var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
        if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {
            if (warningsForRoot === undefined) {
                warningsForRoot = [];
                pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
            }
            warningsForRoot.push(fiber);
        }
    };
    ReactStrictModeWarnings.flushLegacyContextWarning = function() {
        pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
            if (fiberArray.length === 0) return;
            var firstFiber = fiberArray[0];
            var uniqueNames = new Set();
            fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentName(fiber.type) || 'Component');
                didWarnAboutLegacyContext.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            try {
                setCurrentFiber(firstFiber);
                error1("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
            } finally{
                resetCurrentFiber();
            }
        });
    };
    ReactStrictModeWarnings.discardPendingWarnings = function() {
        pendingComponentWillMountWarnings = [];
        pendingUNSAFE_ComponentWillMountWarnings = [];
        pendingComponentWillReceivePropsWarnings = [];
        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
        pendingComponentWillUpdateWarnings = [];
        pendingUNSAFE_ComponentWillUpdateWarnings = [];
        pendingLegacyContextWarning = new Map();
    };
    function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
            // Resolve default props. Taken from ReactElement
            var props = _assign({
            }, baseProps);
            var defaultProps = Component.defaultProps;
            for(var propName in defaultProps)if (props[propName] === undefined) props[propName] = defaultProps[propName];
            return props;
        }
        return baseProps;
    }
    // Max 31 bit integer. The max integer size in V8 for 32-bit systems.
    // Math.pow(2, 30) - 1
    // 0b111111111111111111111111111111
    var MAX_SIGNED_31_BIT_INT = 1073741823;
    var valueCursor = createCursor(null);
    var rendererSigil;
    // Use this to detect multiple renderers using the same context
    rendererSigil = {
    };
    var currentlyRenderingFiber = null;
    var lastContextDependency = null;
    var lastContextWithAllBitsObserved = null;
    var isDisallowedContextReadInDEV = false;
    function resetContextDependencies() {
        // This is called right before React yields execution, to ensure `readContext`
        // cannot be called outside the render phase.
        currentlyRenderingFiber = null;
        lastContextDependency = null;
        lastContextWithAllBitsObserved = null;
        isDisallowedContextReadInDEV = false;
    }
    function enterDisallowedContextReadInDEV() {
        isDisallowedContextReadInDEV = true;
    }
    function exitDisallowedContextReadInDEV() {
        isDisallowedContextReadInDEV = false;
    }
    function pushProvider(providerFiber, nextValue) {
        var context = providerFiber.type._context;
        push(valueCursor, context._currentValue, providerFiber);
        context._currentValue = nextValue;
        if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) error1("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
        context._currentRenderer = rendererSigil;
    }
    function popProvider(providerFiber) {
        var currentValue = valueCursor.current;
        pop(valueCursor, providerFiber);
        var context = providerFiber.type._context;
        context._currentValue = currentValue;
    }
    function calculateChangedBits(context, newValue, oldValue) {
        if (objectIs(oldValue, newValue)) // No change
        return 0;
        else {
            var changedBits = typeof context._calculateChangedBits === 'function' ? context._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
            if ((changedBits & MAX_SIGNED_31_BIT_INT) !== changedBits) error1("calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: %s", changedBits);
            return changedBits | 0;
        }
    }
    function scheduleWorkOnParentPath(parent, renderLanes) {
        // Update the child lanes of all the ancestors, including the alternates.
        var node = parent;
        while(node !== null){
            var alternate = node.alternate;
            if (!isSubsetOfLanes(node.childLanes, renderLanes)) {
                node.childLanes = mergeLanes(node.childLanes, renderLanes);
                if (alternate !== null) alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
            } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
            else break;
            node = node.return;
        }
    }
    function propagateContextChange(workInProgress, context, changedBits, renderLanes) {
        var fiber = workInProgress.child;
        if (fiber !== null) // Set the return pointer of the child to the work-in-progress fiber.
        fiber.return = workInProgress;
        while(fiber !== null){
            var nextFiber = void 0; // Visit this fiber.
            var list = fiber.dependencies;
            if (list !== null) {
                nextFiber = fiber.child;
                var dependency = list.firstContext;
                while(dependency !== null){
                    // Check if the context matches.
                    if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
                        // Match! Schedule an update on this fiber.
                        if (fiber.tag === ClassComponent) {
                            // Schedule a force update on the work-in-progress.
                            var update = createUpdate(NoTimestamp, pickArbitraryLane(renderLanes));
                            update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the
                            // update to the current fiber, too, which means it will persist even if
                            // this render is thrown away. Since it's a race condition, not sure it's
                            // worth fixing.
                            enqueueUpdate(fiber, update);
                        }
                        fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
                        var alternate = fiber.alternate;
                        if (alternate !== null) alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
                        scheduleWorkOnParentPath(fiber.return, renderLanes); // Mark the updated lanes on the list, too.
                        list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the
                        break;
                    }
                    dependency = dependency.next;
                }
            } else if (fiber.tag === ContextProvider) // Don't scan deeper if this is a matching provider
            nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
            else // Traverse down.
            nextFiber = fiber.child;
            if (nextFiber !== null) // Set the return pointer of the child to the work-in-progress fiber.
            nextFiber.return = fiber;
            else {
                // No child. Traverse to next sibling.
                nextFiber = fiber;
                while(nextFiber !== null){
                    if (nextFiber === workInProgress) {
                        // We're back to the root of this subtree. Exit.
                        nextFiber = null;
                        break;
                    }
                    var sibling = nextFiber.sibling;
                    if (sibling !== null) {
                        // Set the return pointer of the sibling to the work-in-progress fiber.
                        sibling.return = nextFiber.return;
                        nextFiber = sibling;
                        break;
                    } // No more siblings. Traverse up.
                    nextFiber = nextFiber.return;
                }
            }
            fiber = nextFiber;
        }
    }
    function prepareToReadContext(workInProgress, renderLanes) {
        currentlyRenderingFiber = workInProgress;
        lastContextDependency = null;
        lastContextWithAllBitsObserved = null;
        var dependencies = workInProgress.dependencies;
        if (dependencies !== null) {
            var firstContext = dependencies.firstContext;
            if (firstContext !== null) {
                if (includesSomeLane(dependencies.lanes, renderLanes)) // Context list has a pending update. Mark that this fiber performed work.
                markWorkInProgressReceivedUpdate();
                 // Reset the work-in-progress list
                dependencies.firstContext = null;
            }
        }
    }
    function readContext(context, observedBits) {
        // This warning would fire if you read context inside a Hook like useMemo.
        // Unlike the class check below, it's not enforced in production for perf.
        if (isDisallowedContextReadInDEV) error1("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        if (lastContextWithAllBitsObserved === context) ;
        else if (observedBits === false || observedBits === 0) ;
        else {
            var resolvedObservedBits; // Avoid deopting on observable arguments or heterogeneous types.
            if (typeof observedBits !== 'number' || observedBits === MAX_SIGNED_31_BIT_INT) {
                // Observe all updates.
                lastContextWithAllBitsObserved = context;
                resolvedObservedBits = MAX_SIGNED_31_BIT_INT;
            } else resolvedObservedBits = observedBits;
            var contextItem = {
                context: context,
                observedBits: resolvedObservedBits,
                next: null
            };
            if (lastContextDependency === null) {
                if (!(currentlyRenderingFiber !== null)) throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                 // This is the first dependency for this component. Create a new list.
                lastContextDependency = contextItem;
                currentlyRenderingFiber.dependencies = {
                    lanes: NoLanes,
                    firstContext: contextItem,
                    responders: null
                };
            } else // Append a new context item.
            lastContextDependency = lastContextDependency.next = contextItem;
        }
        return context._currentValue;
    }
    var UpdateState = 0;
    var ReplaceState = 1;
    var ForceUpdate = 2;
    var CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.
    // It should only be read right after calling `processUpdateQueue`, via
    // `checkHasForceUpdateAfterProcessing`.
    var hasForceUpdate = false;
    var didWarnUpdateInsideUpdate;
    var currentlyProcessingQueue;
    didWarnUpdateInsideUpdate = false;
    currentlyProcessingQueue = null;
    function initializeUpdateQueue(fiber) {
        var queue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null
            },
            effects: null
        };
        fiber.updateQueue = queue;
    }
    function cloneUpdateQueue(current, workInProgress) {
        // Clone the update queue from current. Unless it's already a clone.
        var queue = workInProgress.updateQueue;
        var currentQueue = current.updateQueue;
        if (queue === currentQueue) {
            var clone = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: currentQueue.firstBaseUpdate,
                lastBaseUpdate: currentQueue.lastBaseUpdate,
                shared: currentQueue.shared,
                effects: currentQueue.effects
            };
            workInProgress.updateQueue = clone;
        }
    }
    function createUpdate(eventTime, lane) {
        var update = {
            eventTime: eventTime,
            lane: lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
        };
        return update;
    }
    function enqueueUpdate(fiber, update) {
        var updateQueue = fiber.updateQueue;
        if (updateQueue === null) // Only occurs if the fiber has been unmounted.
        return;
        var sharedQueue = updateQueue.shared;
        var pending = sharedQueue.pending;
        if (pending === null) // This is the first update. Create a circular list.
        update.next = update;
        else {
            update.next = pending.next;
            pending.next = update;
        }
        sharedQueue.pending = update;
        if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
            error1("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
            didWarnUpdateInsideUpdate = true;
        }
    }
    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
        // Captured updates are updates that are thrown by a child during the render
        // phase. They should be discarded if the render is aborted. Therefore,
        // we should only put them on the work-in-progress queue, not the current one.
        var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.
        var current = workInProgress.alternate;
        if (current !== null) {
            var currentQueue = current.updateQueue;
            if (queue === currentQueue) {
                // The work-in-progress queue is the same as current. This happens when
                // we bail out on a parent fiber that then captures an error thrown by
                // a child. Since we want to append the update only to the work-in
                // -progress queue, we need to clone the updates. We usually clone during
                // processUpdateQueue, but that didn't happen in this case because we
                // skipped over the parent when we bailed out.
                var newFirst = null;
                var newLast = null;
                var firstBaseUpdate = queue.firstBaseUpdate;
                if (firstBaseUpdate !== null) {
                    // Loop through the updates and clone them.
                    var update = firstBaseUpdate;
                    do {
                        var clone = {
                            eventTime: update.eventTime,
                            lane: update.lane,
                            tag: update.tag,
                            payload: update.payload,
                            callback: update.callback,
                            next: null
                        };
                        if (newLast === null) newFirst = newLast = clone;
                        else {
                            newLast.next = clone;
                            newLast = clone;
                        }
                        update = update.next;
                    }while (update !== null) // Append the captured update the end of the cloned list.
                    if (newLast === null) newFirst = newLast = capturedUpdate;
                    else {
                        newLast.next = capturedUpdate;
                        newLast = capturedUpdate;
                    }
                } else // There are no base updates.
                newFirst = newLast = capturedUpdate;
                queue = {
                    baseState: currentQueue.baseState,
                    firstBaseUpdate: newFirst,
                    lastBaseUpdate: newLast,
                    shared: currentQueue.shared,
                    effects: currentQueue.effects
                };
                workInProgress.updateQueue = queue;
                return;
            }
        } // Append the update to the end of the list.
        var lastBaseUpdate = queue.lastBaseUpdate;
        if (lastBaseUpdate === null) queue.firstBaseUpdate = capturedUpdate;
        else lastBaseUpdate.next = capturedUpdate;
        queue.lastBaseUpdate = capturedUpdate;
    }
    function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
        switch(update.tag){
            case ReplaceState:
                var payload = update.payload;
                if (typeof payload === 'function') {
                    enterDisallowedContextReadInDEV();
                    var nextState = payload.call(instance, prevState, nextProps);
                    if (workInProgress.mode & StrictMode) {
                        disableLogs();
                        try {
                            payload.call(instance, prevState, nextProps);
                        } finally{
                            reenableLogs();
                        }
                    }
                    exitDisallowedContextReadInDEV();
                    return nextState;
                } // State object
                return payload;
            case CaptureUpdate:
                workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;
            // Intentional fallthrough
            case UpdateState:
                var _payload = update.payload;
                var partialState;
                if (typeof _payload === 'function') {
                    enterDisallowedContextReadInDEV();
                    partialState = _payload.call(instance, prevState, nextProps);
                    if (workInProgress.mode & StrictMode) {
                        disableLogs();
                        try {
                            _payload.call(instance, prevState, nextProps);
                        } finally{
                            reenableLogs();
                        }
                    }
                    exitDisallowedContextReadInDEV();
                } else // Partial state object
                partialState = _payload;
                if (partialState === null || partialState === undefined) // Null and undefined are treated as no-ops.
                return prevState;
                 // Merge the partial state and the previous state.
                return _assign({
                }, prevState, partialState);
            case ForceUpdate:
                hasForceUpdate = true;
                return prevState;
        }
        return prevState;
    }
    function processUpdateQueue(workInProgress, props, instance, renderLanes) {
        // This is always non-null on a ClassComponent or HostRoot
        var queue = workInProgress.updateQueue;
        hasForceUpdate = false;
        currentlyProcessingQueue = queue.shared;
        var firstBaseUpdate = queue.firstBaseUpdate;
        var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.
        var pendingQueue = queue.shared.pending;
        if (pendingQueue !== null) {
            queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first
            // and last so that it's non-circular.
            var lastPendingUpdate = pendingQueue;
            var firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null; // Append pending updates to base queue
            if (lastBaseUpdate === null) firstBaseUpdate = firstPendingUpdate;
            else lastBaseUpdate.next = firstPendingUpdate;
            lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then
            // we need to transfer the updates to that queue, too. Because the base
            // queue is a singly-linked list with no cycles, we can append to both
            // lists and take advantage of structural sharing.
            // TODO: Pass `current` as argument
            var current = workInProgress.alternate;
            if (current !== null) {
                // This is always non-null on a ClassComponent or HostRoot
                var currentQueue = current.updateQueue;
                var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
                if (currentLastBaseUpdate !== lastBaseUpdate) {
                    if (currentLastBaseUpdate === null) currentQueue.firstBaseUpdate = firstPendingUpdate;
                    else currentLastBaseUpdate.next = firstPendingUpdate;
                    currentQueue.lastBaseUpdate = lastPendingUpdate;
                }
            }
        } // These values may change as we process the queue.
        if (firstBaseUpdate !== null) {
            // Iterate through the list of updates to compute the result.
            var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes
            // from the original lanes.
            var newLanes = NoLanes;
            var newBaseState = null;
            var newFirstBaseUpdate = null;
            var newLastBaseUpdate = null;
            var update = firstBaseUpdate;
            do {
                var updateLane = update.lane;
                var updateEventTime = update.eventTime;
                if (!isSubsetOfLanes(renderLanes, updateLane)) {
                    // Priority is insufficient. Skip this update. If this is the first
                    // skipped update, the previous update/state is the new base
                    // update/state.
                    var clone = {
                        eventTime: updateEventTime,
                        lane: updateLane,
                        tag: update.tag,
                        payload: update.payload,
                        callback: update.callback,
                        next: null
                    };
                    if (newLastBaseUpdate === null) {
                        newFirstBaseUpdate = newLastBaseUpdate = clone;
                        newBaseState = newState;
                    } else newLastBaseUpdate = newLastBaseUpdate.next = clone;
                     // Update the remaining priority in the queue.
                    newLanes = mergeLanes(newLanes, updateLane);
                } else {
                    // This update does have sufficient priority.
                    if (newLastBaseUpdate !== null) {
                        var _clone = {
                            eventTime: updateEventTime,
                            // This update is going to be committed so we never want uncommit
                            // it. Using NoLane works because 0 is a subset of all bitmasks, so
                            // this will never be skipped by the check above.
                            lane: NoLane,
                            tag: update.tag,
                            payload: update.payload,
                            callback: update.callback,
                            next: null
                        };
                        newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                    } // Process this update.
                    newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);
                    var callback = update.callback;
                    if (callback !== null) {
                        workInProgress.flags |= Callback;
                        var effects = queue.effects;
                        if (effects === null) queue.effects = [
                            update
                        ];
                        else effects.push(update);
                    }
                }
                update = update.next;
                if (update === null) {
                    pendingQueue = queue.shared.pending;
                    if (pendingQueue === null) break;
                    else {
                        // An update was scheduled from inside a reducer. Add the new
                        // pending updates to the end of the list and keep processing.
                        var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we
                        // unravel them when transferring them to the base queue.
                        var _firstPendingUpdate = _lastPendingUpdate.next;
                        _lastPendingUpdate.next = null;
                        update = _firstPendingUpdate;
                        queue.lastBaseUpdate = _lastPendingUpdate;
                        queue.shared.pending = null;
                    }
                }
            }while (true)
            if (newLastBaseUpdate === null) newBaseState = newState;
            queue.baseState = newBaseState;
            queue.firstBaseUpdate = newFirstBaseUpdate;
            queue.lastBaseUpdate = newLastBaseUpdate; // Set the remaining expiration time to be whatever is remaining in the queue.
            // This should be fine because the only two other things that contribute to
            // expiration time are props and context. We're already in the middle of the
            // begin phase by the time we start processing the queue, so we've already
            // dealt with the props. Context in components that specify
            // shouldComponentUpdate is tricky; but we'll have to account for
            // that regardless.
            markSkippedUpdateLanes(newLanes);
            workInProgress.lanes = newLanes;
            workInProgress.memoizedState = newState;
        }
        currentlyProcessingQueue = null;
    }
    function callCallback1(callback, context) {
        if (!(typeof callback === 'function')) throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
        callback.call(context);
    }
    function resetHasForceUpdateBeforeProcessing() {
        hasForceUpdate = false;
    }
    function checkHasForceUpdateAfterProcessing() {
        return hasForceUpdate;
    }
    function commitUpdateQueue(finishedWork, finishedQueue, instance) {
        // Commit the effects
        var effects = finishedQueue.effects;
        finishedQueue.effects = null;
        if (effects !== null) for(var i = 0; i < effects.length; i++){
            var effect = effects[i];
            var callback = effect.callback;
            if (callback !== null) {
                effect.callback = null;
                callCallback1(callback, instance);
            }
        }
    }
    var fakeInternalInstance = {
    };
    var isArray1 = Array.isArray; // React.Component uses a shared frozen object by default.
    // We'll use it to determine whether we need to initialize legacy refs.
    var emptyRefsObject = new React.Component().refs;
    var didWarnAboutStateAssignmentForComponent;
    var didWarnAboutUninitializedState;
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
    var didWarnAboutLegacyLifecyclesAndDerivedState;
    var didWarnAboutUndefinedDerivedState;
    var warnOnUndefinedDerivedState;
    var warnOnInvalidCallback;
    var didWarnAboutDirectlyAssigningPropsToState;
    var didWarnAboutContextTypeAndContextTypes;
    var didWarnAboutInvalidateContextType;
    didWarnAboutStateAssignmentForComponent = new Set();
    didWarnAboutUninitializedState = new Set();
    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
    didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
    didWarnAboutDirectlyAssigningPropsToState = new Set();
    didWarnAboutUndefinedDerivedState = new Set();
    didWarnAboutContextTypeAndContextTypes = new Set();
    didWarnAboutInvalidateContextType = new Set();
    var didWarnOnInvalidCallback = new Set();
    warnOnInvalidCallback = function(callback, callerName) {
        if (callback === null || typeof callback === 'function') return;
        var key = callerName + '_' + callback;
        if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            error1("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
        }
    };
    warnOnUndefinedDerivedState = function(type, partialState) {
        if (partialState === undefined) {
            var componentName = getComponentName(type) || 'Component';
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error1("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
            }
        }
    }; // This is so gross but it's at least non-critical and can be removed if
    // it causes problems. This is meant to give a nicer error message for
    // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
    // ...)) which otherwise throws a "_processChildContext is not a function"
    // exception.
    Object.defineProperty(fakeInternalInstance, '_processChildContext', {
        enumerable: false,
        value: function() {
            throw Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
    });
    Object.freeze(fakeInternalInstance);
    function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
        var prevState = workInProgress.memoizedState;
        if (workInProgress.mode & StrictMode) {
            disableLogs();
            try {
                // Invoke the function an extra time to help detect side-effects.
                getDerivedStateFromProps(nextProps, prevState);
            } finally{
                reenableLogs();
            }
        }
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        warnOnUndefinedDerivedState(ctor, partialState);
        var memoizedState = partialState === null || partialState === undefined ? prevState : _assign({
        }, prevState, partialState);
        workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the
        // base state.
        if (workInProgress.lanes === NoLanes) {
            // Queue is always non-null for classes
            var updateQueue = workInProgress.updateQueue;
            updateQueue.baseState = memoizedState;
        }
    }
    var classComponentUpdater = {
        isMounted: isMounted,
        enqueueSetState: function(inst, payload, callback) {
            var fiber = get1(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.payload = payload;
            if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, 'setState');
                update.callback = callback;
            }
            enqueueUpdate(fiber, update);
            scheduleUpdateOnFiber(fiber, lane, eventTime);
        },
        enqueueReplaceState: function(inst, payload, callback) {
            var fiber = get1(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.tag = ReplaceState;
            update.payload = payload;
            if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, 'replaceState');
                update.callback = callback;
            }
            enqueueUpdate(fiber, update);
            scheduleUpdateOnFiber(fiber, lane, eventTime);
        },
        enqueueForceUpdate: function(inst, callback) {
            var fiber = get1(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.tag = ForceUpdate;
            if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, 'forceUpdate');
                update.callback = callback;
            }
            enqueueUpdate(fiber, update);
            scheduleUpdateOnFiber(fiber, lane, eventTime);
        }
    };
    function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
        var instance = workInProgress.stateNode;
        if (typeof instance.shouldComponentUpdate === 'function') {
            if (workInProgress.mode & StrictMode) {
                disableLogs();
                try {
                    // Invoke the function an extra time to help detect side-effects.
                    instance.shouldComponentUpdate(newProps, newState, nextContext);
                } finally{
                    reenableLogs();
                }
            }
            var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
            if (shouldUpdate === undefined) error1("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentName(ctor) || 'Component');
            return shouldUpdate;
        }
        if (ctor.prototype && ctor.prototype.isPureReactComponent) return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
        return true;
    }
    function checkClassInstance(workInProgress, ctor, newProps) {
        var instance = workInProgress.stateNode;
        var name = getComponentName(ctor) || 'Component';
        var renderPresent = instance.render;
        if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === 'function') error1("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
            else error1("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
        }
        if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) error1("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
        if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) error1("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
        if (instance.propTypes) error1("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
        if (instance.contextType) error1("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
        if (instance.contextTypes) error1("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
        if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
            didWarnAboutContextTypeAndContextTypes.add(ctor);
            error1("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
        }
        if (typeof instance.componentShouldUpdate === 'function') error1("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
        if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') error1("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentName(ctor) || 'A pure component');
        if (typeof instance.componentDidUnmount === 'function') error1("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
        if (typeof instance.componentDidReceiveProps === 'function') error1("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
        if (typeof instance.componentWillRecieveProps === 'function') error1("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
        if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') error1("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
        var hasMutatedProps = instance.props !== newProps;
        if (instance.props !== undefined && hasMutatedProps) error1("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
        if (instance.defaultProps) error1("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
        if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            error1("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentName(ctor));
        }
        if (typeof instance.getDerivedStateFromProps === 'function') error1("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
        if (typeof instance.getDerivedStateFromError === 'function') error1("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
        if (typeof ctor.getSnapshotBeforeUpdate === 'function') error1("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
        var _state = instance.state;
        if (_state && (typeof _state !== 'object' || isArray1(_state))) error1('%s.state: must be set to an object or null', name);
        if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') error1("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
    }
    function adoptClassInstance(workInProgress, instance) {
        instance.updater = classComponentUpdater;
        workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates
        set1(instance, workInProgress);
        instance._reactInternalInstance = fakeInternalInstance;
    }
    function constructClassInstance(workInProgress, ctor, props) {
        var isLegacyContextConsumer = false;
        var unmaskedContext = emptyContextObject;
        var context = emptyContextObject;
        var contextType = ctor.contextType;
        if ('contextType' in ctor) {
            var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>
            if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = '';
                if (contextType === undefined) addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                else if (typeof contextType !== 'object') addendum = ' However, it is set to a ' + typeof contextType + '.';
                else if (contextType.$$typeof === REACT_PROVIDER_TYPE) addendum = ' Did you accidentally pass the Context.Provider instead?';
                else if (contextType._context !== undefined) // <Context.Consumer>
                addendum = ' Did you accidentally pass the Context.Consumer instead?';
                else addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';
                error1("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentName(ctor) || 'Component', addendum);
            }
        }
        if (typeof contextType === 'object' && contextType !== null) context = readContext(contextType);
        else {
            unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
            var contextTypes = ctor.contextTypes;
            isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;
            context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;
        } // Instantiate twice to help detect side-effects.
        if (workInProgress.mode & StrictMode) {
            disableLogs();
            try {
                new ctor(props, context); // eslint-disable-line no-new
            } finally{
                reenableLogs();
            }
        }
        var instance = new ctor(props, context);
        var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
        adoptClassInstance(workInProgress, instance);
        if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {
            var componentName = getComponentName(ctor) || 'Component';
            if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error1("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? 'null' : 'undefined', componentName);
            }
        } // If new component APIs are defined, "unsafe" lifecycles won't be called.
        // Warn about these lifecycles if they are present.
        // Don't warn about react-lifecycles-compat polyfilled methods though.
        if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;
            if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) foundWillMountName = 'componentWillMount';
            else if (typeof instance.UNSAFE_componentWillMount === 'function') foundWillMountName = 'UNSAFE_componentWillMount';
            if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) foundWillReceivePropsName = 'componentWillReceiveProps';
            else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
            if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) foundWillUpdateName = 'componentWillUpdate';
            else if (typeof instance.UNSAFE_componentWillUpdate === 'function') foundWillUpdateName = 'UNSAFE_componentWillUpdate';
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentName(ctor) || 'Component';
                var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error1("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : '', foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : '', foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : '');
                }
            }
        }
        // ReactFiberContext usually updates this cache but can't for newly-created instances.
        if (isLegacyContextConsumer) cacheContext(workInProgress, unmaskedContext, context);
        return instance;
    }
    function callComponentWillMount(workInProgress, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === 'function') instance.componentWillMount();
        if (typeof instance.UNSAFE_componentWillMount === 'function') instance.UNSAFE_componentWillMount();
        if (oldState !== instance.state) {
            error1("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentName(workInProgress.type) || 'Component');
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
    }
    function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
        var oldState = instance.state;
        if (typeof instance.componentWillReceiveProps === 'function') instance.componentWillReceiveProps(newProps, nextContext);
        if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        if (instance.state !== oldState) {
            var componentName = getComponentName(workInProgress.type) || 'Component';
            if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                didWarnAboutStateAssignmentForComponent.add(componentName);
                error1("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
    } // Invokes the mount life-cycles on a previously never rendered instance.
    function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
        checkClassInstance(workInProgress, ctor, newProps);
        var instance = workInProgress.stateNode;
        instance.props = newProps;
        instance.state = workInProgress.memoizedState;
        instance.refs = emptyRefsObject;
        initializeUpdateQueue(workInProgress);
        var contextType = ctor.contextType;
        if (typeof contextType === 'object' && contextType !== null) instance.context = readContext(contextType);
        else {
            var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
            instance.context = getMaskedContext(workInProgress, unmaskedContext);
        }
        if (instance.state === newProps) {
            var componentName = getComponentName(ctor) || 'Component';
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error1("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
            }
        }
        if (workInProgress.mode & StrictMode) ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);
        processUpdateQueue(workInProgress, newProps, instance, renderLanes);
        instance.state = workInProgress.memoizedState;
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === 'function') {
            applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
            instance.state = workInProgress.memoizedState;
        } // In order to support react-lifecycles-compat polyfilled components,
        // Unsafe lifecycles should not be invoked for components using the new APIs.
        if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
            callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's
            // process them now.
            processUpdateQueue(workInProgress, newProps, instance, renderLanes);
            instance.state = workInProgress.memoizedState;
        }
        if (typeof instance.componentDidMount === 'function') workInProgress.flags |= Update;
    }
    function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {
        var instance = workInProgress.stateNode;
        var oldProps = workInProgress.memoizedProps;
        instance.props = oldProps;
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = emptyContextObject;
        if (typeof contextType === 'object' && contextType !== null) nextContext = readContext(contextType);
        else {
            var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
            nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what
        // ever the previously attempted to render - not the "current". However,
        // during componentDidUpdate we pass the "current" props.
        // In order to support react-lifecycles-compat polyfilled components,
        // Unsafe lifecycles should not be invoked for components using the new APIs.
        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
            if (oldProps !== newProps || oldContext !== nextContext) callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
        }
        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress.memoizedState;
        var newState = instance.state = oldState;
        processUpdateQueue(workInProgress, newProps, instance, renderLanes);
        newState = workInProgress.memoizedState;
        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
            // If an update was already in progress, we should schedule an Update
            // effect even though we're bailing out, so that cWU/cDU are called.
            if (typeof instance.componentDidMount === 'function') workInProgress.flags |= Update;
            return false;
        }
        if (typeof getDerivedStateFromProps === 'function') {
            applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress.memoizedState;
        }
        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);
        if (shouldUpdate) {
            // In order to support react-lifecycles-compat polyfilled components,
            // Unsafe lifecycles should not be invoked for components using the new APIs.
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
                if (typeof instance.componentWillMount === 'function') instance.componentWillMount();
                if (typeof instance.UNSAFE_componentWillMount === 'function') instance.UNSAFE_componentWillMount();
            }
            if (typeof instance.componentDidMount === 'function') workInProgress.flags |= Update;
        } else {
            // If an update was already in progress, we should schedule an Update
            // effect even though we're bailing out, so that cWU/cDU are called.
            if (typeof instance.componentDidMount === 'function') workInProgress.flags |= Update;
             // If shouldComponentUpdate returned false, we should still update the
            // memoized state to indicate that this work can be reused.
            workInProgress.memoizedProps = newProps;
            workInProgress.memoizedState = newState;
        } // Update the existing instance's state, props, and context pointers even
        // if shouldComponentUpdate returns false.
        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
    } // Invokes the update life-cycles and returns false if it shouldn't rerender.
    function updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {
        var instance = workInProgress.stateNode;
        cloneUpdateQueue(current, workInProgress);
        var unresolvedOldProps = workInProgress.memoizedProps;
        var oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);
        instance.props = oldProps;
        var unresolvedNewProps = workInProgress.pendingProps;
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = emptyContextObject;
        if (typeof contextType === 'object' && contextType !== null) nextContext = readContext(contextType);
        else {
            var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
            nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what
        // ever the previously attempted to render - not the "current". However,
        // during componentDidUpdate we pass the "current" props.
        // In order to support react-lifecycles-compat polyfilled components,
        // Unsafe lifecycles should not be invoked for components using the new APIs.
        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
            if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
        }
        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress.memoizedState;
        var newState = instance.state = oldState;
        processUpdateQueue(workInProgress, newProps, instance, renderLanes);
        newState = workInProgress.memoizedState;
        if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
            // If an update was already in progress, we should schedule an Update
            // effect even though we're bailing out, so that cWU/cDU are called.
            if (typeof instance.componentDidUpdate === 'function') {
                if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) workInProgress.flags |= Update;
            }
            if (typeof instance.getSnapshotBeforeUpdate === 'function') {
                if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) workInProgress.flags |= Snapshot;
            }
            return false;
        }
        if (typeof getDerivedStateFromProps === 'function') {
            applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress.memoizedState;
        }
        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);
        if (shouldUpdate) {
            // In order to support react-lifecycles-compat polyfilled components,
            // Unsafe lifecycles should not be invoked for components using the new APIs.
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {
                if (typeof instance.componentWillUpdate === 'function') instance.componentWillUpdate(newProps, newState, nextContext);
                if (typeof instance.UNSAFE_componentWillUpdate === 'function') instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
            }
            if (typeof instance.componentDidUpdate === 'function') workInProgress.flags |= Update;
            if (typeof instance.getSnapshotBeforeUpdate === 'function') workInProgress.flags |= Snapshot;
        } else {
            // If an update was already in progress, we should schedule an Update
            // effect even though we're bailing out, so that cWU/cDU are called.
            if (typeof instance.componentDidUpdate === 'function') {
                if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) workInProgress.flags |= Update;
            }
            if (typeof instance.getSnapshotBeforeUpdate === 'function') {
                if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) workInProgress.flags |= Snapshot;
            } // If shouldComponentUpdate returned false, we should still update the
            // memoized props/state to indicate that this work can be reused.
            workInProgress.memoizedProps = newProps;
            workInProgress.memoizedState = newState;
        } // Update the existing instance's state, props, and context pointers even
        // if shouldComponentUpdate returns false.
        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
    }
    var didWarnAboutMaps;
    var didWarnAboutGenerators;
    var didWarnAboutStringRefs;
    var ownerHasKeyUseWarning;
    var ownerHasFunctionTypeWarning;
    var warnForMissingKey = function(child, returnFiber) {
    };
    didWarnAboutMaps = false;
    didWarnAboutGenerators = false;
    didWarnAboutStringRefs = {
    };
    /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */ ownerHasKeyUseWarning = {
    };
    ownerHasFunctionTypeWarning = {
    };
    warnForMissingKey = function(child, returnFiber) {
        if (child === null || typeof child !== 'object') return;
        if (!child._store || child._store.validated || child.key != null) return;
        if (!(typeof child._store === 'object')) throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        child._store.validated = true;
        var componentName = getComponentName(returnFiber.type) || 'Component';
        if (ownerHasKeyUseWarning[componentName]) return;
        ownerHasKeyUseWarning[componentName] = true;
        error1("Each child in a list should have a unique \"key\" prop. See https://reactjs.org/link/warning-keys for more information.");
    };
    var isArray$1 = Array.isArray;
    function coerceRef(returnFiber, current, element) {
        var mixedRef = element.ref;
        if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {
            // TODO: Clean this up once we turn on the string ref warning for
            // everyone, because the strict mode case will no longer be relevant
            if ((returnFiber.mode & StrictMode || warnAboutStringRefs) && // because these cannot be automatically converted to an arrow function
            // using a codemod. Therefore, we don't have to warn about string refs again.
            !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                var componentName = getComponentName(returnFiber.type) || 'Component';
                if (!didWarnAboutStringRefs[componentName]) {
                    error1("A string ref, \"%s\", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref", mixedRef);
                    didWarnAboutStringRefs[componentName] = true;
                }
            }
            if (element._owner) {
                var owner = element._owner;
                var inst;
                if (owner) {
                    var ownerFiber = owner;
                    if (!(ownerFiber.tag === ClassComponent)) throw Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                    inst = ownerFiber.stateNode;
                }
                if (!inst) throw Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
                var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref
                if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) return current.ref;
                var ref = function(value) {
                    var refs = inst.refs;
                    if (refs === emptyRefsObject) // This is a lazy pooled frozen object, so we need to initialize.
                    refs = inst.refs = {
                    };
                    if (value === null) delete refs[stringRef];
                    else refs[stringRef] = value;
                };
                ref._stringRef = stringRef;
                return ref;
            } else {
                if (!(typeof mixedRef === 'string')) throw Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                if (!element._owner) throw Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
            }
        }
        return mixedRef;
    }
    function throwOnInvalidObjectType(returnFiber, newChild) {
        if (returnFiber.type !== 'textarea') throw Error("Objects are not valid as a React child (found: " + (Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild) + "). If you meant to render a collection of children, use an array instead.");
    }
    function warnOnFunctionType(returnFiber) {
        var componentName = getComponentName(returnFiber.type) || 'Component';
        if (ownerHasFunctionTypeWarning[componentName]) return;
        ownerHasFunctionTypeWarning[componentName] = true;
        error1("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    } // We avoid inlining this to avoid potential deopts from using try/catch.
    // to be able to optimize each path individually by branching early. This needs
    // a compiler or we can do it manually. Helpers that don't need this branching
    // live outside of this function.
    function ChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
            if (!shouldTrackSideEffects) // Noop.
            return;
             // Deletions are added in reversed order so we add it to the front.
            // At this point, the return fiber's effect list is empty except for
            // deletions, so we can just append the deletion to the list. The remaining
            // effects aren't added until the complete phase. Once we implement
            // resuming, this may not be true.
            var last = returnFiber.lastEffect;
            if (last !== null) {
                last.nextEffect = childToDelete;
                returnFiber.lastEffect = childToDelete;
            } else returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
            childToDelete.nextEffect = null;
            childToDelete.flags = Deletion;
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) // Noop.
            return null;
             // TODO: For the shouldClone case, this could be micro-optimized a bit by
            // assuming that after the first child we've already added everything.
            var childToDelete = currentFirstChild;
            while(childToDelete !== null){
                deleteChild(returnFiber, childToDelete);
                childToDelete = childToDelete.sibling;
            }
            return null;
        }
        function mapRemainingChildren(returnFiber, currentFirstChild) {
            // Add the remaining children to a temporary map so that we can find them by
            // keys quickly. Implicit (null) keys get added to this set with their index
            // instead.
            var existingChildren = new Map();
            var existingChild = currentFirstChild;
            while(existingChild !== null){
                if (existingChild.key !== null) existingChildren.set(existingChild.key, existingChild);
                else existingChildren.set(existingChild.index, existingChild);
                existingChild = existingChild.sibling;
            }
            return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
            // We currently set sibling to null and index to 0 here because it is easy
            // to forget to do before returning it. E.g. for the single child case.
            var clone = createWorkInProgress(fiber, pendingProps);
            clone.index = 0;
            clone.sibling = null;
            return clone;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects) // Noop.
            return lastPlacedIndex;
            var current = newFiber.alternate;
            if (current !== null) {
                var oldIndex = current.index;
                if (oldIndex < lastPlacedIndex) {
                    // This is a move.
                    newFiber.flags = Placement;
                    return lastPlacedIndex;
                } else // This item can stay in place.
                return oldIndex;
            } else {
                // This is an insertion.
                newFiber.flags = Placement;
                return lastPlacedIndex;
            }
        }
        function placeSingleChild(newFiber) {
            // This is simpler for the single child case. We only need to do a
            // placement for inserting new children.
            if (shouldTrackSideEffects && newFiber.alternate === null) newFiber.flags = Placement;
            return newFiber;
        }
        function updateTextNode(returnFiber, current, textContent, lanes) {
            if (current === null || current.tag !== HostText) {
                // Insert
                var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
            } else {
                // Update
                var existing = useFiber(current, textContent);
                existing.return = returnFiber;
                return existing;
            }
        }
        function updateElement(returnFiber, current, element, lanes) {
            if (current !== null) {
                if (current.elementType === element.type || isCompatibleFamilyForHotReloading(current, element)) {
                    // Move based on index
                    var existing = useFiber(current, element.props);
                    existing.ref = coerceRef(returnFiber, current, element);
                    existing.return = returnFiber;
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                    return existing;
                }
            } // Insert
            var created = createFiberFromElement(element, returnFiber.mode, lanes);
            created.ref = coerceRef(returnFiber, current, element);
            created.return = returnFiber;
            return created;
        }
        function updatePortal(returnFiber, current, portal, lanes) {
            if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
                // Insert
                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
            } else {
                // Update
                var existing = useFiber(current, portal.children || []);
                existing.return = returnFiber;
                return existing;
            }
        }
        function updateFragment(returnFiber, current, fragment, lanes, key) {
            if (current === null || current.tag !== Fragment) {
                // Insert
                var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
                created.return = returnFiber;
                return created;
            } else {
                // Update
                var existing = useFiber(current, fragment);
                existing.return = returnFiber;
                return existing;
            }
        }
        function createChild(returnFiber, newChild, lanes) {
            if (typeof newChild === 'string' || typeof newChild === 'number') {
                // Text nodes don't have keys. If the previous node is implicitly keyed
                // we can continue to replace it without aborting even if it is not a text
                // node.
                var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
            }
            if (typeof newChild === 'object' && newChild !== null) {
                switch(newChild.$$typeof){
                    case REACT_ELEMENT_TYPE:
                        var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                        _created.ref = coerceRef(returnFiber, null, newChild);
                        _created.return = returnFiber;
                        return _created;
                    case REACT_PORTAL_TYPE:
                        var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                        _created2.return = returnFiber;
                        return _created2;
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                    var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                    _created3.return = returnFiber;
                    return _created3;
                }
                throwOnInvalidObjectType(returnFiber, newChild);
            }
            if (typeof newChild === 'function') warnOnFunctionType(returnFiber);
            return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            // Update the fiber if the keys match, otherwise return null.
            var key = oldFiber !== null ? oldFiber.key : null;
            if (typeof newChild === 'string' || typeof newChild === 'number') {
                // Text nodes don't have keys. If the previous node is implicitly keyed
                // we can continue to replace it without aborting even if it is not a text
                // node.
                if (key !== null) return null;
                return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);
            }
            if (typeof newChild === 'object' && newChild !== null) {
                switch(newChild.$$typeof){
                    case REACT_ELEMENT_TYPE:
                        if (newChild.key === key) {
                            if (newChild.type === REACT_FRAGMENT_TYPE) return updateFragment(returnFiber, oldFiber, newChild.props.children, lanes, key);
                            return updateElement(returnFiber, oldFiber, newChild, lanes);
                        } else return null;
                    case REACT_PORTAL_TYPE:
                        if (newChild.key === key) return updatePortal(returnFiber, oldFiber, newChild, lanes);
                        else return null;
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                    if (key !== null) return null;
                    return updateFragment(returnFiber, oldFiber, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
            }
            if (typeof newChild === 'function') warnOnFunctionType(returnFiber);
            return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if (typeof newChild === 'string' || typeof newChild === 'number') {
                // Text nodes don't have keys, so we neither have to check the old nor
                // new node for the key. If both are text nodes, they match.
                var matchedFiber = existingChildren.get(newIdx) || null;
                return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);
            }
            if (typeof newChild === 'object' && newChild !== null) {
                switch(newChild.$$typeof){
                    case REACT_ELEMENT_TYPE:
                        var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                        if (newChild.type === REACT_FRAGMENT_TYPE) return updateFragment(returnFiber, _matchedFiber, newChild.props.children, lanes, newChild.key);
                        return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                    case REACT_PORTAL_TYPE:
                        var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                        return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                    var _matchedFiber3 = existingChildren.get(newIdx) || null;
                    return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
            }
            if (typeof newChild === 'function') warnOnFunctionType(returnFiber);
            return null;
        }
        /**
   * Warns if there is a duplicate or missing key
   */ function warnOnInvalidKey(child, knownKeys, returnFiber) {
            if (typeof child !== 'object' || child === null) return knownKeys;
            switch(child.$$typeof){
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                    warnForMissingKey(child, returnFiber);
                    var key = child.key;
                    if (typeof key !== 'string') break;
                    if (knownKeys === null) {
                        knownKeys = new Set();
                        knownKeys.add(key);
                        break;
                    }
                    if (!knownKeys.has(key)) {
                        knownKeys.add(key);
                        break;
                    }
                    error1("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted â€” the behavior is unsupported and could change in a future version.", key);
                    break;
            }
            return knownKeys;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            // First, validate keys.
            var knownKeys = null;
            for(var i = 0; i < newChildren.length; i++){
                var child = newChildren[i];
                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            for(; oldFiber !== null && newIdx < newChildren.length; newIdx++){
                if (oldFiber.index > newIdx) {
                    nextOldFiber = oldFiber;
                    oldFiber = null;
                } else nextOldFiber = oldFiber.sibling;
                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                if (newFiber === null) {
                    // TODO: This breaks on empty slots like null children. That's
                    // unfortunate because it triggers the slow path all the time. We need
                    // a better way to communicate whether this was a miss or null,
                    // boolean, undefined, etc.
                    if (oldFiber === null) oldFiber = nextOldFiber;
                    break;
                }
                if (shouldTrackSideEffects) {
                    if (oldFiber && newFiber.alternate === null) // We matched the slot, but we didn't reuse the existing fiber, so we
                    // need to delete the existing child.
                    deleteChild(returnFiber, oldFiber);
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) // TODO: Move out of the loop. This only happens for the first run.
                resultingFirstChild = newFiber;
                else // TODO: Defer siblings if we're not at the right index for this slot.
                // I.e. if we had null values before, then we want to defer this
                // for each null value. However, we also don't want to call updateSlot
                // with the previous one.
                previousNewFiber.sibling = newFiber;
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length) {
                // We've reached the end of the new children. We can delete the rest.
                deleteRemainingChildren(returnFiber, oldFiber);
                return resultingFirstChild;
            }
            if (oldFiber === null) {
                // If we don't have any more existing children we can choose a fast path
                // since the rest will all be insertions.
                for(; newIdx < newChildren.length; newIdx++){
                    var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                    if (_newFiber === null) continue;
                    lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                    if (previousNewFiber === null) // TODO: Move out of the loop. This only happens for the first run.
                    resultingFirstChild = _newFiber;
                    else previousNewFiber.sibling = _newFiber;
                    previousNewFiber = _newFiber;
                }
                return resultingFirstChild;
            } // Add all children to a key map for quick lookups.
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.
            for(; newIdx < newChildren.length; newIdx++){
                var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
                if (_newFiber2 !== null) {
                    if (shouldTrackSideEffects) {
                        if (_newFiber2.alternate !== null) // The new fiber is a work in progress, but if there exists a
                        // current, that means that we reused the fiber. We need to delete
                        // it from the child list so that we don't add it to the deletion
                        // list.
                        existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                    }
                    lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                    if (previousNewFiber === null) resultingFirstChild = _newFiber2;
                    else previousNewFiber.sibling = _newFiber2;
                    previousNewFiber = _newFiber2;
                }
            }
            if (shouldTrackSideEffects) // Any existing children that weren't consumed above were deleted. We need
            // to add them to the deletion list.
            existingChildren.forEach(function(child) {
                return deleteChild(returnFiber, child);
            });
            return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
            // This is the same implementation as reconcileChildrenArray(),
            // but using the iterator instead.
            var iteratorFn = getIteratorFn(newChildrenIterable);
            if (!(typeof iteratorFn === 'function')) throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            // We don't support rendering Generators because it's a mutation.
            // See https://github.com/facebook/react/issues/12995
            if (typeof Symbol === 'function' && newChildrenIterable[Symbol.toStringTag] === 'Generator') {
                if (!didWarnAboutGenerators) error1("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                didWarnAboutGenerators = true;
            } // Warn about using Maps as children
            if (newChildrenIterable.entries === iteratorFn) {
                if (!didWarnAboutMaps) error1("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                didWarnAboutMaps = true;
            } // First, validate keys.
            // We'll get a different iterator later for the main pass.
            var _newChildren = iteratorFn.call(newChildrenIterable);
            if (_newChildren) {
                var knownKeys = null;
                var _step = _newChildren.next();
                for(; !_step.done; _step = _newChildren.next()){
                    var child = _step.value;
                    knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
            }
            var newChildren = iteratorFn.call(newChildrenIterable);
            if (!(newChildren != null)) throw Error("An iterable object provided no iterator.");
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            var step = newChildren.next();
            for(; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()){
                if (oldFiber.index > newIdx) {
                    nextOldFiber = oldFiber;
                    oldFiber = null;
                } else nextOldFiber = oldFiber.sibling;
                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                if (newFiber === null) {
                    // TODO: This breaks on empty slots like null children. That's
                    // unfortunate because it triggers the slow path all the time. We need
                    // a better way to communicate whether this was a miss or null,
                    // boolean, undefined, etc.
                    if (oldFiber === null) oldFiber = nextOldFiber;
                    break;
                }
                if (shouldTrackSideEffects) {
                    if (oldFiber && newFiber.alternate === null) // We matched the slot, but we didn't reuse the existing fiber, so we
                    // need to delete the existing child.
                    deleteChild(returnFiber, oldFiber);
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) // TODO: Move out of the loop. This only happens for the first run.
                resultingFirstChild = newFiber;
                else // TODO: Defer siblings if we're not at the right index for this slot.
                // I.e. if we had null values before, then we want to defer this
                // for each null value. However, we also don't want to call updateSlot
                // with the previous one.
                previousNewFiber.sibling = newFiber;
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
            }
            if (step.done) {
                // We've reached the end of the new children. We can delete the rest.
                deleteRemainingChildren(returnFiber, oldFiber);
                return resultingFirstChild;
            }
            if (oldFiber === null) {
                // If we don't have any more existing children we can choose a fast path
                // since the rest will all be insertions.
                for(; !step.done; newIdx++, step = newChildren.next()){
                    var _newFiber3 = createChild(returnFiber, step.value, lanes);
                    if (_newFiber3 === null) continue;
                    lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                    if (previousNewFiber === null) // TODO: Move out of the loop. This only happens for the first run.
                    resultingFirstChild = _newFiber3;
                    else previousNewFiber.sibling = _newFiber3;
                    previousNewFiber = _newFiber3;
                }
                return resultingFirstChild;
            } // Add all children to a key map for quick lookups.
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.
            for(; !step.done; newIdx++, step = newChildren.next()){
                var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
                if (_newFiber4 !== null) {
                    if (shouldTrackSideEffects) {
                        if (_newFiber4.alternate !== null) // The new fiber is a work in progress, but if there exists a
                        // current, that means that we reused the fiber. We need to delete
                        // it from the child list so that we don't add it to the deletion
                        // list.
                        existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                    }
                    lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                    if (previousNewFiber === null) resultingFirstChild = _newFiber4;
                    else previousNewFiber.sibling = _newFiber4;
                    previousNewFiber = _newFiber4;
                }
            }
            if (shouldTrackSideEffects) // Any existing children that weren't consumed above were deleted. We need
            // to add them to the deletion list.
            existingChildren.forEach(function(child) {
                return deleteChild(returnFiber, child);
            });
            return resultingFirstChild;
        }
        function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
            // There's no need to check for keys on text nodes since we don't have a
            // way to define them.
            if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                // We already have an existing node so let's just update it and delete
                // the rest.
                deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                var existing = useFiber(currentFirstChild, textContent);
                existing.return = returnFiber;
                return existing;
            } // The existing first child is not a text node so we need to create one
            // and delete the existing ones.
            deleteRemainingChildren(returnFiber, currentFirstChild);
            var created = createFiberFromText(textContent, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
        }
        function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
            var key = element.key;
            var child = currentFirstChild;
            while(child !== null){
                // TODO: If key === null and child.key === null, then this only applies to
                // the first item in the list.
                if (child.key === key) {
                    switch(child.tag){
                        case Fragment:
                            if (element.type === REACT_FRAGMENT_TYPE) {
                                deleteRemainingChildren(returnFiber, child.sibling);
                                var existing = useFiber(child, element.props.children);
                                existing.return = returnFiber;
                                existing._debugSource = element._source;
                                existing._debugOwner = element._owner;
                                return existing;
                            }
                            break;
                        case Block:
                        // We intentionally fallthrough here if enableBlocksAPI is not on.
                        // eslint-disable-next-lined no-fallthrough
                        default:
                            if (child.elementType === element.type || isCompatibleFamilyForHotReloading(child, element)) {
                                deleteRemainingChildren(returnFiber, child.sibling);
                                var _existing3 = useFiber(child, element.props);
                                _existing3.ref = coerceRef(returnFiber, child, element);
                                _existing3.return = returnFiber;
                                _existing3._debugSource = element._source;
                                _existing3._debugOwner = element._owner;
                                return _existing3;
                            }
                            break;
                    } // Didn't match.
                    deleteRemainingChildren(returnFiber, child);
                    break;
                } else deleteChild(returnFiber, child);
                child = child.sibling;
            }
            if (element.type === REACT_FRAGMENT_TYPE) {
                var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                created.return = returnFiber;
                return created;
            } else {
                var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                _created4.return = returnFiber;
                return _created4;
            }
        }
        function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
            var key = portal.key;
            var child = currentFirstChild;
            while(child !== null){
                // TODO: If key === null and child.key === null, then this only applies to
                // the first item in the list.
                if (child.key === key) {
                    if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                        deleteRemainingChildren(returnFiber, child.sibling);
                        var existing = useFiber(child, portal.children || []);
                        existing.return = returnFiber;
                        return existing;
                    } else {
                        deleteRemainingChildren(returnFiber, child);
                        break;
                    }
                } else deleteChild(returnFiber, child);
                child = child.sibling;
            }
            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
        } // This API will tag the children with the side-effect of the reconciliation
        // itself. They will be added to the side-effect list as we pass through the
        // children and the parent.
        function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {
            // This function is not recursive.
            // If the top level item is an array, we treat it as a set of children,
            // not as a fragment. Nested arrays on the other hand will be treated as
            // fragment nodes. Recursion happens at the normal flow.
            // Handle top level unkeyed fragments as if they were arrays.
            // This leads to an ambiguity between <>{[...]}</> and <>...</>.
            // We treat the ambiguous cases above the same.
            var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
            if (isUnkeyedTopLevelFragment) newChild = newChild.props.children;
             // Handle object types
            var isObject = typeof newChild === 'object' && newChild !== null;
            if (isObject) switch(newChild.$$typeof){
                case REACT_ELEMENT_TYPE:
                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_PORTAL_TYPE:
                    return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
            }
            if (typeof newChild === 'string' || typeof newChild === 'number') return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));
            if (isArray$1(newChild)) return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
            if (getIteratorFn(newChild)) return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
            if (isObject) throwOnInvalidObjectType(returnFiber, newChild);
            if (typeof newChild === 'function') warnOnFunctionType(returnFiber);
            if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) // If the new child is undefined, and the return fiber is a composite
            // component, throw an error. If Fiber return types are disabled,
            // we already threw above.
            switch(returnFiber.tag){
                case ClassComponent:
                    var instance = returnFiber.stateNode;
                    if (instance.render._isMockFunction) break;
                // Intentionally fall through to the next case, which handles both
                // functions and classes
                // eslint-disable-next-lined no-fallthrough
                case Block:
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent:
                    throw Error((getComponentName(returnFiber.type) || 'Component') + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
            }
             // Remaining cases are all treated as empty.
            return deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return reconcileChildFibers;
    }
    var reconcileChildFibers1 = ChildReconciler(true);
    var mountChildFibers = ChildReconciler(false);
    function cloneChildFibers(current, workInProgress) {
        if (!(current === null || workInProgress.child === current.child)) throw Error("Resuming work not yet implemented.");
        if (workInProgress.child === null) return;
        var currentChild = workInProgress.child;
        var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
        workInProgress.child = newChild;
        newChild.return = workInProgress;
        while(currentChild.sibling !== null){
            currentChild = currentChild.sibling;
            newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
            newChild.return = workInProgress;
        }
        newChild.sibling = null;
    } // Reset a workInProgress child set to prepare it for a second pass.
    function resetChildFibers(workInProgress, lanes) {
        var child = workInProgress.child;
        while(child !== null){
            resetWorkInProgress(child, lanes);
            child = child.sibling;
        }
    }
    var NO_CONTEXT = {
    };
    var contextStackCursor$1 = createCursor(NO_CONTEXT);
    var contextFiberStackCursor = createCursor(NO_CONTEXT);
    var rootInstanceStackCursor = createCursor(NO_CONTEXT);
    function requiredContext(c) {
        if (!(c !== NO_CONTEXT)) throw Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
        return c;
    }
    function getRootHostContainer() {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        return rootInstance;
    }
    function pushHostContainer(fiber, nextRootInstance) {
        // Push current root instance onto the stack;
        // This allows us to reset root when portals are popped.
        push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.
        // This enables us to pop only Fibers that provide unique contexts.
        push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.
        // However, we can't just call getRootHostContext() and push it because
        // we'd have a different number of entries on the stack depending on
        // whether getRootHostContext() throws somewhere in renderer code or not.
        // So we push an empty value first. This lets us safely unwind on errors.
        push(contextStackCursor$1, NO_CONTEXT, fiber);
        var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.
        pop(contextStackCursor$1, fiber);
        push(contextStackCursor$1, nextRootContext, fiber);
    }
    function popHostContainer(fiber) {
        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
        pop(rootInstanceStackCursor, fiber);
    }
    function getHostContext() {
        var context = requiredContext(contextStackCursor$1.current);
        return context;
    }
    function pushHostContext(fiber) {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        var context = requiredContext(contextStackCursor$1.current);
        var nextContext = getChildHostContext(context, fiber.type); // Don't push this Fiber's context unless it's unique.
        if (context === nextContext) return;
         // Track the context and the Fiber that provided it.
        // This enables us to pop only Fibers that provide unique contexts.
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, nextContext, fiber);
    }
    function popHostContext(fiber) {
        // Do not pop unless this Fiber provided the current context.
        // pushHostContext() only pushes Fibers that provide unique contexts.
        if (contextFiberStackCursor.current !== fiber) return;
        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
    }
    var DefaultSuspenseContext = 0; // The Suspense Context is split into two parts. The lower bits is
    // inherited deeply down the subtree. The upper bits only affect
    // this immediate suspense boundary and gets reset each new
    // boundary or suspense list.
    var SubtreeSuspenseContextMask = 1; // Subtree Flags:
    // InvisibleParentSuspenseContext indicates that one of our parent Suspense
    // boundaries is not currently showing visible main content.
    // Either because it is already showing a fallback or is not mounted at all.
    // We can use this to determine if it is desirable to trigger a fallback at
    // the parent. If not, then we might need to trigger undesirable boundaries
    // and/or suspend the commit to avoid hiding the parent content.
    var InvisibleParentSuspenseContext = 1; // Shallow Flags:
    // ForceSuspenseFallback can be used by SuspenseList to force newly added
    // items into their fallback state during one of the render passes.
    var ForceSuspenseFallback = 2;
    var suspenseStackCursor = createCursor(DefaultSuspenseContext);
    function hasSuspenseContext(parentContext, flag) {
        return (parentContext & flag) !== 0;
    }
    function setDefaultShallowSuspenseContext(parentContext) {
        return parentContext & SubtreeSuspenseContextMask;
    }
    function setShallowSuspenseContext(parentContext, shallowContext) {
        return parentContext & SubtreeSuspenseContextMask | shallowContext;
    }
    function addSubtreeSuspenseContext(parentContext, subtreeContext) {
        return parentContext | subtreeContext;
    }
    function pushSuspenseContext(fiber, newContext) {
        push(suspenseStackCursor, newContext, fiber);
    }
    function popSuspenseContext(fiber) {
        pop(suspenseStackCursor, fiber);
    }
    function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {
        // If it was the primary children that just suspended, capture and render the
        // fallback. Otherwise, don't capture and bubble to the next boundary.
        var nextState = workInProgress.memoizedState;
        if (nextState !== null) {
            if (nextState.dehydrated !== null) // A dehydrated boundary always captures.
            return true;
            return false;
        }
        var props = workInProgress.memoizedProps; // In order to capture, the Suspense component must have a fallback prop.
        if (props.fallback === undefined) return false;
         // Regular boundaries always capture.
        if (props.unstable_avoidThisFallback !== true) return true;
         // If it's a boundary we should avoid, then we prefer to bubble up to the
        // parent boundary if it is currently invisible.
        if (hasInvisibleParent) return false;
         // If the parent is not able to handle it, we must handle it.
        return true;
    }
    function findFirstSuspended(row) {
        var node = row;
        while(node !== null){
            if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                    var dehydrated = state.dehydrated;
                    if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) return node;
                }
            } else if (node.tag === SuspenseListComponent && // keep track of whether it suspended or not.
            node.memoizedProps.revealOrder !== undefined) {
                var didSuspend = (node.flags & DidCapture) !== NoFlags;
                if (didSuspend) return node;
            } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === row) return null;
            while(node.sibling === null){
                if (node.return === null || node.return === row) return null;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
        return null;
    }
    var NoFlags$1 = /*  */ 0; // Represents whether effect should fire.
    var HasEffect = /* */ 1; // Represents the phase in which the effect (not the clean-up) fires.
    var Layout = /*    */ 2;
    var Passive$1 = /*   */ 4;
    // This may have been an insertion or a hydration.
    var hydrationParentFiber = null;
    var nextHydratableInstance = null;
    var isHydrating1 = false;
    function enterHydrationState(fiber) {
        var parentInstance = fiber.stateNode.containerInfo;
        nextHydratableInstance = getFirstHydratableChild(parentInstance);
        hydrationParentFiber = fiber;
        isHydrating1 = true;
        return true;
    }
    function deleteHydratableInstance(returnFiber, instance) {
        switch(returnFiber.tag){
            case HostRoot:
                didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
                break;
            case HostComponent:
                didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
                break;
        }
        var childToDelete = createFiberFromHostInstanceForDeletion();
        childToDelete.stateNode = instance;
        childToDelete.return = returnFiber;
        childToDelete.flags = Deletion; // This might seem like it belongs on progressedFirstDeletion. However,
        // these children are not part of the reconciliation list of children.
        // Even if we abort and rereconcile the children, that will try to hydrate
        // again and the nodes are still in the host tree so these will be
        // recreated.
        if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = childToDelete;
            returnFiber.lastEffect = childToDelete;
        } else returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
    function insertNonHydratedInstance(returnFiber, fiber) {
        fiber.flags = fiber.flags & ~Hydrating | Placement;
        switch(returnFiber.tag){
            case HostRoot:
                var parentContainer = returnFiber.stateNode.containerInfo;
                switch(fiber.tag){
                    case HostComponent:
                        var type = fiber.type;
                        var props = fiber.pendingProps;
                        didNotFindHydratableContainerInstance(parentContainer, type);
                        break;
                    case HostText:
                        var text = fiber.pendingProps;
                        didNotFindHydratableContainerTextInstance(parentContainer, text);
                        break;
                }
                break;
            case HostComponent:
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                switch(fiber.tag){
                    case HostComponent:
                        var _type = fiber.type;
                        var _props = fiber.pendingProps;
                        didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type);
                        break;
                    case HostText:
                        var _text = fiber.pendingProps;
                        didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                        break;
                    case SuspenseComponent:
                        didNotFindHydratableSuspenseInstance(parentType, parentProps);
                        break;
                }
                break;
            default:
                return;
        }
    }
    function tryHydrate(fiber, nextInstance) {
        switch(fiber.tag){
            case HostComponent:
                var type = fiber.type;
                var props = fiber.pendingProps;
                var instance = canHydrateInstance(nextInstance, type);
                if (instance !== null) {
                    fiber.stateNode = instance;
                    return true;
                }
                return false;
            case HostText:
                var text = fiber.pendingProps;
                var textInstance = canHydrateTextInstance(nextInstance, text);
                if (textInstance !== null) {
                    fiber.stateNode = textInstance;
                    return true;
                }
                return false;
            case SuspenseComponent:
                return false;
            default:
                return false;
        }
    }
    function tryToClaimNextHydratableInstance(fiber) {
        if (!isHydrating1) return;
        var nextInstance = nextHydratableInstance;
        if (!nextInstance) {
            // Nothing to hydrate. Make it an insertion.
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating1 = false;
            hydrationParentFiber = fiber;
            return;
        }
        var firstAttemptedInstance = nextInstance;
        if (!tryHydrate(fiber, nextInstance)) {
            // If we can't hydrate this instance let's try the next one.
            // We use this as a heuristic. It's based on intuition and not data so it
            // might be flawed or unnecessary.
            nextInstance = getNextHydratableSibling(firstAttemptedInstance);
            if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                // Nothing to hydrate. Make it an insertion.
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                isHydrating1 = false;
                hydrationParentFiber = fiber;
                return;
            } // We matched the next one, we'll now assume that the first one was
            // superfluous and we'll delete it. Since we can't eagerly delete it
            // we'll have to schedule a deletion. To do that, this node needs a dummy
            // fiber associated with it.
            deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
        }
        hydrationParentFiber = fiber;
        nextHydratableInstance = getFirstHydratableChild(nextInstance);
    }
    function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
        var instance = fiber.stateNode;
        var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber); // TODO: Type this specific to this type of component.
        fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
        // is a new ref we mark this as an update.
        if (updatePayload !== null) return true;
        return false;
    }
    function prepareToHydrateHostTextInstance(fiber) {
        var textInstance = fiber.stateNode;
        var textContent = fiber.memoizedProps;
        var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
        if (shouldUpdate) {
            // We assume that prepareToHydrateHostTextInstance is called in a context where the
            // hydration parent is the parent host component of this host text.
            var returnFiber = hydrationParentFiber;
            if (returnFiber !== null) switch(returnFiber.tag){
                case HostRoot:
                    var parentContainer = returnFiber.stateNode.containerInfo;
                    didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                    break;
                case HostComponent:
                    var parentType = returnFiber.type;
                    var parentProps = returnFiber.memoizedProps;
                    var parentInstance = returnFiber.stateNode;
                    didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                    break;
            }
        }
        return shouldUpdate;
    }
    function skipPastDehydratedSuspenseInstance(fiber) {
        var suspenseState = fiber.memoizedState;
        var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
        if (!suspenseInstance) throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
    }
    function popToNextHostParent(fiber) {
        var parent = fiber.return;
        while(parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent)parent = parent.return;
        hydrationParentFiber = parent;
    }
    function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) // We're deeper than the current hydration context, inside an inserted
        // tree.
        return false;
        if (!isHydrating1) {
            // If we're not currently hydrating but we're in a hydration context, then
            // we were an insertion and now need to pop up reenter hydration of our
            // siblings.
            popToNextHostParent(fiber);
            isHydrating1 = true;
            return false;
        }
        var type = fiber.type; // If we have any remaining hydratable nodes, we need to delete them now.
        // We only do this deeper than head and body since they tend to have random
        // other nodes in them. We also ignore components with pure text content in
        // side of them.
        // TODO: Better heuristic.
        if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
            var nextInstance = nextHydratableInstance;
            while(nextInstance){
                deleteHydratableInstance(fiber, nextInstance);
                nextInstance = getNextHydratableSibling(nextInstance);
            }
        }
        popToNextHostParent(fiber);
        if (fiber.tag === SuspenseComponent) nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
        else nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
        return true;
    }
    function resetHydrationState() {
        hydrationParentFiber = null;
        nextHydratableInstance = null;
        isHydrating1 = false;
    }
    function getIsHydrating() {
        return isHydrating1;
    }
    // and should be reset before starting a new render.
    // This tracks which mutable sources need to be reset after a render.
    var workInProgressSources = [];
    var rendererSigil$1;
    // Used to detect multiple renderers using the same mutable source.
    rendererSigil$1 = {
    };
    function markSourceAsDirty(mutableSource) {
        workInProgressSources.push(mutableSource);
    }
    function resetWorkInProgressVersions() {
        for(var i = 0; i < workInProgressSources.length; i++){
            var mutableSource = workInProgressSources[i];
            mutableSource._workInProgressVersionPrimary = null;
        }
        workInProgressSources.length = 0;
    }
    function getWorkInProgressVersion(mutableSource) {
        return mutableSource._workInProgressVersionPrimary;
    }
    function setWorkInProgressVersion(mutableSource, version) {
        mutableSource._workInProgressVersionPrimary = version;
        workInProgressSources.push(mutableSource);
    }
    function warnAboutMultipleRenderersDEV(mutableSource) {
        if (mutableSource._currentPrimaryRenderer == null) mutableSource._currentPrimaryRenderer = rendererSigil$1;
        else if (mutableSource._currentPrimaryRenderer !== rendererSigil$1) error1("Detected multiple renderers concurrently rendering the same mutable source. This is currently unsupported.");
    } // Eager reads the version of a mutable source and stores it on the root.
    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
    var didWarnAboutMismatchedHooksForComponent;
    var didWarnAboutUseOpaqueIdentifier;
    didWarnAboutUseOpaqueIdentifier = {
    };
    didWarnAboutMismatchedHooksForComponent = new Set();
    // These are set right before calling the component.
    var renderLanes1 = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from
    // the work-in-progress hook.
    var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The
    // current hook list is the list that belongs to the current fiber. The
    // work-in-progress hook list is a new list that will be added to the
    // work-in-progress fiber.
    var currentHook1 = null;
    var workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This
    // does not get reset if we do another render pass; only when we're completely
    // finished evaluating this component. This is an optimization so we know
    // whether we need to clear render phase updates after a throw.
    var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This
    // gets reset after each attempt.
    // TODO: Maybe there's some way to consolidate this with
    // `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.
    var didScheduleRenderPhaseUpdateDuringThisPass = false;
    var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook
    var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.
    // The list stores the order of hooks used during the initial render (mount).
    // Subsequent renders (updates) reference this list.
    var hookTypesDev = null;
    var hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore
    // the dependencies for Hooks that need them (e.g. useEffect or useMemo).
    // When true, such Hooks will always be "remounted". Only used during hot reload.
    var ignorePreviousDependencies = false;
    function mountHookTypesDev() {
        var hookName = currentHookNameInDev;
        if (hookTypesDev === null) hookTypesDev = [
            hookName
        ];
        else hookTypesDev.push(hookName);
    }
    function updateHookTypesDev() {
        var hookName = currentHookNameInDev;
        if (hookTypesDev !== null) {
            hookTypesUpdateIndexDev++;
            if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) warnOnHookMismatchInDev(hookName);
        }
    }
    function checkDepsAreArrayDev(deps) {
        if (deps !== undefined && deps !== null && !Array.isArray(deps)) // Verify deps, but only on mount to avoid extra checks.
        // It's unlikely their type would change as usually you define them inline.
        error1("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
    }
    function warnOnHookMismatchInDev(currentHookName) {
        var componentName = getComponentName(currentlyRenderingFiber$1.type);
        if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
            didWarnAboutMismatchedHooksForComponent.add(componentName);
            if (hookTypesDev !== null) {
                var table = '';
                var secondColumnStart = 30;
                for(var i = 0; i <= hookTypesUpdateIndexDev; i++){
                    var oldHookName = hookTypesDev[i];
                    var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                    var row = i + 1 + ". " + oldHookName; // Extra space so second column lines up
                    // lol @ IE not supporting String#repeat
                    while(row.length < secondColumnStart)row += ' ';
                    row += newHookName + '\n';
                    table += row;
                }
                error1("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
            }
        }
    }
    function throwInvalidHookError() {
        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
        if (ignorePreviousDependencies) // Only true when this component is being hot reloaded.
        return false;
        if (prevDeps === null) {
            error1("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            return false;
        }
        // Don't bother comparing lengths in prod because these arrays should be
        // passed inline.
        if (nextDeps.length !== prevDeps.length) error1("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(', ') + "]", "[" + nextDeps.join(', ') + "]");
        for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){
            if (objectIs(nextDeps[i], prevDeps[i])) continue;
            return false;
        }
        return true;
    }
    function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
        renderLanes1 = nextRenderLanes;
        currentlyRenderingFiber$1 = workInProgress;
        hookTypesDev = current !== null ? current._debugHookTypes : null;
        hookTypesUpdateIndexDev = -1; // Used for hot reloading:
        ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;
        workInProgress.memoizedState = null;
        workInProgress.updateQueue = null;
        workInProgress.lanes = NoLanes; // The following should have already been reset
        if (current !== null && current.memoizedState !== null) ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
        else if (hookTypesDev !== null) // This dispatcher handles an edge case where a component is updating,
        // but no stateful hooks have been used.
        // We want to match the production code behavior (which will use HooksDispatcherOnMount),
        // but with the extra DEV validation to ensure hooks ordering hasn't changed.
        // This dispatcher does that.
        ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
        else ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
        var children = Component(props, secondArg); // Check if there was a render phase update
        if (didScheduleRenderPhaseUpdateDuringThisPass) {
            // Keep rendering in a loop for as long as render phase updates continue to
            // be scheduled. Use a counter to prevent infinite loops.
            var numberOfReRenders = 0;
            do {
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                if (!(numberOfReRenders < RE_RENDER_LIMIT)) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                numberOfReRenders += 1;
                // Even when hot reloading, allow dependencies to stabilize
                // after first render to prevent infinite render phase updates.
                ignorePreviousDependencies = false;
                currentHook1 = null;
                workInProgressHook = null;
                workInProgress.updateQueue = null;
                // Also validate hook order for cascading updates.
                hookTypesUpdateIndexDev = -1;
                ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                children = Component(props, secondArg);
            }while (didScheduleRenderPhaseUpdateDuringThisPass)
        } // We can assume the previous dispatcher is always this one, since we set it
        // at the beginning of the render phase and there's no re-entrancy.
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        workInProgress._debugHookTypes = hookTypesDev;
        // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.
        var didRenderTooFewHooks = currentHook1 !== null && currentHook1.next !== null;
        renderLanes1 = NoLanes;
        currentlyRenderingFiber$1 = null;
        currentHook1 = null;
        workInProgressHook = null;
        currentHookNameInDev = null;
        hookTypesDev = null;
        hookTypesUpdateIndexDev = -1;
        didScheduleRenderPhaseUpdate = false;
        if (!!didRenderTooFewHooks) throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
        return children;
    }
    function bailoutHooks(current, workInProgress, lanes) {
        workInProgress.updateQueue = current.updateQueue;
        workInProgress.flags &= ~(Passive | Update);
        current.lanes = removeLanes(current.lanes, lanes);
    }
    function resetHooksAfterThrow() {
        // We can assume the previous dispatcher is always this one, since we set it
        // at the beginning of the render phase and there's no re-entrancy.
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        if (didScheduleRenderPhaseUpdate) {
            // There were render phase updates. These are only valid for this render
            // phase, which we are now aborting. Remove the updates from the queues so
            // they do not persist to the next render. Do not remove updates from hooks
            // that weren't processed.
            //
            // Only reset the updates from the queue if it has a clone. If it does
            // not have a clone, that means it wasn't processed, and the updates were
            // scheduled before we entered the render phase.
            var hook = currentlyRenderingFiber$1.memoizedState;
            while(hook !== null){
                var queue = hook.queue;
                if (queue !== null) queue.pending = null;
                hook = hook.next;
            }
            didScheduleRenderPhaseUpdate = false;
        }
        renderLanes1 = NoLanes;
        currentlyRenderingFiber$1 = null;
        currentHook1 = null;
        workInProgressHook = null;
        hookTypesDev = null;
        hookTypesUpdateIndexDev = -1;
        currentHookNameInDev = null;
        isUpdatingOpaqueValueInRenderPhase = false;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
    }
    function mountWorkInProgressHook() {
        var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        if (workInProgressHook === null) // This is the first hook in the list
        currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
        else // Append to the end of the list
        workInProgressHook = workInProgressHook.next = hook;
        return workInProgressHook;
    }
    function updateWorkInProgressHook() {
        // This function is used both for updates and for re-renders triggered by a
        // render phase update. It assumes there is either a current hook we can
        // clone, or a work-in-progress hook from a previous render pass that we can
        // use as a base. When we reach the end of the base list, we must switch to
        // the dispatcher used for mounts.
        var nextCurrentHook;
        if (currentHook1 === null) {
            var current = currentlyRenderingFiber$1.alternate;
            if (current !== null) nextCurrentHook = current.memoizedState;
            else nextCurrentHook = null;
        } else nextCurrentHook = currentHook1.next;
        var nextWorkInProgressHook;
        if (workInProgressHook === null) nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
        else nextWorkInProgressHook = workInProgressHook.next;
        if (nextWorkInProgressHook !== null) {
            // There's already a work-in-progress. Reuse it.
            workInProgressHook = nextWorkInProgressHook;
            nextWorkInProgressHook = workInProgressHook.next;
            currentHook1 = nextCurrentHook;
        } else {
            // Clone from the current hook.
            if (!(nextCurrentHook !== null)) throw Error("Rendered more hooks than during the previous render.");
            currentHook1 = nextCurrentHook;
            var newHook = {
                memoizedState: currentHook1.memoizedState,
                baseState: currentHook1.baseState,
                baseQueue: currentHook1.baseQueue,
                queue: currentHook1.queue,
                next: null
            };
            if (workInProgressHook === null) // This is the first hook in the list.
            currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
            else // Append to the end of the list.
            workInProgressHook = workInProgressHook.next = newHook;
        }
        return workInProgressHook;
    }
    function createFunctionComponentUpdateQueue() {
        return {
            lastEffect: null
        };
    }
    function basicStateReducer(state, action) {
        // $FlowFixMe: Flow doesn't like mixed types
        return typeof action === 'function' ? action(state) : action;
    }
    function mountReducer(reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        var initialState;
        if (init !== undefined) initialState = init(initialArg);
        else initialState = initialArg;
        hook.memoizedState = hook.baseState = initialState;
        var queue = hook.queue = {
            pending: null,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
        };
        var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
        return [
            hook.memoizedState,
            dispatch
        ];
    }
    function updateReducer(reducer, initialArg, init) {
        var hook = updateWorkInProgressHook();
        var queue = hook.queue;
        if (!(queue !== null)) throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
        queue.lastRenderedReducer = reducer;
        var current = currentHook1; // The last rebase update that is NOT part of the base state.
        var baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.
        var pendingQueue = queue.pending;
        if (pendingQueue !== null) {
            // We have new updates that haven't been processed yet.
            // We'll add them to the base queue.
            if (baseQueue !== null) {
                // Merge the pending queue and the base queue.
                var baseFirst = baseQueue.next;
                var pendingFirst = pendingQueue.next;
                baseQueue.next = pendingFirst;
                pendingQueue.next = baseFirst;
            }
            if (current.baseQueue !== baseQueue) // Internal invariant that should never happen, but feasibly could in
            // the future if we implement resuming, or some form of that.
            error1("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
            current.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
        }
        if (baseQueue !== null) {
            // We have a queue to process.
            var first = baseQueue.next;
            var newState = current.baseState;
            var newBaseState = null;
            var newBaseQueueFirst = null;
            var newBaseQueueLast = null;
            var update = first;
            do {
                var updateLane = update.lane;
                if (!isSubsetOfLanes(renderLanes1, updateLane)) {
                    // Priority is insufficient. Skip this update. If this is the first
                    // skipped update, the previous update/state is the new base
                    // update/state.
                    var clone = {
                        lane: updateLane,
                        action: update.action,
                        eagerReducer: update.eagerReducer,
                        eagerState: update.eagerState,
                        next: null
                    };
                    if (newBaseQueueLast === null) {
                        newBaseQueueFirst = newBaseQueueLast = clone;
                        newBaseState = newState;
                    } else newBaseQueueLast = newBaseQueueLast.next = clone;
                     // Update the remaining priority in the queue.
                    // TODO: Don't need to accumulate this. Instead, we can remove
                    // renderLanes from the original lanes.
                    currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                    markSkippedUpdateLanes(updateLane);
                } else {
                    // This update does have sufficient priority.
                    if (newBaseQueueLast !== null) {
                        var _clone = {
                            // This update is going to be committed so we never want uncommit
                            // it. Using NoLane works because 0 is a subset of all bitmasks, so
                            // this will never be skipped by the check above.
                            lane: NoLane,
                            action: update.action,
                            eagerReducer: update.eagerReducer,
                            eagerState: update.eagerState,
                            next: null
                        };
                        newBaseQueueLast = newBaseQueueLast.next = _clone;
                    } // Process this update.
                    if (update.eagerReducer === reducer) // If this update was processed eagerly, and its reducer matches the
                    // current reducer, we can use the eagerly computed state.
                    newState = update.eagerState;
                    else {
                        var action = update.action;
                        newState = reducer(newState, action);
                    }
                }
                update = update.next;
            }while (update !== null && update !== first)
            if (newBaseQueueLast === null) newBaseState = newState;
            else newBaseQueueLast.next = newBaseQueueFirst;
             // Mark that the fiber performed work, but only if the new state is
            // different from the current state.
            if (!objectIs(newState, hook.memoizedState)) markWorkInProgressReceivedUpdate();
            hook.memoizedState = newState;
            hook.baseState = newBaseState;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = newState;
        }
        var dispatch = queue.dispatch;
        return [
            hook.memoizedState,
            dispatch
        ];
    }
    function rerenderReducer(reducer, initialArg, init) {
        var hook = updateWorkInProgressHook();
        var queue = hook.queue;
        if (!(queue !== null)) throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
        queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous
        // work-in-progress hook.
        var dispatch = queue.dispatch;
        var lastRenderPhaseUpdate = queue.pending;
        var newState = hook.memoizedState;
        if (lastRenderPhaseUpdate !== null) {
            // The queue doesn't persist past this render pass.
            queue.pending = null;
            var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            var update = firstRenderPhaseUpdate;
            do {
                // Process this render phase update. We don't have to check the
                // priority because it will always be the same as the current
                // render's.
                var action = update.action;
                newState = reducer(newState, action);
                update = update.next;
            }while (update !== firstRenderPhaseUpdate) // Mark that the fiber performed work, but only if the new state is
            // different from the current state.
            if (!objectIs(newState, hook.memoizedState)) markWorkInProgressReceivedUpdate();
            hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to
            // the base state unless the queue is empty.
            // TODO: Not sure if this is the desired semantics, but it's what we
            // do for gDSFP. I can't remember why.
            if (hook.baseQueue === null) hook.baseState = newState;
            queue.lastRenderedState = newState;
        }
        return [
            newState,
            dispatch
        ];
    }
    function readFromUnsubcribedMutableSource(root, source, getSnapshot) {
        warnAboutMultipleRenderersDEV(source);
        var getVersion = source._getVersion;
        var version = getVersion(source._source); // Is it safe for this component to read from this source during the current render?
        var isSafeToReadFromSource = false; // Check the version first.
        // If this render has already been started with a specific version,
        // we can use it alone to determine if we can safely read from the source.
        var currentRenderVersion = getWorkInProgressVersion(source);
        if (currentRenderVersion !== null) // It's safe to read if the store hasn't been mutated since the last time
        // we read something.
        isSafeToReadFromSource = currentRenderVersion === version;
        else {
            // If there's no version, then this is the first time we've read from the
            // source during the current render pass, so we need to do a bit more work.
            // What we need to determine is if there are any hooks that already
            // subscribed to the source, and if so, whether there are any pending
            // mutations that haven't been synchronized yet.
            //
            // If there are no pending mutations, then `root.mutableReadLanes` will be
            // empty, and we know we can safely read.
            //
            // If there *are* pending mutations, we may still be able to safely read
            // if the currently rendering lanes are inclusive of the pending mutation
            // lanes, since that guarantees that the value we're about to read from
            // the source is consistent with the values that we read during the most
            // recent mutation.
            isSafeToReadFromSource = isSubsetOfLanes(renderLanes1, root.mutableReadLanes);
            if (isSafeToReadFromSource) // If it's safe to read from this source during the current render,
            // store the version in case other components read from it.
            // A changed version number will let those components know to throw and restart the render.
            setWorkInProgressVersion(source, version);
        }
        if (isSafeToReadFromSource) {
            var snapshot = getSnapshot(source._source);
            if (typeof snapshot === 'function') error1("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing.");
            return snapshot;
        } else {
            // This handles the special case of a mutable source being shared between renderers.
            // In that case, if the source is mutated between the first and second renderer,
            // The second renderer don't know that it needs to reset the WIP version during unwind,
            // (because the hook only marks sources as dirty if it's written to their WIP version).
            // That would cause this tear check to throw again and eventually be visible to the user.
            // We can avoid this infinite loop by explicitly marking the source as dirty.
            //
            // This can lead to tearing in the first renderer when it resumes,
            // but there's nothing we can do about that (short of throwing here and refusing to continue the render).
            markSourceAsDirty(source);
            throw Error("Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue.");
        }
    }
    function useMutableSource(hook, source, getSnapshot, subscribe) {
        var root = getWorkInProgressRoot();
        if (!(root !== null)) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        var getVersion = source._getVersion;
        var version = getVersion(source._source);
        var dispatcher = ReactCurrentDispatcher$1.current; // eslint-disable-next-line prefer-const
        var _dispatcher$useState = dispatcher.useState(function() {
            return readFromUnsubcribedMutableSource(root, source, getSnapshot);
        }), currentSnapshot = _dispatcher$useState[0], setSnapshot = _dispatcher$useState[1];
        var snapshot = currentSnapshot; // Grab a handle to the state hook as well.
        // We use it to clear the pending update queue if we have a new source.
        var stateHook = workInProgressHook;
        var memoizedState = hook.memoizedState;
        var refs = memoizedState.refs;
        var prevGetSnapshot = refs.getSnapshot;
        var prevSource = memoizedState.source;
        var prevSubscribe = memoizedState.subscribe;
        var fiber = currentlyRenderingFiber$1;
        hook.memoizedState = {
            refs: refs,
            source: source,
            subscribe: subscribe
        }; // Sync the values needed by our subscription handler after each commit.
        dispatcher.useEffect(function() {
            refs.getSnapshot = getSnapshot; // Normally the dispatch function for a state hook never changes,
            // but this hook recreates the queue in certain cases  to avoid updates from stale sources.
            // handleChange() below needs to reference the dispatch function without re-subscribing,
            // so we use a ref to ensure that it always has the latest version.
            refs.setSnapshot = setSnapshot; // Check for a possible change between when we last rendered now.
            var maybeNewVersion = getVersion(source._source);
            if (!objectIs(version, maybeNewVersion)) {
                var maybeNewSnapshot = getSnapshot(source._source);
                if (typeof maybeNewSnapshot === 'function') error1("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing.");
                if (!objectIs(snapshot, maybeNewSnapshot)) {
                    setSnapshot(maybeNewSnapshot);
                    var lane = requestUpdateLane(fiber);
                    markRootMutableRead(root, lane);
                } // If the source mutated between render and now,
                // there may be state updates already scheduled from the old source.
                // Entangle the updates so that they render in the same batch.
                markRootEntangled(root, root.mutableReadLanes);
            }
        }, [
            getSnapshot,
            source,
            subscribe
        ]); // If we got a new source or subscribe function, re-subscribe in a passive effect.
        dispatcher.useEffect(function() {
            var handleChange = function() {
                var latestGetSnapshot = refs.getSnapshot;
                var latestSetSnapshot = refs.setSnapshot;
                try {
                    latestSetSnapshot(latestGetSnapshot(source._source)); // Record a pending mutable source update with the same expiration time.
                    var lane = requestUpdateLane(fiber);
                    markRootMutableRead(root, lane);
                } catch (error) {
                    // A selector might throw after a source mutation.
                    // e.g. it might try to read from a part of the store that no longer exists.
                    // In this case we should still schedule an update with React.
                    // Worst case the selector will throw again and then an error boundary will handle it.
                    latestSetSnapshot(function() {
                        throw error;
                    });
                }
            };
            var unsubscribe = subscribe(source._source, handleChange);
            if (typeof unsubscribe !== 'function') error1('Mutable source subscribe function must return an unsubscribe function.');
            return unsubscribe;
        }, [
            source,
            subscribe
        ]); // If any of the inputs to useMutableSource change, reading is potentially unsafe.
        //
        // If either the source or the subscription have changed we can't can't trust the update queue.
        // Maybe the source changed in a way that the old subscription ignored but the new one depends on.
        //
        // If the getSnapshot function changed, we also shouldn't rely on the update queue.
        // It's possible that the underlying source was mutated between the when the last "change" event fired,
        // and when the current render (with the new getSnapshot function) is processed.
        //
        // In both cases, we need to throw away pending updates (since they are no longer relevant)
        // and treat reading from the source as we do in the mount case.
        if (!objectIs(prevGetSnapshot, getSnapshot) || !objectIs(prevSource, source) || !objectIs(prevSubscribe, subscribe)) {
            // Create a new queue and setState method,
            // So if there are interleaved updates, they get pushed to the older queue.
            // When this becomes current, the previous queue and dispatch method will be discarded,
            // including any interleaving updates that occur.
            var newQueue = {
                pending: null,
                dispatch: null,
                lastRenderedReducer: basicStateReducer,
                lastRenderedState: snapshot
            };
            newQueue.dispatch = setSnapshot = dispatchAction.bind(null, currentlyRenderingFiber$1, newQueue);
            stateHook.queue = newQueue;
            stateHook.baseQueue = null;
            snapshot = readFromUnsubcribedMutableSource(root, source, getSnapshot);
            stateHook.memoizedState = stateHook.baseState = snapshot;
        }
        return snapshot;
    }
    function mountMutableSource(source, getSnapshot, subscribe) {
        var hook = mountWorkInProgressHook();
        hook.memoizedState = {
            refs: {
                getSnapshot: getSnapshot,
                setSnapshot: null
            },
            source: source,
            subscribe: subscribe
        };
        return useMutableSource(hook, source, getSnapshot, subscribe);
    }
    function updateMutableSource(source, getSnapshot, subscribe) {
        var hook = updateWorkInProgressHook();
        return useMutableSource(hook, source, getSnapshot, subscribe);
    }
    function mountState(initialState) {
        var hook = mountWorkInProgressHook();
        if (typeof initialState === 'function') // $FlowFixMe: Flow doesn't like mixed types
        initialState = initialState();
        hook.memoizedState = hook.baseState = initialState;
        var queue = hook.queue = {
            pending: null,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
        };
        var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
        return [
            hook.memoizedState,
            dispatch
        ];
    }
    function updateState(initialState) {
        return updateReducer(basicStateReducer);
    }
    function rerenderState(initialState) {
        return rerenderReducer(basicStateReducer);
    }
    function pushEffect(tag, create, destroy, deps) {
        var effect = {
            tag: tag,
            create: create,
            destroy: destroy,
            deps: deps,
            // Circular
            next: null
        };
        var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
        if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.lastEffect = effect.next = effect;
        } else {
            var lastEffect = componentUpdateQueue.lastEffect;
            if (lastEffect === null) componentUpdateQueue.lastEffect = effect.next = effect;
            else {
                var firstEffect = lastEffect.next;
                lastEffect.next = effect;
                effect.next = firstEffect;
                componentUpdateQueue.lastEffect = effect;
            }
        }
        return effect;
    }
    function mountRef(initialValue) {
        var hook = mountWorkInProgressHook();
        var ref = {
            current: initialValue
        };
        Object.seal(ref);
        hook.memoizedState = ref;
        return ref;
    }
    function updateRef(initialValue) {
        var hook = updateWorkInProgressHook();
        return hook.memoizedState;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        currentlyRenderingFiber$1.flags |= fiberFlags;
        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var destroy = undefined;
        if (currentHook1 !== null) {
            var prevEffect = currentHook1.memoizedState;
            destroy = prevEffect.destroy;
            if (nextDeps !== null) {
                var prevDeps = prevEffect.deps;
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                    pushEffect(hookFlags, create, destroy, nextDeps);
                    return;
                }
            }
        }
        currentlyRenderingFiber$1.flags |= fiberFlags;
        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
    }
    function mountEffect(create, deps) {
        // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
        if ('undefined' !== typeof jest) warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
        return mountEffectImpl(Update | Passive, Passive$1, create, deps);
    }
    function updateEffect(create, deps) {
        // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
        if ('undefined' !== typeof jest) warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
        return updateEffectImpl(Update | Passive, Passive$1, create, deps);
    }
    function mountLayoutEffect(create, deps) {
        return mountEffectImpl(Update, Layout, create, deps);
    }
    function updateLayoutEffect(create, deps) {
        return updateEffectImpl(Update, Layout, create, deps);
    }
    function imperativeHandleEffect(create, ref) {
        if (typeof ref === 'function') {
            var refCallback = ref;
            var _inst = create();
            refCallback(_inst);
            return function() {
                refCallback(null);
            };
        } else if (ref !== null && ref !== undefined) {
            var refObject = ref;
            if (!refObject.hasOwnProperty('current')) error1("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", 'an object with keys {' + Object.keys(refObject).join(', ') + '}');
            var _inst2 = create();
            refObject.current = _inst2;
            return function() {
                refObject.current = null;
            };
        }
    }
    function mountImperativeHandle(ref, create, deps) {
        if (typeof create !== 'function') error1("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : 'null');
        var effectDeps = deps !== null && deps !== undefined ? deps.concat([
            ref
        ]) : null;
        return mountEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
    }
    function updateImperativeHandle(ref, create, deps) {
        if (typeof create !== 'function') error1("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : 'null');
        var effectDeps = deps !== null && deps !== undefined ? deps.concat([
            ref
        ]) : null;
        return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
    }
    function mountDebugValue(value, formatterFn) {
    // The react-debug-hooks package injects its own implementation
    // so that e.g. DevTools can display custom hook values.
    }
    var updateDebugValue = mountDebugValue;
    function mountCallback(callback, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        hook.memoizedState = [
            callback,
            nextDeps
        ];
        return callback;
    }
    function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var prevState = hook.memoizedState;
        if (prevState !== null) {
            if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) return prevState[0];
            }
        }
        hook.memoizedState = [
            callback,
            nextDeps
        ];
        return callback;
    }
    function mountMemo(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var nextValue = nextCreate();
        hook.memoizedState = [
            nextValue,
            nextDeps
        ];
        return nextValue;
    }
    function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var prevState = hook.memoizedState;
        if (prevState !== null) // Assume these are defined. If they're not, areHookInputsEqual will warn.
        {
            if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) return prevState[0];
            }
        }
        var nextValue = nextCreate();
        hook.memoizedState = [
            nextValue,
            nextDeps
        ];
        return nextValue;
    }
    function mountDeferredValue(value) {
        var _mountState = mountState(value), prevValue = _mountState[0], setValue = _mountState[1];
        mountEffect(function() {
            var prevTransition = ReactCurrentBatchConfig$1.transition;
            ReactCurrentBatchConfig$1.transition = 1;
            try {
                setValue(value);
            } finally{
                ReactCurrentBatchConfig$1.transition = prevTransition;
            }
        }, [
            value
        ]);
        return prevValue;
    }
    function updateDeferredValue(value) {
        var _updateState = updateState(), prevValue = _updateState[0], setValue = _updateState[1];
        updateEffect(function() {
            var prevTransition = ReactCurrentBatchConfig$1.transition;
            ReactCurrentBatchConfig$1.transition = 1;
            try {
                setValue(value);
            } finally{
                ReactCurrentBatchConfig$1.transition = prevTransition;
            }
        }, [
            value
        ]);
        return prevValue;
    }
    function rerenderDeferredValue(value) {
        var _rerenderState = rerenderState(), prevValue = _rerenderState[0], setValue = _rerenderState[1];
        updateEffect(function() {
            var prevTransition = ReactCurrentBatchConfig$1.transition;
            ReactCurrentBatchConfig$1.transition = 1;
            try {
                setValue(value);
            } finally{
                ReactCurrentBatchConfig$1.transition = prevTransition;
            }
        }, [
            value
        ]);
        return prevValue;
    }
    function startTransition(setPending, callback) {
        var priorityLevel = getCurrentPriorityLevel();
        runWithPriority$1(priorityLevel < UserBlockingPriority$2 ? UserBlockingPriority$2 : priorityLevel, function() {
            setPending(true);
        });
        runWithPriority$1(priorityLevel > NormalPriority$1 ? NormalPriority$1 : priorityLevel, function() {
            var prevTransition = ReactCurrentBatchConfig$1.transition;
            ReactCurrentBatchConfig$1.transition = 1;
            try {
                setPending(false);
                callback();
            } finally{
                ReactCurrentBatchConfig$1.transition = prevTransition;
            }
        });
    }
    function mountTransition() {
        var _mountState2 = mountState(false), isPending = _mountState2[0], setPending = _mountState2[1]; // The `start` method can be stored on a ref, since `setPending`
        // never changes.
        var start = startTransition.bind(null, setPending);
        mountRef(start);
        return [
            start,
            isPending
        ];
    }
    function updateTransition() {
        var _updateState2 = updateState(), isPending = _updateState2[0];
        var startRef = updateRef();
        var start = startRef.current;
        return [
            start,
            isPending
        ];
    }
    function rerenderTransition() {
        var _rerenderState2 = rerenderState(), isPending = _rerenderState2[0];
        var startRef = updateRef();
        var start = startRef.current;
        return [
            start,
            isPending
        ];
    }
    var isUpdatingOpaqueValueInRenderPhase = false;
    function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
        return isUpdatingOpaqueValueInRenderPhase;
    }
    function warnOnOpaqueIdentifierAccessInDEV(fiber) {
        // TODO: Should warn in effects and callbacks, too
        var name = getComponentName(fiber.type) || 'Unknown';
        if (getIsRendering() && !didWarnAboutUseOpaqueIdentifier[name]) {
            error1("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.");
            didWarnAboutUseOpaqueIdentifier[name] = true;
        }
    }
    function mountOpaqueIdentifier() {
        var makeId = makeClientIdInDEV.bind(null, warnOnOpaqueIdentifierAccessInDEV.bind(null, currentlyRenderingFiber$1));
        if (getIsHydrating()) {
            var didUpgrade = false;
            var fiber = currentlyRenderingFiber$1;
            var readValue = function() {
                if (!didUpgrade) {
                    // Only upgrade once. This works even inside the render phase because
                    // the update is added to a shared queue, which outlasts the
                    // in-progress render.
                    didUpgrade = true;
                    isUpdatingOpaqueValueInRenderPhase = true;
                    setId(makeId());
                    isUpdatingOpaqueValueInRenderPhase = false;
                    warnOnOpaqueIdentifierAccessInDEV(fiber);
                }
                throw Error("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.");
            };
            var id = makeOpaqueHydratingObject(readValue);
            var setId = mountState(id)[1];
            if ((currentlyRenderingFiber$1.mode & BlockingMode) === NoMode) {
                currentlyRenderingFiber$1.flags |= Update | Passive;
                pushEffect(HasEffect | Passive$1, function() {
                    setId(makeId());
                }, undefined, null);
            }
            return id;
        } else {
            var _id = makeId();
            mountState(_id);
            return _id;
        }
    }
    function updateOpaqueIdentifier() {
        var id = updateState()[0];
        return id;
    }
    function rerenderOpaqueIdentifier() {
        var id = rerenderState()[0];
        return id;
    }
    function dispatchAction(fiber, queue, action) {
        if (typeof arguments[3] === 'function') error1("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
        var eventTime = requestEventTime();
        var lane = requestUpdateLane(fiber);
        var update = {
            lane: lane,
            action: action,
            eagerReducer: null,
            eagerState: null,
            next: null
        }; // Append the update to the end of the list.
        var pending = queue.pending;
        if (pending === null) // This is the first update. Create a circular list.
        update.next = update;
        else {
            update.next = pending.next;
            pending.next = update;
        }
        queue.pending = update;
        var alternate = fiber.alternate;
        if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) // This is a render phase update. Stash it in a lazily-created map of
        // queue -> linked list of updates. After this render pass, we'll restart
        // and apply the stashed updates on top of the work-in-progress hook.
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        else {
            if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                // The queue is currently empty, which means we can eagerly compute the
                // next state before entering the render phase. If the new state is the
                // same as the current state, we may be able to bail out entirely.
                var lastRenderedReducer = queue.lastRenderedReducer;
                if (lastRenderedReducer !== null) {
                    var prevDispatcher;
                    prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        var currentState = queue.lastRenderedState;
                        var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute
                        // it, on the update object. If the reducer hasn't changed by the
                        // time we enter the render phase, then the eager state can be used
                        // without calling the reducer again.
                        update.eagerReducer = lastRenderedReducer;
                        update.eagerState = eagerState;
                        if (objectIs(eagerState, currentState)) // Fast path. We can bail out without scheduling React to re-render.
                        // It's still possible that we'll need to rebase this update later,
                        // if the component re-renders for a different reason and by that
                        // time the reducer has changed.
                        return;
                    } catch (error) {
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                }
            }
            // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
            if ('undefined' !== typeof jest) {
                warnIfNotScopedWithMatchingAct(fiber);
                warnIfNotCurrentlyActingUpdatesInDev(fiber);
            }
            scheduleUpdateOnFiber(fiber, lane, eventTime);
        }
    }
    var ContextOnlyDispatcher = {
        readContext: readContext,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useMutableSource: throwInvalidHookError,
        useOpaqueIdentifier: throwInvalidHookError,
        unstable_isNewReconciler: enableNewReconciler
    };
    var HooksDispatcherOnMountInDEV = null;
    var HooksDispatcherOnMountWithHookTypesInDEV = null;
    var HooksDispatcherOnUpdateInDEV = null;
    var HooksDispatcherOnRerenderInDEV = null;
    var InvalidNestedHooksDispatcherOnMountInDEV = null;
    var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
    var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
    var warnInvalidContextAccess = function() {
        error1("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
    };
    var warnInvalidHookAccess = function() {
        error1("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
    };
    HooksDispatcherOnMountInDEV = {
        readContext: function(context, observedBits) {
            return readContext(context, observedBits);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = 'useCallback';
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback, deps);
        },
        useContext: function(context, observedBits) {
            currentHookNameInDev = 'useContext';
            mountHookTypesDev();
            return readContext(context, observedBits);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = 'useEffect';
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = 'useImperativeHandle';
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = 'useLayoutEffect';
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = 'useMemo';
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountMemo(create, deps);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = 'useReducer';
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountReducer(reducer, initialArg, init);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = 'useRef';
            mountHookTypesDev();
            return mountRef(initialValue);
        },
        useState: function(initialState) {
            currentHookNameInDev = 'useState';
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountState(initialState);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = 'useDebugValue';
            mountHookTypesDev();
            return mountDebugValue();
        },
        useDeferredValue: function(value) {
            currentHookNameInDev = 'useDeferredValue';
            mountHookTypesDev();
            return mountDeferredValue(value);
        },
        useTransition: function() {
            currentHookNameInDev = 'useTransition';
            mountHookTypesDev();
            return mountTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = 'useMutableSource';
            mountHookTypesDev();
            return mountMutableSource(source, getSnapshot, subscribe);
        },
        useOpaqueIdentifier: function() {
            currentHookNameInDev = 'useOpaqueIdentifier';
            mountHookTypesDev();
            return mountOpaqueIdentifier();
        },
        unstable_isNewReconciler: enableNewReconciler
    };
    HooksDispatcherOnMountWithHookTypesInDEV = {
        readContext: function(context, observedBits) {
            return readContext(context, observedBits);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = 'useCallback';
            updateHookTypesDev();
            return mountCallback(callback, deps);
        },
        useContext: function(context, observedBits) {
            currentHookNameInDev = 'useContext';
            updateHookTypesDev();
            return readContext(context, observedBits);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = 'useEffect';
            updateHookTypesDev();
            return mountEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = 'useImperativeHandle';
            updateHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = 'useLayoutEffect';
            updateHookTypesDev();
            return mountLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = 'useMemo';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountMemo(create, deps);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = 'useReducer';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountReducer(reducer, initialArg, init);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = 'useRef';
            updateHookTypesDev();
            return mountRef(initialValue);
        },
        useState: function(initialState) {
            currentHookNameInDev = 'useState';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountState(initialState);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = 'useDebugValue';
            updateHookTypesDev();
            return mountDebugValue();
        },
        useDeferredValue: function(value) {
            currentHookNameInDev = 'useDeferredValue';
            updateHookTypesDev();
            return mountDeferredValue(value);
        },
        useTransition: function() {
            currentHookNameInDev = 'useTransition';
            updateHookTypesDev();
            return mountTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = 'useMutableSource';
            updateHookTypesDev();
            return mountMutableSource(source, getSnapshot, subscribe);
        },
        useOpaqueIdentifier: function() {
            currentHookNameInDev = 'useOpaqueIdentifier';
            updateHookTypesDev();
            return mountOpaqueIdentifier();
        },
        unstable_isNewReconciler: enableNewReconciler
    };
    HooksDispatcherOnUpdateInDEV = {
        readContext: function(context, observedBits) {
            return readContext(context, observedBits);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = 'useCallback';
            updateHookTypesDev();
            return updateCallback(callback, deps);
        },
        useContext: function(context, observedBits) {
            currentHookNameInDev = 'useContext';
            updateHookTypesDev();
            return readContext(context, observedBits);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = 'useEffect';
            updateHookTypesDev();
            return updateEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = 'useImperativeHandle';
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = 'useLayoutEffect';
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = 'useMemo';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateMemo(create, deps);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = 'useReducer';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateReducer(reducer, initialArg, init);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = 'useRef';
            updateHookTypesDev();
            return updateRef();
        },
        useState: function(initialState) {
            currentHookNameInDev = 'useState';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateState(initialState);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = 'useDebugValue';
            updateHookTypesDev();
            return updateDebugValue();
        },
        useDeferredValue: function(value) {
            currentHookNameInDev = 'useDeferredValue';
            updateHookTypesDev();
            return updateDeferredValue(value);
        },
        useTransition: function() {
            currentHookNameInDev = 'useTransition';
            updateHookTypesDev();
            return updateTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = 'useMutableSource';
            updateHookTypesDev();
            return updateMutableSource(source, getSnapshot, subscribe);
        },
        useOpaqueIdentifier: function() {
            currentHookNameInDev = 'useOpaqueIdentifier';
            updateHookTypesDev();
            return updateOpaqueIdentifier();
        },
        unstable_isNewReconciler: enableNewReconciler
    };
    HooksDispatcherOnRerenderInDEV = {
        readContext: function(context, observedBits) {
            return readContext(context, observedBits);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = 'useCallback';
            updateHookTypesDev();
            return updateCallback(callback, deps);
        },
        useContext: function(context, observedBits) {
            currentHookNameInDev = 'useContext';
            updateHookTypesDev();
            return readContext(context, observedBits);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = 'useEffect';
            updateHookTypesDev();
            return updateEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = 'useImperativeHandle';
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = 'useLayoutEffect';
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = 'useMemo';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
                return updateMemo(create, deps);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = 'useReducer';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
                return rerenderReducer(reducer, initialArg, init);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = 'useRef';
            updateHookTypesDev();
            return updateRef();
        },
        useState: function(initialState) {
            currentHookNameInDev = 'useState';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
                return rerenderState(initialState);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = 'useDebugValue';
            updateHookTypesDev();
            return updateDebugValue();
        },
        useDeferredValue: function(value) {
            currentHookNameInDev = 'useDeferredValue';
            updateHookTypesDev();
            return rerenderDeferredValue(value);
        },
        useTransition: function() {
            currentHookNameInDev = 'useTransition';
            updateHookTypesDev();
            return rerenderTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = 'useMutableSource';
            updateHookTypesDev();
            return updateMutableSource(source, getSnapshot, subscribe);
        },
        useOpaqueIdentifier: function() {
            currentHookNameInDev = 'useOpaqueIdentifier';
            updateHookTypesDev();
            return rerenderOpaqueIdentifier();
        },
        unstable_isNewReconciler: enableNewReconciler
    };
    InvalidNestedHooksDispatcherOnMountInDEV = {
        readContext: function(context, observedBits) {
            warnInvalidContextAccess();
            return readContext(context, observedBits);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = 'useCallback';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback, deps);
        },
        useContext: function(context, observedBits) {
            currentHookNameInDev = 'useContext';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context, observedBits);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = 'useEffect';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = 'useImperativeHandle';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = 'useLayoutEffect';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = 'useMemo';
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountMemo(create, deps);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = 'useReducer';
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountReducer(reducer, initialArg, init);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = 'useRef';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue);
        },
        useState: function(initialState) {
            currentHookNameInDev = 'useState';
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountState(initialState);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = 'useDebugValue';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDebugValue();
        },
        useDeferredValue: function(value) {
            currentHookNameInDev = 'useDeferredValue';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDeferredValue(value);
        },
        useTransition: function() {
            currentHookNameInDev = 'useTransition';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = 'useMutableSource';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountMutableSource(source, getSnapshot, subscribe);
        },
        useOpaqueIdentifier: function() {
            currentHookNameInDev = 'useOpaqueIdentifier';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountOpaqueIdentifier();
        },
        unstable_isNewReconciler: enableNewReconciler
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV = {
        readContext: function(context, observedBits) {
            warnInvalidContextAccess();
            return readContext(context, observedBits);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = 'useCallback';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
        },
        useContext: function(context, observedBits) {
            currentHookNameInDev = 'useContext';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context, observedBits);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = 'useEffect';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = 'useImperativeHandle';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = 'useLayoutEffect';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = 'useMemo';
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateMemo(create, deps);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = 'useReducer';
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateReducer(reducer, initialArg, init);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = 'useRef';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateRef();
        },
        useState: function(initialState) {
            currentHookNameInDev = 'useState';
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateState(initialState);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = 'useDebugValue';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDebugValue();
        },
        useDeferredValue: function(value) {
            currentHookNameInDev = 'useDeferredValue';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDeferredValue(value);
        },
        useTransition: function() {
            currentHookNameInDev = 'useTransition';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = 'useMutableSource';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateMutableSource(source, getSnapshot, subscribe);
        },
        useOpaqueIdentifier: function() {
            currentHookNameInDev = 'useOpaqueIdentifier';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateOpaqueIdentifier();
        },
        unstable_isNewReconciler: enableNewReconciler
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV = {
        readContext: function(context, observedBits) {
            warnInvalidContextAccess();
            return readContext(context, observedBits);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = 'useCallback';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
        },
        useContext: function(context, observedBits) {
            currentHookNameInDev = 'useContext';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context, observedBits);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = 'useEffect';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = 'useImperativeHandle';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = 'useLayoutEffect';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = 'useMemo';
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateMemo(create, deps);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = 'useReducer';
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return rerenderReducer(reducer, initialArg, init);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = 'useRef';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateRef();
        },
        useState: function(initialState) {
            currentHookNameInDev = 'useState';
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return rerenderState(initialState);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = 'useDebugValue';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDebugValue();
        },
        useDeferredValue: function(value) {
            currentHookNameInDev = 'useDeferredValue';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderDeferredValue(value);
        },
        useTransition: function() {
            currentHookNameInDev = 'useTransition';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = 'useMutableSource';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateMutableSource(source, getSnapshot, subscribe);
        },
        useOpaqueIdentifier: function() {
            currentHookNameInDev = 'useOpaqueIdentifier';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderOpaqueIdentifier();
        },
        unstable_isNewReconciler: enableNewReconciler
    };
    var now$1 = Scheduler.unstable_now;
    var commitTime1 = 0;
    var profilerStartTime = -1;
    function getCommitTime() {
        return commitTime1;
    }
    function recordCommitTime() {
        commitTime1 = now$1();
    }
    function startProfilerTimer(fiber) {
        profilerStartTime = now$1();
        if (fiber.actualStartTime < 0) fiber.actualStartTime = now$1();
    }
    function stopProfilerTimerIfRunning(fiber) {
        profilerStartTime = -1;
    }
    function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
        if (profilerStartTime >= 0) {
            var elapsedTime = now$1() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            if (overrideBaseTime) fiber.selfBaseDuration = elapsedTime;
            profilerStartTime = -1;
        }
    }
    function transferActualDuration(fiber) {
        // Transfer time spent rendering these children so we don't lose it
        // after we rerender. This is used as a helper in special cases
        // where we should count the work of multiple passes.
        var child = fiber.child;
        while(child){
            fiber.actualDuration += child.actualDuration;
            child = child.sibling;
        }
    }
    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
    var didReceiveUpdate = false;
    var didWarnAboutBadClass;
    var didWarnAboutModulePatternComponent;
    var didWarnAboutContextTypeOnFunctionComponent;
    var didWarnAboutGetDerivedStateOnFunctionComponent;
    var didWarnAboutFunctionRefs;
    var didWarnAboutReassigningProps;
    var didWarnAboutRevealOrder;
    var didWarnAboutTailOptions;
    didWarnAboutBadClass = {
    };
    didWarnAboutModulePatternComponent = {
    };
    didWarnAboutContextTypeOnFunctionComponent = {
    };
    didWarnAboutGetDerivedStateOnFunctionComponent = {
    };
    didWarnAboutFunctionRefs = {
    };
    didWarnAboutReassigningProps = false;
    didWarnAboutRevealOrder = {
    };
    didWarnAboutTailOptions = {
    };
    function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
        if (current === null) // If this is a fresh new component that hasn't been rendered yet, we
        // won't update its child set by applying minimal side-effects. Instead,
        // we will add them all to the child before it gets rendered. That means
        // we can optimize this reconciliation pass by not tracking side-effects.
        workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);
        else // If the current child is the same as the work in progress, it means that
        // we haven't yet started any work on these children. Therefore, we use
        // the clone algorithm to create a copy of all the current children.
        // If we had any progressed work already, that is invalid at this point so
        // let's throw it out.
        workInProgress.child = reconcileChildFibers1(workInProgress, current.child, nextChildren, renderLanes);
    }
    function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {
        // This function is fork of reconcileChildren. It's used in cases where we
        // want to reconcile without matching against the existing set. This has the
        // effect of all current children being unmounted; even if the type and key
        // are the same, the old child is unmounted and a new child is created.
        //
        // To do this, we're going to go through the reconcile algorithm twice. In
        // the first pass, we schedule a deletion for all the current children by
        // passing null.
        workInProgress.child = reconcileChildFibers1(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we
        // pass null in place of where we usually pass the current child set. This has
        // the effect of remounting all children regardless of whether their
        // identities match.
        workInProgress.child = reconcileChildFibers1(workInProgress, null, nextChildren, renderLanes);
    }
    function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
        if (workInProgress.type !== workInProgress.elementType) {
            // Lazy component props can't be validated in createElement
            // because they're only guaranteed to be resolved here.
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentName(Component));
        }
        var render = Component.render;
        var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent
        var nextChildren;
        prepareToReadContext(workInProgress, renderLanes);
        ReactCurrentOwner$1.current = workInProgress;
        setIsRendering(true);
        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);
        if (workInProgress.mode & StrictMode) {
            disableLogs();
            try {
                nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);
            } finally{
                reenableLogs();
            }
        }
        setIsRendering(false);
        if (current !== null && !didReceiveUpdate) {
            bailoutHooks(current, workInProgress, renderLanes);
            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
        } // React DevTools reads this flag.
        workInProgress.flags |= PerformedWork;
        reconcileChildren(current, workInProgress, nextChildren, renderLanes);
        return workInProgress.child;
    }
    function updateMemoComponent(current, workInProgress, Component, nextProps, updateLanes, renderLanes) {
        if (current === null) {
            var type = Component.type;
            if (isSimpleFunctionComponent(type) && Component.compare === null && Component.defaultProps === undefined) {
                var resolvedType = type;
                resolvedType = resolveFunctionForHotReloading(type);
                // and with only the default shallow comparison, we upgrade it
                // to a SimpleMemoComponent to allow fast path updates.
                workInProgress.tag = SimpleMemoComponent;
                workInProgress.type = resolvedType;
                validateFunctionComponentInDev(workInProgress, type);
                return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, updateLanes, renderLanes);
            }
            var innerPropTypes = type.propTypes;
            if (innerPropTypes) // Inner memo component props aren't currently validated in createElement.
            // We could move it there, but we'd still need this for lazy code path.
            checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentName(type));
            var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);
            child.ref = workInProgress.ref;
            child.return = workInProgress;
            workInProgress.child = child;
            return child;
        }
        var _type = Component.type;
        var _innerPropTypes = _type.propTypes;
        if (_innerPropTypes) // Inner memo component props aren't currently validated in createElement.
        // We could move it there, but we'd still need this for lazy code path.
        checkPropTypes(_innerPropTypes, nextProps, 'prop', getComponentName(_type));
        var currentChild = current.child; // This is always exactly one child
        if (!includesSomeLane(updateLanes, renderLanes)) {
            // This will be the props with resolved defaultProps,
            // unlike current.memoizedProps which will be the unresolved ones.
            var prevProps = currentChild.memoizedProps; // Default to shallow comparison
            var compare = Component.compare;
            compare = compare !== null ? compare : shallowEqual;
            if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
        } // React DevTools reads this flag.
        workInProgress.flags |= PerformedWork;
        var newChild = createWorkInProgress(currentChild, nextProps);
        newChild.ref = workInProgress.ref;
        newChild.return = workInProgress;
        workInProgress.child = newChild;
        return newChild;
    }
    function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, updateLanes, renderLanes) {
        if (workInProgress.type !== workInProgress.elementType) {
            // Lazy component props can't be validated in createElement
            // because they're only guaranteed to be resolved here.
            var outerMemoType = workInProgress.elementType;
            if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                // We warn when you define propTypes on lazy()
                // so let's just skip over it to find memo() outer wrapper.
                // Inner props for memo are validated later.
                var lazyComponent = outerMemoType;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    outerMemoType = init(payload);
                } catch (x) {
                    outerMemoType = null;
                } // Inner propTypes will be validated in the function component path.
                var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                if (outerPropTypes) checkPropTypes(outerPropTypes, nextProps, 'prop', getComponentName(outerMemoType));
            }
        }
        if (current !== null) {
            var prevProps = current.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) {
                didReceiveUpdate = false;
                if (!includesSomeLane(renderLanes, updateLanes)) {
                    // The pending lanes were cleared at the beginning of beginWork. We're
                    // about to bail out, but there might be other lanes that weren't
                    // included in the current render. Usually, the priority level of the
                    // remaining updates is accumlated during the evaluation of the
                    // component (i.e. when processing the update queue). But since since
                    // we're bailing out early *without* evaluating the component, we need
                    // to account for it here, too. Reset to the value of the current fiber.
                    // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,
                    // because a MemoComponent fiber does not have hooks or an update queue;
                    // rather, it wraps around an inner component, which may or may not
                    // contains hooks.
                    // TODO: Move the reset at in beginWork out of the common path so that
                    // this is no longer necessary.
                    workInProgress.lanes = current.lanes;
                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) // This is a special case that only exists for legacy mode.
                // See https://github.com/facebook/react/pull/19216.
                didReceiveUpdate = true;
            }
        }
        return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
    }
    function updateOffscreenComponent(current, workInProgress, renderLanes) {
        var nextProps = workInProgress.pendingProps;
        var nextChildren = nextProps.children;
        var prevState = current !== null ? current.memoizedState : null;
        if (nextProps.mode === 'hidden' || nextProps.mode === 'unstable-defer-without-hiding') {
            if ((workInProgress.mode & ConcurrentMode) === NoMode) {
                // In legacy sync mode, don't defer the subtree. Render it now.
                // TODO: Figure out what we should do in Blocking mode.
                var nextState = {
                    baseLanes: NoLanes
                };
                workInProgress.memoizedState = nextState;
                pushRenderLanes(workInProgress, renderLanes);
            } else if (!includesSomeLane(renderLanes, OffscreenLane)) {
                var nextBaseLanes;
                if (prevState !== null) {
                    var prevBaseLanes = prevState.baseLanes;
                    nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);
                } else nextBaseLanes = renderLanes;
                 // Schedule this fiber to re-render at offscreen priority. Then bailout.
                markSpawnedWork(OffscreenLane);
                workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);
                var _nextState = {
                    baseLanes: nextBaseLanes
                };
                workInProgress.memoizedState = _nextState; // We're about to bail out, but we need to push this to the stack anyway
                // to avoid a push/pop misalignment.
                pushRenderLanes(workInProgress, nextBaseLanes);
                return null;
            } else {
                // Rendering at offscreen, so we can clear the base lanes.
                var _nextState2 = {
                    baseLanes: NoLanes
                };
                workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.
                var subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;
                pushRenderLanes(workInProgress, subtreeRenderLanes);
            }
        } else {
            var _subtreeRenderLanes;
            if (prevState !== null) {
                _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes); // Since we're not hidden anymore, reset the state
                workInProgress.memoizedState = null;
            } else // We weren't previously hidden, and we still aren't, so there's nothing
            // special to do. Need to push to the stack regardless, though, to avoid
            // a push/pop misalignment.
            _subtreeRenderLanes = renderLanes;
            pushRenderLanes(workInProgress, _subtreeRenderLanes);
        }
        reconcileChildren(current, workInProgress, nextChildren, renderLanes);
        return workInProgress.child;
    } // Note: These happen to have identical begin phases, for now. We shouldn't hold
    // ourselves to this constraint, though. If the behavior diverges, we should
    // fork the function.
    var updateLegacyHiddenComponent = updateOffscreenComponent;
    function updateFragment1(current, workInProgress, renderLanes) {
        var nextChildren = workInProgress.pendingProps;
        reconcileChildren(current, workInProgress, nextChildren, renderLanes);
        return workInProgress.child;
    }
    function updateMode(current, workInProgress, renderLanes) {
        var nextChildren = workInProgress.pendingProps.children;
        reconcileChildren(current, workInProgress, nextChildren, renderLanes);
        return workInProgress.child;
    }
    function updateProfiler(current, workInProgress, renderLanes) {
        workInProgress.flags |= Update; // Reset effect durations for the next eventual effect phase.
        // These are reset during render to allow the DevTools commit hook a chance to read them,
        var stateNode = workInProgress.stateNode;
        stateNode.effectDuration = 0;
        stateNode.passiveEffectDuration = 0;
        var nextProps = workInProgress.pendingProps;
        var nextChildren = nextProps.children;
        reconcileChildren(current, workInProgress, nextChildren, renderLanes);
        return workInProgress.child;
    }
    function markRef(current, workInProgress) {
        var ref = workInProgress.ref;
        if (current === null && ref !== null || current !== null && current.ref !== ref) // Schedule a Ref effect
        workInProgress.flags |= Ref;
    }
    function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
        if (workInProgress.type !== workInProgress.elementType) {
            // Lazy component props can't be validated in createElement
            // because they're only guaranteed to be resolved here.
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentName(Component));
        }
        var context;
        var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
        context = getMaskedContext(workInProgress, unmaskedContext);
        var nextChildren;
        prepareToReadContext(workInProgress, renderLanes);
        ReactCurrentOwner$1.current = workInProgress;
        setIsRendering(true);
        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);
        if (workInProgress.mode & StrictMode) {
            disableLogs();
            try {
                nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);
            } finally{
                reenableLogs();
            }
        }
        setIsRendering(false);
        if (current !== null && !didReceiveUpdate) {
            bailoutHooks(current, workInProgress, renderLanes);
            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
        } // React DevTools reads this flag.
        workInProgress.flags |= PerformedWork;
        reconcileChildren(current, workInProgress, nextChildren, renderLanes);
        return workInProgress.child;
    }
    function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {
        if (workInProgress.type !== workInProgress.elementType) {
            // Lazy component props can't be validated in createElement
            // because they're only guaranteed to be resolved here.
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentName(Component));
        }
        // During mounting we don't know the child context yet as the instance doesn't exist.
        // We will invalidate the child context in finishClassComponent() right after rendering.
        var hasContext;
        if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress);
        } else hasContext = false;
        prepareToReadContext(workInProgress, renderLanes);
        var instance = workInProgress.stateNode;
        var shouldUpdate;
        if (instance === null) {
            if (current !== null) {
                // A class component without an instance only mounts if it suspended
                // inside a non-concurrent tree, in an inconsistent state. We want to
                // treat it like a new mount, even though an empty version of it already
                // committed. Disconnect the alternate pointers.
                current.alternate = null;
                workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect
                workInProgress.flags |= Placement;
            } // In the initial pass we might need to construct the instance.
            constructClassInstance(workInProgress, Component, nextProps);
            mountClassInstance(workInProgress, Component, nextProps, renderLanes);
            shouldUpdate = true;
        } else if (current === null) // In a resume, we'll already have an instance we can reuse.
        shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);
        else shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);
        var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);
        var inst = workInProgress.stateNode;
        if (shouldUpdate && inst.props !== nextProps) {
            if (!didWarnAboutReassigningProps) error1("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentName(workInProgress.type) || 'a component');
            didWarnAboutReassigningProps = true;
        }
        return nextUnitOfWork;
    }
    function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {
        // Refs should update even if shouldComponentUpdate returns false
        markRef(current, workInProgress);
        var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;
        if (!shouldUpdate && !didCaptureError) {
            // Context providers should defer to sCU for rendering
            if (hasContext) invalidateContextProvider(workInProgress, Component, false);
            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
        }
        var instance = workInProgress.stateNode; // Rerender
        ReactCurrentOwner$1.current = workInProgress;
        var nextChildren;
        if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {
            // If we captured an error, but getDerivedStateFromError is not defined,
            // unmount all the children. componentDidCatch will schedule an update to
            // re-render a fallback. This is temporary until we migrate everyone to
            // the new API.
            // TODO: Warn in a future release.
            nextChildren = null;
            stopProfilerTimerIfRunning();
        } else {
            setIsRendering(true);
            nextChildren = instance.render();
            if (workInProgress.mode & StrictMode) {
                disableLogs();
                try {
                    instance.render();
                } finally{
                    reenableLogs();
                }
            }
            setIsRendering(false);
        } // React DevTools reads this flag.
        workInProgress.flags |= PerformedWork;
        if (current !== null && didCaptureError) // If we're recovering from an error, reconcile without reusing any of
        // the existing children. Conceptually, the normal children and the children
        // that are shown on error are two different sets, so we shouldn't reuse
        // normal children even if their identities match.
        forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);
        else reconcileChildren(current, workInProgress, nextChildren, renderLanes);
         // Memoize state using the values we just used to render.
        // TODO: Restructure so we never read values from the instance.
        workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.
        if (hasContext) invalidateContextProvider(workInProgress, Component, true);
        return workInProgress.child;
    }
    function pushHostRootContext(workInProgress) {
        var root = workInProgress.stateNode;
        if (root.pendingContext) pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
        else if (root.context) // Should always be set
        pushTopLevelContextObject(workInProgress, root.context, false);
        pushHostContainer(workInProgress, root.containerInfo);
    }
    function updateHostRoot(current, workInProgress, renderLanes) {
        pushHostRootContext(workInProgress);
        var updateQueue = workInProgress.updateQueue;
        if (!(current !== null && updateQueue !== null)) throw Error("If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.");
        var nextProps = workInProgress.pendingProps;
        var prevState = workInProgress.memoizedState;
        var prevChildren = prevState !== null ? prevState.element : null;
        cloneUpdateQueue(current, workInProgress);
        processUpdateQueue(workInProgress, nextProps, null, renderLanes);
        var nextState = workInProgress.memoizedState; // Caution: React DevTools currently depends on this property
        // being called "element".
        var nextChildren = nextState.element;
        if (nextChildren === prevChildren) {
            resetHydrationState();
            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
        }
        var root = workInProgress.stateNode;
        if (root.hydrate && enterHydrationState(workInProgress)) {
            var mutableSourceEagerHydrationData = root.mutableSourceEagerHydrationData;
            if (mutableSourceEagerHydrationData != null) for(var i = 0; i < mutableSourceEagerHydrationData.length; i += 2){
                var mutableSource = mutableSourceEagerHydrationData[i];
                var version = mutableSourceEagerHydrationData[i + 1];
                setWorkInProgressVersion(mutableSource, version);
            }
            var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);
            workInProgress.child = child;
            var node = child;
            while(node){
                // Mark each child as hydrating. This is a fast path to know whether this
                // tree is part of a hydrating tree. This is used to determine if a child
                // node has fully mounted yet, and for scheduling event replaying.
                // Conceptually this is similar to Placement in that a new subtree is
                // inserted into the React tree here. It just happens to not need DOM
                // mutations because it already exists.
                node.flags = node.flags & ~Placement | Hydrating;
                node = node.sibling;
            }
        } else {
            // Otherwise reset hydration state in case we aborted and resumed another
            // root.
            reconcileChildren(current, workInProgress, nextChildren, renderLanes);
            resetHydrationState();
        }
        return workInProgress.child;
    }
    function updateHostComponent(current, workInProgress, renderLanes) {
        pushHostContext(workInProgress);
        if (current === null) tryToClaimNextHydratableInstance(workInProgress);
        var type = workInProgress.type;
        var nextProps = workInProgress.pendingProps;
        var prevProps = current !== null ? current.memoizedProps : null;
        var nextChildren = nextProps.children;
        var isDirectTextChild = shouldSetTextContent(type, nextProps);
        if (isDirectTextChild) // We special case a direct text child of a host node. This is a common
        // case. We won't handle it as a reified child. We will instead handle
        // this in the host environment that also has access to this prop. That
        // avoids allocating another HostText fiber and traversing it.
        nextChildren = null;
        else if (prevProps !== null && shouldSetTextContent(type, prevProps)) // If we're switching from a direct text child to a normal child, or to
        // empty, we need to schedule the text content to be reset.
        workInProgress.flags |= ContentReset;
        markRef(current, workInProgress);
        reconcileChildren(current, workInProgress, nextChildren, renderLanes);
        return workInProgress.child;
    }
    function updateHostText(current, workInProgress) {
        if (current === null) tryToClaimNextHydratableInstance(workInProgress);
         // Nothing to do here. This is terminal. We'll do the completion step
        // immediately after.
        return null;
    }
    function mountLazyComponent(_current, workInProgress, elementType, updateLanes, renderLanes) {
        if (_current !== null) {
            // A lazy component only mounts if it suspended inside a non-
            // concurrent tree, in an inconsistent state. We want to treat it like
            // a new mount, even though an empty version of it already committed.
            // Disconnect the alternate pointers.
            _current.alternate = null;
            workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect
            workInProgress.flags |= Placement;
        }
        var props = workInProgress.pendingProps;
        var lazyComponent = elementType;
        var payload = lazyComponent._payload;
        var init = lazyComponent._init;
        var Component = init(payload); // Store the unwrapped component in the type.
        workInProgress.type = Component;
        var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);
        var resolvedProps = resolveDefaultProps(Component, props);
        var child;
        switch(resolvedTag){
            case FunctionComponent:
                validateFunctionComponentInDev(workInProgress, Component);
                workInProgress.type = Component = resolveFunctionForHotReloading(Component);
                child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);
                return child;
            case ClassComponent:
                workInProgress.type = Component = resolveClassForHotReloading(Component);
                child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);
                return child;
            case ForwardRef:
                workInProgress.type = Component = resolveForwardRefForHotReloading(Component);
                child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);
                return child;
            case MemoComponent:
                if (workInProgress.type !== workInProgress.elementType) {
                    var outerPropTypes = Component.propTypes;
                    if (outerPropTypes) checkPropTypes(outerPropTypes, resolvedProps, 'prop', getComponentName(Component));
                }
                child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), updateLanes, renderLanes);
                return child;
        }
        var hint = '';
        if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) hint = ' Did you wrap a component in React.lazy() more than once?';
        throw Error("Element type is invalid. Received a promise that resolves to: " + Component + ". Lazy element type must resolve to a class or function." + hint);
    }
    function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {
        if (_current !== null) {
            // An incomplete component only mounts if it suspended inside a non-
            // concurrent tree, in an inconsistent state. We want to treat it like
            // a new mount, even though an empty version of it already committed.
            // Disconnect the alternate pointers.
            _current.alternate = null;
            workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect
            workInProgress.flags |= Placement;
        } // Promote the fiber to a class and try rendering again.
        workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`
        // Push context providers early to prevent context stack mismatches.
        // During mounting we don't know the child context yet as the instance doesn't exist.
        // We will invalidate the child context in finishClassComponent() right after rendering.
        var hasContext;
        if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress);
        } else hasContext = false;
        prepareToReadContext(workInProgress, renderLanes);
        constructClassInstance(workInProgress, Component, nextProps);
        mountClassInstance(workInProgress, Component, nextProps, renderLanes);
        return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);
    }
    function mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {
        if (_current !== null) {
            // An indeterminate component only mounts if it suspended inside a non-
            // concurrent tree, in an inconsistent state. We want to treat it like
            // a new mount, even though an empty version of it already committed.
            // Disconnect the alternate pointers.
            _current.alternate = null;
            workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect
            workInProgress.flags |= Placement;
        }
        var props = workInProgress.pendingProps;
        var context;
        var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
        context = getMaskedContext(workInProgress, unmaskedContext);
        prepareToReadContext(workInProgress, renderLanes);
        var value;
        if (Component.prototype && typeof Component.prototype.render === 'function') {
            var componentName = getComponentName(Component) || 'Unknown';
            if (!didWarnAboutBadClass[componentName]) {
                error1("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
            }
        }
        if (workInProgress.mode & StrictMode) ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
        setIsRendering(true);
        ReactCurrentOwner$1.current = workInProgress;
        value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);
        setIsRendering(false);
        workInProgress.flags |= PerformedWork;
        // Support for module components is deprecated and is removed behind a flag.
        // Whether or not it would crash later, we want to show a good message in DEV first.
        if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
            var _componentName = getComponentName(Component) || 'Unknown';
            if (!didWarnAboutModulePatternComponent[_componentName]) {
                error1("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
            }
        }
        if (// Eventually we'll delete this branch altogether.
        typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
            var _componentName2 = getComponentName(Component) || 'Unknown';
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error1("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
            }
            workInProgress.tag = ClassComponent; // Throw out any hooks that were used.
            workInProgress.memoizedState = null;
            workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.
            // During mounting we don't know the child context yet as the instance doesn't exist.
            // We will invalidate the child context in finishClassComponent() right after rendering.
            var hasContext = false;
            if (isContextProvider(Component)) {
                hasContext = true;
                pushContextProvider(workInProgress);
            } else hasContext = false;
            workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;
            initializeUpdateQueue(workInProgress);
            var getDerivedStateFromProps = Component.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === 'function') applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);
            adoptClassInstance(workInProgress, value);
            mountClassInstance(workInProgress, Component, props, renderLanes);
            return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);
        } else {
            // Proceed under the assumption that this is a function component
            workInProgress.tag = FunctionComponent;
            if (workInProgress.mode & StrictMode) {
                disableLogs();
                try {
                    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);
                } finally{
                    reenableLogs();
                }
            }
            reconcileChildren(null, workInProgress, value, renderLanes);
            validateFunctionComponentInDev(workInProgress, Component);
            return workInProgress.child;
        }
    }
    function validateFunctionComponentInDev(workInProgress, Component) {
        if (Component) {
            if (Component.childContextTypes) error1('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');
        }
        if (workInProgress.ref !== null) {
            var info = '';
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) info += '\n\nCheck the render method of `' + ownerName + '`.';
            var warningKey = ownerName || workInProgress._debugID || '';
            var debugSource = workInProgress._debugSource;
            if (debugSource) warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
            if (!didWarnAboutFunctionRefs[warningKey]) {
                didWarnAboutFunctionRefs[warningKey] = true;
                error1("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
            }
        }
        if (typeof Component.getDerivedStateFromProps === 'function') {
            var _componentName3 = getComponentName(Component) || 'Unknown';
            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error1('%s: Function components do not support getDerivedStateFromProps.', _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
            }
        }
        if (typeof Component.contextType === 'object' && Component.contextType !== null) {
            var _componentName4 = getComponentName(Component) || 'Unknown';
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error1('%s: Function components do not support contextType.', _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
            }
        }
    }
    var SUSPENDED_MARKER = {
        dehydrated: null,
        retryLane: NoLane
    };
    function mountSuspenseOffscreenState(renderLanes) {
        return {
            baseLanes: renderLanes
        };
    }
    function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {
        return {
            baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes)
        };
    } // TODO: Probably should inline this back
    function shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {
        // If we're already showing a fallback, there are cases where we need to
        // remain on that fallback regardless of whether the content has resolved.
        // For example, SuspenseList coordinates when nested content appears.
        if (current !== null) {
            var suspenseState = current.memoizedState;
            if (suspenseState === null) // Currently showing content. Don't hide it, even if ForceSuspenseFallack
            // is true. More precise name might be "ForceRemainSuspenseFallback".
            // Note: This is a factoring smell. Can't remain on a fallback if there's
            // no fallback to remain on.
            return false;
        } // Not currently showing content. Consult the Suspense context.
        return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
    }
    function getRemainingWorkInPrimaryTree(current, renderLanes) {
        // TODO: Should not remove render lanes that were pinged during this render
        return removeLanes(current.childLanes, renderLanes);
    }
    function updateSuspenseComponent(current, workInProgress, renderLanes) {
        var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.
        if (shouldSuspend(workInProgress)) workInProgress.flags |= DidCapture;
        var suspenseContext = suspenseStackCursor.current;
        var showFallback = false;
        var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;
        if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {
            // Something in this boundary's subtree already suspended. Switch to
            // rendering the fallback children.
            showFallback = true;
            workInProgress.flags &= ~DidCapture;
        } else {
            // Attempting the main content
            if (current === null || current.memoizedState !== null) // This is a new mount or this boundary is already showing a fallback state.
            // Mark this subtree context as having at least one invisible parent that could
            // handle the fallback state.
            // Boundaries without fallbacks or should be avoided are not considered since
            // they cannot handle preferred fallback states.
            {
                if (nextProps.fallback !== undefined && nextProps.unstable_avoidThisFallback !== true) suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
            }
        }
        suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
        pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense
        // boundary's children. This involves some custom reconcilation logic. Two
        // main reasons this is so complicated.
        //
        // First, Legacy Mode has different semantics for backwards compatibility. The
        // primary tree will commit in an inconsistent state, so when we do the
        // second pass to render the fallback, we do some exceedingly, uh, clever
        // hacks to make that not totally break. Like transferring effects and
        // deletions from hidden tree. In Concurrent Mode, it's much simpler,
        // because we bailout on the primary tree completely and leave it in its old
        // state, no effects. Same as what we do for Offscreen (except that
        // Offscreen doesn't have the first render pass).
        //
        // Second is hydration. During hydration, the Suspense fiber has a slightly
        // different layout, where the child points to a dehydrated fragment, which
        // contains the DOM rendered by the server.
        //
        // Third, even if you set all that aside, Suspense is like error boundaries in
        // that we first we try to render one tree, and if that fails, we render again
        // and switch to a different tree. Like a try/catch block. So we have to track
        // which branch we're currently rendering. Ideally we would model this using
        // a stack.
        if (current === null) {
            // Initial mount
            // If we're currently hydrating, try to hydrate this boundary.
            // But only if this has a fallback.
            if (nextProps.fallback !== undefined) tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.
            var nextPrimaryChildren = nextProps.children;
            var nextFallbackChildren = nextProps.fallback;
            if (showFallback) {
                var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);
                var primaryChildFragment = workInProgress.child;
                primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);
                workInProgress.memoizedState = SUSPENDED_MARKER;
                return fallbackFragment;
            } else if (typeof nextProps.unstable_expectedLoadTime === 'number') {
                // This is a CPU-bound tree. Skip this tree and show a placeholder to
                // unblock the surrounding content. Then immediately retry after the
                // initial commit.
                var _fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);
                var _primaryChildFragment = workInProgress.child;
                _primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);
                workInProgress.memoizedState = SUSPENDED_MARKER; // Since nothing actually suspended, there will nothing to ping this to
                // get it started back up to attempt the next item. While in terms of
                // priority this work has the same priority as this current render, it's
                // not part of the same transition once the transition has committed. If
                // it's sync, we still want to yield so that it can be painted.
                // Conceptually, this is really the same as pinging. We can use any
                // RetryLane even if it's the one currently rendering since we're leaving
                // it behind on this node.
                workInProgress.lanes = SomeRetryLane;
                markSpawnedWork(SomeRetryLane);
                return _fallbackFragment;
            } else return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren, renderLanes);
        } else {
            // This is an update.
            // If the current fiber has a SuspenseState, that means it's already showing
            // a fallback.
            var prevState = current.memoizedState;
            if (prevState !== null) {
                if (showFallback) {
                    var _nextFallbackChildren2 = nextProps.fallback;
                    var _nextPrimaryChildren2 = nextProps.children;
                    var _fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes);
                    var _primaryChildFragment3 = workInProgress.child;
                    var prevOffscreenState = current.child.memoizedState;
                    _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);
                    _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);
                    workInProgress.memoizedState = SUSPENDED_MARKER;
                    return _fallbackChildFragment;
                } else {
                    var _nextPrimaryChildren3 = nextProps.children;
                    var _primaryChildFragment4 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren3, renderLanes);
                    workInProgress.memoizedState = null;
                    return _primaryChildFragment4;
                }
            } else // The current tree is not already showing a fallback.
            if (showFallback) {
                // Timed out.
                var _nextFallbackChildren3 = nextProps.fallback;
                var _nextPrimaryChildren4 = nextProps.children;
                var _fallbackChildFragment2 = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes);
                var _primaryChildFragment5 = workInProgress.child;
                var _prevOffscreenState = current.child.memoizedState;
                _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes);
                _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes); // Skip the primary children, and continue working on the
                // fallback children.
                workInProgress.memoizedState = SUSPENDED_MARKER;
                return _fallbackChildFragment2;
            } else {
                // Still haven't timed out. Continue rendering the children, like we
                // normally do.
                var _nextPrimaryChildren5 = nextProps.children;
                var _primaryChildFragment6 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren5, renderLanes);
                workInProgress.memoizedState = null;
                return _primaryChildFragment6;
            }
        }
    }
    function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {
        var mode = workInProgress.mode;
        var primaryChildProps = {
            mode: 'visible',
            children: primaryChildren
        };
        var primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, renderLanes, null);
        primaryChildFragment.return = workInProgress;
        workInProgress.child = primaryChildFragment;
        return primaryChildFragment;
    }
    function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {
        var mode = workInProgress.mode;
        var progressedPrimaryFragment = workInProgress.child;
        var primaryChildProps = {
            mode: 'hidden',
            children: primaryChildren
        };
        var primaryChildFragment;
        var fallbackChildFragment;
        if ((mode & BlockingMode) === NoMode && progressedPrimaryFragment !== null) {
            // In legacy mode, we commit the primary tree as if it successfully
            // completed, even though it's in an inconsistent state.
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress.mode & ProfileMode) {
                // Reset the durations from the first pass so they aren't included in the
                // final amounts. This seems counterintuitive, since we're intentionally
                // not measuring part of the render phase, but this makes it match what we
                // do in Concurrent Mode.
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = 0;
                primaryChildFragment.treeBaseDuration = 0;
            }
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
        } else {
            primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, NoLanes, null);
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
        }
        primaryChildFragment.return = workInProgress;
        fallbackChildFragment.return = workInProgress;
        primaryChildFragment.sibling = fallbackChildFragment;
        workInProgress.child = primaryChildFragment;
        return fallbackChildFragment;
    }
    function createWorkInProgressOffscreenFiber(current, offscreenProps) {
        // The props argument to `createWorkInProgress` is `any` typed, so we use this
        // wrapper function to constrain it.
        return createWorkInProgress(current, offscreenProps);
    }
    function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {
        var currentPrimaryChildFragment = current.child;
        var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
        var primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
            mode: 'visible',
            children: primaryChildren
        });
        if ((workInProgress.mode & BlockingMode) === NoMode) primaryChildFragment.lanes = renderLanes;
        primaryChildFragment.return = workInProgress;
        primaryChildFragment.sibling = null;
        if (currentFallbackChildFragment !== null) {
            // Delete the fallback child fragment
            currentFallbackChildFragment.nextEffect = null;
            currentFallbackChildFragment.flags = Deletion;
            workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChildFragment;
        }
        workInProgress.child = primaryChildFragment;
        return primaryChildFragment;
    }
    function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {
        var mode = workInProgress.mode;
        var currentPrimaryChildFragment = current.child;
        var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
        var primaryChildProps = {
            mode: 'hidden',
            children: primaryChildren
        };
        var primaryChildFragment;
        if (// completed, even though it's in an inconsistent state.
        (mode & BlockingMode) === NoMode && // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        workInProgress.child !== currentPrimaryChildFragment) {
            var progressedPrimaryFragment = workInProgress.child;
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress.mode & ProfileMode) {
                // Reset the durations from the first pass so they aren't included in the
                // final amounts. This seems counterintuitive, since we're intentionally
                // not measuring part of the render phase, but this makes it match what we
                // do in Concurrent Mode.
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
                primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
            } // The fallback fiber was added as a deletion effect during the first pass.
            // However, since we're going to remain on the fallback, we no longer want
            // to delete it. So we need to remove it from the list. Deletions are stored
            // on the same list as effects. We want to keep the effects from the primary
            // tree. So we copy the primary child fragment's effect list, which does not
            // include the fallback deletion effect.
            var progressedLastEffect = primaryChildFragment.lastEffect;
            if (progressedLastEffect !== null) {
                workInProgress.firstEffect = primaryChildFragment.firstEffect;
                workInProgress.lastEffect = progressedLastEffect;
                progressedLastEffect.nextEffect = null;
            } else // TODO: Reset this somewhere else? Lol legacy mode is so weird.
            workInProgress.firstEffect = workInProgress.lastEffect = null;
        } else primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
        var fallbackChildFragment;
        if (currentFallbackChildFragment !== null) fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
        else {
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already
            // mounted but this is a new fiber.
            fallbackChildFragment.flags |= Placement;
        }
        fallbackChildFragment.return = workInProgress;
        primaryChildFragment.return = workInProgress;
        primaryChildFragment.sibling = fallbackChildFragment;
        workInProgress.child = primaryChildFragment;
        return fallbackChildFragment;
    }
    function scheduleWorkOnFiber(fiber, renderLanes) {
        fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
        var alternate = fiber.alternate;
        if (alternate !== null) alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
        scheduleWorkOnParentPath(fiber.return, renderLanes);
    }
    function propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {
        // Mark any Suspense boundaries with fallbacks as having work to do.
        // If they were previously forced into fallbacks, they may now be able
        // to unblock.
        var node = firstChild;
        while(node !== null){
            if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) scheduleWorkOnFiber(node, renderLanes);
            } else if (node.tag === SuspenseListComponent) // If the tail is hidden there might not be an Suspense boundaries
            // to schedule work on. In this case we have to schedule it on the
            // list itself.
            // We don't have to traverse to the children of the list since
            // the list will propagate the change when it rerenders.
            scheduleWorkOnFiber(node, renderLanes);
            else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === workInProgress) return;
            while(node.sibling === null){
                if (node.return === null || node.return === workInProgress) return;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
    }
    function findLastContentRow(firstChild) {
        // This is going to find the last row among these children that is already
        // showing content on the screen, as opposed to being in fallback state or
        // new. If a row has multiple Suspense boundaries, any of them being in the
        // fallback state, counts as the whole row being in a fallback state.
        // Note that the "rows" will be workInProgress, but any nested children
        // will still be current since we haven't rendered them yet. The mounted
        // order may not be the same as the new order. We use the new order.
        var row = firstChild;
        var lastContentRow = null;
        while(row !== null){
            var currentRow = row.alternate; // New rows can't be content rows.
            if (currentRow !== null && findFirstSuspended(currentRow) === null) lastContentRow = row;
            row = row.sibling;
        }
        return lastContentRow;
    }
    function validateRevealOrder(revealOrder) {
        if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {
            didWarnAboutRevealOrder[revealOrder] = true;
            if (typeof revealOrder === 'string') switch(revealOrder.toLowerCase()){
                case 'together':
                case 'forwards':
                case 'backwards':
                    error1("\"%s\" is not a valid value for revealOrder on <SuspenseList />. Use lowercase \"%s\" instead.", revealOrder, revealOrder.toLowerCase());
                    break;
                case 'forward':
                case 'backward':
                    error1("\"%s\" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use \"%ss\" instead.", revealOrder, revealOrder.toLowerCase());
                    break;
                default:
                    error1("\"%s\" is not a supported revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?", revealOrder);
                    break;
            }
            else error1("%s is not a supported value for revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?", revealOrder);
        }
    }
    function validateTailOptions(tailMode, revealOrder) {
        if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {
            if (tailMode !== 'collapsed' && tailMode !== 'hidden') {
                didWarnAboutTailOptions[tailMode] = true;
                error1("\"%s\" is not a supported value for tail on <SuspenseList />. Did you mean \"collapsed\" or \"hidden\"?", tailMode);
            } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {
                didWarnAboutTailOptions[tailMode] = true;
                error1("<SuspenseList tail=\"%s\" /> is only valid if revealOrder is \"forwards\" or \"backwards\". Did you mean to specify revealOrder=\"forwards\"?", tailMode);
            }
        }
    }
    function validateSuspenseListNestedChild(childSlot, index) {
        var isArray = Array.isArray(childSlot);
        var isIterable = !isArray && typeof getIteratorFn(childSlot) === 'function';
        if (isArray || isIterable) {
            var type = isArray ? 'array' : 'iterable';
            error1("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index, type);
            return false;
        }
        return true;
    }
    function validateSuspenseListChildren(children, revealOrder) {
        if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {
            if (Array.isArray(children)) for(var i = 0; i < children.length; i++){
                if (!validateSuspenseListNestedChild(children[i], i)) return;
            }
            else {
                var iteratorFn = getIteratorFn(children);
                if (typeof iteratorFn === 'function') {
                    var childrenIterator = iteratorFn.call(children);
                    if (childrenIterator) {
                        var step = childrenIterator.next();
                        var _i = 0;
                        for(; !step.done; step = childrenIterator.next()){
                            if (!validateSuspenseListNestedChild(step.value, _i)) return;
                            _i++;
                        }
                    }
                } else error1("A single row was passed to a <SuspenseList revealOrder=\"%s\" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?", revealOrder);
            }
        }
    }
    function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering) {
        var renderState = workInProgress.memoizedState;
        if (renderState === null) workInProgress.memoizedState = {
            isBackwards: isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail: tail,
            tailMode: tailMode,
            lastEffect: lastEffectBeforeRendering
        };
        else {
            // We can reuse the existing object from previous renders.
            renderState.isBackwards = isBackwards;
            renderState.rendering = null;
            renderState.renderingStartTime = 0;
            renderState.last = lastContentRow;
            renderState.tail = tail;
            renderState.tailMode = tailMode;
            renderState.lastEffect = lastEffectBeforeRendering;
        }
    } // This can end up rendering this component multiple passes.
    // The first pass splits the children fibers into two sets. A head and tail.
    // We first render the head. If anything is in fallback state, we do another
    // pass through beginWork to rerender all children (including the tail) with
    // the force suspend context. If the first render didn't have anything in
    // in fallback state. Then we render each row in the tail one-by-one.
    // That happens in the completeWork phase without going back to beginWork.
    function updateSuspenseListComponent(current, workInProgress, renderLanes) {
        var nextProps = workInProgress.pendingProps;
        var revealOrder = nextProps.revealOrder;
        var tailMode = nextProps.tail;
        var newChildren = nextProps.children;
        validateRevealOrder(revealOrder);
        validateTailOptions(tailMode, revealOrder);
        validateSuspenseListChildren(newChildren, revealOrder);
        reconcileChildren(current, workInProgress, newChildren, renderLanes);
        var suspenseContext = suspenseStackCursor.current;
        var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        if (shouldForceFallback) {
            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
            workInProgress.flags |= DidCapture;
        } else {
            var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;
            if (didSuspendBefore) // If we previously forced a fallback, we need to schedule work
            // on any nested boundaries to let them know to try to render
            // again. This is the same as context updating.
            propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
        }
        pushSuspenseContext(workInProgress, suspenseContext);
        if ((workInProgress.mode & BlockingMode) === NoMode) // In legacy mode, SuspenseList doesn't work so we just
        // use make it a noop by treating it as the default revealOrder.
        workInProgress.memoizedState = null;
        else switch(revealOrder){
            case 'forwards':
                var lastContentRow = findLastContentRow(workInProgress.child);
                var tail;
                if (lastContentRow === null) {
                    // The whole list is part of the tail.
                    // TODO: We could fast path by just rendering the tail now.
                    tail = workInProgress.child;
                    workInProgress.child = null;
                } else {
                    // Disconnect the tail rows after the content row.
                    // We're going to render them separately later.
                    tail = lastContentRow.sibling;
                    lastContentRow.sibling = null;
                }
                initSuspenseListRenderState(workInProgress, false, tail, lastContentRow, tailMode, workInProgress.lastEffect);
                break;
            case 'backwards':
                // We're going to find the first row that has existing content.
                // At the same time we're going to reverse the list of everything
                // we pass in the meantime. That's going to be our tail in reverse
                // order.
                var _tail = null;
                var row = workInProgress.child;
                workInProgress.child = null;
                while(row !== null){
                    var currentRow = row.alternate; // New rows can't be content rows.
                    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                        // This is the beginning of the main content.
                        workInProgress.child = row;
                        break;
                    }
                    var nextRow = row.sibling;
                    row.sibling = _tail;
                    _tail = row;
                    row = nextRow;
                } // TODO: If workInProgress.child is null, we can continue on the tail immediately.
                initSuspenseListRenderState(workInProgress, true, _tail, null, tailMode, workInProgress.lastEffect);
                break;
            case 'together':
                initSuspenseListRenderState(workInProgress, false, null, null, undefined, workInProgress.lastEffect);
                break;
            default:
                // The default reveal order is the same as not having
                // a boundary.
                workInProgress.memoizedState = null;
        }
        return workInProgress.child;
    }
    function updatePortalComponent(current, workInProgress, renderLanes) {
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        var nextChildren = workInProgress.pendingProps;
        if (current === null) // Portals are special because we don't append the children during mount
        // but at commit. Therefore we need to track insertions which the normal
        // flow doesn't do during mount. This doesn't happen at the root because
        // the root always starts with a "current" with a null child.
        // TODO: Consider unifying this with how the root works.
        workInProgress.child = reconcileChildFibers1(workInProgress, null, nextChildren, renderLanes);
        else reconcileChildren(current, workInProgress, nextChildren, renderLanes);
        return workInProgress.child;
    }
    var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
    function updateContextProvider(current, workInProgress, renderLanes) {
        var providerType = workInProgress.type;
        var context = providerType._context;
        var newProps = workInProgress.pendingProps;
        var oldProps = workInProgress.memoizedProps;
        var newValue = newProps.value;
        if (!('value' in newProps)) {
            if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                error1('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');
            }
        }
        var providerPropTypes = workInProgress.type.propTypes;
        if (providerPropTypes) checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');
        pushProvider(workInProgress, newValue);
        if (oldProps !== null) {
            var oldValue = oldProps.value;
            var changedBits = calculateChangedBits(context, newValue, oldValue);
            if (changedBits === 0) {
                // No change. Bailout early if children are the same.
                if (oldProps.children === newProps.children && !hasContextChanged()) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
            } else // The context value changed. Search for matching consumers and schedule
            // them to update.
            propagateContextChange(workInProgress, context, changedBits, renderLanes);
        }
        var newChildren = newProps.children;
        reconcileChildren(current, workInProgress, newChildren, renderLanes);
        return workInProgress.child;
    }
    var hasWarnedAboutUsingContextAsConsumer = false;
    function updateContextConsumer(current, workInProgress, renderLanes) {
        var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In
        if (context._context === undefined) {
            // This may be because it's a Context (rather than a Consumer).
            // Or it may be because it's older React where they're the same thing.
            // We only want to warn if we're sure it's a new React.
            if (context !== context.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error1("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
            }
        } else context = context._context;
        var newProps = workInProgress.pendingProps;
        var render = newProps.children;
        if (typeof render !== 'function') error1("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
        prepareToReadContext(workInProgress, renderLanes);
        var newValue = readContext(context, newProps.unstable_observedBits);
        var newChildren;
        ReactCurrentOwner$1.current = workInProgress;
        setIsRendering(true);
        newChildren = render(newValue);
        setIsRendering(false);
        workInProgress.flags |= PerformedWork;
        reconcileChildren(current, workInProgress, newChildren, renderLanes);
        return workInProgress.child;
    }
    function markWorkInProgressReceivedUpdate() {
        didReceiveUpdate = true;
    }
    function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
        if (current !== null) // Reuse previous dependencies
        workInProgress.dependencies = current.dependencies;
        // Don't update "base" render times for bailouts.
        stopProfilerTimerIfRunning();
        markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.
        if (!includesSomeLane(renderLanes, workInProgress.childLanes)) // The children don't have any work either. We can skip them.
        // TODO: Once we add back resuming, we should check if the children are
        // a work-in-progress set. If so, we need to transfer their effects.
        return null;
        else {
            // This fiber doesn't have work, but its subtree does. Clone the child
            // fibers and continue.
            cloneChildFibers(current, workInProgress);
            return workInProgress.child;
        }
    }
    function remountFiber(current, oldWorkInProgress, newWorkInProgress) {
        var returnFiber = oldWorkInProgress.return;
        if (returnFiber === null) throw new Error('Cannot swap the root fiber.');
         // Disconnect from the old current.
        // It will get deleted.
        current.alternate = null;
        oldWorkInProgress.alternate = null; // Connect to the new tree.
        newWorkInProgress.index = oldWorkInProgress.index;
        newWorkInProgress.sibling = oldWorkInProgress.sibling;
        newWorkInProgress.return = oldWorkInProgress.return;
        newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.
        if (oldWorkInProgress === returnFiber.child) returnFiber.child = newWorkInProgress;
        else {
            var prevSibling = returnFiber.child;
            if (prevSibling === null) throw new Error('Expected parent to have a child.');
            while(prevSibling.sibling !== oldWorkInProgress){
                prevSibling = prevSibling.sibling;
                if (prevSibling === null) throw new Error('Expected to find the previous sibling.');
            }
            prevSibling.sibling = newWorkInProgress;
        } // Delete the old fiber and place the new one.
        // Since the old fiber is disconnected, we have to schedule it manually.
        var last = returnFiber.lastEffect;
        if (last !== null) {
            last.nextEffect = current;
            returnFiber.lastEffect = current;
        } else returnFiber.firstEffect = returnFiber.lastEffect = current;
        current.nextEffect = null;
        current.flags = Deletion;
        newWorkInProgress.flags |= Placement; // Restart work from the new fiber.
        return newWorkInProgress;
    }
    function beginWork(current, workInProgress, renderLanes) {
        var updateLanes = workInProgress.lanes;
        if (workInProgress._debugNeedsRemount && current !== null) // This will restart the begin phase with a new fiber.
        return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));
        if (current !== null) {
            var oldProps = current.memoizedProps;
            var newProps = workInProgress.pendingProps;
            if (oldProps !== newProps || hasContextChanged() || workInProgress.type !== current.type) // If props or context changed, mark the fiber as having performed work.
            // This may be unset if the props are determined to be equal later (memo).
            didReceiveUpdate = true;
            else if (!includesSomeLane(renderLanes, updateLanes)) {
                didReceiveUpdate = false; // This fiber does not have any pending work. Bailout without entering
                // the begin phase. There's still some bookkeeping we that needs to be done
                // in this optimized path, mostly pushing stuff onto the stack.
                switch(workInProgress.tag){
                    case HostRoot:
                        pushHostRootContext(workInProgress);
                        resetHydrationState();
                        break;
                    case HostComponent:
                        pushHostContext(workInProgress);
                        break;
                    case ClassComponent:
                        var Component = workInProgress.type;
                        if (isContextProvider(Component)) pushContextProvider(workInProgress);
                        break;
                    case HostPortal:
                        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                        break;
                    case ContextProvider:
                        var newValue = workInProgress.memoizedProps.value;
                        pushProvider(workInProgress, newValue);
                        break;
                    case Profiler:
                        // Profiler should only call onRender when one of its descendants actually rendered.
                        var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);
                        if (hasChildWork) workInProgress.flags |= Update;
                         // Reset effect durations for the next eventual effect phase.
                        // These are reset during render to allow the DevTools commit hook a chance to read them,
                        var stateNode = workInProgress.stateNode;
                        stateNode.effectDuration = 0;
                        stateNode.passiveEffectDuration = 0;
                        break;
                    case SuspenseComponent:
                        var state = workInProgress.memoizedState;
                        if (state !== null) {
                            // whether to retry the primary children, or to skip over it and
                            // go straight to the fallback. Check the priority of the primary
                            // child fragment.
                            var primaryChildFragment = workInProgress.child;
                            var primaryChildLanes = primaryChildFragment.childLanes;
                            if (includesSomeLane(renderLanes, primaryChildLanes)) // The primary children have pending work. Use the normal path
                            // to attempt to render the primary children again.
                            return updateSuspenseComponent(current, workInProgress, renderLanes);
                            else {
                                // The primary child fragment does not have pending work marked
                                // on it
                                pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient
                                // priority. Bailout.
                                var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                                if (child !== null) // The fallback children have pending work. Skip over the
                                // primary children and work on the fallback.
                                return child.sibling;
                                else return null;
                            }
                        } else pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                        break;
                    case SuspenseListComponent:
                        var didSuspendBefore = (current.flags & DidCapture) !== NoFlags;
                        var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);
                        if (didSuspendBefore) {
                            if (_hasChildWork) // If something was in fallback state last time, and we have all the
                            // same children then we're still in progressive loading state.
                            // Something might get unblocked by state updates or retries in the
                            // tree which will affect the tail. So we need to use the normal
                            // path to compute the correct tail.
                            return updateSuspenseListComponent(current, workInProgress, renderLanes);
                             // If none of the children had any work, that means that none of
                            // them got retried so they'll still be blocked in the same way
                            // as before. We can fast bail out.
                            workInProgress.flags |= DidCapture;
                        } // If nothing suspended before and we're rendering the same children,
                        // then the tail doesn't matter. Anything new that suspends will work
                        // in the "together" mode, so we can continue from the state we had.
                        var renderState = workInProgress.memoizedState;
                        if (renderState !== null) {
                            // Reset to the "together" mode in case we've started a different
                            // update in the past but didn't complete it.
                            renderState.rendering = null;
                            renderState.tail = null;
                            renderState.lastEffect = null;
                        }
                        pushSuspenseContext(workInProgress, suspenseStackCursor.current);
                        if (_hasChildWork) break;
                        else // If none of the children had any work, that means that none of
                        // them got retried so they'll still be blocked in the same way
                        // as before. We can fast bail out.
                        return null;
                    case OffscreenComponent:
                    case LegacyHiddenComponent:
                        // Need to check if the tree still needs to be deferred. This is
                        // almost identical to the logic used in the normal update path,
                        // so we'll just enter that. The only difference is we'll bail out
                        // at the next level instead of this one, because the child props
                        // have not changed. Which is fine.
                        // TODO: Probably should refactor `beginWork` to split the bailout
                        // path from the normal path. I'm tempted to do a labeled break here
                        // but I won't :)
                        workInProgress.lanes = NoLanes;
                        return updateOffscreenComponent(current, workInProgress, renderLanes);
                }
                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
            } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) // This is a special case that only exists for legacy mode.
            // See https://github.com/facebook/react/pull/19216.
            didReceiveUpdate = true;
            else // An update was scheduled on this fiber, but there are no new props
            // nor legacy context. Set this to false. If an update queue or context
            // consumer produces a changed value, it will set this to true. Otherwise,
            // the component will assume the children have not changed and bail out.
            didReceiveUpdate = false;
        } else didReceiveUpdate = false;
         // Before entering the begin phase, clear pending update priority.
        // TODO: This assumes that we're about to evaluate the component and process
        // the update queue. However, there's an exception: SimpleMemoComponent
        // sometimes bails out later in the begin phase. This indicates that we should
        // move this assignment out of the common path and into each branch.
        workInProgress.lanes = NoLanes;
        switch(workInProgress.tag){
            case IndeterminateComponent:
                return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);
            case LazyComponent:
                var elementType = workInProgress.elementType;
                return mountLazyComponent(current, workInProgress, elementType, updateLanes, renderLanes);
            case FunctionComponent:
                var _Component = workInProgress.type;
                var unresolvedProps = workInProgress.pendingProps;
                var resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
                return updateFunctionComponent(current, workInProgress, _Component, resolvedProps, renderLanes);
            case ClassComponent:
                var _Component2 = workInProgress.type;
                var _unresolvedProps = workInProgress.pendingProps;
                var _resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);
                return updateClassComponent(current, workInProgress, _Component2, _resolvedProps, renderLanes);
            case HostRoot:
                return updateHostRoot(current, workInProgress, renderLanes);
            case HostComponent:
                return updateHostComponent(current, workInProgress, renderLanes);
            case HostText:
                return updateHostText(current, workInProgress);
            case SuspenseComponent:
                return updateSuspenseComponent(current, workInProgress, renderLanes);
            case HostPortal:
                return updatePortalComponent(current, workInProgress, renderLanes);
            case ForwardRef:
                var type = workInProgress.type;
                var _unresolvedProps2 = workInProgress.pendingProps;
                var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
                return updateForwardRef(current, workInProgress, type, _resolvedProps2, renderLanes);
            case Fragment:
                return updateFragment1(current, workInProgress, renderLanes);
            case Mode:
                return updateMode(current, workInProgress, renderLanes);
            case Profiler:
                return updateProfiler(current, workInProgress, renderLanes);
            case ContextProvider:
                return updateContextProvider(current, workInProgress, renderLanes);
            case ContextConsumer:
                return updateContextConsumer(current, workInProgress, renderLanes);
            case MemoComponent:
                var _type2 = workInProgress.type;
                var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.
                var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                if (workInProgress.type !== workInProgress.elementType) {
                    var outerPropTypes = _type2.propTypes;
                    if (outerPropTypes) checkPropTypes(outerPropTypes, _resolvedProps3, 'prop', getComponentName(_type2));
                }
                _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                return updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, updateLanes, renderLanes);
            case SimpleMemoComponent:
                return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, updateLanes, renderLanes);
            case IncompleteClassComponent:
                var _Component3 = workInProgress.type;
                var _unresolvedProps4 = workInProgress.pendingProps;
                var _resolvedProps4 = workInProgress.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);
                return mountIncompleteClassComponent(current, workInProgress, _Component3, _resolvedProps4, renderLanes);
            case SuspenseListComponent:
                return updateSuspenseListComponent(current, workInProgress, renderLanes);
            case FundamentalComponent:
                break;
            case ScopeComponent:
                break;
            case Block:
                break;
            case OffscreenComponent:
                return updateOffscreenComponent(current, workInProgress, renderLanes);
            case LegacyHiddenComponent:
                return updateLegacyHiddenComponent(current, workInProgress, renderLanes);
        }
        throw Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function markUpdate(workInProgress) {
        // Tag the fiber with an update effect. This turns a Placement into
        // a PlacementAndUpdate.
        workInProgress.flags |= Update;
    }
    function markRef$1(workInProgress) {
        workInProgress.flags |= Ref;
    }
    var appendAllChildren;
    var updateHostContainer;
    var updateHostComponent$1;
    var updateHostText$1;
    // Mutation mode
    appendAllChildren = function(parent, workInProgress, needsVisibilityToggle, isHidden) {
        // We only have the top Fiber that was created but we need recurse down its
        // children to find all the terminal nodes.
        var node = workInProgress.child;
        while(node !== null){
            if (node.tag === HostComponent || node.tag === HostText) appendInitialChild(parent, node.stateNode);
            else if (node.tag === HostPortal) ;
            else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === workInProgress) return;
            while(node.sibling === null){
                if (node.return === null || node.return === workInProgress) return;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
    };
    updateHostContainer = function(workInProgress) {
    };
    updateHostComponent$1 = function(current, workInProgress, type, newProps, rootContainerInstance) {
        // If we have an alternate, that means this is an update and we need to
        // schedule a side-effect to do the updates.
        var oldProps = current.memoizedProps;
        if (oldProps === newProps) // In mutation mode, this is sufficient for a bailout because
        // we won't touch this node even if children changed.
        return;
         // If we get updated because one of our children updated, we don't
        // have newProps so we'll have to reuse them.
        // TODO: Split the update API as separate for the props vs. children.
        // Even better would be if children weren't special cased at all tho.
        var instance = workInProgress.stateNode;
        var currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host
        // component is hitting the resume path. Figure out why. Possibly
        // related to `hidden`.
        var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.
        workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
        // is a new ref we mark this as an update. All the work is done in commitWork.
        if (updatePayload) markUpdate(workInProgress);
    };
    updateHostText$1 = function(current, workInProgress, oldText, newText) {
        // If the text differs, mark it as an update. All the work in done in commitWork.
        if (oldText !== newText) markUpdate(workInProgress);
    };
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (getIsHydrating()) // If we're hydrating, we should consume as many items as we can
        // so we don't leave any behind.
        return;
        switch(renderState.tailMode){
            case 'hidden':
                // Any insertions at the end of the tail list after this point
                // should be invisible. If there are already mounted boundaries
                // anything before them are not considered for collapsing.
                // Therefore we need to go through the whole tail to find if
                // there are any.
                var tailNode = renderState.tail;
                var lastTailNode = null;
                while(tailNode !== null){
                    if (tailNode.alternate !== null) lastTailNode = tailNode;
                    tailNode = tailNode.sibling;
                } // Next we're simply going to delete all insertions after the
                // last rendered item.
                if (lastTailNode === null) // All remaining items in the tail are insertions.
                renderState.tail = null;
                else // Detach the insertion after the last node that was already
                // inserted.
                lastTailNode.sibling = null;
                break;
            case 'collapsed':
                // Any insertions at the end of the tail list after this point
                // should be invisible. If there are already mounted boundaries
                // anything before them are not considered for collapsing.
                // Therefore we need to go through the whole tail to find if
                // there are any.
                var _tailNode = renderState.tail;
                var _lastTailNode = null;
                while(_tailNode !== null){
                    if (_tailNode.alternate !== null) _lastTailNode = _tailNode;
                    _tailNode = _tailNode.sibling;
                } // Next we're simply going to delete all insertions after the
                // last rendered item.
                if (_lastTailNode === null) {
                    // All remaining items in the tail are insertions.
                    if (!hasRenderedATailFallback && renderState.tail !== null) // We suspended during the head. We want to show at least one
                    // row at the tail. So we'll keep on and cut off the rest.
                    renderState.tail.sibling = null;
                    else renderState.tail = null;
                } else // Detach the insertion after the last node that was already
                // inserted.
                _lastTailNode.sibling = null;
                break;
        }
    }
    function completeWork(current, workInProgress, renderLanes) {
        var newProps = workInProgress.pendingProps;
        switch(workInProgress.tag){
            case IndeterminateComponent:
            case LazyComponent:
            case SimpleMemoComponent:
            case FunctionComponent:
            case ForwardRef:
            case Fragment:
            case Mode:
            case Profiler:
            case ContextConsumer:
            case MemoComponent:
                return null;
            case ClassComponent:
                var Component = workInProgress.type;
                if (isContextProvider(Component)) popContext(workInProgress);
                return null;
            case HostRoot:
                popHostContainer(workInProgress);
                popTopLevelContextObject(workInProgress);
                resetWorkInProgressVersions();
                var fiberRoot = workInProgress.stateNode;
                if (fiberRoot.pendingContext) {
                    fiberRoot.context = fiberRoot.pendingContext;
                    fiberRoot.pendingContext = null;
                }
                if (current === null || current.child === null) {
                    // If we hydrated, pop so that we can delete any remaining children
                    // that weren't hydrated.
                    var wasHydrated = popHydrationState(workInProgress);
                    if (wasHydrated) // If we hydrated, then we'll need to schedule an update for
                    // the commit side-effects on the root.
                    markUpdate(workInProgress);
                    else if (!fiberRoot.hydrate) // Schedule an effect to clear this container at the start of the next commit.
                    // This handles the case of React rendering into a container with previous children.
                    // It's also safe to do for updates too, because current.child would only be null
                    // if the previous render was null (so the the container would already be empty).
                    workInProgress.flags |= Snapshot;
                }
                updateHostContainer(workInProgress);
                return null;
            case HostComponent:
                popHostContext(workInProgress);
                var rootContainerInstance = getRootHostContainer();
                var type = workInProgress.type;
                if (current !== null && workInProgress.stateNode != null) {
                    updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);
                    if (current.ref !== workInProgress.ref) markRef$1(workInProgress);
                } else {
                    if (!newProps) {
                        if (!(workInProgress.stateNode !== null)) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                         // This can happen when we abort work.
                        return null;
                    }
                    var currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context
                    // "stack" as the parent. Then append children as we go in beginWork
                    // or completeWork depending on whether we want to add them top->down or
                    // bottom->up. Top->down is faster in IE11.
                    var _wasHydrated = popHydrationState(workInProgress);
                    if (_wasHydrated) // TODO: Move this and createInstance step into the beginPhase
                    // to consolidate.
                    {
                        if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) // If changes to the hydrated node need to be applied at the
                        // commit-phase we mark this as such.
                        markUpdate(workInProgress);
                    } else {
                        var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);
                        appendAllChildren(instance, workInProgress, false, false);
                        workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.
                        // (eg DOM renderer supports auto-focus for certain elements).
                        // Make sure such renderers get scheduled for later work.
                        if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) markUpdate(workInProgress);
                    }
                    if (workInProgress.ref !== null) // If there is a ref on a host node we need to schedule a callback
                    markRef$1(workInProgress);
                }
                return null;
            case HostText:
                var newText = newProps;
                if (current && workInProgress.stateNode != null) {
                    var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need
                    // to schedule a side-effect to do the updates.
                    updateHostText$1(current, workInProgress, oldText, newText);
                } else {
                    if (typeof newText !== 'string') {
                        if (!(workInProgress.stateNode !== null)) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                         // This can happen when we abort work.
                    }
                    var _rootContainerInstance = getRootHostContainer();
                    var _currentHostContext = getHostContext();
                    var _wasHydrated2 = popHydrationState(workInProgress);
                    if (_wasHydrated2) {
                        if (prepareToHydrateHostTextInstance(workInProgress)) markUpdate(workInProgress);
                    } else workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);
                }
                return null;
            case SuspenseComponent:
                popSuspenseContext(workInProgress);
                var nextState = workInProgress.memoizedState;
                if ((workInProgress.flags & DidCapture) !== NoFlags) {
                    // Something suspended. Re-render with the fallback children.
                    workInProgress.lanes = renderLanes; // Do not reset the effect list.
                    if ((workInProgress.mode & ProfileMode) !== NoMode) transferActualDuration(workInProgress);
                    return workInProgress;
                }
                var nextDidTimeout = nextState !== null;
                var prevDidTimeout = false;
                if (current === null) {
                    if (workInProgress.memoizedProps.fallback !== undefined) popHydrationState(workInProgress);
                } else {
                    var prevState = current.memoizedState;
                    prevDidTimeout = prevState !== null;
                }
                if (nextDidTimeout && !prevDidTimeout) // If this subtreee is running in blocking mode we can suspend,
                // otherwise we won't suspend.
                // TODO: This will still suspend a synchronous tree if anything
                // in the concurrent tree already suspended during this render.
                // This is a known bug.
                {
                    if ((workInProgress.mode & BlockingMode) !== NoMode) {
                        // TODO: Move this back to throwException because this is too late
                        // if this is a large tree which is common for initial loads. We
                        // don't know if we should restart a render or not until we get
                        // this marker, and this is too late.
                        // If this render already had a ping or lower pri updates,
                        // and this is the first time we know we're going to suspend we
                        // should be able to immediately restart from within throwException.
                        var hasInvisibleChildContext = current === null && workInProgress.memoizedProps.unstable_avoidThisFallback !== true;
                        if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) // If this was in an invisible tree or a new render, then showing
                        // this boundary is ok.
                        renderDidSuspend();
                        else // Otherwise, we're going to have to hide content so we should
                        // suspend for longer if possible.
                        renderDidSuspendDelayIfPossible();
                    }
                }
                // TODO: Only schedule updates if these values are non equal, i.e. it changed.
                if (nextDidTimeout || prevDidTimeout) // If this boundary just timed out, schedule an effect to attach a
                // retry listener to the promise. This flag is also used to hide the
                // primary children. In mutation mode, we also need the flag to
                // *unhide* children that were previously hidden, so check if this
                // is currently timed out, too.
                workInProgress.flags |= Update;
                return null;
            case HostPortal:
                popHostContainer(workInProgress);
                updateHostContainer(workInProgress);
                if (current === null) preparePortalMount(workInProgress.stateNode.containerInfo);
                return null;
            case ContextProvider:
                // Pop provider fiber
                popProvider(workInProgress);
                return null;
            case IncompleteClassComponent:
                // Same as class component case. I put it down here so that the tags are
                // sequential to ensure this switch is compiled to a jump table.
                var _Component = workInProgress.type;
                if (isContextProvider(_Component)) popContext(workInProgress);
                return null;
            case SuspenseListComponent:
                popSuspenseContext(workInProgress);
                var renderState = workInProgress.memoizedState;
                if (renderState === null) // We're running in the default, "independent" mode.
                // We don't do anything in this mode.
                return null;
                var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;
                var renderedTail = renderState.rendering;
                if (renderedTail === null) {
                    // We just rendered the head.
                    if (!didSuspendAlready) {
                        // This is the first pass. We need to figure out if anything is still
                        // suspended in the rendered set.
                        // If new content unsuspended, but there's still some content that
                        // didn't. Then we need to do a second pass that forces everything
                        // to keep showing their fallbacks.
                        // We might be suspended if something in this render pass suspended, or
                        // something in the previous committed pass suspended. Otherwise,
                        // there's no chance so we can skip the expensive call to
                        // findFirstSuspended.
                        var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);
                        if (!cannotBeSuspended) {
                            var row = workInProgress.child;
                            while(row !== null){
                                var suspended = findFirstSuspended(row);
                                if (suspended !== null) {
                                    didSuspendAlready = true;
                                    workInProgress.flags |= DidCapture;
                                    cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as
                                    // part of the second pass. In that case nothing will subscribe to
                                    // its thennables. Instead, we'll transfer its thennables to the
                                    // SuspenseList so that it can retry if they resolve.
                                    // There might be multiple of these in the list but since we're
                                    // going to wait for all of them anyway, it doesn't really matter
                                    // which ones gets to ping. In theory we could get clever and keep
                                    // track of how many dependencies remain but it gets tricky because
                                    // in the meantime, we can add/remove/change items and dependencies.
                                    // We might bail out of the loop before finding any but that
                                    // doesn't matter since that means that the other boundaries that
                                    // we did find already has their listeners attached.
                                    var newThennables = suspended.updateQueue;
                                    if (newThennables !== null) {
                                        workInProgress.updateQueue = newThennables;
                                        workInProgress.flags |= Update;
                                    } // Rerender the whole list, but this time, we'll force fallbacks
                                    // to stay in place.
                                    // Reset the effect list before doing the second pass since that's now invalid.
                                    if (renderState.lastEffect === null) workInProgress.firstEffect = null;
                                    workInProgress.lastEffect = renderState.lastEffect; // Reset the child fibers to their original state.
                                    resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately
                                    // rerender the children.
                                    pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                                    return workInProgress.child;
                                }
                                row = row.sibling;
                            }
                        }
                        if (renderState.tail !== null && now() > getRenderTargetTime()) {
                            // We have already passed our CPU deadline but we still have rows
                            // left in the tail. We'll just give up further attempts to render
                            // the main content and only render fallbacks.
                            workInProgress.flags |= DidCapture;
                            didSuspendAlready = true;
                            cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this
                            // to get it started back up to attempt the next item. While in terms
                            // of priority this work has the same priority as this current render,
                            // it's not part of the same transition once the transition has
                            // committed. If it's sync, we still want to yield so that it can be
                            // painted. Conceptually, this is really the same as pinging.
                            // We can use any RetryLane even if it's the one currently rendering
                            // since we're leaving it behind on this node.
                            workInProgress.lanes = SomeRetryLane;
                            markSpawnedWork(SomeRetryLane);
                        }
                    } else cutOffTailIfNeeded(renderState, false);
                     // Next we're going to render the tail.
                } else {
                    // Append the rendered row to the child list.
                    if (!didSuspendAlready) {
                        var _suspended = findFirstSuspended(renderedTail);
                        if (_suspended !== null) {
                            workInProgress.flags |= DidCapture;
                            didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't
                            // get lost if this row ends up dropped during a second pass.
                            var _newThennables = _suspended.updateQueue;
                            if (_newThennables !== null) {
                                workInProgress.updateQueue = _newThennables;
                                workInProgress.flags |= Update;
                            }
                            cutOffTailIfNeeded(renderState, true); // This might have been modified.
                            if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.
                            ) {
                                // We need to delete the row we just rendered.
                                // Reset the effect list to what it was before we rendered this
                                // child. The nested children have already appended themselves.
                                var lastEffect = workInProgress.lastEffect = renderState.lastEffect; // Remove any effects that were appended after this point.
                                if (lastEffect !== null) lastEffect.nextEffect = null;
                                 // We're done.
                                return null;
                            }
                        } else if (// time we have to render. So rendering one more row would likely
                        // exceed it.
                        now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {
                            // We have now passed our CPU deadline and we'll just give up further
                            // attempts to render the main content and only render fallbacks.
                            // The assumption is that this is usually faster.
                            workInProgress.flags |= DidCapture;
                            didSuspendAlready = true;
                            cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this
                            // to get it started back up to attempt the next item. While in terms
                            // of priority this work has the same priority as this current render,
                            // it's not part of the same transition once the transition has
                            // committed. If it's sync, we still want to yield so that it can be
                            // painted. Conceptually, this is really the same as pinging.
                            // We can use any RetryLane even if it's the one currently rendering
                            // since we're leaving it behind on this node.
                            workInProgress.lanes = SomeRetryLane;
                            markSpawnedWork(SomeRetryLane);
                        }
                    }
                    if (renderState.isBackwards) {
                        // The effect list of the backwards tail will have been added
                        // to the end. This breaks the guarantee that life-cycles fire in
                        // sibling order but that isn't a strong guarantee promised by React.
                        // Especially since these might also just pop in during future commits.
                        // Append to the beginning of the list.
                        renderedTail.sibling = workInProgress.child;
                        workInProgress.child = renderedTail;
                    } else {
                        var previousSibling = renderState.last;
                        if (previousSibling !== null) previousSibling.sibling = renderedTail;
                        else workInProgress.child = renderedTail;
                        renderState.last = renderedTail;
                    }
                }
                if (renderState.tail !== null) {
                    // We still have tail rows to render.
                    // Pop a row.
                    var next = renderState.tail;
                    renderState.rendering = next;
                    renderState.tail = next.sibling;
                    renderState.lastEffect = workInProgress.lastEffect;
                    renderState.renderingStartTime = now();
                    next.sibling = null; // Restore the context.
                    // TODO: We can probably just avoid popping it instead and only
                    // setting it the first time we go from not suspended to suspended.
                    var suspenseContext = suspenseStackCursor.current;
                    if (didSuspendAlready) suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                    else suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                    pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.
                    return next;
                }
                return null;
            case FundamentalComponent:
                break;
            case ScopeComponent:
                break;
            case Block:
                break;
            case OffscreenComponent:
            case LegacyHiddenComponent:
                popRenderLanes(workInProgress);
                if (current !== null) {
                    var _nextState = workInProgress.memoizedState;
                    var _prevState = current.memoizedState;
                    var prevIsHidden = _prevState !== null;
                    var nextIsHidden = _nextState !== null;
                    if (prevIsHidden !== nextIsHidden && newProps.mode !== 'unstable-defer-without-hiding') workInProgress.flags |= Update;
                }
                return null;
        }
        throw Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function unwindWork(workInProgress, renderLanes) {
        switch(workInProgress.tag){
            case ClassComponent:
                var Component = workInProgress.type;
                if (isContextProvider(Component)) popContext(workInProgress);
                var flags = workInProgress.flags;
                if (flags & ShouldCapture) {
                    workInProgress.flags = flags & ~ShouldCapture | DidCapture;
                    if ((workInProgress.mode & ProfileMode) !== NoMode) transferActualDuration(workInProgress);
                    return workInProgress;
                }
                return null;
            case HostRoot:
                popHostContainer(workInProgress);
                popTopLevelContextObject(workInProgress);
                resetWorkInProgressVersions();
                var _flags = workInProgress.flags;
                if (!((_flags & DidCapture) === NoFlags)) throw Error("The root failed to unmount after an error. This is likely a bug in React. Please file an issue.");
                workInProgress.flags = _flags & ~ShouldCapture | DidCapture;
                return workInProgress;
            case HostComponent:
                // TODO: popHydrationState
                popHostContext(workInProgress);
                return null;
            case SuspenseComponent:
                popSuspenseContext(workInProgress);
                var _flags2 = workInProgress.flags;
                if (_flags2 & ShouldCapture) {
                    workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.
                    if ((workInProgress.mode & ProfileMode) !== NoMode) transferActualDuration(workInProgress);
                    return workInProgress;
                }
                return null;
            case SuspenseListComponent:
                popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been
                // caught by a nested boundary. If not, it should bubble through.
                return null;
            case HostPortal:
                popHostContainer(workInProgress);
                return null;
            case ContextProvider:
                popProvider(workInProgress);
                return null;
            case OffscreenComponent:
            case LegacyHiddenComponent:
                popRenderLanes(workInProgress);
                return null;
            default:
                return null;
        }
    }
    function unwindInterruptedWork(interruptedWork) {
        switch(interruptedWork.tag){
            case ClassComponent:
                var childContextTypes = interruptedWork.type.childContextTypes;
                if (childContextTypes !== null && childContextTypes !== undefined) popContext(interruptedWork);
                break;
            case HostRoot:
                popHostContainer(interruptedWork);
                popTopLevelContextObject(interruptedWork);
                resetWorkInProgressVersions();
                break;
            case HostComponent:
                popHostContext(interruptedWork);
                break;
            case HostPortal:
                popHostContainer(interruptedWork);
                break;
            case SuspenseComponent:
                popSuspenseContext(interruptedWork);
                break;
            case SuspenseListComponent:
                popSuspenseContext(interruptedWork);
                break;
            case ContextProvider:
                popProvider(interruptedWork);
                break;
            case OffscreenComponent:
            case LegacyHiddenComponent:
                popRenderLanes(interruptedWork);
                break;
        }
    }
    function createCapturedValue(value, source) {
        // If the value is an error, call this function immediately after it is thrown
        // so the stack is accurate.
        return {
            value: value,
            source: source,
            stack: getStackByFiberInDevAndProd(source)
        };
    }
    // This module is forked in different environments.
    // By default, return `true` to log errors to the console.
    // Forks can return `false` if this isn't desirable.
    function showErrorDialog(boundary, errorInfo) {
        return true;
    }
    function logCapturedError(boundary, errorInfo) {
        try {
            var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.
            // This enables renderers like ReactNative to better manage redbox behavior.
            if (logError === false) return;
            var error = errorInfo.value;
            var source = errorInfo.source;
            var stack = errorInfo.stack;
            var componentStack = stack !== null ? stack : ''; // Browsers support silencing uncaught errors by calling
            // `preventDefault()` in window `error` handler.
            // We record this information as an expando on the error.
            if (error != null && error._suppressLogging) {
                if (boundary.tag === ClassComponent) // The error is recoverable and was silenced.
                // Ignore it and don't print the stack addendum.
                // This is handy for testing error boundaries without noise.
                return;
                 // The error is fatal. Since the silencing might have
                // been accidental, we'll surface it anyway.
                // However, the browser would have silenced the original error
                // so we'll print it first, and then print the stack addendum.
                console['error'](error); // Don't transform to our wrapper
            // For a more detailed description of this block, see:
            // https://github.com/facebook/react/pull/13384
            }
            var componentName = source ? getComponentName(source.type) : null;
            var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : 'The above error occurred in one of your React components:';
            var errorBoundaryMessage;
            var errorBoundaryName = getComponentName(boundary.type);
            if (errorBoundaryName) errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
            else errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
            var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.
            // We don't include the original error message and JS stack because the browser
            // has already printed it. Even if the application swallows the error, it is still
            // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
            console['error'](combinedMessage); // Don't transform to our wrapper
        } catch (e) {
            // This method must not throw, or React internal state will get messed up.
            // If console.error is overridden, or logCapturedError() shows a dialog that throws,
            // we want to report this error outside of the normal stack as a last resort.
            // https://github.com/facebook/react/issues/13188
            setTimeout(function() {
                throw e;
            });
        }
    }
    var PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;
    function createRootErrorUpdate(fiber, errorInfo, lane) {
        var update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.
        update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property
        // being called "element".
        update.payload = {
            element: null
        };
        var error = errorInfo.value;
        update.callback = function() {
            onUncaughtError(error);
            logCapturedError(fiber, errorInfo);
        };
        return update;
    }
    function createClassErrorUpdate(fiber, errorInfo, lane) {
        var update = createUpdate(NoTimestamp, lane);
        update.tag = CaptureUpdate;
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if (typeof getDerivedStateFromError === 'function') {
            var error$1 = errorInfo.value;
            update.payload = function() {
                logCapturedError(fiber, errorInfo);
                return getDerivedStateFromError(error$1);
            };
        }
        var inst = fiber.stateNode;
        if (inst !== null && typeof inst.componentDidCatch === 'function') update.callback = function callback() {
            markFailedErrorBoundaryForHotReloading(fiber);
            if (typeof getDerivedStateFromError !== 'function') {
                // To preserve the preexisting retry behavior of error boundaries,
                // we keep track of which ones already failed during this batch.
                // This gets reset before we yield back to the browser.
                // TODO: Warn in strict mode if getDerivedStateFromError is
                // not defined.
                markLegacyErrorBoundaryAsFailed(this); // Only log here if componentDidCatch is the only error boundary method defined
                logCapturedError(fiber, errorInfo);
            }
            var error$1 = errorInfo.value;
            var stack = errorInfo.stack;
            this.componentDidCatch(error$1, {
                componentStack: stack !== null ? stack : ''
            });
            if (typeof getDerivedStateFromError !== 'function') // If componentDidCatch is the only error boundary method defined,
            // then it needs to call setState to recover from errors.
            // If no state update is scheduled then the boundary will swallow the error.
            {
                if (!includesSomeLane(fiber.lanes, SyncLane)) error1("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentName(fiber.type) || 'Unknown');
            }
        };
        else update.callback = function() {
            markFailedErrorBoundaryForHotReloading(fiber);
        };
        return update;
    }
    function attachPingListener(root, wakeable, lanes) {
        // Attach a listener to the promise to "ping" the root and retry. But only if
        // one does not already exist for the lanes we're currently rendering (which
        // acts like a "thread ID" here).
        var pingCache = root.pingCache;
        var threadIDs;
        if (pingCache === null) {
            pingCache = root.pingCache = new PossiblyWeakMap$1();
            threadIDs = new Set();
            pingCache.set(wakeable, threadIDs);
        } else {
            threadIDs = pingCache.get(wakeable);
            if (threadIDs === undefined) {
                threadIDs = new Set();
                pingCache.set(wakeable, threadIDs);
            }
        }
        if (!threadIDs.has(lanes)) {
            // Memoize using the thread ID to prevent redundant listeners.
            threadIDs.add(lanes);
            var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);
            wakeable.then(ping, ping);
        }
    }
    function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
        // The source fiber did not complete.
        sourceFiber.flags |= Incomplete; // Its effect list is no longer valid.
        sourceFiber.firstEffect = sourceFiber.lastEffect = null;
        if (value !== null && typeof value === 'object' && typeof value.then === 'function') {
            // This is a wakeable.
            var wakeable = value;
            if ((sourceFiber.mode & BlockingMode) === NoMode) {
                // Reset the memoizedState to what it was before we attempted
                // to render it.
                var currentSource = sourceFiber.alternate;
                if (currentSource) {
                    sourceFiber.updateQueue = currentSource.updateQueue;
                    sourceFiber.memoizedState = currentSource.memoizedState;
                    sourceFiber.lanes = currentSource.lanes;
                } else {
                    sourceFiber.updateQueue = null;
                    sourceFiber.memoizedState = null;
                }
            }
            var hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext); // Schedule the nearest Suspense to re-render the timed out view.
            var _workInProgress = returnFiber;
            do {
                if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)) {
                    // Found the nearest boundary.
                    // Stash the promise on the boundary fiber. If the boundary times out, we'll
                    // attach another listener to flip the boundary back to its normal state.
                    var wakeables = _workInProgress.updateQueue;
                    if (wakeables === null) {
                        var updateQueue = new Set();
                        updateQueue.add(wakeable);
                        _workInProgress.updateQueue = updateQueue;
                    } else wakeables.add(wakeable);
                     // If the boundary is outside of blocking mode, we should *not*
                    // suspend the commit. Pretend as if the suspended component rendered
                    // null and keep rendering. In the commit phase, we'll schedule a
                    // subsequent synchronous update to re-render the Suspense.
                    //
                    // Note: It doesn't matter whether the component that suspended was
                    // inside a blocking mode tree. If the Suspense is outside of it, we
                    // should *not* suspend the commit.
                    if ((_workInProgress.mode & BlockingMode) === NoMode) {
                        _workInProgress.flags |= DidCapture;
                        sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.
                        // But we shouldn't call any lifecycle methods or callbacks. Remove
                        // all lifecycle effect tags.
                        sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
                        if (sourceFiber.tag === ClassComponent) {
                            var currentSourceFiber = sourceFiber.alternate;
                            if (currentSourceFiber === null) // This is a new mount. Change the tag so it's not mistaken for a
                            // completed class component. For example, we should not call
                            // componentWillUnmount if it is deleted.
                            sourceFiber.tag = IncompleteClassComponent;
                            else {
                                // When we try rendering again, we should not reuse the current fiber,
                                // since it's known to be in an inconsistent state. Use a force update to
                                // prevent a bail out.
                                var update = createUpdate(NoTimestamp, SyncLane);
                                update.tag = ForceUpdate;
                                enqueueUpdate(sourceFiber, update);
                            }
                        } // The source fiber did not complete. Mark it with Sync priority to
                        // indicate that it still has pending work.
                        sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane); // Exit without suspending.
                        return;
                    } // Confirmed that the boundary is in a concurrent mode tree. Continue
                    // with the normal suspend path.
                    //
                    // After this we'll use a set of heuristics to determine whether this
                    // render pass will run to completion or restart or "suspend" the commit.
                    // The actual logic for this is spread out in different places.
                    //
                    // This first principle is that if we're going to suspend when we complete
                    // a root, then we should also restart if we get an update or ping that
                    // might unsuspend it, and vice versa. The only reason to suspend is
                    // because you think you might want to restart before committing. However,
                    // it doesn't make sense to restart only while in the period we're suspended.
                    //
                    // Restarting too aggressively is also not good because it starves out any
                    // intermediate loading state. So we use heuristics to determine when.
                    // Suspense Heuristics
                    //
                    // If nothing threw a Promise or all the same fallbacks are already showing,
                    // then don't suspend/restart.
                    //
                    // If this is an initial render of a new tree of Suspense boundaries and
                    // those trigger a fallback, then don't suspend/restart. We want to ensure
                    // that we can show the initial loading state as quickly as possible.
                    //
                    // If we hit a "Delayed" case, such as when we'd switch from content back into
                    // a fallback, then we should always suspend/restart. Transitions apply
                    // to this case. If none is defined, JND is used instead.
                    //
                    // If we're already showing a fallback and it gets "retried", allowing us to show
                    // another level, but there's still an inner boundary that would show a fallback,
                    // then we suspend/restart for 500ms since the last time we showed a fallback
                    // anywhere in the tree. This effectively throttles progressive loading into a
                    // consistent train of commits. This also gives us an opportunity to restart to
                    // get to the completed state slightly earlier.
                    //
                    // If there's ambiguity due to batching it's resolved in preference of:
                    // 1) "delayed", 2) "initial render", 3) "retry".
                    //
                    // We want to ensure that a "busy" state doesn't get force committed. We want to
                    // ensure that new initial loading states can commit as soon as possible.
                    attachPingListener(root, wakeable, rootRenderLanes);
                    _workInProgress.flags |= ShouldCapture;
                    _workInProgress.lanes = rootRenderLanes;
                    return;
                } // This boundary already captured during this render. Continue to the next
                // boundary.
                _workInProgress = _workInProgress.return;
            }while (_workInProgress !== null) // No boundary was found. Fallthrough to error mode.
            // TODO: Use invariant so the message is stripped in prod?
            value = new Error((getComponentName(sourceFiber.type) || 'A React component') + ' suspended while rendering, but no fallback UI was specified.\n' + '\n' + 'Add a <Suspense fallback=...> component higher in the tree to ' + 'provide a loading indicator or placeholder to display.');
        } // We didn't find a boundary that could handle this type of exception. Start
        // over and traverse parent path again, this time treating the exception
        // as an error.
        renderDidError();
        value = createCapturedValue(value, sourceFiber);
        var workInProgress = returnFiber;
        do {
            switch(workInProgress.tag){
                case HostRoot:
                    var _errorInfo = value;
                    workInProgress.flags |= ShouldCapture;
                    var lane = pickArbitraryLane(rootRenderLanes);
                    workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);
                    var _update = createRootErrorUpdate(workInProgress, _errorInfo, lane);
                    enqueueCapturedUpdate(workInProgress, _update);
                    return;
                case ClassComponent:
                    // Capture and retry
                    var errorInfo = value;
                    var ctor = workInProgress.type;
                    var instance = workInProgress.stateNode;
                    if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                        workInProgress.flags |= ShouldCapture;
                        var _lane = pickArbitraryLane(rootRenderLanes);
                        workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state
                        var _update2 = createClassErrorUpdate(workInProgress, errorInfo, _lane);
                        enqueueCapturedUpdate(workInProgress, _update2);
                        return;
                    }
                    break;
            }
            workInProgress = workInProgress.return;
        }while (workInProgress !== null)
    }
    var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
    var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;
    var callComponentWillUnmountWithTimer = function(current, instance) {
        instance.props = current.memoizedProps;
        instance.state = current.memoizedState;
        instance.componentWillUnmount();
    }; // Capture errors so they don't interrupt unmounting.
    function safelyCallComponentWillUnmount(current, instance) {
        invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current, instance);
        if (hasCaughtError()) {
            var unmountError = clearCaughtError();
            captureCommitPhaseError(current, unmountError);
        }
    }
    function safelyDetachRef(current) {
        var ref = current.ref;
        if (ref !== null) {
            if (typeof ref === 'function') {
                invokeGuardedCallback(null, ref, null, null);
                if (hasCaughtError()) {
                    var refError = clearCaughtError();
                    captureCommitPhaseError(current, refError);
                }
            } else ref.current = null;
        }
    }
    function safelyCallDestroy(current, destroy) {
        invokeGuardedCallback(null, destroy, null);
        if (hasCaughtError()) {
            var error = clearCaughtError();
            captureCommitPhaseError(current, error);
        }
    }
    function commitBeforeMutationLifeCycles(current, finishedWork) {
        switch(finishedWork.tag){
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent:
            case Block:
                return;
            case ClassComponent:
                if (finishedWork.flags & Snapshot) {
                    if (current !== null) {
                        var prevProps = current.memoizedProps;
                        var prevState = current.memoizedState;
                        var instance = finishedWork.stateNode; // We could update instance props and state here,
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) error1("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || 'instance');
                            if (instance.state !== finishedWork.memoizedState) error1("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || 'instance');
                        }
                        var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                        var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                        if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                            didWarnSet.add(finishedWork.type);
                            error1("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentName(finishedWork.type));
                        }
                        instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                    }
                }
                return;
            case HostRoot:
                if (finishedWork.flags & Snapshot) {
                    var root = finishedWork.stateNode;
                    clearContainer(root.containerInfo);
                }
                return;
            case HostComponent:
            case HostText:
            case HostPortal:
            case IncompleteClassComponent:
                // Nothing to do for these component types
                return;
        }
        throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function commitHookEffectListUnmount(tag, finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
                if ((effect.tag & tag) === tag) {
                    // Unmount
                    var destroy = effect.destroy;
                    effect.destroy = undefined;
                    if (destroy !== undefined) destroy();
                }
                effect = effect.next;
            }while (effect !== firstEffect)
        }
    }
    function commitHookEffectListMount(tag, finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
                if ((effect.tag & tag) === tag) {
                    // Mount
                    var create = effect.create;
                    effect.destroy = create();
                    var destroy = effect.destroy;
                    if (destroy !== undefined && typeof destroy !== 'function') {
                        var addendum = void 0;
                        if (destroy === null) addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                        else if (typeof destroy.then === 'function') addendum = "\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                        else addendum = ' You returned: ' + destroy;
                        error1("An effect function must not return anything besides a function, which is used for clean-up.%s", addendum);
                    }
                }
                effect = effect.next;
            }while (effect !== firstEffect)
        }
    }
    function schedulePassiveEffects(finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
                var _effect = effect, next = _effect.next, tag = _effect.tag;
                if ((tag & Passive$1) !== NoFlags$1 && (tag & HasEffect) !== NoFlags$1) {
                    enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);
                    enqueuePendingPassiveHookEffectMount(finishedWork, effect);
                }
                effect = next;
            }while (effect !== firstEffect)
        }
    }
    function commitLifeCycles(finishedRoot, current, finishedWork, committedLanes) {
        switch(finishedWork.tag){
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent:
            case Block:
                commitHookEffectListMount(Layout | HasEffect, finishedWork);
                schedulePassiveEffects(finishedWork);
                return;
            case ClassComponent:
                var instance = finishedWork.stateNode;
                if (finishedWork.flags & Update) {
                    if (current === null) {
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) error1("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || 'instance');
                            if (instance.state !== finishedWork.memoizedState) error1("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || 'instance');
                        }
                        instance.componentDidMount();
                    } else {
                        var prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);
                        var prevState = current.memoizedState; // We could update instance props and state here,
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) error1("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || 'instance');
                            if (instance.state !== finishedWork.memoizedState) error1("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || 'instance');
                        }
                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                    }
                } // TODO: I think this is now always non-null by the time it reaches the
                // commit phase. Consider removing the type check.
                var updateQueue = finishedWork.updateQueue;
                if (updateQueue !== null) {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) error1("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || 'instance');
                        if (instance.state !== finishedWork.memoizedState) error1("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || 'instance');
                    }
                    // but instead we rely on them being set during last render.
                    // TODO: revisit this when we implement resuming.
                    commitUpdateQueue(finishedWork, updateQueue, instance);
                }
                return;
            case HostRoot:
                // TODO: I think this is now always non-null by the time it reaches the
                // commit phase. Consider removing the type check.
                var _updateQueue = finishedWork.updateQueue;
                if (_updateQueue !== null) {
                    var _instance = null;
                    if (finishedWork.child !== null) switch(finishedWork.child.tag){
                        case HostComponent:
                            _instance = getPublicInstance(finishedWork.child.stateNode);
                            break;
                        case ClassComponent:
                            _instance = finishedWork.child.stateNode;
                            break;
                    }
                    commitUpdateQueue(finishedWork, _updateQueue, _instance);
                }
                return;
            case HostComponent:
                var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted
                // (eg DOM renderer may schedule auto-focus for inputs and form controls).
                // These effects should only be committed when components are first mounted,
                // aka when there is no current/alternate.
                if (current === null && finishedWork.flags & Update) {
                    var type = finishedWork.type;
                    var props = finishedWork.memoizedProps;
                    commitMount(_instance2, type, props);
                }
                return;
            case HostText:
                // We have no life-cycles associated with text.
                return;
            case HostPortal:
                // We have no life-cycles associated with portals.
                return;
            case Profiler:
                var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                var effectDuration = finishedWork.stateNode.effectDuration;
                var commitTime = getCommitTime();
                if (typeof onRender === 'function') onRender(finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime, finishedRoot.memoizedInteractions);
                return;
            case SuspenseComponent:
                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                return;
            case SuspenseListComponent:
            case IncompleteClassComponent:
            case FundamentalComponent:
            case ScopeComponent:
            case OffscreenComponent:
            case LegacyHiddenComponent:
                return;
        }
        throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function hideOrUnhideAllChildren(finishedWork, isHidden) {
        // We only have the top Fiber that was inserted but we need to recurse down its
        // children to find all the terminal nodes.
        var node = finishedWork;
        while(true){
            if (node.tag === HostComponent) {
                var instance = node.stateNode;
                if (isHidden) hideInstance(instance);
                else unhideInstance(node.stateNode, node.memoizedProps);
            } else if (node.tag === HostText) {
                var _instance3 = node.stateNode;
                if (isHidden) hideTextInstance(_instance3);
                else unhideTextInstance(_instance3, node.memoizedProps);
            } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;
            else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === finishedWork) return;
            while(node.sibling === null){
                if (node.return === null || node.return === finishedWork) return;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
    }
    function commitAttachRef(finishedWork) {
        var ref = finishedWork.ref;
        if (ref !== null) {
            var instance = finishedWork.stateNode;
            var instanceToUse;
            switch(finishedWork.tag){
                case HostComponent:
                    instanceToUse = getPublicInstance(instance);
                    break;
                default:
                    instanceToUse = instance;
            } // Moved outside to ensure DCE works with this flag
            if (typeof ref === 'function') ref(instanceToUse);
            else {
                if (!ref.hasOwnProperty('current')) error1("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentName(finishedWork.type));
                ref.current = instanceToUse;
            }
        }
    }
    function commitDetachRef(current) {
        var currentRef = current.ref;
        if (currentRef !== null) {
            if (typeof currentRef === 'function') currentRef(null);
            else currentRef.current = null;
        }
    } // User-originating errors (lifecycles and refs) should not interrupt
    // deletion, so don't let them throw. Host-originating errors should
    // interrupt deletion, so it's okay
    function commitUnmount(finishedRoot, current, renderPriorityLevel) {
        onCommitUnmount(current);
        switch(current.tag){
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent:
            case Block:
                var updateQueue = current.updateQueue;
                if (updateQueue !== null) {
                    var lastEffect = updateQueue.lastEffect;
                    if (lastEffect !== null) {
                        var firstEffect = lastEffect.next;
                        var effect = firstEffect;
                        do {
                            var _effect2 = effect, destroy = _effect2.destroy, tag = _effect2.tag;
                            if (destroy !== undefined) {
                                if ((tag & Passive$1) !== NoFlags$1) enqueuePendingPassiveHookEffectUnmount(current, effect);
                                else safelyCallDestroy(current, destroy);
                            }
                            effect = effect.next;
                        }while (effect !== firstEffect)
                    }
                }
                return;
            case ClassComponent:
                safelyDetachRef(current);
                var instance = current.stateNode;
                if (typeof instance.componentWillUnmount === 'function') safelyCallComponentWillUnmount(current, instance);
                return;
            case HostComponent:
                safelyDetachRef(current);
                return;
            case HostPortal:
                unmountHostComponents(finishedRoot, current);
                return;
            case FundamentalComponent:
                return;
            case DehydratedFragment:
                return;
            case ScopeComponent:
                return;
        }
    }
    function commitNestedUnmounts(finishedRoot, root, renderPriorityLevel) {
        // While we're inside a removed host node we don't want to call
        // removeChild on the inner nodes because they're removed by the top
        // call anyway. We also want to call componentWillUnmount on all
        // composites before this host node is removed from the tree. Therefore
        // we do an inner loop while we're still inside the host node.
        var node = root;
        while(true){
            commitUnmount(finishedRoot, node); // Visit children because they may contain more composite or host nodes.
            // Skip portals because commitUnmount() currently visits them recursively.
            if (node.child !== null && // If we don't use mutation we drill down into portals here instead.
            node.tag !== HostPortal) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === root) return;
            while(node.sibling === null){
                if (node.return === null || node.return === root) return;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
    }
    function detachFiberMutation(fiber) {
        // Cut off the return pointers to disconnect it from the tree. Ideally, we
        // should clear the child pointer of the parent alternate to let this
        // get GC:ed but we don't know which for sure which parent is the current
        // one so we'll settle for GC:ing the subtree of this child. This child
        // itself will be GC:ed when the parent updates the next time.
        // Note: we cannot null out sibling here, otherwise it can cause issues
        // with findDOMNode and how it requires the sibling field to carry out
        // traversal in a later effect. See PR #16820. We now clear the sibling
        // field after effects, see: detachFiberAfterEffects.
        //
        // Don't disconnect stateNode now; it will be detached in detachFiberAfterEffects.
        // It may be required if the current component is an error boundary,
        // and one of its descendants throws while unmounting a passive effect.
        fiber.alternate = null;
        fiber.child = null;
        fiber.dependencies = null;
        fiber.firstEffect = null;
        fiber.lastEffect = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.return = null;
        fiber.updateQueue = null;
        fiber._debugOwner = null;
    }
    function getHostParentFiber(fiber) {
        var parent = fiber.return;
        while(parent !== null){
            if (isHostParent(parent)) return parent;
            parent = parent.return;
        }
        throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function isHostParent(fiber) {
        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
    }
    function getHostSibling(fiber) {
        // We're going to search forward into the tree until we find a sibling host
        // node. Unfortunately, if multiple insertions are done in a row we have to
        // search past them. This leads to exponential search for the next sibling.
        // TODO: Find a more efficient way to do this.
        var node = fiber;
        siblings: while(true){
            // If we didn't find anything, let's try the next sibling.
            while(node.sibling === null){
                if (node.return === null || isHostParent(node.return)) // If we pop out of the root or hit the parent the fiber we are the
                // last sibling.
                return null;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
            while(node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment){
                // If it is not host node and, we might have a host node inside it.
                // Try to search down until we find one.
                if (node.flags & Placement) continue siblings;
                 // If we don't have a child, try the siblings instead.
                // We also skip portals because they are not part of this host tree.
                if (node.child === null || node.tag === HostPortal) continue siblings;
                else {
                    node.child.return = node;
                    node = node.child;
                }
            } // Check if this host node is stable or about to be placed.
            if (!(node.flags & Placement)) // Found it!
            return node.stateNode;
        }
    }
    function commitPlacement(finishedWork) {
        var parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.
        var parent;
        var isContainer;
        var parentStateNode = parentFiber.stateNode;
        switch(parentFiber.tag){
            case HostComponent:
                parent = parentStateNode;
                isContainer = false;
                break;
            case HostRoot:
                parent = parentStateNode.containerInfo;
                isContainer = true;
                break;
            case HostPortal:
                parent = parentStateNode.containerInfo;
                isContainer = true;
                break;
            case FundamentalComponent:
            // eslint-disable-next-line-no-fallthrough
            default:
                throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
        if (parentFiber.flags & ContentReset) {
            // Reset the text content of the parent before doing any insertions
            resetTextContent(parent); // Clear ContentReset from the effect tag
            parentFiber.flags &= ~ContentReset;
        }
        var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its
        // children to find all the terminal nodes.
        if (isContainer) insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
        else insertOrAppendPlacementNode(finishedWork, before, parent);
    }
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        var isHost = tag === HostComponent || tag === HostText;
        if (isHost || enableFundamentalAPI) {
            var stateNode = isHost ? node.stateNode : node.stateNode.instance;
            if (before) insertInContainerBefore(parent, stateNode, before);
            else appendChildToContainer(parent, stateNode);
        } else if (tag === HostPortal) ;
        else {
            var child = node.child;
            if (child !== null) {
                insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                var sibling = child.sibling;
                while(sibling !== null){
                    insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                    sibling = sibling.sibling;
                }
            }
        }
    }
    function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        var isHost = tag === HostComponent || tag === HostText;
        if (isHost || enableFundamentalAPI) {
            var stateNode = isHost ? node.stateNode : node.stateNode.instance;
            if (before) insertBefore(parent, stateNode, before);
            else appendChild(parent, stateNode);
        } else if (tag === HostPortal) ;
        else {
            var child = node.child;
            if (child !== null) {
                insertOrAppendPlacementNode(child, before, parent);
                var sibling = child.sibling;
                while(sibling !== null){
                    insertOrAppendPlacementNode(sibling, before, parent);
                    sibling = sibling.sibling;
                }
            }
        }
    }
    function unmountHostComponents(finishedRoot, current, renderPriorityLevel) {
        // We only have the top Fiber that was deleted but we need to recurse down its
        // children to find all the terminal nodes.
        var node = current; // Each iteration, currentParent is populated with node's host parent if not
        // currentParentIsValid.
        var currentParentIsValid = false; // Note: these two variables *must* always be updated together.
        var currentParent;
        var currentParentIsContainer;
        while(true){
            if (!currentParentIsValid) {
                var parent = node.return;
                findParent: while(true){
                    if (!(parent !== null)) throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
                    var parentStateNode = parent.stateNode;
                    switch(parent.tag){
                        case HostComponent:
                            currentParent = parentStateNode;
                            currentParentIsContainer = false;
                            break findParent;
                        case HostRoot:
                            currentParent = parentStateNode.containerInfo;
                            currentParentIsContainer = true;
                            break findParent;
                        case HostPortal:
                            currentParent = parentStateNode.containerInfo;
                            currentParentIsContainer = true;
                            break findParent;
                    }
                    parent = parent.return;
                }
                currentParentIsValid = true;
            }
            if (node.tag === HostComponent || node.tag === HostText) {
                commitNestedUnmounts(finishedRoot, node); // After all the children have unmounted, it is now safe to remove the
                // node from the tree.
                if (currentParentIsContainer) removeChildFromContainer(currentParent, node.stateNode);
                else removeChild(currentParent, node.stateNode);
                 // Don't visit children because we already visited them.
            } else if (node.tag === HostPortal) {
                if (node.child !== null) {
                    // When we go into a portal, it becomes the parent to remove from.
                    // We will reassign it back when we pop the portal on the way up.
                    currentParent = node.stateNode.containerInfo;
                    currentParentIsContainer = true; // Visit children because portals might contain host components.
                    node.child.return = node;
                    node = node.child;
                    continue;
                }
            } else {
                commitUnmount(finishedRoot, node); // Visit children because we may find more host components below.
                if (node.child !== null) {
                    node.child.return = node;
                    node = node.child;
                    continue;
                }
            }
            if (node === current) return;
            while(node.sibling === null){
                if (node.return === null || node.return === current) return;
                node = node.return;
                if (node.tag === HostPortal) // When we go out of the portal, we need to restore the parent.
                // Since we don't keep a stack of them, we will search for it.
                currentParentIsValid = false;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
    }
    function commitDeletion(finishedRoot, current, renderPriorityLevel) {
        // Recursively delete all host nodes from the parent.
        // Detach refs and call componentWillUnmount() on the whole subtree.
        unmountHostComponents(finishedRoot, current);
        var alternate = current.alternate;
        detachFiberMutation(current);
        if (alternate !== null) detachFiberMutation(alternate);
    }
    function commitWork(current, finishedWork) {
        switch(finishedWork.tag){
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent:
            case Block:
                commitHookEffectListUnmount(Layout | HasEffect, finishedWork);
                return;
            case ClassComponent:
                return;
            case HostComponent:
                var instance = finishedWork.stateNode;
                if (instance != null) {
                    // Commit the work prepared earlier.
                    var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
                    // as the newProps. The updatePayload will contain the real change in
                    // this case.
                    var oldProps = current !== null ? current.memoizedProps : newProps;
                    var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.
                    var updatePayload = finishedWork.updateQueue;
                    finishedWork.updateQueue = null;
                    if (updatePayload !== null) commitUpdate(instance, updatePayload, type, oldProps, newProps);
                }
                return;
            case HostText:
                if (!(finishedWork.stateNode !== null)) throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                var textInstance = finishedWork.stateNode;
                var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
                // as the newProps. The updatePayload will contain the real change in
                // this case.
                var oldText = current !== null ? current.memoizedProps : newText;
                commitTextUpdate(textInstance, oldText, newText);
                return;
            case HostRoot:
                var _root = finishedWork.stateNode;
                if (_root.hydrate) {
                    // We've just hydrated. No need to hydrate again.
                    _root.hydrate = false;
                    commitHydratedContainer(_root.containerInfo);
                }
                return;
            case Profiler:
                return;
            case SuspenseComponent:
                commitSuspenseComponent(finishedWork);
                attachSuspenseRetryListeners(finishedWork);
                return;
            case SuspenseListComponent:
                attachSuspenseRetryListeners(finishedWork);
                return;
            case IncompleteClassComponent:
                return;
            case FundamentalComponent:
                break;
            case ScopeComponent:
                break;
            case OffscreenComponent:
            case LegacyHiddenComponent:
                var newState = finishedWork.memoizedState;
                var isHidden = newState !== null;
                hideOrUnhideAllChildren(finishedWork, isHidden);
                return;
        }
        throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function commitSuspenseComponent(finishedWork) {
        var newState = finishedWork.memoizedState;
        if (newState !== null) {
            markCommitTimeOfFallback();
            // Hide the Offscreen component that contains the primary children. TODO:
            // Ideally, this effect would have been scheduled on the Offscreen fiber
            // itself. That's how unhiding works: the Offscreen component schedules an
            // effect on itself. However, in this case, the component didn't complete,
            // so the fiber was never added to the effect list in the normal path. We
            // could have appended it to the effect list in the Suspense component's
            // second pass, but doing it this way is less complicated. This would be
            // simpler if we got rid of the effect list and traversed the tree, like
            // we're planning to do.
            var primaryChildParent = finishedWork.child;
            hideOrUnhideAllChildren(primaryChildParent, true);
        }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        var newState = finishedWork.memoizedState;
        if (newState === null) {
            var current = finishedWork.alternate;
            if (current !== null) {
                var prevState = current.memoizedState;
                if (prevState !== null) {
                    var suspenseInstance = prevState.dehydrated;
                    if (suspenseInstance !== null) commitHydratedSuspenseInstance(suspenseInstance);
                }
            }
        }
    }
    function attachSuspenseRetryListeners(finishedWork) {
        // If this boundary just timed out, then it will have a set of wakeables.
        // For each wakeable, attach a listener so that when it resolves, React
        // attempts to re-render the boundary in the primary (pre-timeout) state.
        var wakeables = finishedWork.updateQueue;
        if (wakeables !== null) {
            finishedWork.updateQueue = null;
            var retryCache = finishedWork.stateNode;
            if (retryCache === null) retryCache = finishedWork.stateNode = new PossiblyWeakSet();
            wakeables.forEach(function(wakeable) {
                // Memoize using the boundary fiber to prevent redundant listeners.
                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                if (!retryCache.has(wakeable)) {
                    if (wakeable.__reactDoNotTraceInteractions !== true) retry = tracing.unstable_wrap(retry);
                    retryCache.add(wakeable);
                    wakeable.then(retry, retry);
                }
            });
        }
    } // This function detects when a Suspense boundary goes from visible to hidden.
    // It returns false if the boundary is already hidden.
    // TODO: Use an effect tag.
    function isSuspenseBoundaryBeingHidden(current, finishedWork) {
        if (current !== null) {
            var oldState = current.memoizedState;
            if (oldState === null || oldState.dehydrated !== null) {
                var newState = finishedWork.memoizedState;
                return newState !== null && newState.dehydrated === null;
            }
        }
        return false;
    }
    function commitResetTextContent(current) {
        resetTextContent(current.stateNode);
    }
    var COMPONENT_TYPE = 0;
    var HAS_PSEUDO_CLASS_TYPE = 1;
    var ROLE_TYPE = 2;
    var TEST_NAME_TYPE = 3;
    var TEXT_TYPE = 4;
    if (typeof Symbol === 'function' && Symbol.for) {
        var symbolFor$1 = Symbol.for;
        COMPONENT_TYPE = symbolFor$1('selector.component');
        HAS_PSEUDO_CLASS_TYPE = symbolFor$1('selector.has_pseudo_class');
        ROLE_TYPE = symbolFor$1('selector.role');
        TEST_NAME_TYPE = symbolFor$1('selector.test_id');
        TEXT_TYPE = symbolFor$1('selector.text');
    }
    var commitHooks = [];
    function onCommitRoot$1() {
        commitHooks.forEach(function(commitHook) {
            return commitHook();
        });
    }
    var ceil = Math.ceil;
    var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
    var NoContext = /*             */ 0;
    var BatchedContext = /*               */ 1;
    var EventContext = /*                 */ 2;
    var DiscreteEventContext = /*         */ 4;
    var LegacyUnbatchedContext = /*       */ 8;
    var RenderContext = /*                */ 16;
    var CommitContext = /*                */ 32;
    var RetryAfterError = /*       */ 64;
    var RootIncomplete = 0;
    var RootFatalErrored = 1;
    var RootErrored = 2;
    var RootSuspended = 3;
    var RootSuspendedWithDelay = 4;
    var RootCompleted = 5; // Describes where we are in the React execution stack
    var executionContext = NoContext; // The root we're working on
    var workInProgressRoot = null; // The fiber we're working on
    var workInProgress1 = null; // The lanes we're rendering
    var workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree
    // This is a superset of the lanes we started working on at the root. The only
    // case where it's different from `workInProgressRootRenderLanes` is when we
    // enter a subtree that is hidden and needs to be unhidden: Suspense and
    // Offscreen component.
    //
    // Most things in the work loop should deal with workInProgressRootRenderLanes.
    // Most things in begin/complete phases should deal with subtreeRenderLanes.
    var subtreeRenderLanes1 = NoLanes;
    var subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.
    var workInProgressRootExitStatus = RootIncomplete; // A fatal error, if one is thrown
    var workInProgressRootFatalError = null; // "Included" lanes refer to lanes that were worked on during this render. It's
    // slightly different than `renderLanes` because `renderLanes` can change as you
    // enter and exit an Offscreen tree. This value is the combination of all render
    // lanes for the entire render phase.
    var workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only
    // includes unprocessed updates, not work in bailed out children.
    var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.
    var workInProgressRootUpdatedLanes = NoLanes; // Lanes that were pinged (in an interleaved event) during this render.
    var workInProgressRootPingedLanes = NoLanes;
    var mostRecentlyUpdatedRoot = null; // The most recent time we committed a fallback. This lets us ensure a train
    // model where we don't commit new loading states in too quick succession.
    var globalMostRecentFallbackTime = 0;
    var FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering
    // more and prefer CPU suspense heuristics instead.
    var workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU
    // suspense heuristics and opt out of rendering more content.
    var RENDER_TIMEOUT_MS = 500;
    function resetRenderTimer() {
        workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
    }
    function getRenderTargetTime() {
        return workInProgressRootRenderTargetTime;
    }
    var nextEffect = null;
    var hasUncaughtError = false;
    var firstUncaughtError = null;
    var legacyErrorBoundariesThatAlreadyFailed = null;
    var rootDoesHavePassiveEffects = false;
    var rootWithPendingPassiveEffects = null;
    var pendingPassiveEffectsRenderPriority = NoPriority$1;
    var pendingPassiveEffectsLanes = NoLanes;
    var pendingPassiveHookEffectsMount = [];
    var pendingPassiveHookEffectsUnmount = [];
    var rootsWithPendingDiscreteUpdates = null; // Use these to prevent an infinite loop of nested updates
    var NESTED_UPDATE_LIMIT = 50;
    var nestedUpdateCount = 0;
    var rootWithNestedUpdates = null;
    var NESTED_PASSIVE_UPDATE_LIMIT = 50;
    var nestedPassiveUpdateCount = 0; // Marks the need to reschedule pending interactions at these lanes
    // during the commit phase. This enables them to be traced across components
    // that spawn new work during render. E.g. hidden boundaries, suspended SSR
    // hydration or SuspenseList.
    // TODO: Can use a bitmask instead of an array
    var spawnedWorkDuringRender = null; // If two updates are scheduled within the same event, we should treat their
    // event times as simultaneous, even if the actual clock time has advanced
    // between the first and second call.
    var currentEventTime = NoTimestamp;
    var currentEventWipLanes = NoLanes;
    var currentEventPendingLanes = NoLanes; // Dev only flag that tracks if passive effects are currently being flushed.
    // We warn about state updates for unmounted components differently in this case.
    var isFlushingPassiveEffects = false;
    var focusedInstanceHandle = null;
    var shouldFireAfterActiveInstanceBlur = false;
    function getWorkInProgressRoot() {
        return workInProgressRoot;
    }
    function requestEventTime() {
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) // We're inside React, so it's fine to read the actual time.
        return now();
         // We're not inside React, so we may be in the middle of a browser event.
        if (currentEventTime !== NoTimestamp) // Use the same start time for all updates until we enter React again.
        return currentEventTime;
         // This is the first update since React yielded. Compute a new start time.
        currentEventTime = now();
        return currentEventTime;
    }
    function requestUpdateLane(fiber) {
        // Special cases
        var mode = fiber.mode;
        if ((mode & BlockingMode) === NoMode) return SyncLane;
        else if ((mode & ConcurrentMode) === NoMode) return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
         // The algorithm for assigning an update to a lane should be stable for all
        // updates at the same priority within the same event. To do this, the inputs
        // to the algorithm must be the same. For example, we use the `renderLanes`
        // to avoid choosing a lane that is already in the middle of rendering.
        //
        // However, the "included" lanes could be mutated in between updates in the
        // same event, like if you perform an update inside `flushSync`. Or any other
        // code path that might call `prepareFreshStack`.
        //
        // The trick we use is to cache the first of each of these inputs within an
        // event. Then reset the cached values once we can be sure the event is over.
        // Our heuristic for that is whenever we enter a concurrent work loop.
        //
        // We'll do the same for `currentEventPendingLanes` below.
        if (currentEventWipLanes === NoLanes) currentEventWipLanes = workInProgressRootIncludedLanes;
        var isTransition = requestCurrentTransition() !== NoTransition;
        if (isTransition) {
            if (currentEventPendingLanes !== NoLanes) currentEventPendingLanes = mostRecentlyUpdatedRoot !== null ? mostRecentlyUpdatedRoot.pendingLanes : NoLanes;
            return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);
        } // TODO: Remove this dependency on the Scheduler priority.
        // To do that, we're replacing it with an update lane priority.
        var schedulerPriority = getCurrentPriorityLevel(); // The old behavior was using the priority level of the Scheduler.
        // This couples React to the Scheduler internals, so we're replacing it
        // with the currentUpdateLanePriority above. As an example of how this
        // could be problematic, if we're not inside `Scheduler.runWithPriority`,
        // then we'll get the priority of the current running Scheduler task,
        // which is probably not what we want.
        var lane;
        if ((executionContext & DiscreteEventContext) !== NoContext && schedulerPriority === UserBlockingPriority$2) lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);
        else {
            var schedulerLanePriority = schedulerPriorityToLanePriority(schedulerPriority);
            lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);
        }
        return lane;
    }
    function requestRetryLane(fiber) {
        // This is a fork of `requestUpdateLane` designed specifically for Suspense
        // "retries" â€” a special update that attempts to flip a Suspense boundary
        // from its placeholder state to its primary/resolved state.
        // Special cases
        var mode = fiber.mode;
        if ((mode & BlockingMode) === NoMode) return SyncLane;
        else if ((mode & ConcurrentMode) === NoMode) return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
         // See `requestUpdateLane` for explanation of `currentEventWipLanes`
        if (currentEventWipLanes === NoLanes) currentEventWipLanes = workInProgressRootIncludedLanes;
        return findRetryLane(currentEventWipLanes);
    }
    function scheduleUpdateOnFiber(fiber, lane, eventTime) {
        checkForNestedUpdates();
        warnAboutRenderPhaseUpdatesInDEV(fiber);
        var root = markUpdateLaneFromFiberToRoot(fiber, lane);
        if (root === null) {
            warnAboutUpdateOnUnmountedFiberInDEV(fiber);
            return null;
        } // Mark that the root has a pending update.
        markRootUpdated(root, lane, eventTime);
        if (root === workInProgressRoot) {
            workInProgressRootUpdatedLanes = mergeLanes(workInProgressRootUpdatedLanes, lane);
            if (workInProgressRootExitStatus === RootSuspendedWithDelay) // The root already suspended with a delay, which means this render
            // definitely won't finish. Since we have a new update, let's mark it as
            // suspended now, right before marking the incoming update. This has the
            // effect of interrupting the current render and switching to the update.
            // TODO: Make sure this doesn't override pings that happen while we've
            // already started rendering.
            markRootSuspended$1(root, workInProgressRootRenderLanes);
        } // TODO: requestUpdateLanePriority also reads the priority. Pass the
        // priority as an argument to that function and this one.
        var priorityLevel = getCurrentPriorityLevel();
        if (lane === SyncLane) {
            if ((executionContext & LegacyUnbatchedContext) !== NoContext && (executionContext & (RenderContext | CommitContext)) === NoContext) {
                // Register pending interactions on the root to avoid losing traced interaction data.
                schedulePendingInteractions(root, lane); // This is a legacy edge case. The initial mount of a ReactDOM.render-ed
                // root inside of batchedUpdates should be synchronous, but layout updates
                // should be deferred until the end of the batch.
                performSyncWorkOnRoot(root);
            } else {
                ensureRootIsScheduled(root, eventTime);
                schedulePendingInteractions(root, lane);
                if (executionContext === NoContext) {
                    // Flush the synchronous work now, unless we're already working or inside
                    // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
                    // scheduleCallbackForFiber to preserve the ability to schedule a callback
                    // without immediately flushing it. We only do this for user-initiated
                    // updates, to preserve historical behavior of legacy mode.
                    resetRenderTimer();
                    flushSyncCallbackQueue();
                }
            }
        } else {
            // Schedule a discrete update but only if it's not Sync.
            if ((executionContext & DiscreteEventContext) !== NoContext && // discrete, even inside a discrete event.
            (priorityLevel === UserBlockingPriority$2 || priorityLevel === ImmediatePriority$1)) {
                // This is the result of a discrete event. Track the lowest priority
                // discrete update per root so we can flush them early, if needed.
                if (rootsWithPendingDiscreteUpdates === null) rootsWithPendingDiscreteUpdates = new Set([
                    root
                ]);
                else rootsWithPendingDiscreteUpdates.add(root);
            } // Schedule other updates after in case the callback is sync.
            ensureRootIsScheduled(root, eventTime);
            schedulePendingInteractions(root, lane);
        } // We use this when assigning a lane for a transition inside
        // `requestUpdateLane`. We assume it's the same as the root being updated,
        // since in the common case of a single root app it probably is. If it's not
        // the same root, then it's not a huge deal, we just might batch more stuff
        // together more than necessary.
        mostRecentlyUpdatedRoot = root;
    } // This is split into a separate function so we can mark a fiber with pending
    // work without treating it as a typical update that originates from an event;
    // e.g. retrying a Suspense boundary isn't an update, but it does schedule work
    // on a fiber.
    function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
        // Update the source fiber's lanes
        sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
        var alternate = sourceFiber.alternate;
        if (alternate !== null) alternate.lanes = mergeLanes(alternate.lanes, lane);
        if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
        var node = sourceFiber;
        var parent = sourceFiber.return;
        while(parent !== null){
            parent.childLanes = mergeLanes(parent.childLanes, lane);
            alternate = parent.alternate;
            if (alternate !== null) alternate.childLanes = mergeLanes(alternate.childLanes, lane);
            else if ((parent.flags & (Placement | Hydrating)) !== NoFlags) warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
            node = parent;
            parent = parent.return;
        }
        if (node.tag === HostRoot) {
            var root = node.stateNode;
            return root;
        } else return null;
    } // Use this function to schedule a task for a root. There's only one task per
    // root; if a task was already scheduled, we'll check to make sure the priority
    // of the existing task is the same as the priority of the next level that the
    // root has work on. This function is called on every update, and right before
    // exiting a task.
    function ensureRootIsScheduled(root, currentTime) {
        var existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as
        // expired so we know to work on those next.
        markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.
        var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes); // This returns the priority level computed during the `getNextLanes` call.
        var newCallbackPriority = returnNextLanesPriority();
        if (nextLanes === NoLanes) {
            // Special case: There's nothing to work on.
            if (existingCallbackNode !== null) {
                cancelCallback(existingCallbackNode);
                root.callbackNode = null;
                root.callbackPriority = NoLanePriority;
            }
            return;
        } // Check if there's an existing task. We may be able to reuse it.
        if (existingCallbackNode !== null) {
            var existingCallbackPriority = root.callbackPriority;
            if (existingCallbackPriority === newCallbackPriority) // The priority hasn't changed. We can reuse the existing task. Exit.
            return;
             // The priority changed. Cancel the existing callback. We'll schedule a new
            // one below.
            cancelCallback(existingCallbackNode);
        } // Schedule a new callback.
        var newCallbackNode;
        if (newCallbackPriority === SyncLanePriority) // Special case: Sync React callbacks are scheduled on a special
        // internal queue
        newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
        else if (newCallbackPriority === SyncBatchedLanePriority) newCallbackNode = scheduleCallback(ImmediatePriority$1, performSyncWorkOnRoot.bind(null, root));
        else {
            var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);
            newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));
        }
        root.callbackPriority = newCallbackPriority;
        root.callbackNode = newCallbackNode;
    } // This is the entry point for every concurrent task, i.e. anything that
    // goes through Scheduler.
    function performConcurrentWorkOnRoot(root) {
        // Since we know we're in a React event, we can clear the current
        // event time. The next update will compute a new event time.
        currentEventTime = NoTimestamp;
        currentEventWipLanes = NoLanes;
        currentEventPendingLanes = NoLanes;
        if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) throw Error("Should not already be working.");
         // Flush any pending passive effects before deciding which lanes to work on,
        // in case they schedule additional work.
        var originalCallbackNode = root.callbackNode;
        var didFlushPassiveEffects = flushPassiveEffects();
        if (didFlushPassiveEffects) {
            // Something in the passive effect phase may have canceled the current task.
            // Check if the task node for this root was changed.
            if (root.callbackNode !== originalCallbackNode) // The current task was canceled. Exit. We don't need to call
            // `ensureRootIsScheduled` because the check above implies either that
            // there's a new task, or that there's no remaining work on this root.
            return null;
        } // Determine the next expiration time to work on, using the fields stored
        // on the root.
        var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
        if (lanes === NoLanes) // Defensive coding. This is never expected to happen.
        return null;
        var exitStatus = renderRootConcurrent(root, lanes);
        if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) // The render included lanes that were updated during the render phase.
        // For example, when unhiding a hidden tree, we include all the lanes
        // that were previously skipped when the tree was hidden. That set of
        // lanes is a superset of the lanes we started rendering with.
        //
        // So we'll throw out the current work and restart.
        prepareFreshStack(root, NoLanes);
        else if (exitStatus !== RootIncomplete) {
            if (exitStatus === RootErrored) {
                executionContext |= RetryAfterError; // If an error occurred during hydration,
                // discard server response and fall back to client side render.
                if (root.hydrate) {
                    root.hydrate = false;
                    clearContainer(root.containerInfo);
                } // If something threw an error, try rendering one more time. We'll render
                // synchronously to block concurrent data mutations, and we'll includes
                // all pending updates are included. If it still fails after the second
                // attempt, we'll give up and commit the resulting tree.
                lanes = getLanesToRetrySynchronouslyOnError(root);
                if (lanes !== NoLanes) exitStatus = renderRootSync(root, lanes);
            }
            if (exitStatus === RootFatalErrored) {
                var fatalError = workInProgressRootFatalError;
                prepareFreshStack(root, NoLanes);
                markRootSuspended$1(root, lanes);
                ensureRootIsScheduled(root, now());
                throw fatalError;
            } // We now have a consistent tree. The next step is either to commit it,
            // or, if something suspended, wait to commit it after a timeout.
            var finishedWork = root.current.alternate;
            root.finishedWork = finishedWork;
            root.finishedLanes = lanes;
            finishConcurrentRender(root, exitStatus, lanes);
        }
        ensureRootIsScheduled(root, now());
        if (root.callbackNode === originalCallbackNode) // The task node scheduled for this root is the same one that's
        // currently executed. Need to return a continuation.
        return performConcurrentWorkOnRoot.bind(null, root);
        return null;
    }
    function finishConcurrentRender(root, exitStatus, lanes) {
        switch(exitStatus){
            case RootIncomplete:
            case RootFatalErrored:
                throw Error("Root did not complete. This is a bug in React.");
            // Flow knows about invariant, so it complains if I add a break
            // statement, but eslint doesn't know about invariant, so it complains
            // if I do. eslint-disable-next-line no-fallthrough
            case RootErrored:
                // We should have already attempted to retry this tree. If we reached
                // this point, it errored again. Commit it.
                commitRoot(root);
                break;
            case RootSuspended:
                markRootSuspended$1(root, lanes); // We have an acceptable loading state. We need to figure out if we
                // should immediately commit it or wait a bit.
                if (includesOnlyRetries(lanes) && !shouldForceFlushFallbacksInDEV()) {
                    // This render only included retries, no updates. Throttle committing
                    // retries so that we don't show too many loading states too quickly.
                    var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.
                    if (msUntilTimeout > 10) {
                        var nextLanes = getNextLanes(root, NoLanes);
                        if (nextLanes !== NoLanes) break;
                        var suspendedLanes = root.suspendedLanes;
                        if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                            // We should prefer to render the fallback of at the last
                            // suspended level. Ping the last suspended level to try
                            // rendering it again.
                            // FIXME: What if the suspended lanes are Idle? Should not restart.
                            var eventTime = requestEventTime();
                            markRootPinged(root, suspendedLanes);
                            break;
                        } // The render is suspended, it hasn't timed out, and there's no
                        // lower priority work to do. Instead of committing the fallback
                        // immediately, wait for more data to arrive.
                        root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);
                        break;
                    }
                } // The work expired. Commit immediately.
                commitRoot(root);
                break;
            case RootSuspendedWithDelay:
                markRootSuspended$1(root, lanes);
                if (includesOnlyTransitions(lanes)) break;
                if (!shouldForceFlushFallbacksInDEV()) {
                    // This is not a transition, but we did trigger an avoided state.
                    // Schedule a placeholder to display after a short delay, using the Just
                    // Noticeable Difference.
                    // TODO: Is the JND optimization worth the added complexity? If this is
                    // the only reason we track the event time, then probably not.
                    // Consider removing.
                    var mostRecentEventTime = getMostRecentEventTime(root, lanes);
                    var eventTimeMs = mostRecentEventTime;
                    var timeElapsedMs = now() - eventTimeMs;
                    var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.
                    if (_msUntilTimeout > 10) {
                        // Instead of committing the fallback immediately, wait for more data
                        // to arrive.
                        root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), _msUntilTimeout);
                        break;
                    }
                } // Commit the placeholder.
                commitRoot(root);
                break;
            case RootCompleted:
                // The work completed. Ready to commit.
                commitRoot(root);
                break;
            default:
                throw Error("Unknown root exit status.");
        }
    }
    function markRootSuspended$1(root, suspendedLanes) {
        // When suspending, we should always exclude lanes that were pinged or (more
        // rarely, since we try to avoid it) updated during the render phase.
        // TODO: Lol maybe there's a better way to factor this besides this
        // obnoxiously named function :)
        suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
        suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);
        markRootSuspended(root, suspendedLanes);
    } // This is the entry point for synchronous tasks that don't go
    // through Scheduler
    function performSyncWorkOnRoot(root) {
        if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) throw Error("Should not already be working.");
        flushPassiveEffects();
        var lanes;
        var exitStatus;
        if (root === workInProgressRoot && includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)) {
            // There's a partial tree, and at least one of its lanes has expired. Finish
            // rendering it before rendering the rest of the expired work.
            lanes = workInProgressRootRenderLanes;
            exitStatus = renderRootSync(root, lanes);
            if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
                // The render included lanes that were updated during the render phase.
                // For example, when unhiding a hidden tree, we include all the lanes
                // that were previously skipped when the tree was hidden. That set of
                // lanes is a superset of the lanes we started rendering with.
                //
                // Note that this only happens when part of the tree is rendered
                // concurrently. If the whole tree is rendered synchronously, then there
                // are no interleaved events.
                lanes = getNextLanes(root, lanes);
                exitStatus = renderRootSync(root, lanes);
            }
        } else {
            lanes = getNextLanes(root, NoLanes);
            exitStatus = renderRootSync(root, lanes);
        }
        if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
            executionContext |= RetryAfterError; // If an error occurred during hydration,
            // discard server response and fall back to client side render.
            if (root.hydrate) {
                root.hydrate = false;
                clearContainer(root.containerInfo);
            } // If something threw an error, try rendering one more time. We'll render
            // synchronously to block concurrent data mutations, and we'll includes
            // all pending updates are included. If it still fails after the second
            // attempt, we'll give up and commit the resulting tree.
            lanes = getLanesToRetrySynchronouslyOnError(root);
            if (lanes !== NoLanes) exitStatus = renderRootSync(root, lanes);
        }
        if (exitStatus === RootFatalErrored) {
            var fatalError = workInProgressRootFatalError;
            prepareFreshStack(root, NoLanes);
            markRootSuspended$1(root, lanes);
            ensureRootIsScheduled(root, now());
            throw fatalError;
        } // We now have a consistent tree. Because this is a sync render, we
        // will commit it even if something suspended.
        var finishedWork = root.current.alternate;
        root.finishedWork = finishedWork;
        root.finishedLanes = lanes;
        commitRoot(root); // Before exiting, make sure there's a callback scheduled for the next
        // pending level.
        ensureRootIsScheduled(root, now());
        return null;
    }
    function flushDiscreteUpdates() {
        // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.
        // However, `act` uses `batchedUpdates`, so there's no way to distinguish
        // those two cases. Need to fix this before exposing flushDiscreteUpdates
        // as a public API.
        if ((executionContext & (BatchedContext | RenderContext | CommitContext)) !== NoContext) {
            if ((executionContext & RenderContext) !== NoContext) error1("unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.");
            // This is probably a nested event dispatch triggered by a lifecycle/effect,
            // like `el.focus()`. Exit.
            return;
        }
        flushPendingDiscreteUpdates(); // If the discrete updates scheduled passive effects, flush them now so that
        // they fire before the next serial event.
        flushPassiveEffects();
    }
    function flushPendingDiscreteUpdates() {
        if (rootsWithPendingDiscreteUpdates !== null) {
            // For each root with pending discrete updates, schedule a callback to
            // immediately flush them.
            var roots = rootsWithPendingDiscreteUpdates;
            rootsWithPendingDiscreteUpdates = null;
            roots.forEach(function(root) {
                markDiscreteUpdatesExpired(root);
                ensureRootIsScheduled(root, now());
            });
        } // Now flush the immediate queue.
        flushSyncCallbackQueue();
    }
    function batchedUpdates$1(fn, a) {
        var prevExecutionContext = executionContext;
        executionContext |= BatchedContext;
        try {
            return fn(a);
        } finally{
            executionContext = prevExecutionContext;
            if (executionContext === NoContext) {
                // Flush the immediate callbacks that were scheduled during this batch
                resetRenderTimer();
                flushSyncCallbackQueue();
            }
        }
    }
    function batchedEventUpdates$1(fn, a) {
        var prevExecutionContext = executionContext;
        executionContext |= EventContext;
        try {
            return fn(a);
        } finally{
            executionContext = prevExecutionContext;
            if (executionContext === NoContext) {
                // Flush the immediate callbacks that were scheduled during this batch
                resetRenderTimer();
                flushSyncCallbackQueue();
            }
        }
    }
    function discreteUpdates$1(fn, a, b, c, d) {
        var prevExecutionContext = executionContext;
        executionContext |= DiscreteEventContext;
        try {
            return runWithPriority$1(UserBlockingPriority$2, fn.bind(null, a, b, c, d));
        } finally{
            executionContext = prevExecutionContext;
            if (executionContext === NoContext) {
                // Flush the immediate callbacks that were scheduled during this batch
                resetRenderTimer();
                flushSyncCallbackQueue();
            }
        }
    }
    function unbatchedUpdates(fn, a) {
        var prevExecutionContext = executionContext;
        executionContext &= ~BatchedContext;
        executionContext |= LegacyUnbatchedContext;
        try {
            return fn(a);
        } finally{
            executionContext = prevExecutionContext;
            if (executionContext === NoContext) {
                // Flush the immediate callbacks that were scheduled during this batch
                resetRenderTimer();
                flushSyncCallbackQueue();
            }
        }
    }
    function flushSync(fn, a) {
        var prevExecutionContext = executionContext;
        if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {
            error1("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
            return fn(a);
        }
        executionContext |= BatchedContext;
        try {
            if (fn) return runWithPriority$1(ImmediatePriority$1, fn.bind(null, a));
            else return undefined;
        } finally{
            executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.
            // Note that this will happen even if batchedUpdates is higher up
            // the stack.
            flushSyncCallbackQueue();
        }
    }
    function pushRenderLanes(fiber, lanes) {
        push(subtreeRenderLanesCursor, subtreeRenderLanes1, fiber);
        subtreeRenderLanes1 = mergeLanes(subtreeRenderLanes1, lanes);
        workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
    }
    function popRenderLanes(fiber) {
        subtreeRenderLanes1 = subtreeRenderLanesCursor.current;
        pop(subtreeRenderLanesCursor, fiber);
    }
    function prepareFreshStack(root, lanes) {
        root.finishedWork = null;
        root.finishedLanes = NoLanes;
        var timeoutHandle = root.timeoutHandle;
        if (timeoutHandle !== noTimeout) {
            // The root previous suspended and scheduled a timeout to commit a fallback
            // state. Now that we have additional work, cancel the timeout.
            root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
            cancelTimeout(timeoutHandle);
        }
        if (workInProgress1 !== null) {
            var interruptedWork = workInProgress1.return;
            while(interruptedWork !== null){
                unwindInterruptedWork(interruptedWork);
                interruptedWork = interruptedWork.return;
            }
        }
        workInProgressRoot = root;
        workInProgress1 = createWorkInProgress(root.current, null);
        workInProgressRootRenderLanes = subtreeRenderLanes1 = workInProgressRootIncludedLanes = lanes;
        workInProgressRootExitStatus = RootIncomplete;
        workInProgressRootFatalError = null;
        workInProgressRootSkippedLanes = NoLanes;
        workInProgressRootUpdatedLanes = NoLanes;
        workInProgressRootPingedLanes = NoLanes;
        spawnedWorkDuringRender = null;
        ReactStrictModeWarnings.discardPendingWarnings();
    }
    function handleError(root, thrownValue) {
        do {
            var erroredWork = workInProgress1;
            try {
                // Reset module-level state that was set during the render phase.
                resetContextDependencies();
                resetHooksAfterThrow();
                resetCurrentFiber(); // TODO: I found and added this missing line while investigating a
                // separate issue. Write a regression test using string refs.
                ReactCurrentOwner$2.current = null;
                if (erroredWork === null || erroredWork.return === null) {
                    // Expected to be working on a non-root fiber. This is a fatal error
                    // because there's no ancestor that can handle it; the root is
                    // supposed to capture all errors that weren't caught by an error
                    // boundary.
                    workInProgressRootExitStatus = RootFatalErrored;
                    workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next
                    // sibling, or the parent if there are no siblings. But since the root
                    // has no siblings nor a parent, we set it to null. Usually this is
                    // handled by `completeUnitOfWork` or `unwindWork`, but since we're
                    // intentionally not calling those, we need set it here.
                    // TODO: Consider calling `unwindWork` to pop the contexts.
                    workInProgress1 = null;
                    return;
                }
                if (enableProfilerTimer && erroredWork.mode & ProfileMode) // Record the time spent rendering before an error was thrown. This
                // avoids inaccurate Profiler durations in the case of a
                // suspended render.
                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
                throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
                completeUnitOfWork(erroredWork);
            } catch (yetAnotherThrownValue) {
                // Something in the return path also threw.
                thrownValue = yetAnotherThrownValue;
                if (workInProgress1 === erroredWork && erroredWork !== null) {
                    // If this boundary has already errored, then we had trouble processing
                    // the error. Bubble it to the next boundary.
                    erroredWork = erroredWork.return;
                    workInProgress1 = erroredWork;
                } else erroredWork = workInProgress1;
                continue;
            } // Return to the normal work loop.
            return;
        }while (true)
    }
    function pushDispatcher() {
        var prevDispatcher = ReactCurrentDispatcher$2.current;
        ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
        if (prevDispatcher === null) // The React isomorphic package does not include a default dispatcher.
        // Instead the first renderer will lazily attach one, in order to give
        // nicer error messages.
        return ContextOnlyDispatcher;
        else return prevDispatcher;
    }
    function popDispatcher(prevDispatcher) {
        ReactCurrentDispatcher$2.current = prevDispatcher;
    }
    function pushInteractions(root) {
        var prevInteractions = tracing.__interactionsRef.current;
        tracing.__interactionsRef.current = root.memoizedInteractions;
        return prevInteractions;
    }
    function popInteractions(prevInteractions) {
        tracing.__interactionsRef.current = prevInteractions;
    }
    function markCommitTimeOfFallback() {
        globalMostRecentFallbackTime = now();
    }
    function markSkippedUpdateLanes(lane) {
        workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
    }
    function renderDidSuspend() {
        if (workInProgressRootExitStatus === RootIncomplete) workInProgressRootExitStatus = RootSuspended;
    }
    function renderDidSuspendDelayIfPossible() {
        if (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) workInProgressRootExitStatus = RootSuspendedWithDelay;
         // Check if there are updates that we skipped tree that might have unblocked
        // this render.
        if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootUpdatedLanes))) // Mark the current render as suspended so that we switch to working on
        // the updates that were skipped. Usually we only suspend at the end of
        // the render phase.
        // TODO: We should probably always mark the root as suspended immediately
        // (inside this function), since by suspending at the end of the render
        // phase introduces a potential mistake where we suspend lanes that were
        // pinged or updated while we were rendering.
        markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
    }
    function renderDidError() {
        if (workInProgressRootExitStatus !== RootCompleted) workInProgressRootExitStatus = RootErrored;
    } // Called during render to determine if anything has suspended.
    // Returns false if we're not sure.
    function renderHasNotSuspendedYet() {
        // If something errored or completed, we can't really be sure,
        // so those are false.
        return workInProgressRootExitStatus === RootIncomplete;
    }
    function renderRootSync(root, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
        // and prepare a fresh one. Otherwise we'll continue where we left off.
        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
            prepareFreshStack(root, lanes);
            startWorkOnPendingInteractions(root, lanes);
        }
        var prevInteractions = pushInteractions(root);
        for(;;)try {
            workLoopSync();
            break;
        } catch (thrownValue) {
            handleError(root, thrownValue);
        }
        resetContextDependencies();
        popInteractions(prevInteractions);
        executionContext = prevExecutionContext;
        popDispatcher(prevDispatcher);
        if (workInProgress1 !== null) throw Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
        workInProgressRoot = null;
        workInProgressRootRenderLanes = NoLanes;
        return workInProgressRootExitStatus;
    } // The work loop is an extremely hot path. Tell Closure not to inline it.
    /** @noinline */ function workLoopSync() {
        // Already timed out, so perform work without checking if we need to yield.
        while(workInProgress1 !== null)performUnitOfWork(workInProgress1);
    }
    function renderRootConcurrent(root, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
        // and prepare a fresh one. Otherwise we'll continue where we left off.
        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
            resetRenderTimer();
            prepareFreshStack(root, lanes);
            startWorkOnPendingInteractions(root, lanes);
        }
        var prevInteractions = pushInteractions(root);
        for(;;)try {
            workLoopConcurrent();
            break;
        } catch (thrownValue) {
            handleError(root, thrownValue);
        }
        resetContextDependencies();
        popInteractions(prevInteractions);
        popDispatcher(prevDispatcher);
        executionContext = prevExecutionContext;
        if (workInProgress1 !== null) return RootIncomplete;
        else {
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes; // Return the final exit status.
            return workInProgressRootExitStatus;
        }
    }
    /** @noinline */ function workLoopConcurrent() {
        // Perform work until Scheduler asks us to yield
        while(workInProgress1 !== null && !shouldYield())performUnitOfWork(workInProgress1);
    }
    function performUnitOfWork(unitOfWork) {
        // The current, flushed, state of this fiber is the alternate. Ideally
        // nothing should rely on this, but relying on it here means that we don't
        // need an additional field on the work in progress.
        var current = unitOfWork.alternate;
        setCurrentFiber(unitOfWork);
        var next;
        if ((unitOfWork.mode & ProfileMode) !== NoMode) {
            startProfilerTimer(unitOfWork);
            next = beginWork$1(current, unitOfWork, subtreeRenderLanes1);
            stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
        } else next = beginWork$1(current, unitOfWork, subtreeRenderLanes1);
        resetCurrentFiber();
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        if (next === null) // If this doesn't spawn new work, complete the current work.
        completeUnitOfWork(unitOfWork);
        else workInProgress1 = next;
        ReactCurrentOwner$2.current = null;
    }
    function completeUnitOfWork(unitOfWork) {
        // Attempt to complete the current unit of work, then move to the next
        // sibling. If there are no more siblings, return to the parent fiber.
        var completedWork = unitOfWork;
        do {
            // The current, flushed, state of this fiber is the alternate. Ideally
            // nothing should rely on this, but relying on it here means that we don't
            // need an additional field on the work in progress.
            var current = completedWork.alternate;
            var returnFiber = completedWork.return; // Check if the work completed or if something threw.
            if ((completedWork.flags & Incomplete) === NoFlags) {
                setCurrentFiber(completedWork);
                var next = void 0;
                if ((completedWork.mode & ProfileMode) === NoMode) next = completeWork(current, completedWork, subtreeRenderLanes1);
                else {
                    startProfilerTimer(completedWork);
                    next = completeWork(current, completedWork, subtreeRenderLanes1); // Update render duration assuming we didn't error.
                    stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                }
                resetCurrentFiber();
                if (next !== null) {
                    // Completing this fiber spawned new work. Work on that next.
                    workInProgress1 = next;
                    return;
                }
                resetChildLanes(completedWork);
                if (returnFiber !== null && (returnFiber.flags & Incomplete) === NoFlags) {
                    // Append all the effects of the subtree and this fiber onto the effect
                    // list of the parent. The completion order of the children affects the
                    // side-effect order.
                    if (returnFiber.firstEffect === null) returnFiber.firstEffect = completedWork.firstEffect;
                    if (completedWork.lastEffect !== null) {
                        if (returnFiber.lastEffect !== null) returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
                        returnFiber.lastEffect = completedWork.lastEffect;
                    } // If this fiber had side-effects, we append it AFTER the children's
                    // side-effects. We can perform certain side-effects earlier if needed,
                    // by doing multiple passes over the effect list. We don't want to
                    // schedule our own side-effect on our own list because if end up
                    // reusing children we'll schedule this effect onto itself since we're
                    // at the end.
                    var flags = completedWork.flags; // Skip both NoWork and PerformedWork tags when creating the effect
                    // list. PerformedWork effect is read by React DevTools but shouldn't be
                    // committed.
                    if (flags > PerformedWork) {
                        if (returnFiber.lastEffect !== null) returnFiber.lastEffect.nextEffect = completedWork;
                        else returnFiber.firstEffect = completedWork;
                        returnFiber.lastEffect = completedWork;
                    }
                }
            } else {
                // This fiber did not complete because something threw. Pop values off
                // the stack without entering the complete phase. If this is a boundary,
                // capture values if possible.
                var _next = unwindWork(completedWork); // Because this fiber did not complete, don't reset its expiration time.
                if (_next !== null) {
                    // If completing this work spawned new work, do that next. We'll come
                    // back here again.
                    // Since we're restarting, remove anything that is not a host effect
                    // from the effect tag.
                    _next.flags &= HostEffectMask;
                    workInProgress1 = _next;
                    return;
                }
                if ((completedWork.mode & ProfileMode) !== NoMode) {
                    // Record the render duration for the fiber that errored.
                    stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.
                    var actualDuration = completedWork.actualDuration;
                    var child = completedWork.child;
                    while(child !== null){
                        actualDuration += child.actualDuration;
                        child = child.sibling;
                    }
                    completedWork.actualDuration = actualDuration;
                }
                if (returnFiber !== null) {
                    // Mark the parent fiber as incomplete and clear its effect list.
                    returnFiber.firstEffect = returnFiber.lastEffect = null;
                    returnFiber.flags |= Incomplete;
                }
            }
            var siblingFiber = completedWork.sibling;
            if (siblingFiber !== null) {
                // If there is more work to do in this returnFiber, do that next.
                workInProgress1 = siblingFiber;
                return;
            } // Otherwise, return to the parent
            completedWork = returnFiber; // Update the next thing we're working on in case something throws.
            workInProgress1 = completedWork;
        }while (completedWork !== null) // We've reached the root.
        if (workInProgressRootExitStatus === RootIncomplete) workInProgressRootExitStatus = RootCompleted;
    }
    function resetChildLanes(completedWork) {
        if (// to switch statement in `completeWork`.
        (completedWork.tag === LegacyHiddenComponent || completedWork.tag === OffscreenComponent) && completedWork.memoizedState !== null && !includesSomeLane(subtreeRenderLanes1, OffscreenLane) && (completedWork.mode & ConcurrentMode) !== NoLanes) // The children of this component are hidden. Don't bubble their
        // expiration times.
        return;
        var newChildLanes = NoLanes; // Bubble up the earliest expiration time.
        if ((completedWork.mode & ProfileMode) !== NoMode) {
            // In profiling mode, resetChildExpirationTime is also used to reset
            // profiler durations.
            var actualDuration = completedWork.actualDuration;
            var treeBaseDuration = completedWork.selfBaseDuration; // When a fiber is cloned, its actualDuration is reset to 0. This value will
            // only be updated if work is done on the fiber (i.e. it doesn't bailout).
            // When work is done, it should bubble to the parent's actualDuration. If
            // the fiber has not been cloned though, (meaning no work was done), then
            // this value will reflect the amount of time spent working on a previous
            // render. In that case it should not bubble. We determine whether it was
            // cloned by comparing the child pointer.
            var shouldBubbleActualDurations = completedWork.alternate === null || completedWork.child !== completedWork.alternate.child;
            var child = completedWork.child;
            while(child !== null){
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                if (shouldBubbleActualDurations) actualDuration += child.actualDuration;
                treeBaseDuration += child.treeBaseDuration;
                child = child.sibling;
            }
            var isTimedOutSuspense = completedWork.tag === SuspenseComponent && completedWork.memoizedState !== null;
            if (isTimedOutSuspense) {
                // Don't count time spent in a timed out Suspense subtree as part of the base duration.
                var primaryChildFragment = completedWork.child;
                if (primaryChildFragment !== null) treeBaseDuration -= primaryChildFragment.treeBaseDuration;
            }
            completedWork.actualDuration = actualDuration;
            completedWork.treeBaseDuration = treeBaseDuration;
        } else {
            var _child = completedWork.child;
            while(_child !== null){
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                _child = _child.sibling;
            }
        }
        completedWork.childLanes = newChildLanes;
    }
    function commitRoot(root) {
        var renderPriorityLevel = getCurrentPriorityLevel();
        runWithPriority$1(ImmediatePriority$1, commitRootImpl.bind(null, root, renderPriorityLevel));
        return null;
    }
    function commitRootImpl(root, renderPriorityLevel) {
        do // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
        // means `flushPassiveEffects` will sometimes result in additional
        // passive effects. So we need to keep flushing in a loop until there are
        // no more pending effects.
        // TODO: Might be better if `flushPassiveEffects` did not automatically
        // flush synchronous work at the end, to avoid factoring hazards like this.
        flushPassiveEffects();
        while (rootWithPendingPassiveEffects !== null)
        flushRenderPhaseStrictModeWarningsInDEV();
        if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) throw Error("Should not already be working.");
        var finishedWork = root.finishedWork;
        var lanes = root.finishedLanes;
        if (finishedWork === null) return null;
        root.finishedWork = null;
        root.finishedLanes = NoLanes;
        if (!(finishedWork !== root.current)) throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
         // commitRoot never returns a continuation; it always finishes synchronously.
        // So we can clear these now to allow a new callback to be scheduled.
        root.callbackNode = null; // Update the first and last pending times on this root. The new first
        // pending time is whatever is left on the root fiber.
        var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
        markRootFinished(root, remainingLanes); // Clear already finished discrete updates in case that a later call of
        // `flushDiscreteUpdates` starts a useless render pass which may cancels
        // a scheduled timeout.
        if (rootsWithPendingDiscreteUpdates !== null) {
            if (!hasDiscreteLanes(remainingLanes) && rootsWithPendingDiscreteUpdates.has(root)) rootsWithPendingDiscreteUpdates.delete(root);
        }
        if (root === workInProgressRoot) {
            // We can reset these now that they are finished.
            workInProgressRoot = null;
            workInProgress1 = null;
            workInProgressRootRenderLanes = NoLanes;
        } // Get the list of effects.
        var firstEffect;
        if (finishedWork.flags > PerformedWork) {
            // A fiber's effect list consists only of its children, not itself. So if
            // the root has an effect, we need to add it to the end of the list. The
            // resulting list is the set that would belong to the root's parent, if it
            // had one; that is, all the effects in the tree including the root.
            if (finishedWork.lastEffect !== null) {
                finishedWork.lastEffect.nextEffect = finishedWork;
                firstEffect = finishedWork.firstEffect;
            } else firstEffect = finishedWork;
        } else // There is no effect on the root.
        firstEffect = finishedWork.firstEffect;
        if (firstEffect !== null) {
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            var prevInteractions = pushInteractions(root); // Reset this to null before calling lifecycles
            ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass
            // of the effect list for each phase: all mutation effects come before all
            // layout effects, and so on.
            // The first phase a "before mutation" phase. We use this phase to read the
            // state of the host tree right before we mutate it. This is where
            // getSnapshotBeforeUpdate is called.
            focusedInstanceHandle = prepareForCommit(root.containerInfo);
            shouldFireAfterActiveInstanceBlur = false;
            nextEffect = firstEffect;
            do {
                invokeGuardedCallback(null, commitBeforeMutationEffects, null);
                if (hasCaughtError()) {
                    if (!(nextEffect !== null)) throw Error("Should be working on an effect.");
                    var error = clearCaughtError();
                    captureCommitPhaseError(nextEffect, error);
                    nextEffect = nextEffect.nextEffect;
                }
            }while (nextEffect !== null) // We no longer need to track the active instance fiber
            focusedInstanceHandle = null;
            // Mark the current commit time to be shared by all Profilers in this
            // batch. This enables them to be grouped later.
            recordCommitTime();
            nextEffect = firstEffect;
            do {
                invokeGuardedCallback(null, commitMutationEffects, null, root, renderPriorityLevel);
                if (hasCaughtError()) {
                    if (!(nextEffect !== null)) throw Error("Should be working on an effect.");
                    var _error = clearCaughtError();
                    captureCommitPhaseError(nextEffect, _error);
                    nextEffect = nextEffect.nextEffect;
                }
            }while (nextEffect !== null)
            resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after
            // the mutation phase, so that the previous tree is still current during
            // componentWillUnmount, but before the layout phase, so that the finished
            // work is current during componentDidMount/Update.
            root.current = finishedWork; // The next phase is the layout phase, where we call effects that read
            // the host tree after it's been mutated. The idiomatic use case for this is
            // layout, but class component lifecycles also fire here for legacy reasons.
            nextEffect = firstEffect;
            do {
                invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);
                if (hasCaughtError()) {
                    if (!(nextEffect !== null)) throw Error("Should be working on an effect.");
                    var _error2 = clearCaughtError();
                    captureCommitPhaseError(nextEffect, _error2);
                    nextEffect = nextEffect.nextEffect;
                }
            }while (nextEffect !== null)
            nextEffect = null; // Tell Scheduler to yield at the end of the frame, so the browser has an
            // opportunity to paint.
            requestPaint();
            popInteractions(prevInteractions);
            executionContext = prevExecutionContext;
        } else {
            // No effects.
            root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were
            recordCommitTime();
        }
        var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
        if (rootDoesHavePassiveEffects) {
            // This commit has passive effects. Stash a reference to them. But don't
            // schedule a callback until after flushing layout work.
            rootDoesHavePassiveEffects = false;
            rootWithPendingPassiveEffects = root;
            pendingPassiveEffectsLanes = lanes;
            pendingPassiveEffectsRenderPriority = renderPriorityLevel;
        } else {
            // We are done with the effect chain at this point so let's clear the
            // nextEffect pointers to assist with GC. If we have passive effects, we'll
            // clear this in flushPassiveEffects.
            nextEffect = firstEffect;
            while(nextEffect !== null){
                var nextNextEffect = nextEffect.nextEffect;
                nextEffect.nextEffect = null;
                if (nextEffect.flags & Deletion) detachFiberAfterEffects(nextEffect);
                nextEffect = nextNextEffect;
            }
        } // Read this again, since an effect might have updated it
        remainingLanes = root.pendingLanes; // Check if there's remaining work on this root
        if (remainingLanes !== NoLanes) {
            if (spawnedWorkDuringRender !== null) {
                var expirationTimes = spawnedWorkDuringRender;
                spawnedWorkDuringRender = null;
                for(var i = 0; i < expirationTimes.length; i++)scheduleInteractions(root, expirationTimes[i], root.memoizedInteractions);
            }
            schedulePendingInteractions(root, remainingLanes);
        } else // If there's no remaining work, we can clear the set of already failed
        // error boundaries.
        legacyErrorBoundariesThatAlreadyFailed = null;
        if (!rootDidHavePassiveEffects) // If there are no passive effects, then we can complete the pending interactions.
        // Otherwise, we'll wait until after the passive effects are flushed.
        // Wait to do this until after remaining work has been scheduled,
        // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.
        finishPendingInteractions(root, lanes);
        if (remainingLanes === SyncLane) {
            // Count the number of times the root synchronously re-renders without
            // finishing. If there are too many, it indicates an infinite update loop.
            if (root === rootWithNestedUpdates) nestedUpdateCount++;
            else {
                nestedUpdateCount = 0;
                rootWithNestedUpdates = root;
            }
        } else nestedUpdateCount = 0;
        onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
        onCommitRoot$1();
        // additional work on this root is scheduled.
        ensureRootIsScheduled(root, now());
        if (hasUncaughtError) {
            hasUncaughtError = false;
            var _error3 = firstUncaughtError;
            firstUncaughtError = null;
            throw _error3;
        }
        if ((executionContext & LegacyUnbatchedContext) !== NoContext) // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired
        // synchronously, but layout updates should be deferred until the end
        // of the batch.
        return null;
         // If layout work was scheduled, flush it now.
        flushSyncCallbackQueue();
        return null;
    }
    function commitBeforeMutationEffects() {
        while(nextEffect !== null){
            var current = nextEffect.alternate;
            if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
                if ((nextEffect.flags & Deletion) !== NoFlags) {
                    if (doesFiberContain(nextEffect, focusedInstanceHandle)) shouldFireAfterActiveInstanceBlur = true;
                } else // TODO: Move this out of the hot path using a dedicated effect tag.
                if (nextEffect.tag === SuspenseComponent && isSuspenseBoundaryBeingHidden(current, nextEffect) && doesFiberContain(nextEffect, focusedInstanceHandle)) shouldFireAfterActiveInstanceBlur = true;
            }
            var flags = nextEffect.flags;
            if ((flags & Snapshot) !== NoFlags) {
                setCurrentFiber(nextEffect);
                commitBeforeMutationLifeCycles(current, nextEffect);
                resetCurrentFiber();
            }
            if ((flags & Passive) !== NoFlags) // If there are passive effects, schedule a callback to flush at
            // the earliest opportunity.
            {
                if (!rootDoesHavePassiveEffects) {
                    rootDoesHavePassiveEffects = true;
                    scheduleCallback(NormalPriority$1, function() {
                        flushPassiveEffects();
                        return null;
                    });
                }
            }
            nextEffect = nextEffect.nextEffect;
        }
    }
    function commitMutationEffects(root, renderPriorityLevel) {
        // TODO: Should probably move the bulk of this function to commitWork.
        while(nextEffect !== null){
            setCurrentFiber(nextEffect);
            var flags = nextEffect.flags;
            if (flags & ContentReset) commitResetTextContent(nextEffect);
            if (flags & Ref) {
                var current = nextEffect.alternate;
                if (current !== null) commitDetachRef(current);
            } // The following switch statement is only concerned about placement,
            // updates, and deletions. To avoid needing to add a case for every possible
            // bitmap value, we remove the secondary effects from the effect tag and
            // switch on that value.
            var primaryFlags = flags & (Placement | Update | Deletion | Hydrating);
            switch(primaryFlags){
                case Placement:
                    commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
                    // inserted, before any life-cycles like componentDidMount gets called.
                    // TODO: findDOMNode doesn't rely on this any more but isMounted does
                    // and isMounted is deprecated anyway so we should be able to kill this.
                    nextEffect.flags &= ~Placement;
                    break;
                case PlacementAndUpdate:
                    // Placement
                    commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
                    // inserted, before any life-cycles like componentDidMount gets called.
                    nextEffect.flags &= ~Placement; // Update
                    var _current = nextEffect.alternate;
                    commitWork(_current, nextEffect);
                    break;
                case Hydrating:
                    nextEffect.flags &= ~Hydrating;
                    break;
                case HydratingAndUpdate:
                    nextEffect.flags &= ~Hydrating; // Update
                    var _current2 = nextEffect.alternate;
                    commitWork(_current2, nextEffect);
                    break;
                case Update:
                    var _current3 = nextEffect.alternate;
                    commitWork(_current3, nextEffect);
                    break;
                case Deletion:
                    commitDeletion(root, nextEffect);
                    break;
            }
            resetCurrentFiber();
            nextEffect = nextEffect.nextEffect;
        }
    }
    function commitLayoutEffects(root, committedLanes) {
        while(nextEffect !== null){
            setCurrentFiber(nextEffect);
            var flags = nextEffect.flags;
            if (flags & (Update | Callback)) {
                var current = nextEffect.alternate;
                commitLifeCycles(root, current, nextEffect);
            }
            if (flags & Ref) commitAttachRef(nextEffect);
            resetCurrentFiber();
            nextEffect = nextEffect.nextEffect;
        }
    }
    function flushPassiveEffects() {
        // Returns whether passive effects were flushed.
        if (pendingPassiveEffectsRenderPriority !== NoPriority$1) {
            var priorityLevel = pendingPassiveEffectsRenderPriority > NormalPriority$1 ? NormalPriority$1 : pendingPassiveEffectsRenderPriority;
            pendingPassiveEffectsRenderPriority = NoPriority$1;
            return runWithPriority$1(priorityLevel, flushPassiveEffectsImpl);
        }
        return false;
    }
    function enqueuePendingPassiveHookEffectMount(fiber, effect) {
        pendingPassiveHookEffectsMount.push(effect, fiber);
        if (!rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = true;
            scheduleCallback(NormalPriority$1, function() {
                flushPassiveEffects();
                return null;
            });
        }
    }
    function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {
        pendingPassiveHookEffectsUnmount.push(effect, fiber);
        fiber.flags |= PassiveUnmountPendingDev;
        var alternate = fiber.alternate;
        if (alternate !== null) alternate.flags |= PassiveUnmountPendingDev;
        if (!rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = true;
            scheduleCallback(NormalPriority$1, function() {
                flushPassiveEffects();
                return null;
            });
        }
    }
    function invokePassiveEffectCreate(effect) {
        var create = effect.create;
        effect.destroy = create();
    }
    function flushPassiveEffectsImpl() {
        if (rootWithPendingPassiveEffects === null) return false;
        var root = rootWithPendingPassiveEffects;
        var lanes = pendingPassiveEffectsLanes;
        rootWithPendingPassiveEffects = null;
        pendingPassiveEffectsLanes = NoLanes;
        if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) throw Error("Cannot flush passive effects while already rendering.");
        isFlushingPassiveEffects = true;
        var prevExecutionContext = executionContext;
        executionContext |= CommitContext;
        var prevInteractions = pushInteractions(root); // It's important that ALL pending passive effect destroy functions are called
        // before ANY passive effect create functions are called.
        // Otherwise effects in sibling components might interfere with each other.
        // e.g. a destroy function in one component may unintentionally override a ref
        // value set by a create function in another component.
        // Layout effects have the same constraint.
        // First pass: Destroy stale passive effects.
        var unmountEffects = pendingPassiveHookEffectsUnmount;
        pendingPassiveHookEffectsUnmount = [];
        for(var i = 0; i < unmountEffects.length; i += 2){
            var _effect = unmountEffects[i];
            var fiber = unmountEffects[i + 1];
            var destroy = _effect.destroy;
            _effect.destroy = undefined;
            fiber.flags &= ~PassiveUnmountPendingDev;
            var alternate = fiber.alternate;
            if (alternate !== null) alternate.flags &= ~PassiveUnmountPendingDev;
            if (typeof destroy === 'function') {
                setCurrentFiber(fiber);
                invokeGuardedCallback(null, destroy, null);
                if (hasCaughtError()) {
                    if (!(fiber !== null)) throw Error("Should be working on an effect.");
                    var error = clearCaughtError();
                    captureCommitPhaseError(fiber, error);
                }
                resetCurrentFiber();
            }
        } // Second pass: Create new passive effects.
        var mountEffects = pendingPassiveHookEffectsMount;
        pendingPassiveHookEffectsMount = [];
        for(var _i = 0; _i < mountEffects.length; _i += 2){
            var _effect2 = mountEffects[_i];
            var _fiber = mountEffects[_i + 1];
            setCurrentFiber(_fiber);
            invokeGuardedCallback(null, invokePassiveEffectCreate, null, _effect2);
            if (hasCaughtError()) {
                if (!(_fiber !== null)) throw Error("Should be working on an effect.");
                var _error4 = clearCaughtError();
                captureCommitPhaseError(_fiber, _error4);
            }
            resetCurrentFiber();
        } // Note: This currently assumes there are no passive effects on the root fiber
        // because the root is not part of its own effect list.
        // This could change in the future.
        var effect = root.current.firstEffect;
        while(effect !== null){
            var nextNextEffect = effect.nextEffect; // Remove nextEffect pointer to assist GC
            effect.nextEffect = null;
            if (effect.flags & Deletion) detachFiberAfterEffects(effect);
            effect = nextNextEffect;
        }
        popInteractions(prevInteractions);
        finishPendingInteractions(root, lanes);
        isFlushingPassiveEffects = false;
        executionContext = prevExecutionContext;
        flushSyncCallbackQueue(); // If additional passive effects were scheduled, increment a counter. If this
        // exceeds the limit, we'll fire a warning.
        nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;
        return true;
    }
    function isAlreadyFailedLegacyErrorBoundary(instance) {
        return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
    }
    function markLegacyErrorBoundaryAsFailed(instance) {
        if (legacyErrorBoundariesThatAlreadyFailed === null) legacyErrorBoundariesThatAlreadyFailed = new Set([
            instance
        ]);
        else legacyErrorBoundariesThatAlreadyFailed.add(instance);
    }
    function prepareToThrowUncaughtError(error) {
        if (!hasUncaughtError) {
            hasUncaughtError = true;
            firstUncaughtError = error;
        }
    }
    var onUncaughtError = prepareToThrowUncaughtError;
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
        var errorInfo = createCapturedValue(error, sourceFiber);
        var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
        enqueueUpdate(rootFiber, update);
        var eventTime = requestEventTime();
        var root = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);
        if (root !== null) {
            markRootUpdated(root, SyncLane, eventTime);
            ensureRootIsScheduled(root, eventTime);
            schedulePendingInteractions(root, SyncLane);
        }
    }
    function captureCommitPhaseError(sourceFiber, error) {
        if (sourceFiber.tag === HostRoot) {
            // Error was thrown at the root. There is no parent, so the root
            // itself should capture it.
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
            return;
        }
        var fiber = sourceFiber.return;
        while(fiber !== null){
            if (fiber.tag === HostRoot) {
                captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);
                return;
            } else if (fiber.tag === ClassComponent) {
                var ctor = fiber.type;
                var instance = fiber.stateNode;
                if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                    var errorInfo = createCapturedValue(error, sourceFiber);
                    var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                    enqueueUpdate(fiber, update);
                    var eventTime = requestEventTime();
                    var root = markUpdateLaneFromFiberToRoot(fiber, SyncLane);
                    if (root !== null) {
                        markRootUpdated(root, SyncLane, eventTime);
                        ensureRootIsScheduled(root, eventTime);
                        schedulePendingInteractions(root, SyncLane);
                    } else {
                        // This component has already been unmounted.
                        // We can't schedule any follow up work for the root because the fiber is already unmounted,
                        // but we can still call the log-only boundary so the error isn't swallowed.
                        //
                        // TODO This is only a temporary bandaid for the old reconciler fork.
                        // We can delete this special case once the new fork is merged.
                        if (typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) try {
                            instance.componentDidCatch(error, errorInfo);
                        } catch (errorToIgnore) {
                        // This is kind of an edge case.
                        }
                    }
                    return;
                }
            }
            fiber = fiber.return;
        }
    }
    function pingSuspendedRoot(root, wakeable, pingedLanes) {
        var pingCache = root.pingCache;
        if (pingCache !== null) // The wakeable resolved, so we no longer need to memoize, because it will
        // never be thrown again.
        pingCache.delete(wakeable);
        var eventTime = requestEventTime();
        markRootPinged(root, pingedLanes);
        if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
            // Received a ping at the same priority level at which we're currently
            // rendering. We might want to restart this render. This should mirror
            // the logic of whether or not a root suspends once it completes.
            // TODO: If we're rendering sync either due to Sync, Batched or expired,
            // we should probably never restart.
            // If we're suspended with delay, or if it's a retry, we'll always suspend
            // so we can always restart.
            if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) // Restart from the root.
            prepareFreshStack(root, NoLanes);
            else // Even though we can't restart right now, we might get an
            // opportunity later. So we mark this render as having a ping.
            workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
        }
        ensureRootIsScheduled(root, eventTime);
        schedulePendingInteractions(root, pingedLanes);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
        // The boundary fiber (a Suspense component or SuspenseList component)
        // previously was rendered in its fallback state. One of the promises that
        // suspended it has resolved, which means at least part of the tree was
        // likely unblocked. Try rendering again, at a new expiration time.
        if (retryLane === NoLane) retryLane = requestRetryLane(boundaryFiber);
         // TODO: Special case idle priority?
        var eventTime = requestEventTime();
        var root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);
        if (root !== null) {
            markRootUpdated(root, retryLane, eventTime);
            ensureRootIsScheduled(root, eventTime);
            schedulePendingInteractions(root, retryLane);
        }
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = NoLane; // Default
        var retryCache;
        retryCache = boundaryFiber.stateNode;
        if (retryCache !== null) // The wakeable resolved, so we no longer need to memoize, because it will
        // never be thrown again.
        retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
    } // Computes the next Just Noticeable Difference (JND) boundary.
    // The theory is that a person can't tell the difference between small differences in time.
    // Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
    // difference in the experience. However, waiting for longer might mean that we can avoid
    // showing an intermediate loading state. The longer we have already waited, the harder it
    // is to tell small differences in time. Therefore, the longer we've already waited,
    // the longer we can wait additionally. At some point we have to give up though.
    // We pick a train model where the next boundary commits at a consistent schedule.
    // These particular numbers are vague estimates. We expect to adjust them based on research.
    function jnd(timeElapsed) {
        return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
    }
    function checkForNestedUpdates() {
        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
            nestedUpdateCount = 0;
            rootWithNestedUpdates = null;
            throw Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
        }
        if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
            nestedPassiveUpdateCount = 0;
            error1("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
        }
    }
    function flushRenderPhaseStrictModeWarningsInDEV() {
        ReactStrictModeWarnings.flushLegacyContextWarning();
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
    }
    var didWarnStateUpdateForNotYetMountedComponent = null;
    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
        if ((executionContext & RenderContext) !== NoContext) // We let the other warning about render phase updates deal with this one.
        return;
        if (!(fiber.mode & (BlockingMode | ConcurrentMode))) return;
        var tag = fiber.tag;
        if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) // Only warn for user-defined components, not internal ones like Suspense.
        return;
         // We show the whole stack but dedupe on the top component's name because
        // the problematic code almost always lies inside that component.
        var componentName = getComponentName(fiber.type) || 'ReactComponent';
        if (didWarnStateUpdateForNotYetMountedComponent !== null) {
            if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) return;
            didWarnStateUpdateForNotYetMountedComponent.add(componentName);
        } else didWarnStateUpdateForNotYetMountedComponent = new Set([
            componentName
        ]);
        var previousFiber = current1;
        try {
            setCurrentFiber(fiber);
            error1("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally{
            if (previousFiber) setCurrentFiber(fiber);
            else resetCurrentFiber();
        }
    }
    var didWarnStateUpdateForUnmountedComponent = null;
    function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
        var tag = fiber.tag;
        if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) // Only warn for user-defined components, not internal ones like Suspense.
        return;
         // If there are pending passive effects unmounts for this Fiber,
        // we can assume that they would have prevented this update.
        if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) return;
         // We show the whole stack but dedupe on the top component's name because
        // the problematic code almost always lies inside that component.
        var componentName = getComponentName(fiber.type) || 'ReactComponent';
        if (didWarnStateUpdateForUnmountedComponent !== null) {
            if (didWarnStateUpdateForUnmountedComponent.has(componentName)) return;
            didWarnStateUpdateForUnmountedComponent.add(componentName);
        } else didWarnStateUpdateForUnmountedComponent = new Set([
            componentName
        ]);
        if (isFlushingPassiveEffects) ;
        else {
            var previousFiber = current1;
            try {
                setCurrentFiber(fiber);
                error1("Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in %s.", tag === ClassComponent ? 'the componentWillUnmount method' : 'a useEffect cleanup function');
            } finally{
                if (previousFiber) setCurrentFiber(fiber);
                else resetCurrentFiber();
            }
        }
    }
    var beginWork$1;
    var dummyFiber = null;
    beginWork$1 = function(current, unitOfWork, lanes) {
        // If a component throws an error, we replay it again in a synchronously
        // dispatched event, so that the debugger will treat it as an uncaught
        // error See ReactErrorUtils for more information.
        // Before entering the begin phase, copy the work-in-progress onto a dummy
        // fiber. If beginWork throws, we'll use this to reset the state.
        var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
        try {
            return beginWork(current, unitOfWork, lanes);
        } catch (originalError) {
            if (originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') // Don't replay promises. Treat everything else like an error.
            throw originalError;
             // Keep this code in sync with handleError; any changes here must have
            // corresponding changes there.
            resetContextDependencies();
            resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the
            // same fiber again.
            // Unwind the failed stack frame
            unwindInterruptedWork(unitOfWork); // Restore the original properties of the fiber.
            assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
            if (unitOfWork.mode & ProfileMode) // Reset the profiler timer.
            startProfilerTimer(unitOfWork);
             // Run beginWork again.
            invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);
            if (hasCaughtError()) {
                var replayError = clearCaughtError(); // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.
                // Rethrow this error instead of the original one.
                throw replayError;
            } else // This branch is reachable if the render phase is impure.
            throw originalError;
        }
    };
    var didWarnAboutUpdateInRender = false;
    var didWarnAboutUpdateInRenderForAnotherComponent;
    didWarnAboutUpdateInRenderForAnotherComponent = new Set();
    function warnAboutRenderPhaseUpdatesInDEV(fiber) {
        if (isRendering && (executionContext & RenderContext) !== NoContext && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) switch(fiber.tag){
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent:
                var renderingComponentName = workInProgress1 && getComponentName(workInProgress1.type) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.
                var dedupeKey = renderingComponentName;
                if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                    var setStateComponentName = getComponentName(fiber.type) || 'Unknown';
                    error1("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                }
                break;
            case ClassComponent:
                if (!didWarnAboutUpdateInRender) {
                    error1("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                    didWarnAboutUpdateInRender = true;
                }
                break;
        }
    } // a 'shared' variable that changes when act() opens/closes in tests.
    var IsThisRendererActing = {
        current: false
    };
    function warnIfNotScopedWithMatchingAct(fiber) {
        if (IsSomeRendererActing.current === true && IsThisRendererActing.current !== true) {
            var previousFiber = current1;
            try {
                setCurrentFiber(fiber);
                error1("It looks like you're using the wrong act() around your test interactions.\nBe sure to use the matching version of act() corresponding to your renderer:\n\n// for react-dom:\nimport {act} from 'react-dom/test-utils';\n// ...\nact(() => ...);\n\n// for react-test-renderer:\nimport TestRenderer from react-test-renderer';\nconst {act} = TestRenderer;\n// ...\nact(() => ...);");
            } finally{
                if (previousFiber) setCurrentFiber(fiber);
                else resetCurrentFiber();
            }
        }
    }
    function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
        if ((fiber.mode & StrictMode) !== NoMode && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) error1("An update to %s ran an effect, but was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentName(fiber.type));
    }
    function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
        if (executionContext === NoContext && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
            var previousFiber = current1;
            try {
                setCurrentFiber(fiber);
                error1("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentName(fiber.type));
            } finally{
                if (previousFiber) setCurrentFiber(fiber);
                else resetCurrentFiber();
            }
        }
    }
    var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; // In tests, we want to enforce a mocked scheduler.
    var didWarnAboutUnmockedScheduler = false; // TODO Before we release concurrent mode, revisit this and decide whether a mocked
    // scheduler is the actual recommendation. The alternative could be a testing build,
    // a new lib, or whatever; we dunno just yet. This message is for early adopters
    // to get their tests right.
    function warnIfUnmockedScheduler(fiber) {
        if (didWarnAboutUnmockedScheduler === false && Scheduler.unstable_flushAllWithoutAsserting === undefined) {
            if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {
                didWarnAboutUnmockedScheduler = true;
                error1("In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked to guarantee consistent behaviour across tests and browsers. For example, with jest: \njest.mock('scheduler', () => require('scheduler/unstable_mock'));\n\nFor more info, visit https://reactjs.org/link/mock-scheduler");
            }
        }
    }
    function computeThreadID(root, lane) {
        // Interaction threads are unique per root and expiration time.
        // NOTE: Intentionally unsound cast. All that matters is that it's a number
        // and it represents a batch of work. Could make a helper function instead,
        // but meh this is fine for now.
        return lane * 1000 + root.interactionThreadID;
    }
    function markSpawnedWork(lane) {
        if (spawnedWorkDuringRender === null) spawnedWorkDuringRender = [
            lane
        ];
        else spawnedWorkDuringRender.push(lane);
    }
    function scheduleInteractions(root, lane, interactions) {
        if (interactions.size > 0) {
            var pendingInteractionMap = root.pendingInteractionMap;
            var pendingInteractions = pendingInteractionMap.get(lane);
            if (pendingInteractions != null) interactions.forEach(function(interaction) {
                if (!pendingInteractions.has(interaction)) // Update the pending async work count for previously unscheduled interaction.
                interaction.__count++;
                pendingInteractions.add(interaction);
            });
            else {
                pendingInteractionMap.set(lane, new Set(interactions)); // Update the pending async work count for the current interactions.
                interactions.forEach(function(interaction) {
                    interaction.__count++;
                });
            }
            var subscriber = tracing.__subscriberRef.current;
            if (subscriber !== null) {
                var threadID = computeThreadID(root, lane);
                subscriber.onWorkScheduled(interactions, threadID);
            }
        }
    }
    function schedulePendingInteractions(root, lane) {
        scheduleInteractions(root, lane, tracing.__interactionsRef.current);
    }
    function startWorkOnPendingInteractions(root, lanes) {
        // we can accurately attribute time spent working on it, And so that cascading
        // work triggered during the render phase will be associated with it.
        var interactions = new Set();
        root.pendingInteractionMap.forEach(function(scheduledInteractions, scheduledLane) {
            if (includesSomeLane(lanes, scheduledLane)) scheduledInteractions.forEach(function(interaction) {
                return interactions.add(interaction);
            });
        }); // Store the current set of interactions on the FiberRoot for a few reasons:
        // We can re-use it in hot functions like performConcurrentWorkOnRoot()
        // without having to recalculate it. We will also use it in commitWork() to
        // pass to any Profiler onRender() hooks. This also provides DevTools with a
        // way to access it when the onCommitRoot() hook is called.
        root.memoizedInteractions = interactions;
        if (interactions.size > 0) {
            var subscriber = tracing.__subscriberRef.current;
            if (subscriber !== null) {
                var threadID = computeThreadID(root, lanes);
                try {
                    subscriber.onWorkStarted(interactions, threadID);
                } catch (error) {
                    // If the subscriber throws, rethrow it in a separate task
                    scheduleCallback(ImmediatePriority$1, function() {
                        throw error;
                    });
                }
            }
        }
    }
    function finishPendingInteractions(root, committedLanes) {
        var remainingLanesAfterCommit = root.pendingLanes;
        var subscriber;
        try {
            subscriber = tracing.__subscriberRef.current;
            if (subscriber !== null && root.memoizedInteractions.size > 0) {
                // FIXME: More than one lane can finish in a single commit.
                var threadID = computeThreadID(root, committedLanes);
                subscriber.onWorkStopped(root.memoizedInteractions, threadID);
            }
        } catch (error2) {
            // If the subscriber throws, rethrow it in a separate task
            scheduleCallback(ImmediatePriority$1, function() {
                throw error2;
            });
        } finally{
            // Clear completed interactions from the pending Map.
            // Unless the render was suspended or cascading work was scheduled,
            // In which caseâ€“ leave pending interactions until the subsequent render.
            var pendingInteractionMap = root.pendingInteractionMap;
            pendingInteractionMap.forEach(function(scheduledInteractions, lane) {
                // Only decrement the pending interaction count if we're done.
                // If there's still work at the current priority,
                // That indicates that we are waiting for suspense data.
                if (!includesSomeLane(remainingLanesAfterCommit, lane)) {
                    pendingInteractionMap.delete(lane);
                    scheduledInteractions.forEach(function(interaction) {
                        interaction.__count--;
                        if (subscriber !== null && interaction.__count === 0) try {
                            subscriber.onInteractionScheduledWorkCompleted(interaction);
                        } catch (error) {
                            // If the subscriber throws, rethrow it in a separate task
                            scheduleCallback(ImmediatePriority$1, function() {
                                throw error;
                            });
                        }
                    });
                }
            });
        }
    } // `act` testing API
    function shouldForceFlushFallbacksInDEV() {
        // Never force flush in production. This function should get stripped out.
        return actingUpdatesScopeDepth > 0;
    }
    // so we can tell if any async act() calls try to run in parallel.
    var actingUpdatesScopeDepth = 0;
    function detachFiberAfterEffects(fiber) {
        fiber.sibling = null;
        fiber.stateNode = null;
    }
    var resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.
    var failedBoundaries = null;
    var setRefreshHandler = function(handler) {
        resolveFamily = handler;
    };
    function resolveFunctionForHotReloading(type) {
        if (resolveFamily === null) // Hot reloading is disabled.
        return type;
        var family = resolveFamily(type);
        if (family === undefined) return type;
         // Use the latest known implementation.
        return family.current;
    }
    function resolveClassForHotReloading(type) {
        // No implementation differences.
        return resolveFunctionForHotReloading(type);
    }
    function resolveForwardRefForHotReloading(type) {
        if (resolveFamily === null) // Hot reloading is disabled.
        return type;
        var family = resolveFamily(type);
        if (family === undefined) {
            // Check if we're dealing with a real forwardRef. Don't want to crash early.
            if (type !== null && type !== undefined && typeof type.render === 'function') {
                // ForwardRef is special because its resolved .type is an object,
                // but it's possible that we only have its inner render function in the map.
                // If that inner render function is different, we'll build a new forwardRef type.
                var currentRender = resolveFunctionForHotReloading(type.render);
                if (type.render !== currentRender) {
                    var syntheticType = {
                        $$typeof: REACT_FORWARD_REF_TYPE,
                        render: currentRender
                    };
                    if (type.displayName !== undefined) syntheticType.displayName = type.displayName;
                    return syntheticType;
                }
            }
            return type;
        } // Use the latest known implementation.
        return family.current;
    }
    function isCompatibleFamilyForHotReloading(fiber, element) {
        if (resolveFamily === null) // Hot reloading is disabled.
        return false;
        var prevType = fiber.elementType;
        var nextType = element.type; // If we got here, we know types aren't === equal.
        var needsCompareFamilies = false;
        var $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;
        switch(fiber.tag){
            case ClassComponent:
                if (typeof nextType === 'function') needsCompareFamilies = true;
                break;
            case FunctionComponent:
                if (typeof nextType === 'function') needsCompareFamilies = true;
                else if ($$typeofNextType === REACT_LAZY_TYPE) // We don't know the inner type yet.
                // We're going to assume that the lazy inner type is stable,
                // and so it is sufficient to avoid reconciling it away.
                // We're not going to unwrap or actually use the new lazy type.
                needsCompareFamilies = true;
                break;
            case ForwardRef:
                if ($$typeofNextType === REACT_FORWARD_REF_TYPE) needsCompareFamilies = true;
                else if ($$typeofNextType === REACT_LAZY_TYPE) needsCompareFamilies = true;
                break;
            case MemoComponent:
            case SimpleMemoComponent:
                if ($$typeofNextType === REACT_MEMO_TYPE) // TODO: if it was but can no longer be simple,
                // we shouldn't set this.
                needsCompareFamilies = true;
                else if ($$typeofNextType === REACT_LAZY_TYPE) needsCompareFamilies = true;
                break;
            default:
                return false;
        } // Check if both types have a family and it's the same one.
        if (needsCompareFamilies) {
            // Note: memo() and forwardRef() we'll compare outer rather than inner type.
            // This means both of them need to be registered to preserve state.
            // If we unwrapped and compared the inner types for wrappers instead,
            // then we would risk falsely saying two separate memo(Foo)
            // calls are equivalent because they wrap the same Foo function.
            var prevFamily = resolveFamily(prevType);
            if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) return true;
        }
        return false;
    }
    function markFailedErrorBoundaryForHotReloading(fiber) {
        if (resolveFamily === null) // Hot reloading is disabled.
        return;
        if (typeof WeakSet !== 'function') return;
        if (failedBoundaries === null) failedBoundaries = new WeakSet();
        failedBoundaries.add(fiber);
    }
    var scheduleRefresh = function(root, update) {
        if (resolveFamily === null) // Hot reloading is disabled.
        return;
        var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
        flushPassiveEffects();
        flushSync(function() {
            scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);
        });
    };
    var scheduleRoot = function(root, element) {
        if (root.context !== emptyContextObject) // Super edge case: root has a legacy _renderSubtree context
        // but we don't know the parentComponent so we can't pass it.
        // Just ignore. We'll delete this with _renderSubtree code path later.
        return;
        flushPassiveEffects();
        flushSync(function() {
            updateContainer(element, root, null, null);
        });
    };
    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
        var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
        var candidateType = null;
        switch(tag){
            case FunctionComponent:
            case SimpleMemoComponent:
            case ClassComponent:
                candidateType = type;
                break;
            case ForwardRef:
                candidateType = type.render;
                break;
        }
        if (resolveFamily === null) throw new Error('Expected resolveFamily to be set during hot reload.');
        var needsRender = false;
        var needsRemount = false;
        if (candidateType !== null) {
            var family = resolveFamily(candidateType);
            if (family !== undefined) {
                if (staleFamilies.has(family)) needsRemount = true;
                else if (updatedFamilies.has(family)) {
                    if (tag === ClassComponent) needsRemount = true;
                    else needsRender = true;
                }
            }
        }
        if (failedBoundaries !== null) {
            if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) needsRemount = true;
        }
        if (needsRemount) fiber._debugNeedsRemount = true;
        if (needsRemount || needsRender) scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
        if (child !== null && !needsRemount) scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
        if (sibling !== null) scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
    }
    var findHostInstancesForRefresh = function(root, families) {
        var hostInstances = new Set();
        var types = new Set(families.map(function(family) {
            return family.current;
        }));
        findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);
        return hostInstances;
    };
    function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
        var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
        var candidateType = null;
        switch(tag){
            case FunctionComponent:
            case SimpleMemoComponent:
            case ClassComponent:
                candidateType = type;
                break;
            case ForwardRef:
                candidateType = type.render;
                break;
        }
        var didMatch = false;
        if (candidateType !== null) {
            if (types.has(candidateType)) didMatch = true;
        }
        if (didMatch) // We have a match. This only drills down to the closest host components.
        // There's no need to search deeper because for the purpose of giving
        // visual feedback, "flashing" outermost parent rectangles is sufficient.
        findHostInstancesForFiberShallowly(fiber, hostInstances);
        else // If there's no match, maybe there will be one further down in the child tree.
        if (child !== null) findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
        if (sibling !== null) findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
    }
    function findHostInstancesForFiberShallowly(fiber, hostInstances) {
        var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
        if (foundHostInstances) return;
         // If we didn't find any host children, fallback to closest host parent.
        var node = fiber;
        while(true){
            switch(node.tag){
                case HostComponent:
                    hostInstances.add(node.stateNode);
                    return;
                case HostPortal:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                case HostRoot:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
            }
            if (node.return === null) throw new Error('Expected to reach root first.');
            node = node.return;
        }
    }
    function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
        var node = fiber;
        var foundHostInstances = false;
        while(true){
            if (node.tag === HostComponent) {
                // We got a match.
                foundHostInstances = true;
                hostInstances.add(node.stateNode); // There may still be more, so keep searching.
            } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === fiber) return foundHostInstances;
            while(node.sibling === null){
                if (node.return === null || node.return === fiber) return foundHostInstances;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
        return false;
    }
    var hasBadMapPolyfill;
    hasBadMapPolyfill = false;
    try {
        var nonExtensibleObject = Object.preventExtensions({
        });
        /* eslint-disable no-new */ new Map([
            [
                nonExtensibleObject,
                null
            ]
        ]);
        new Set([
            nonExtensibleObject
        ]);
    /* eslint-enable no-new */ } catch (e) {
        // TODO: Consider warning about bad polyfills
        hasBadMapPolyfill = true;
    }
    var debugCounter = 1;
    function FiberNode(tag, pendingProps, key, mode) {
        // Instance
        this.tag = tag;
        this.key = key;
        this.elementType = null;
        this.type = null;
        this.stateNode = null; // Fiber
        this.return = null;
        this.child = null;
        this.sibling = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = pendingProps;
        this.memoizedProps = null;
        this.updateQueue = null;
        this.memoizedState = null;
        this.dependencies = null;
        this.mode = mode; // Effects
        this.flags = NoFlags;
        this.nextEffect = null;
        this.firstEffect = null;
        this.lastEffect = null;
        this.lanes = NoLanes;
        this.childLanes = NoLanes;
        this.alternate = null;
        // Note: The following is done to avoid a v8 performance cliff.
        //
        // Initializing the fields below to smis and later updating them with
        // double values will cause Fibers to end up having separate shapes.
        // This behavior/bug has something to do with Object.preventExtension().
        // Fortunately this only impacts DEV builds.
        // Unfortunately it makes React unusably slow for some applications.
        // To work around this, initialize the fields below with doubles.
        //
        // Learn more about this here:
        // https://github.com/facebook/react/issues/14365
        // https://bugs.chromium.org/p/v8/issues/detail?id=8538
        this.actualDuration = Number.NaN;
        this.actualStartTime = Number.NaN;
        this.selfBaseDuration = Number.NaN;
        this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.
        // This won't trigger the performance cliff mentioned above,
        // and it simplifies other profiler code (including DevTools).
        this.actualDuration = 0;
        this.actualStartTime = -1;
        this.selfBaseDuration = 0;
        this.treeBaseDuration = 0;
        // This isn't directly used but is handy for debugging internals:
        this._debugID = debugCounter++;
        this._debugSource = null;
        this._debugOwner = null;
        this._debugNeedsRemount = false;
        this._debugHookTypes = null;
        if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') Object.preventExtensions(this);
    } // This is a constructor function, rather than a POJO constructor, still
    // please ensure we do the following:
    // 1) Nobody should add any instance methods on this. Instance methods can be
    //    more difficult to predict when they get optimized and they are almost
    //    never inlined properly in static compilers.
    // 2) Nobody should rely on `instanceof Fiber` for type testing. We should
    //    always know when it is a fiber.
    // 3) We might want to experiment with using numeric keys since they are easier
    //    to optimize in a non-JIT environment.
    // 4) We can easily go from a constructor to a createFiber object literal if that
    //    is faster.
    // 5) It should be easy to port this to a C struct and keep a C implementation
    //    compatible.
    var createFiber = function(tag, pendingProps, key, mode) {
        // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
        return new FiberNode(tag, pendingProps, key, mode);
    };
    function shouldConstruct$1(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
    }
    function isSimpleFunctionComponent(type) {
        return typeof type === 'function' && !shouldConstruct$1(type) && type.defaultProps === undefined;
    }
    function resolveLazyComponentTag(Component) {
        if (typeof Component === 'function') return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
        else if (Component !== undefined && Component !== null) {
            var $$typeof = Component.$$typeof;
            if ($$typeof === REACT_FORWARD_REF_TYPE) return ForwardRef;
            if ($$typeof === REACT_MEMO_TYPE) return MemoComponent;
        }
        return IndeterminateComponent;
    } // This is used to create an alternate fiber to do work on.
    function createWorkInProgress(current, pendingProps) {
        var workInProgress = current.alternate;
        if (workInProgress === null) {
            // We use a double buffering pooling technique because we know that we'll
            // only ever need at most two versions of a tree. We pool the "other" unused
            // node that we're free to reuse. This is lazily created to avoid allocating
            // extra objects for things that are never updated. It also allow us to
            // reclaim the extra memory if needed.
            workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);
            workInProgress.elementType = current.elementType;
            workInProgress.type = current.type;
            workInProgress.stateNode = current.stateNode;
            // DEV-only fields
            workInProgress._debugID = current._debugID;
            workInProgress._debugSource = current._debugSource;
            workInProgress._debugOwner = current._debugOwner;
            workInProgress._debugHookTypes = current._debugHookTypes;
            workInProgress.alternate = current;
            current.alternate = workInProgress;
        } else {
            workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.
            workInProgress.type = current.type; // We already have an alternate.
            // Reset the effect tag.
            workInProgress.flags = NoFlags; // The effect list is no longer valid.
            workInProgress.nextEffect = null;
            workInProgress.firstEffect = null;
            workInProgress.lastEffect = null;
            // We intentionally reset, rather than copy, actualDuration & actualStartTime.
            // This prevents time from endlessly accumulating in new commits.
            // This has the downside of resetting values for different priority renders,
            // But works for yielding (the common case) and should support resuming.
            workInProgress.actualDuration = 0;
            workInProgress.actualStartTime = -1;
        }
        workInProgress.childLanes = current.childLanes;
        workInProgress.lanes = current.lanes;
        workInProgress.child = current.child;
        workInProgress.memoizedProps = current.memoizedProps;
        workInProgress.memoizedState = current.memoizedState;
        workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so
        // it cannot be shared with the current fiber.
        var currentDependencies = current.dependencies;
        workInProgress.dependencies = currentDependencies === null ? null : {
            lanes: currentDependencies.lanes,
            firstContext: currentDependencies.firstContext
        }; // These will be overridden during the parent's reconciliation
        workInProgress.sibling = current.sibling;
        workInProgress.index = current.index;
        workInProgress.ref = current.ref;
        workInProgress.selfBaseDuration = current.selfBaseDuration;
        workInProgress.treeBaseDuration = current.treeBaseDuration;
        workInProgress._debugNeedsRemount = current._debugNeedsRemount;
        switch(workInProgress.tag){
            case IndeterminateComponent:
            case FunctionComponent:
            case SimpleMemoComponent:
                workInProgress.type = resolveFunctionForHotReloading(current.type);
                break;
            case ClassComponent:
                workInProgress.type = resolveClassForHotReloading(current.type);
                break;
            case ForwardRef:
                workInProgress.type = resolveForwardRefForHotReloading(current.type);
                break;
        }
        return workInProgress;
    } // Used to reuse a Fiber for a second pass.
    function resetWorkInProgress(workInProgress, renderLanes) {
        // This resets the Fiber to what createFiber or createWorkInProgress would
        // have set the values to before during the first pass. Ideally this wouldn't
        // be necessary but unfortunately many code paths reads from the workInProgress
        // when they should be reading from current and writing to workInProgress.
        // We assume pendingProps, index, key, ref, return are still untouched to
        // avoid doing another reconciliation.
        // Reset the effect tag but keep any Placement tags, since that's something
        // that child fiber is setting, not the reconciliation.
        workInProgress.flags &= Placement; // The effect list is no longer valid.
        workInProgress.nextEffect = null;
        workInProgress.firstEffect = null;
        workInProgress.lastEffect = null;
        var current = workInProgress.alternate;
        if (current === null) {
            // Reset to createFiber's initial values.
            workInProgress.childLanes = NoLanes;
            workInProgress.lanes = renderLanes;
            workInProgress.child = null;
            workInProgress.memoizedProps = null;
            workInProgress.memoizedState = null;
            workInProgress.updateQueue = null;
            workInProgress.dependencies = null;
            workInProgress.stateNode = null;
            // Note: We don't reset the actualTime counts. It's useful to accumulate
            // actual time across multiple render passes.
            workInProgress.selfBaseDuration = 0;
            workInProgress.treeBaseDuration = 0;
        } else {
            // Reset to the cloned values that createWorkInProgress would've.
            workInProgress.childLanes = current.childLanes;
            workInProgress.lanes = current.lanes;
            workInProgress.child = current.child;
            workInProgress.memoizedProps = current.memoizedProps;
            workInProgress.memoizedState = current.memoizedState;
            workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.
            workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so
            // it cannot be shared with the current fiber.
            var currentDependencies = current.dependencies;
            workInProgress.dependencies = currentDependencies === null ? null : {
                lanes: currentDependencies.lanes,
                firstContext: currentDependencies.firstContext
            };
            // Note: We don't reset the actualTime counts. It's useful to accumulate
            // actual time across multiple render passes.
            workInProgress.selfBaseDuration = current.selfBaseDuration;
            workInProgress.treeBaseDuration = current.treeBaseDuration;
        }
        return workInProgress;
    }
    function createHostRootFiber(tag) {
        var mode;
        if (tag === ConcurrentRoot) mode = ConcurrentMode | BlockingMode | StrictMode;
        else if (tag === BlockingRoot) mode = BlockingMode | StrictMode;
        else mode = NoMode;
        if (isDevToolsPresent) // Always collect profile timings when DevTools are present.
        // This enables DevTools to start capturing timing at any pointâ€“
        // Without some nodes in the tree having empty base times.
        mode |= ProfileMode;
        return createFiber(HostRoot, null, null, mode);
    }
    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.
        var resolvedType = type;
        if (typeof type === 'function') {
            if (shouldConstruct$1(type)) {
                fiberTag = ClassComponent;
                resolvedType = resolveClassForHotReloading(resolvedType);
            } else resolvedType = resolveFunctionForHotReloading(resolvedType);
        } else if (typeof type === 'string') fiberTag = HostComponent;
        else getTag: switch(type){
            case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_DEBUG_TRACING_MODE_TYPE:
                fiberTag = Mode;
                mode |= DebugTracingMode;
                break;
            case REACT_STRICT_MODE_TYPE:
                fiberTag = Mode;
                mode |= StrictMode;
                break;
            case REACT_PROFILER_TYPE:
                return createFiberFromProfiler(pendingProps, mode, lanes, key);
            case REACT_SUSPENSE_TYPE:
                return createFiberFromSuspense(pendingProps, mode, lanes, key);
            case REACT_SUSPENSE_LIST_TYPE:
                return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
            case REACT_OFFSCREEN_TYPE:
                return createFiberFromOffscreen(pendingProps, mode, lanes, key);
            case REACT_LEGACY_HIDDEN_TYPE:
                return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);
            case REACT_SCOPE_TYPE:
            // eslint-disable-next-line no-fallthrough
            default:
                if (typeof type === 'object' && type !== null) switch(type.$$typeof){
                    case REACT_PROVIDER_TYPE:
                        fiberTag = ContextProvider;
                        break getTag;
                    case REACT_CONTEXT_TYPE:
                        // This is a consumer
                        fiberTag = ContextConsumer;
                        break getTag;
                    case REACT_FORWARD_REF_TYPE:
                        fiberTag = ForwardRef;
                        resolvedType = resolveForwardRefForHotReloading(resolvedType);
                        break getTag;
                    case REACT_MEMO_TYPE:
                        fiberTag = MemoComponent;
                        break getTag;
                    case REACT_LAZY_TYPE:
                        fiberTag = LazyComponent;
                        resolvedType = null;
                        break getTag;
                    case REACT_BLOCK_TYPE:
                        fiberTag = Block;
                        break getTag;
                }
                var info = '';
                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                var ownerName = owner ? getComponentName(owner.type) : null;
                if (ownerName) info += '\n\nCheck the render method of `' + ownerName + '`.';
                throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (type == null ? type : typeof type) + "." + info);
        }
        var fiber = createFiber(fiberTag, pendingProps, key, mode);
        fiber.elementType = type;
        fiber.type = resolvedType;
        fiber.lanes = lanes;
        fiber._debugOwner = owner;
        return fiber;
    }
    function createFiberFromElement(element, mode, lanes) {
        var owner = null;
        owner = element._owner;
        var type = element.type;
        var key = element.key;
        var pendingProps = element.props;
        var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
        fiber._debugSource = element._source;
        fiber._debugOwner = element._owner;
        return fiber;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
        var fiber = createFiber(Fragment, elements, key, mode);
        fiber.lanes = lanes;
        return fiber;
    }
    function createFiberFromProfiler(pendingProps, mode, lanes, key) {
        if (typeof pendingProps.id !== 'string') error1('Profiler must specify an "id" as a prop');
        var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode); // TODO: The Profiler fiber shouldn't have a type. It has a tag.
        fiber.elementType = REACT_PROFILER_TYPE;
        fiber.type = REACT_PROFILER_TYPE;
        fiber.lanes = lanes;
        fiber.stateNode = {
            effectDuration: 0,
            passiveEffectDuration: 0
        };
        return fiber;
    }
    function createFiberFromSuspense(pendingProps, mode, lanes, key) {
        var fiber = createFiber(SuspenseComponent, pendingProps, key, mode); // TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
        // This needs to be fixed in getComponentName so that it relies on the tag
        // instead.
        fiber.type = REACT_SUSPENSE_TYPE;
        fiber.elementType = REACT_SUSPENSE_TYPE;
        fiber.lanes = lanes;
        return fiber;
    }
    function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
        var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
        // TODO: The SuspenseListComponent fiber shouldn't have a type. It has a tag.
        // This needs to be fixed in getComponentName so that it relies on the tag
        // instead.
        fiber.type = REACT_SUSPENSE_LIST_TYPE;
        fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
        fiber.lanes = lanes;
        return fiber;
    }
    function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
        var fiber = createFiber(OffscreenComponent, pendingProps, key, mode); // TODO: The OffscreenComponent fiber shouldn't have a type. It has a tag.
        fiber.type = REACT_OFFSCREEN_TYPE;
        fiber.elementType = REACT_OFFSCREEN_TYPE;
        fiber.lanes = lanes;
        return fiber;
    }
    function createFiberFromLegacyHidden(pendingProps, mode, lanes, key) {
        var fiber = createFiber(LegacyHiddenComponent, pendingProps, key, mode); // TODO: The LegacyHidden fiber shouldn't have a type. It has a tag.
        fiber.type = REACT_LEGACY_HIDDEN_TYPE;
        fiber.elementType = REACT_LEGACY_HIDDEN_TYPE;
        fiber.lanes = lanes;
        return fiber;
    }
    function createFiberFromText(content, mode, lanes) {
        var fiber = createFiber(HostText, content, null, mode);
        fiber.lanes = lanes;
        return fiber;
    }
    function createFiberFromHostInstanceForDeletion() {
        var fiber = createFiber(HostComponent, null, null, NoMode); // TODO: These should not need a type.
        fiber.elementType = 'DELETED';
        fiber.type = 'DELETED';
        return fiber;
    }
    function createFiberFromPortal(portal, mode, lanes) {
        var pendingProps = portal.children !== null ? portal.children : [];
        var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
        fiber.lanes = lanes;
        fiber.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            // Used by persistent updates
            implementation: portal.implementation
        };
        return fiber;
    } // Used for stashing WIP properties to replay failed work in DEV.
    function assignFiberPropertiesInDEV(target, source) {
        if (target === null) // This Fiber's initial properties will always be overwritten.
        // We only use a Fiber to ensure the same hidden class so DEV isn't slow.
        target = createFiber(IndeterminateComponent, null, null, NoMode);
         // This is intentionally written as a list of all properties.
        // We tried to use Object.assign() instead but this is called in
        // the hottest path, and Object.assign() was too slow:
        // https://github.com/facebook/react/issues/12502
        // This code is DEV-only so size is not a concern.
        target.tag = source.tag;
        target.key = source.key;
        target.elementType = source.elementType;
        target.type = source.type;
        target.stateNode = source.stateNode;
        target.return = source.return;
        target.child = source.child;
        target.sibling = source.sibling;
        target.index = source.index;
        target.ref = source.ref;
        target.pendingProps = source.pendingProps;
        target.memoizedProps = source.memoizedProps;
        target.updateQueue = source.updateQueue;
        target.memoizedState = source.memoizedState;
        target.dependencies = source.dependencies;
        target.mode = source.mode;
        target.flags = source.flags;
        target.nextEffect = source.nextEffect;
        target.firstEffect = source.firstEffect;
        target.lastEffect = source.lastEffect;
        target.lanes = source.lanes;
        target.childLanes = source.childLanes;
        target.alternate = source.alternate;
        target.actualDuration = source.actualDuration;
        target.actualStartTime = source.actualStartTime;
        target.selfBaseDuration = source.selfBaseDuration;
        target.treeBaseDuration = source.treeBaseDuration;
        target._debugID = source._debugID;
        target._debugSource = source._debugSource;
        target._debugOwner = source._debugOwner;
        target._debugNeedsRemount = source._debugNeedsRemount;
        target._debugHookTypes = source._debugHookTypes;
        return target;
    }
    function FiberRootNode(containerInfo, tag, hydrate) {
        this.tag = tag;
        this.containerInfo = containerInfo;
        this.pendingChildren = null;
        this.current = null;
        this.pingCache = null;
        this.finishedWork = null;
        this.timeoutHandle = noTimeout;
        this.context = null;
        this.pendingContext = null;
        this.hydrate = hydrate;
        this.callbackNode = null;
        this.callbackPriority = NoLanePriority;
        this.eventTimes = createLaneMap(NoLanes);
        this.expirationTimes = createLaneMap(NoTimestamp);
        this.pendingLanes = NoLanes;
        this.suspendedLanes = NoLanes;
        this.pingedLanes = NoLanes;
        this.expiredLanes = NoLanes;
        this.mutableReadLanes = NoLanes;
        this.finishedLanes = NoLanes;
        this.entangledLanes = NoLanes;
        this.entanglements = createLaneMap(NoLanes);
        this.mutableSourceEagerHydrationData = null;
        this.interactionThreadID = tracing.unstable_getThreadID();
        this.memoizedInteractions = new Set();
        this.pendingInteractionMap = new Map();
        switch(tag){
            case BlockingRoot:
                this._debugRootType = 'createBlockingRoot()';
                break;
            case ConcurrentRoot:
                this._debugRootType = 'createRoot()';
                break;
            case LegacyRoot:
                this._debugRootType = 'createLegacyRoot()';
                break;
        }
    }
    function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
        var root = new FiberRootNode(containerInfo, tag, hydrate);
        // stateNode is any.
        var uninitializedFiber = createHostRootFiber(tag);
        root.current = uninitializedFiber;
        uninitializedFiber.stateNode = root;
        initializeUpdateQueue(uninitializedFiber);
        return root;
    }
    // This ensures that the version used for server rendering matches the one
    // that is eventually read during hydration.
    // If they don't match there's a potential tear and a full deopt render is required.
    function registerMutableSourceForHydration(root, mutableSource) {
        var getVersion = mutableSource._getVersion;
        var version = getVersion(mutableSource._source); // TODO Clear this data once all pending hydration work is finished.
        // Retaining it forever may interfere with GC.
        if (root.mutableSourceEagerHydrationData == null) root.mutableSourceEagerHydrationData = [
            mutableSource,
            version
        ];
        else root.mutableSourceEagerHydrationData.push(mutableSource, version);
    }
    function createPortal(children, containerInfo, implementation) {
        var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        return {
            // This tag allow us to uniquely identify this as a React Portal
            $$typeof: REACT_PORTAL_TYPE,
            key: key == null ? null : '' + key,
            children: children,
            containerInfo: containerInfo,
            implementation: implementation
        };
    }
    var didWarnAboutNestedUpdates;
    var didWarnAboutFindNodeInStrictMode;
    didWarnAboutNestedUpdates = false;
    didWarnAboutFindNodeInStrictMode = {
    };
    function getContextForSubtree(parentComponent) {
        if (!parentComponent) return emptyContextObject;
        var fiber = get1(parentComponent);
        var parentContext = findCurrentUnmaskedContext(fiber);
        if (fiber.tag === ClassComponent) {
            var Component = fiber.type;
            if (isContextProvider(Component)) return processChildContext(fiber, Component, parentContext);
        }
        return parentContext;
    }
    function findHostInstanceWithWarning(component, methodName) {
        var fiber = get1(component);
        if (fiber === undefined) {
            if (typeof component.render === 'function') throw Error("Unable to find node on an unmounted component.");
            else throw Error("Argument appears to not be a ReactComponent. Keys: " + Object.keys(component));
        }
        var hostFiber = findCurrentHostFiber(fiber);
        if (hostFiber === null) return null;
        if (hostFiber.mode & StrictMode) {
            var componentName = getComponentName(fiber.type) || 'Component';
            if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                didWarnAboutFindNodeInStrictMode[componentName] = true;
                var previousFiber = current1;
                try {
                    setCurrentFiber(hostFiber);
                    if (fiber.mode & StrictMode) error1("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    else error1("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                } finally{
                    // Ideally this should reset to previous but this shouldn't be called in
                    // render and there's another warning for that anyway.
                    if (previousFiber) setCurrentFiber(previousFiber);
                    else resetCurrentFiber();
                }
            }
        }
        return hostFiber.stateNode;
    }
    function createContainer(containerInfo, tag, hydrate, hydrationCallbacks) {
        return createFiberRoot(containerInfo, tag, hydrate);
    }
    function updateContainer(element, container, parentComponent, callback) {
        onScheduleRoot(container, element);
        var current$1 = container.current;
        var eventTime = requestEventTime();
        // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
        if ('undefined' !== typeof jest) {
            warnIfUnmockedScheduler(current$1);
            warnIfNotScopedWithMatchingAct(current$1);
        }
        var lane = requestUpdateLane(current$1);
        var context = getContextForSubtree(parentComponent);
        if (container.context === null) container.context = context;
        else container.pendingContext = context;
        if (isRendering && current1 !== null && !didWarnAboutNestedUpdates) {
            didWarnAboutNestedUpdates = true;
            error1("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentName(current1.type) || 'Unknown');
        }
        var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property
        // being called "element".
        update.payload = {
            element: element
        };
        callback = callback === undefined ? null : callback;
        if (callback !== null) {
            if (typeof callback !== 'function') error1("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
            update.callback = callback;
        }
        enqueueUpdate(current$1, update);
        scheduleUpdateOnFiber(current$1, lane, eventTime);
        return lane;
    }
    function getPublicRootInstance(container) {
        var containerFiber = container.current;
        if (!containerFiber.child) return null;
        switch(containerFiber.child.tag){
            case HostComponent:
                return getPublicInstance(containerFiber.child.stateNode);
            default:
                return containerFiber.child.stateNode;
        }
    }
    function markRetryLaneImpl(fiber, retryLane) {
        var suspenseState = fiber.memoizedState;
        if (suspenseState !== null && suspenseState.dehydrated !== null) suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
    } // Increases the priority of thennables when they resolve within this boundary.
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        var alternate = fiber.alternate;
        if (alternate) markRetryLaneImpl(alternate, retryLane);
    }
    function attemptUserBlockingHydration$1(fiber) {
        if (fiber.tag !== SuspenseComponent) // We ignore HostRoots here because we can't increase
        // their priority and they should not suspend on I/O,
        // since you have to wrap anything that might suspend in
        // Suspense.
        return;
        var eventTime = requestEventTime();
        var lane = InputDiscreteHydrationLane;
        scheduleUpdateOnFiber(fiber, lane, eventTime);
        markRetryLaneIfNotHydrated(fiber, lane);
    }
    function attemptContinuousHydration$1(fiber) {
        if (fiber.tag !== SuspenseComponent) // We ignore HostRoots here because we can't increase
        // their priority and they should not suspend on I/O,
        // since you have to wrap anything that might suspend in
        // Suspense.
        return;
        var eventTime = requestEventTime();
        var lane = SelectiveHydrationLane;
        scheduleUpdateOnFiber(fiber, lane, eventTime);
        markRetryLaneIfNotHydrated(fiber, lane);
    }
    function attemptHydrationAtCurrentPriority$1(fiber) {
        if (fiber.tag !== SuspenseComponent) // We ignore HostRoots here because we can't increase
        // their priority other than synchronously flush it.
        return;
        var eventTime = requestEventTime();
        var lane = requestUpdateLane(fiber);
        scheduleUpdateOnFiber(fiber, lane, eventTime);
        markRetryLaneIfNotHydrated(fiber, lane);
    }
    function runWithPriority$2(priority, fn) {
        setCurrentUpdateLanePriority(priority);
        return fn();
    }
    function findHostInstanceWithNoPortals(fiber) {
        var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
        if (hostFiber === null) return null;
        if (hostFiber.tag === FundamentalComponent) return hostFiber.stateNode.instance;
        return hostFiber.stateNode;
    }
    var shouldSuspendImpl = function(fiber) {
        return false;
    };
    function shouldSuspend(fiber) {
        return shouldSuspendImpl(fiber);
    }
    var overrideHookState = null;
    var overrideHookStateDeletePath = null;
    var overrideHookStateRenamePath = null;
    var overrideProps = null;
    var overridePropsDeletePath = null;
    var overridePropsRenamePath = null;
    var scheduleUpdate = null;
    var setSuspenseHandler = null;
    var copyWithDeleteImpl = function(obj, path, index) {
        var key = path[index];
        var updated = Array.isArray(obj) ? obj.slice() : _assign({
        }, obj);
        if (index + 1 === path.length) {
            if (Array.isArray(updated)) updated.splice(key, 1);
            else delete updated[key];
            return updated;
        } // $FlowFixMe number or string is fine here
        updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
        return updated;
    };
    var copyWithDelete = function(obj, path) {
        return copyWithDeleteImpl(obj, path, 0);
    };
    var copyWithRenameImpl = function(obj, oldPath, newPath, index) {
        var oldKey = oldPath[index];
        var updated = Array.isArray(obj) ? obj.slice() : _assign({
        }, obj);
        if (index + 1 === oldPath.length) {
            var newKey = newPath[index]; // $FlowFixMe number or string is fine here
            updated[newKey] = updated[oldKey];
            if (Array.isArray(updated)) updated.splice(oldKey, 1);
            else delete updated[oldKey];
        } else // $FlowFixMe number or string is fine here
        updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);
        return updated;
    };
    var copyWithRename = function(obj, oldPath, newPath) {
        if (oldPath.length !== newPath.length) {
            warn('copyWithRename() expects paths of the same length');
            return;
        } else {
            for(var i = 0; i < newPath.length - 1; i++)if (oldPath[i] !== newPath[i]) {
                warn('copyWithRename() expects paths to be the same except for the deepest key');
                return;
            }
        }
        return copyWithRenameImpl(obj, oldPath, newPath, 0);
    };
    var copyWithSetImpl = function(obj, path, index, value) {
        if (index >= path.length) return value;
        var key = path[index];
        var updated = Array.isArray(obj) ? obj.slice() : _assign({
        }, obj); // $FlowFixMe number or string is fine here
        updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
        return updated;
    };
    var copyWithSet = function(obj, path, value) {
        return copyWithSetImpl(obj, path, 0, value);
    };
    var findHook = function(fiber, id) {
        // For now, the "id" of stateful hooks is just the stateful hook index.
        // This may change in the future with e.g. nested hooks.
        var currentHook = fiber.memoizedState;
        while(currentHook !== null && id > 0){
            currentHook = currentHook.next;
            id--;
        }
        return currentHook;
    }; // Support DevTools editable values for useState and useReducer.
    overrideHookState = function(fiber, id, path, value) {
        var hook = findHook(fiber, id);
        if (hook !== null) {
            var newState = copyWithSet(hook.memoizedState, path, value);
            hook.memoizedState = newState;
            hook.baseState = newState; // We aren't actually adding an update to the queue,
            // because there is no update we can add for useReducer hooks that won't trigger an error.
            // (There's no appropriate action type for DevTools overrides.)
            // As a result though, React will see the scheduled update as a noop and bailout.
            // Shallow cloning props works as a workaround for now to bypass the bailout check.
            fiber.memoizedProps = _assign({
            }, fiber.memoizedProps);
            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
        }
    };
    overrideHookStateDeletePath = function(fiber, id, path) {
        var hook = findHook(fiber, id);
        if (hook !== null) {
            var newState = copyWithDelete(hook.memoizedState, path);
            hook.memoizedState = newState;
            hook.baseState = newState; // We aren't actually adding an update to the queue,
            // because there is no update we can add for useReducer hooks that won't trigger an error.
            // (There's no appropriate action type for DevTools overrides.)
            // As a result though, React will see the scheduled update as a noop and bailout.
            // Shallow cloning props works as a workaround for now to bypass the bailout check.
            fiber.memoizedProps = _assign({
            }, fiber.memoizedProps);
            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
        }
    };
    overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
        var hook = findHook(fiber, id);
        if (hook !== null) {
            var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
            hook.memoizedState = newState;
            hook.baseState = newState; // We aren't actually adding an update to the queue,
            // because there is no update we can add for useReducer hooks that won't trigger an error.
            // (There's no appropriate action type for DevTools overrides.)
            // As a result though, React will see the scheduled update as a noop and bailout.
            // Shallow cloning props works as a workaround for now to bypass the bailout check.
            fiber.memoizedProps = _assign({
            }, fiber.memoizedProps);
            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
        }
    }; // Support DevTools props for function components, forwardRef, memo, host components, etc.
    overrideProps = function(fiber, path, value) {
        fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
        if (fiber.alternate) fiber.alternate.pendingProps = fiber.pendingProps;
        scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    };
    overridePropsDeletePath = function(fiber, path) {
        fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
        if (fiber.alternate) fiber.alternate.pendingProps = fiber.pendingProps;
        scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    };
    overridePropsRenamePath = function(fiber, oldPath, newPath) {
        fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
        if (fiber.alternate) fiber.alternate.pendingProps = fiber.pendingProps;
        scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    };
    scheduleUpdate = function(fiber) {
        scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    };
    setSuspenseHandler = function(newShouldSuspendImpl) {
        shouldSuspendImpl = newShouldSuspendImpl;
    };
    function findHostInstanceByFiber(fiber) {
        var hostFiber = findCurrentHostFiber(fiber);
        if (hostFiber === null) return null;
        return hostFiber.stateNode;
    }
    function emptyFindFiberByHostInstance(instance) {
        return null;
    }
    function getCurrentFiberForDevTools() {
        return current1;
    }
    function injectIntoDevTools(devToolsConfig) {
        var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        return injectInternals({
            bundleType: devToolsConfig.bundleType,
            version: devToolsConfig.version,
            rendererPackageName: devToolsConfig.rendererPackageName,
            rendererConfig: devToolsConfig.rendererConfig,
            overrideHookState: overrideHookState,
            overrideHookStateDeletePath: overrideHookStateDeletePath,
            overrideHookStateRenamePath: overrideHookStateRenamePath,
            overrideProps: overrideProps,
            overridePropsDeletePath: overridePropsDeletePath,
            overridePropsRenamePath: overridePropsRenamePath,
            setSuspenseHandler: setSuspenseHandler,
            scheduleUpdate: scheduleUpdate,
            currentDispatcherRef: ReactCurrentDispatcher,
            findHostInstanceByFiber: findHostInstanceByFiber,
            findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
            // React Refresh
            findHostInstancesForRefresh: findHostInstancesForRefresh,
            scheduleRefresh: scheduleRefresh,
            scheduleRoot: scheduleRoot,
            setRefreshHandler: setRefreshHandler,
            // Enables DevTools to append owner stacks to error messages in DEV mode.
            getCurrentFiber: getCurrentFiberForDevTools
        });
    }
    function ReactDOMRoot(container, options) {
        this._internalRoot = createRootImpl(container, ConcurrentRoot, options);
    }
    function ReactDOMBlockingRoot(container, tag, options) {
        this._internalRoot = createRootImpl(container, tag, options);
    }
    ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function(children) {
        var root = this._internalRoot;
        if (typeof arguments[1] === 'function') error1("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
        var container = root.containerInfo;
        if (container.nodeType !== COMMENT_NODE) {
            var hostInstance = findHostInstanceWithNoPortals(root.current);
            if (hostInstance) {
                if (hostInstance.parentNode !== container) error1("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
            }
        }
        updateContainer(children, root, null, null);
    };
    ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function() {
        if (typeof arguments[0] === 'function') error1("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
        var root = this._internalRoot;
        var container = root.containerInfo;
        updateContainer(null, root, null, function() {
            unmarkContainerAsRoot(container);
        });
    };
    function createRootImpl(container, tag, options) {
        // Tag is either LegacyRoot or Concurrent Root
        var hydrate = options != null && options.hydrate === true;
        var hydrationCallbacks = options != null && options.hydrationOptions || null;
        var mutableSources = options != null && options.hydrationOptions != null && options.hydrationOptions.mutableSources || null;
        var root = createContainer(container, tag, hydrate);
        markContainerAsRoot(root.current, container);
        var containerNodeType = container.nodeType;
        var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
        listenToAllSupportedEvents(rootContainerElement);
        if (mutableSources) for(var i = 0; i < mutableSources.length; i++){
            var mutableSource = mutableSources[i];
            registerMutableSourceForHydration(root, mutableSource);
        }
        return root;
    }
    function createLegacyRoot(container, options) {
        return new ReactDOMBlockingRoot(container, LegacyRoot, options);
    }
    function isValidContainer(node) {
        return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
    }
    var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
    var topLevelUpdateWarnings;
    var warnedAboutHydrateAPI = false;
    topLevelUpdateWarnings = function(container) {
        if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
            var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);
            if (hostInstance) {
                if (hostInstance.parentNode !== container) error1("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
            }
        }
        var isRootRenderedBySomeReact = !!container._reactRootContainer;
        var rootEl = getReactRootElementInContainer(container);
        var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
        if (hasNonRootReactChild && !isRootRenderedBySomeReact) error1("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
        if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === 'BODY') error1("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function getReactRootElementInContainer(container) {
        if (!container) return null;
        if (container.nodeType === DOCUMENT_NODE) return container.documentElement;
        else return container.firstChild;
    }
    function shouldHydrateDueToLegacyHeuristic(container) {
        var rootElement = getReactRootElementInContainer(container);
        return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
    }
    function legacyCreateRootFromDOMContainer(container, forceHydrate) {
        var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content.
        if (!shouldHydrate) {
            var warned = false;
            var rootSibling;
            while(rootSibling = container.lastChild){
                if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
                    warned = true;
                    error1("render(): Target node has markup rendered by React, but there are unrelated nodes as well. This is most commonly caused by white-space inserted around server-rendered markup.");
                }
                container.removeChild(rootSibling);
            }
        }
        if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
            warnedAboutHydrateAPI = true;
            warn("render(): Calling ReactDOM.render() to hydrate server-rendered markup will stop working in React v18. Replace the ReactDOM.render() call with ReactDOM.hydrate() if you want React to attach to the server HTML.");
        }
        return createLegacyRoot(container, shouldHydrate ? {
            hydrate: true
        } : undefined);
    }
    function warnOnInvalidCallback$1(callback, callerName) {
        if (callback !== null && typeof callback !== 'function') error1("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
    }
    function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
        topLevelUpdateWarnings(container);
        warnOnInvalidCallback$1(callback === undefined ? null : callback, 'render');
        // member of intersection type." Whyyyyyy.
        var root = container._reactRootContainer;
        var fiberRoot;
        if (!root) {
            // Initial mount
            root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);
            fiberRoot = root._internalRoot;
            if (typeof callback === 'function') {
                var originalCallback = callback;
                callback = function() {
                    var instance = getPublicRootInstance(fiberRoot);
                    originalCallback.call(instance);
                };
            } // Initial mount should not be batched.
            unbatchedUpdates(function() {
                updateContainer(children, fiberRoot, parentComponent, callback);
            });
        } else {
            fiberRoot = root._internalRoot;
            if (typeof callback === 'function') {
                var _originalCallback = callback;
                callback = function() {
                    var instance = getPublicRootInstance(fiberRoot);
                    _originalCallback.call(instance);
                };
            } // Update
            updateContainer(children, fiberRoot, parentComponent, callback);
        }
        return getPublicRootInstance(fiberRoot);
    }
    function findDOMNode(componentOrElement) {
        var owner = ReactCurrentOwner$3.current;
        if (owner !== null && owner.stateNode !== null) {
            var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
            if (!warnedAboutRefsInRender) error1("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentName(owner.type) || 'A component');
            owner.stateNode._warnedAboutRefsInRender = true;
        }
        if (componentOrElement == null) return null;
        if (componentOrElement.nodeType === ELEMENT_NODE) return componentOrElement;
        return findHostInstanceWithWarning(componentOrElement, 'findDOMNode');
    }
    function hydrate1(element, container, callback) {
        if (!isValidContainer(container)) throw Error("Target container is not a DOM element.");
        var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;
        if (isModernRoot) error1("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call createRoot(container, {hydrate: true}).render(element)?");
        return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
    }
    function render1(element, container, callback) {
        if (!isValidContainer(container)) throw Error("Target container is not a DOM element.");
        var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;
        if (isModernRoot) error1("You are calling ReactDOM.render() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.render(element)?");
        return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
    }
    function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
        if (!isValidContainer(containerNode)) throw Error("Target container is not a DOM element.");
        if (!(parentComponent != null && has1(parentComponent))) throw Error("parentComponent must be a valid React Component");
        return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
    }
    function unmountComponentAtNode(container) {
        if (!isValidContainer(container)) throw Error("unmountComponentAtNode(...): Target container is not a DOM element.");
        var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;
        if (isModernRoot) error1("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?");
        if (container._reactRootContainer) {
            var rootEl = getReactRootElementInContainer(container);
            var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
            if (renderedByDifferentReact) error1("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
            unbatchedUpdates(function() {
                legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
                    // $FlowFixMe This should probably use `delete container._reactRootContainer`
                    container._reactRootContainer = null;
                    unmarkContainerAsRoot(container);
                });
            }); // If you call unmountComponentAtNode twice in quick succession, you'll
            // get `true` twice. That's probably fine?
            return true;
        } else {
            var _rootEl = getReactRootElementInContainer(container);
            var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl)); // Check if the container itself is a React root node.
            var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;
            if (hasNonRootReactChild) error1("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
            return false;
        }
    }
    setAttemptUserBlockingHydration(attemptUserBlockingHydration$1);
    setAttemptContinuousHydration(attemptContinuousHydration$1);
    setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
    setAttemptHydrationAtPriority(runWithPriority$2);
    var didWarnAboutUnstableCreatePortal = false;
    if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') error1("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    setRestoreImplementation(restoreControlledState$3);
    setBatchingImplementation(batchedUpdates$1, discreteUpdates$1, flushDiscreteUpdates, batchedEventUpdates$1);
    function createPortal$1(children, container) {
        var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        if (!isValidContainer(container)) throw Error("Target container is not a DOM element.");
         // TODO: pass ReactDOM portal implementation as third argument
        // $FlowFixMe The Flow type is opaque but there's no way to actually create it.
        return createPortal(children, container, null, key);
    }
    function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
        return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
    }
    function unstable_createPortal(children, container) {
        var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        if (!didWarnAboutUnstableCreatePortal) {
            didWarnAboutUnstableCreatePortal = true;
            warn("The ReactDOM.unstable_createPortal() alias has been deprecated, and will be removed in React 18+. Update your code to use ReactDOM.createPortal() instead. It has the exact same API, but without the \"unstable_\" prefix.");
        }
        return createPortal$1(children, container, key);
    }
    var Internals = {
        // Keep in sync with ReactTestUtils.js, and ReactTestUtilsAct.js.
        // This is an array for better minification.
        Events: [
            getInstanceFromNode,
            getNodeFromInstance,
            getFiberCurrentPropsFromNode,
            enqueueStateRestore,
            restoreStateIfNeeded,
            flushPassiveEffects,
            IsThisRendererActing
        ]
    };
    var foundDevTools = injectIntoDevTools({
        findFiberByHostInstance: getClosestInstanceFromNode,
        bundleType: 1,
        version: ReactVersion,
        rendererPackageName: 'react-dom'
    });
    if (!foundDevTools && canUseDOM && window.top === window.self) // If we're in Chrome or Firefox, provide a download link if not installed.
    {
        if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
            var protocol = window.location.protocol; // Don't warn in exotic cases like chrome-extension://.
            if (/^(https?|file):$/.test(protocol)) // eslint-disable-next-line react-internal/no-production-logging
            console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === 'file:' ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ''), 'font-weight:bold');
        }
    }
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
    exports.createPortal = createPortal$1;
    exports.findDOMNode = findDOMNode;
    exports.flushSync = flushSync;
    exports.hydrate = hydrate1;
    exports.render = render1;
    exports.unmountComponentAtNode = unmountComponentAtNode;
    exports.unstable_batchedUpdates = batchedUpdates$1;
    exports.unstable_createPortal = unstable_createPortal;
    exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
    exports.version = ReactVersion;
})();

},{"react":"21dqq","object-assign":"7OXxh","scheduler":"juvHo","scheduler/tracing":"9ZY7A"}],"juvHo":[function(require,module,exports) {
'use strict';
module.exports = require('./cjs/scheduler.development.js');

},{"./cjs/scheduler.development.js":"RqdIf"}],"RqdIf":[function(require,module,exports) {
/** @license React v0.20.2
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    var enableSchedulerDebugging = false;
    var enableProfiling = false;
    var requestHostCallback;
    var requestHostTimeout;
    var cancelHostTimeout;
    var requestPaint;
    var hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';
    if (hasPerformanceNow) {
        var localPerformance = performance;
        exports.unstable_now = function() {
            return localPerformance.now();
        };
    } else {
        var localDate = Date;
        var initialTime = localDate.now();
        exports.unstable_now = function() {
            return localDate.now() - initialTime;
        };
    }
    if (// implementation using setTimeout.
    typeof window === 'undefined' || typeof MessageChannel !== 'function') {
        // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,
        // fallback to a naive implementation.
        var _callback = null;
        var _timeoutID = null;
        var _flushCallback = function() {
            if (_callback !== null) try {
                var currentTime = exports.unstable_now();
                var hasRemainingTime = true;
                _callback(hasRemainingTime, currentTime);
                _callback = null;
            } catch (e) {
                setTimeout(_flushCallback, 0);
                throw e;
            }
        };
        requestHostCallback = function(cb) {
            if (_callback !== null) // Protect against re-entrancy.
            setTimeout(requestHostCallback, 0, cb);
            else {
                _callback = cb;
                setTimeout(_flushCallback, 0);
            }
        };
        requestHostTimeout = function(cb, ms) {
            _timeoutID = setTimeout(cb, ms);
        };
        cancelHostTimeout = function() {
            clearTimeout(_timeoutID);
        };
        exports.unstable_shouldYield = function() {
            return false;
        };
        requestPaint = exports.unstable_forceFrameRate = function() {
        };
    } else {
        // Capture local references to native APIs, in case a polyfill overrides them.
        var _setTimeout = window.setTimeout;
        var _clearTimeout = window.clearTimeout;
        if (typeof console !== 'undefined') {
            // TODO: Scheduler no longer requires these methods to be polyfilled. But
            // maybe we want to continue warning if they don't exist, to preserve the
            // option to rely on it in the future?
            var requestAnimationFrame = window.requestAnimationFrame;
            var cancelAnimationFrame = window.cancelAnimationFrame;
            if (typeof requestAnimationFrame !== 'function') // Using console['error'] to evade Babel and ESLint
            console['error']("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
            if (typeof cancelAnimationFrame !== 'function') // Using console['error'] to evade Babel and ESLint
            console['error']("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main
        // thread, like user events. By default, it yields multiple times per frame.
        // It does not attempt to align with frame boundaries, since most tasks don't
        // need to be frame aligned; for those that do, use requestAnimationFrame.
        var yieldInterval = 5;
        var deadline = 0; // TODO: Make this configurable
        // `isInputPending` is not available. Since we have no way of knowing if
        // there's pending input, always yield at the end of the frame.
        exports.unstable_shouldYield = function() {
            return exports.unstable_now() >= deadline;
        }; // Since we yield every frame regardless, `requestPaint` has no effect.
        requestPaint = function() {
        };
        exports.unstable_forceFrameRate = function(fps) {
            if (fps < 0 || fps > 125) {
                // Using console['error'] to evade Babel and ESLint
                console['error']("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
                return;
            }
            if (fps > 0) yieldInterval = Math.floor(1000 / fps);
            else // reset the framerate
            yieldInterval = 5;
        };
        var performWorkUntilDeadline = function() {
            if (scheduledHostCallback !== null) {
                var currentTime = exports.unstable_now(); // Yield after `yieldInterval` ms, regardless of where we are in the vsync
                // cycle. This means there's always time remaining at the beginning of
                // the message event.
                deadline = currentTime + yieldInterval;
                var hasTimeRemaining = true;
                try {
                    var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
                    if (!hasMoreWork) {
                        isMessageLoopRunning = false;
                        scheduledHostCallback = null;
                    } else // If there's more work, schedule the next message event at the end
                    // of the preceding one.
                    port.postMessage(null);
                } catch (error) {
                    // If a scheduler task throws, exit the current browser task so the
                    // error can be observed.
                    port.postMessage(null);
                    throw error;
                }
            } else isMessageLoopRunning = false;
             // Yielding to the browser will give it a chance to paint, so we can
        };
        var channel = new MessageChannel();
        var port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        requestHostCallback = function(callback) {
            scheduledHostCallback = callback;
            if (!isMessageLoopRunning) {
                isMessageLoopRunning = true;
                port.postMessage(null);
            }
        };
        requestHostTimeout = function(callback, ms) {
            taskTimeoutID = _setTimeout(function() {
                callback(exports.unstable_now());
            }, ms);
        };
        cancelHostTimeout = function() {
            _clearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
        };
    }
    function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        siftUp(heap, node, index);
    }
    function peek(heap) {
        var first = heap[0];
        return first === undefined ? null : first;
    }
    function pop(heap) {
        var first = heap[0];
        if (first !== undefined) {
            var last = heap.pop();
            if (last !== first) {
                heap[0] = last;
                siftDown(heap, last, 0);
            }
            return first;
        } else return null;
    }
    function siftUp(heap, node, i) {
        var index = i;
        while(true){
            var parentIndex = index - 1 >>> 1;
            var parent = heap[parentIndex];
            if (parent !== undefined && compare(parent, node) > 0) {
                // The parent is larger. Swap positions.
                heap[parentIndex] = node;
                heap[index] = parent;
                index = parentIndex;
            } else // The parent is smaller. Exit.
            return;
        }
    }
    function siftDown(heap, node, i) {
        var index = i;
        var length = heap.length;
        while(index < length){
            var leftIndex = (index + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.
            if (left !== undefined && compare(left, node) < 0) {
                if (right !== undefined && compare(right, left) < 0) {
                    heap[index] = right;
                    heap[rightIndex] = node;
                    index = rightIndex;
                } else {
                    heap[index] = left;
                    heap[leftIndex] = node;
                    index = leftIndex;
                }
            } else if (right !== undefined && compare(right, node) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
            } else // Neither child is smaller. Exit.
            return;
        }
    }
    function compare(a, b) {
        // Compare sort index first, then task id.
        var diff = a.sortIndex - b.sortIndex;
        return diff !== 0 ? diff : a.id - b.id;
    }
    // TODO: Use symbols?
    var ImmediatePriority = 1;
    var UserBlockingPriority = 2;
    var NormalPriority = 3;
    var LowPriority = 4;
    var IdlePriority = 5;
    function markTaskErrored(task, ms) {
    }
    /* eslint-disable no-var */ // Math.pow(2, 30) - 1
    // 0b111111111111111111111111111111
    var maxSigned31BitInt = 1073741823; // Times out immediately
    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out
    var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
    var NORMAL_PRIORITY_TIMEOUT = 5000;
    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out
    var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap
    var taskQueue = [];
    var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.
    var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.
    var currentTask = null;
    var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrancy.
    var isPerformingWork = false;
    var isHostCallbackScheduled = false;
    var isHostTimeoutScheduled = false;
    function advanceTimers(currentTime) {
        // Check for tasks that are no longer delayed and add them to the queue.
        var timer = peek(timerQueue);
        while(timer !== null){
            if (timer.callback === null) // Timer was cancelled.
            pop(timerQueue);
            else if (timer.startTime <= currentTime) {
                // Timer fired. Transfer to the task queue.
                pop(timerQueue);
                timer.sortIndex = timer.expirationTime;
                push(taskQueue, timer);
            } else // Remaining timers are pending.
            return;
            timer = peek(timerQueue);
        }
    }
    function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
            } else {
                var firstTimer = peek(timerQueue);
                if (firstTimer !== null) requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
        }
    }
    function flushWork(hasTimeRemaining, initialTime) {
        isHostCallbackScheduled = false;
        if (isHostTimeoutScheduled) {
            // We scheduled a timeout but it's no longer needed. Cancel it.
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
        }
        isPerformingWork = true;
        var previousPriorityLevel = currentPriorityLevel;
        try {
            if (enableProfiling) try {
                return workLoop(hasTimeRemaining, initialTime);
            } catch (error) {
                if (currentTask !== null) {
                    var currentTime = exports.unstable_now();
                    markTaskErrored(currentTask, currentTime);
                    currentTask.isQueued = false;
                }
                throw error;
            }
            else // No catch in prod code path.
            return workLoop(hasTimeRemaining, initialTime);
        } finally{
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
        }
    }
    function workLoop(hasTimeRemaining, initialTime) {
        var currentTime = initialTime;
        advanceTimers(currentTime);
        currentTask = peek(taskQueue);
        while(currentTask !== null && !enableSchedulerDebugging){
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || exports.unstable_shouldYield())) break;
            var callback = currentTask.callback;
            if (typeof callback === 'function') {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                var continuationCallback = callback(didUserCallbackTimeout);
                currentTime = exports.unstable_now();
                if (typeof continuationCallback === 'function') currentTask.callback = continuationCallback;
                else if (currentTask === peek(taskQueue)) pop(taskQueue);
                advanceTimers(currentTime);
            } else pop(taskQueue);
            currentTask = peek(taskQueue);
        } // Return whether there's additional work
        if (currentTask !== null) return true;
        else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            return false;
        }
    }
    function unstable_runWithPriority(priorityLevel, eventHandler) {
        switch(priorityLevel){
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
                break;
            default:
                priorityLevel = NormalPriority;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
            return eventHandler();
        } finally{
            currentPriorityLevel = previousPriorityLevel;
        }
    }
    function unstable_next(eventHandler) {
        var priorityLevel;
        switch(currentPriorityLevel){
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
                // Shift down to normal priority
                priorityLevel = NormalPriority;
                break;
            default:
                // Anything lower than normal priority should remain at the current level.
                priorityLevel = currentPriorityLevel;
                break;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
            return eventHandler();
        } finally{
            currentPriorityLevel = previousPriorityLevel;
        }
    }
    function unstable_wrapCallback(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
            // This is a fork of runWithPriority, inlined for performance.
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
                return callback.apply(this, arguments);
            } finally{
                currentPriorityLevel = previousPriorityLevel;
            }
        };
    }
    function unstable_scheduleCallback(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        var startTime;
        if (typeof options === 'object' && options !== null) {
            var delay = options.delay;
            if (typeof delay === 'number' && delay > 0) startTime = currentTime + delay;
            else startTime = currentTime;
        } else startTime = currentTime;
        var timeout;
        switch(priorityLevel){
            case ImmediatePriority:
                timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                break;
            case UserBlockingPriority:
                timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                break;
            case IdlePriority:
                timeout = IDLE_PRIORITY_TIMEOUT;
                break;
            case LowPriority:
                timeout = LOW_PRIORITY_TIMEOUT;
                break;
            case NormalPriority:
            default:
                timeout = NORMAL_PRIORITY_TIMEOUT;
                break;
        }
        var expirationTime = startTime + timeout;
        var newTask = {
            id: taskIdCounter++,
            callback: callback,
            priorityLevel: priorityLevel,
            startTime: startTime,
            expirationTime: expirationTime,
            sortIndex: -1
        };
        if (startTime > currentTime) {
            // This is a delayed task.
            newTask.sortIndex = startTime;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                // All tasks are delayed, and this is the task with the earliest delay.
                if (isHostTimeoutScheduled) // Cancel an existing timeout.
                cancelHostTimeout();
                else isHostTimeoutScheduled = true;
                 // Schedule a timeout.
                requestHostTimeout(handleTimeout, startTime - currentTime);
            }
        } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            // wait until the next time we yield.
            if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
            }
        }
        return newTask;
    }
    function unstable_pauseExecution() {
    }
    function unstable_continueExecution() {
        if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
        }
    }
    function unstable_getFirstCallbackNode() {
        return peek(taskQueue);
    }
    function unstable_cancelCallback(task) {
        // remove from the queue because you can't remove arbitrary nodes from an
        // array based heap, only the first one.)
        task.callback = null;
    }
    function unstable_getCurrentPriorityLevel() {
        return currentPriorityLevel;
    }
    var unstable_requestPaint = requestPaint;
    var unstable_Profiling = null;
    exports.unstable_IdlePriority = IdlePriority;
    exports.unstable_ImmediatePriority = ImmediatePriority;
    exports.unstable_LowPriority = LowPriority;
    exports.unstable_NormalPriority = NormalPriority;
    exports.unstable_Profiling = unstable_Profiling;
    exports.unstable_UserBlockingPriority = UserBlockingPriority;
    exports.unstable_cancelCallback = unstable_cancelCallback;
    exports.unstable_continueExecution = unstable_continueExecution;
    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
    exports.unstable_next = unstable_next;
    exports.unstable_pauseExecution = unstable_pauseExecution;
    exports.unstable_requestPaint = unstable_requestPaint;
    exports.unstable_runWithPriority = unstable_runWithPriority;
    exports.unstable_scheduleCallback = unstable_scheduleCallback;
    exports.unstable_wrapCallback = unstable_wrapCallback;
})();

},{}],"9ZY7A":[function(require,module,exports) {
'use strict';
module.exports = require('./cjs/scheduler-tracing.development.js');

},{"./cjs/scheduler-tracing.development.js":"dClkR"}],"dClkR":[function(require,module,exports) {
/** @license React v0.20.2
 * scheduler-tracing.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    var DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.
    var interactionIDCounter = 0;
    var threadIDCounter = 0; // Set of currently traced interactions.
    // Interactions "stack"â€“
    // Meaning that newly traced interactions are appended to the previously active set.
    // When an interaction goes out of scope, the previous set (if any) is restored.
    exports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.
    exports.__subscriberRef = null;
    exports.__interactionsRef = {
        current: new Set()
    };
    exports.__subscriberRef = {
        current: null
    };
    function unstable_clear(callback) {
        var prevInteractions = exports.__interactionsRef.current;
        exports.__interactionsRef.current = new Set();
        try {
            return callback();
        } finally{
            exports.__interactionsRef.current = prevInteractions;
        }
    }
    function unstable_getCurrent() {
        return exports.__interactionsRef.current;
    }
    function unstable_getThreadID() {
        return ++threadIDCounter;
    }
    function unstable_trace(name, timestamp, callback) {
        var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;
        var interaction = {
            __count: 1,
            id: interactionIDCounter++,
            name: name,
            timestamp: timestamp
        };
        var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.
        // To do that, clone the current interactions.
        // The previous set will be restored upon completion.
        var interactions = new Set(prevInteractions);
        interactions.add(interaction);
        exports.__interactionsRef.current = interactions;
        var subscriber = exports.__subscriberRef.current;
        var returnValue;
        try {
            if (subscriber !== null) subscriber.onInteractionTraced(interaction);
        } finally{
            try {
                if (subscriber !== null) subscriber.onWorkStarted(interactions, threadID);
            } finally{
                try {
                    returnValue = callback();
                } finally{
                    exports.__interactionsRef.current = prevInteractions;
                    try {
                        if (subscriber !== null) subscriber.onWorkStopped(interactions, threadID);
                    } finally{
                        interaction.__count--; // If no async work was scheduled for this interaction,
                        // Notify subscribers that it's completed.
                        if (subscriber !== null && interaction.__count === 0) subscriber.onInteractionScheduledWorkCompleted(interaction);
                    }
                }
            }
        }
        return returnValue;
    }
    function unstable_wrap(callback) {
        var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;
        var wrappedInteractions = exports.__interactionsRef.current;
        var subscriber = exports.__subscriberRef.current;
        if (subscriber !== null) subscriber.onWorkScheduled(wrappedInteractions, threadID);
         // Update the pending async work count for the current interactions.
        // Update after calling subscribers in case of error.
        wrappedInteractions.forEach(function(interaction) {
            interaction.__count++;
        });
        var hasRun = false;
        function wrapped() {
            var prevInteractions = exports.__interactionsRef.current;
            exports.__interactionsRef.current = wrappedInteractions;
            subscriber = exports.__subscriberRef.current;
            try {
                var returnValue;
                try {
                    if (subscriber !== null) subscriber.onWorkStarted(wrappedInteractions, threadID);
                } finally{
                    try {
                        returnValue = callback.apply(undefined, arguments);
                    } finally{
                        exports.__interactionsRef.current = prevInteractions;
                        if (subscriber !== null) subscriber.onWorkStopped(wrappedInteractions, threadID);
                    }
                }
                return returnValue;
            } finally{
                if (!hasRun) {
                    // We only expect a wrapped function to be executed once,
                    // But in the event that it's executed more than onceâ€“
                    // Only decrement the outstanding interaction counts once.
                    hasRun = true; // Update pending async counts for all wrapped interactions.
                    // If this was the last scheduled async work for any of them,
                    // Mark them as completed.
                    wrappedInteractions.forEach(function(interaction) {
                        interaction.__count--;
                        if (subscriber !== null && interaction.__count === 0) subscriber.onInteractionScheduledWorkCompleted(interaction);
                    });
                }
            }
        }
        wrapped.cancel = function cancel() {
            subscriber = exports.__subscriberRef.current;
            try {
                if (subscriber !== null) subscriber.onWorkCanceled(wrappedInteractions, threadID);
            } finally{
                // Update pending async counts for all wrapped interactions.
                // If this was the last scheduled async work for any of them,
                // Mark them as completed.
                wrappedInteractions.forEach(function(interaction) {
                    interaction.__count--;
                    if (subscriber && interaction.__count === 0) subscriber.onInteractionScheduledWorkCompleted(interaction);
                });
            }
        };
        return wrapped;
    }
    var subscribers = null;
    subscribers = new Set();
    function unstable_subscribe(subscriber) {
        subscribers.add(subscriber);
        if (subscribers.size === 1) exports.__subscriberRef.current = {
            onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,
            onInteractionTraced: onInteractionTraced,
            onWorkCanceled: onWorkCanceled,
            onWorkScheduled: onWorkScheduled,
            onWorkStarted: onWorkStarted,
            onWorkStopped: onWorkStopped
        };
    }
    function unstable_unsubscribe(subscriber) {
        subscribers.delete(subscriber);
        if (subscribers.size === 0) exports.__subscriberRef.current = null;
    }
    function onInteractionTraced(interaction) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function(subscriber) {
            try {
                subscriber.onInteractionTraced(interaction);
            } catch (error) {
                if (!didCatchError) {
                    didCatchError = true;
                    caughtError = error;
                }
            }
        });
        if (didCatchError) throw caughtError;
    }
    function onInteractionScheduledWorkCompleted(interaction) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function(subscriber) {
            try {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
            } catch (error) {
                if (!didCatchError) {
                    didCatchError = true;
                    caughtError = error;
                }
            }
        });
        if (didCatchError) throw caughtError;
    }
    function onWorkScheduled(interactions, threadID) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function(subscriber) {
            try {
                subscriber.onWorkScheduled(interactions, threadID);
            } catch (error) {
                if (!didCatchError) {
                    didCatchError = true;
                    caughtError = error;
                }
            }
        });
        if (didCatchError) throw caughtError;
    }
    function onWorkStarted(interactions, threadID) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function(subscriber) {
            try {
                subscriber.onWorkStarted(interactions, threadID);
            } catch (error) {
                if (!didCatchError) {
                    didCatchError = true;
                    caughtError = error;
                }
            }
        });
        if (didCatchError) throw caughtError;
    }
    function onWorkStopped(interactions, threadID) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function(subscriber) {
            try {
                subscriber.onWorkStopped(interactions, threadID);
            } catch (error) {
                if (!didCatchError) {
                    didCatchError = true;
                    caughtError = error;
                }
            }
        });
        if (didCatchError) throw caughtError;
    }
    function onWorkCanceled(interactions, threadID) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function(subscriber) {
            try {
                subscriber.onWorkCanceled(interactions, threadID);
            } catch (error) {
                if (!didCatchError) {
                    didCatchError = true;
                    caughtError = error;
                }
            }
        });
        if (didCatchError) throw caughtError;
    }
    exports.unstable_clear = unstable_clear;
    exports.unstable_getCurrent = unstable_getCurrent;
    exports.unstable_getThreadID = unstable_getThreadID;
    exports.unstable_subscribe = unstable_subscribe;
    exports.unstable_trace = unstable_trace;
    exports.unstable_unsubscribe = unstable_unsubscribe;
    exports.unstable_wrap = unstable_wrap;
})();

},{}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"km3Ru":[function(require,module,exports) {
"use strict";
var Refresh = require('react-refresh/runtime');
function debounce(func, delay) {
    var args1;
    var timeout = undefined;
    return function(args) {
        clearTimeout(timeout);
        timeout = setTimeout(function() {
            timeout = undefined;
            func.call(null, args);
        }, delay);
    };
}
var enqueueUpdate = debounce(function() {
    Refresh.performReactRefresh();
}, 30); // Everthing below is either adapted or copied from
// https://github.com/facebook/metro/blob/61de16bd1edd7e738dd0311c89555a644023ab2d/packages/metro/src/lib/polyfills/require.js
// MIT License - Copyright (c) Facebook, Inc. and its affiliates.
module.exports.prelude = function(module) {
    window.$RefreshReg$ = function(type, id) {
        Refresh.register(type, module.id + ' ' + id);
    };
    window.$RefreshSig$ = Refresh.createSignatureFunctionForTransform;
};
module.exports.postlude = function(module) {
    if (isReactRefreshBoundary(module.exports)) {
        registerExportsForReactRefresh(module);
        if (module.hot) {
            module.hot.dispose(function(data) {
                if (Refresh.hasUnrecoverableErrors()) window.location.reload();
                data.prevExports = module.exports;
            });
            module.hot.accept(function(getParents) {
                var prevExports = module.hot.data.prevExports;
                var nextExports = module.exports; // Since we just executed the code for it, it's possible
                // that the new exports make it ineligible for being a boundary.
                var isNoLongerABoundary = !isReactRefreshBoundary(nextExports); // It can also become ineligible if its exports are incompatible
                // with the previous exports.
                // For example, if you add/remove/change exports, we'll want
                // to re-execute the importing modules, and force those components
                // to re-render. Similarly, if you convert a class component
                // to a function, we want to invalidate the boundary.
                var didInvalidate = shouldInvalidateReactRefreshBoundary(prevExports, nextExports);
                if (isNoLongerABoundary || didInvalidate) {
                    // We'll be conservative. The only case in which we won't do a full
                    // reload is if all parent modules are also refresh boundaries.
                    // In that case we'll add them to the current queue.
                    var parents = getParents();
                    if (parents.length === 0) {
                        // Looks like we bubbled to the root. Can't recover from that.
                        window.location.reload();
                        return;
                    }
                    return parents;
                }
                enqueueUpdate();
            });
        }
    }
};
function isReactRefreshBoundary(exports) {
    if (Refresh.isLikelyComponentType(exports)) return true;
    if (exports == null || typeof exports !== 'object') // Exit if we can't iterate over exports.
    return false;
    var hasExports = false;
    var areAllExportsComponents = true;
    let isESM = '__esModule' in exports;
    for(var key in exports){
        hasExports = true;
        if (key === '__esModule') continue;
        var desc = Object.getOwnPropertyDescriptor(exports, key);
        if (desc && desc.get && !isESM) // Don't invoke getters for CJS as they may have side effects.
        return false;
        var exportValue = exports[key];
        if (!Refresh.isLikelyComponentType(exportValue)) areAllExportsComponents = false;
    }
    return hasExports && areAllExportsComponents;
}
function shouldInvalidateReactRefreshBoundary(prevExports, nextExports) {
    var prevSignature = getRefreshBoundarySignature(prevExports);
    var nextSignature = getRefreshBoundarySignature(nextExports);
    if (prevSignature.length !== nextSignature.length) return true;
    for(var i = 0; i < nextSignature.length; i++){
        if (prevSignature[i] !== nextSignature[i]) return true;
    }
    return false;
} // When this signature changes, it's unsafe to stop at this refresh boundary.
function getRefreshBoundarySignature(exports) {
    var signature = [];
    signature.push(Refresh.getFamilyByType(exports));
    if (exports == null || typeof exports !== 'object') // Exit if we can't iterate over exports.
    // (This is important for legacy environments.)
    return signature;
    let isESM = '__esModule' in exports;
    for(var key in exports){
        if (key === '__esModule') continue;
        var desc = Object.getOwnPropertyDescriptor(exports, key);
        if (desc && desc.get && !isESM) continue;
        var exportValue = exports[key];
        signature.push(key);
        signature.push(Refresh.getFamilyByType(exportValue));
    }
    return signature;
}
function registerExportsForReactRefresh(module) {
    var exports = module.exports, id = module.id;
    Refresh.register(exports, id + ' %exports%');
    if (exports == null || typeof exports !== 'object') // Exit if we can't iterate over exports.
    // (This is important for legacy environments.)
    return;
    let isESM = '__esModule' in exports;
    for(var key in exports){
        var desc = Object.getOwnPropertyDescriptor(exports, key);
        if (desc && desc.get && !isESM) continue;
        var exportValue = exports[key];
        Refresh.register(exportValue, id + ' %exports% ' + key);
    }
}

},{"react-refresh/runtime":"786KC"}],"2kQhy":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$f00f = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$f00f.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jsxDevRuntime = require("react/jsx-dev-runtime");
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _lightningdevkit = require("lightningdevkit");
const App = ()=>{
    _lightningdevkit.initializeWasmFromBinary("node_modules/lightningdevkit/liblightningjs.wasm");
    return(/*#__PURE__*/ _jsxDevRuntime.jsxDEV("div", {
        children: /*#__PURE__*/ _jsxDevRuntime.jsxDEV("h1", {
            children: "Hello World"
        }, void 0, false, {
            fileName: "src/App.js",
            lineNumber: 10,
            columnNumber: 7
        }, undefined)
    }, void 0, false, {
        fileName: "src/App.js",
        lineNumber: 9,
        columnNumber: 5
    }, undefined));
};
_c = App;
exports.default = App;
var _c;
$RefreshReg$(_c, "App");

  $parcel$ReactRefreshHelpers$f00f.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-dev-runtime":"iTorj","react":"21dqq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"km3Ru","lightningdevkit":"gsSuP"}],"gsSuP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Initializes the WASM backend by calling `fetch()` on the given URI - Browser only */ parcelHelpers.export(exports, "initializeWasmWebFetch", ()=>initializeWasmWebFetch
);
/** Initializes the WASM backend given a Uint8Array of the .wasm binary file - Browser or Node.JS */ parcelHelpers.export(exports, "initializeWasmFromBinary", ()=>initializeWasmFromBinary
);
var _bindingsMjs = require("./bindings.mjs");
var _txOutMjs = require("./structs/TxOut.mjs");
parcelHelpers.exportAll(_txOutMjs, exports);
var _accessErrorMjs = require("./enums/AccessError.mjs");
parcelHelpers.exportAll(_accessErrorMjs, exports);
var _coptionNoneZMjs = require("./enums/COption_NoneZ.mjs");
parcelHelpers.exportAll(_coptionNoneZMjs, exports);
var _channelMonitorUpdateErrMjs = require("./enums/ChannelMonitorUpdateErr.mjs");
parcelHelpers.exportAll(_channelMonitorUpdateErrMjs, exports);
var _confirmationTargetMjs = require("./enums/ConfirmationTarget.mjs");
parcelHelpers.exportAll(_confirmationTargetMjs, exports);
var _levelMjs = require("./enums/Level.mjs");
parcelHelpers.exportAll(_levelMjs, exports);
var _networkMjs = require("./enums/Network.mjs");
parcelHelpers.exportAll(_networkMjs, exports);
var _secp256K1ErrorMjs = require("./enums/Secp256k1Error.mjs");
parcelHelpers.exportAll(_secp256K1ErrorMjs, exports);
var _channelConfigMjs = require("./structs/ChannelConfig.mjs");
parcelHelpers.exportAll(_channelConfigMjs, exports);
var _decodeErrorMjs = require("./structs/DecodeError.mjs");
parcelHelpers.exportAll(_decodeErrorMjs, exports);
var _resultChannelConfigDecodeErrorZMjs = require("./structs/Result_ChannelConfigDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultChannelConfigDecodeErrorZMjs, exports);
var _outPointMjs = require("./structs/OutPoint.mjs");
parcelHelpers.exportAll(_outPointMjs, exports);
var _resultOutPointDecodeErrorZMjs = require("./structs/Result_OutPointDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultOutPointDecodeErrorZMjs, exports);
var _resultSecretKeyErrorZMjs = require("./structs/Result_SecretKeyErrorZ.mjs");
parcelHelpers.exportAll(_resultSecretKeyErrorZMjs, exports);
var _resultPublicKeyErrorZMjs = require("./structs/Result_PublicKeyErrorZ.mjs");
parcelHelpers.exportAll(_resultPublicKeyErrorZMjs, exports);
var _txCreationKeysMjs = require("./structs/TxCreationKeys.mjs");
parcelHelpers.exportAll(_txCreationKeysMjs, exports);
var _resultTxCreationKeysDecodeErrorZMjs = require("./structs/Result_TxCreationKeysDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultTxCreationKeysDecodeErrorZMjs, exports);
var _channelPublicKeysMjs = require("./structs/ChannelPublicKeys.mjs");
parcelHelpers.exportAll(_channelPublicKeysMjs, exports);
var _resultChannelPublicKeysDecodeErrorZMjs = require("./structs/Result_ChannelPublicKeysDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultChannelPublicKeysDecodeErrorZMjs, exports);
var _resultTxCreationKeysErrorZMjs = require("./structs/Result_TxCreationKeysErrorZ.mjs");
parcelHelpers.exportAll(_resultTxCreationKeysErrorZMjs, exports);
var _optionU32ZMjs = require("./structs/Option_u32Z.mjs");
parcelHelpers.exportAll(_optionU32ZMjs, exports);
var _htlcoutputInCommitmentMjs = require("./structs/HTLCOutputInCommitment.mjs");
parcelHelpers.exportAll(_htlcoutputInCommitmentMjs, exports);
var _resultHTLCOutputInCommitmentDecodeErrorZMjs = require("./structs/Result_HTLCOutputInCommitmentDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultHTLCOutputInCommitmentDecodeErrorZMjs, exports);
var _counterpartyChannelTransactionParametersMjs = require("./structs/CounterpartyChannelTransactionParameters.mjs");
parcelHelpers.exportAll(_counterpartyChannelTransactionParametersMjs, exports);
var _resultCounterpartyChannelTransactionParametersDecodeErrorZMjs = require("./structs/Result_CounterpartyChannelTransactionParametersDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultCounterpartyChannelTransactionParametersDecodeErrorZMjs, exports);
var _channelTransactionParametersMjs = require("./structs/ChannelTransactionParameters.mjs");
parcelHelpers.exportAll(_channelTransactionParametersMjs, exports);
var _resultChannelTransactionParametersDecodeErrorZMjs = require("./structs/Result_ChannelTransactionParametersDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultChannelTransactionParametersDecodeErrorZMjs, exports);
var _holderCommitmentTransactionMjs = require("./structs/HolderCommitmentTransaction.mjs");
parcelHelpers.exportAll(_holderCommitmentTransactionMjs, exports);
var _resultHolderCommitmentTransactionDecodeErrorZMjs = require("./structs/Result_HolderCommitmentTransactionDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultHolderCommitmentTransactionDecodeErrorZMjs, exports);
var _builtCommitmentTransactionMjs = require("./structs/BuiltCommitmentTransaction.mjs");
parcelHelpers.exportAll(_builtCommitmentTransactionMjs, exports);
var _resultBuiltCommitmentTransactionDecodeErrorZMjs = require("./structs/Result_BuiltCommitmentTransactionDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultBuiltCommitmentTransactionDecodeErrorZMjs, exports);
var _trustedClosingTransactionMjs = require("./structs/TrustedClosingTransaction.mjs");
parcelHelpers.exportAll(_trustedClosingTransactionMjs, exports);
var _resultTrustedClosingTransactionNoneZMjs = require("./structs/Result_TrustedClosingTransactionNoneZ.mjs");
parcelHelpers.exportAll(_resultTrustedClosingTransactionNoneZMjs, exports);
var _commitmentTransactionMjs = require("./structs/CommitmentTransaction.mjs");
parcelHelpers.exportAll(_commitmentTransactionMjs, exports);
var _resultCommitmentTransactionDecodeErrorZMjs = require("./structs/Result_CommitmentTransactionDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultCommitmentTransactionDecodeErrorZMjs, exports);
var _trustedCommitmentTransactionMjs = require("./structs/TrustedCommitmentTransaction.mjs");
parcelHelpers.exportAll(_trustedCommitmentTransactionMjs, exports);
var _resultTrustedCommitmentTransactionNoneZMjs = require("./structs/Result_TrustedCommitmentTransactionNoneZ.mjs");
parcelHelpers.exportAll(_resultTrustedCommitmentTransactionNoneZMjs, exports);
var _resultCVecSignatureZNoneZMjs = require("./structs/Result_CVec_SignatureZNoneZ.mjs");
parcelHelpers.exportAll(_resultCVecSignatureZNoneZMjs, exports);
var _shutdownScriptMjs = require("./structs/ShutdownScript.mjs");
parcelHelpers.exportAll(_shutdownScriptMjs, exports);
var _resultShutdownScriptDecodeErrorZMjs = require("./structs/Result_ShutdownScriptDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultShutdownScriptDecodeErrorZMjs, exports);
var _invalidShutdownScriptMjs = require("./structs/InvalidShutdownScript.mjs");
parcelHelpers.exportAll(_invalidShutdownScriptMjs, exports);
var _resultShutdownScriptInvalidShutdownScriptZMjs = require("./structs/Result_ShutdownScriptInvalidShutdownScriptZ.mjs");
parcelHelpers.exportAll(_resultShutdownScriptInvalidShutdownScriptZMjs, exports);
var _typeMjs = require("./structs/Type.mjs");
parcelHelpers.exportAll(_typeMjs, exports);
var _optionTypeZMjs = require("./structs/Option_TypeZ.mjs");
parcelHelpers.exportAll(_optionTypeZMjs, exports);
var _resultCOptionTypeZDecodeErrorZMjs = require("./structs/Result_COption_TypeZDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultCOptionTypeZDecodeErrorZMjs, exports);
var _resultStringErrorZMjs = require("./structs/Result_StringErrorZ.mjs");
parcelHelpers.exportAll(_resultStringErrorZMjs, exports);
var _channelMonitorUpdateMjs = require("./structs/ChannelMonitorUpdate.mjs");
parcelHelpers.exportAll(_channelMonitorUpdateMjs, exports);
var _resultChannelMonitorUpdateDecodeErrorZMjs = require("./structs/Result_ChannelMonitorUpdateDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultChannelMonitorUpdateDecodeErrorZMjs, exports);
var _htlcupdateMjs = require("./structs/HTLCUpdate.mjs");
parcelHelpers.exportAll(_htlcupdateMjs, exports);
var _monitorEventMjs = require("./structs/MonitorEvent.mjs");
parcelHelpers.exportAll(_monitorEventMjs, exports);
var _optionMonitorEventZMjs = require("./structs/Option_MonitorEventZ.mjs");
parcelHelpers.exportAll(_optionMonitorEventZMjs, exports);
var _resultCOptionMonitorEventZDecodeErrorZMjs = require("./structs/Result_COption_MonitorEventZDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultCOptionMonitorEventZDecodeErrorZMjs, exports);
var _resultHTLCUpdateDecodeErrorZMjs = require("./structs/Result_HTLCUpdateDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultHTLCUpdateDecodeErrorZMjs, exports);
var _resultNoneNoneZMjs = require("./structs/Result_NoneNoneZ.mjs");
parcelHelpers.exportAll(_resultNoneNoneZMjs, exports);
var _twoTupleOutPointScriptZMjs = require("./structs/TwoTuple_OutPointScriptZ.mjs");
parcelHelpers.exportAll(_twoTupleOutPointScriptZMjs, exports);
var _twoTupleU32ScriptZMjs = require("./structs/TwoTuple_u32ScriptZ.mjs");
parcelHelpers.exportAll(_twoTupleU32ScriptZMjs, exports);
var _twoTupleTxidCVecC2TupleU32ScriptZZZMjs = require("./structs/TwoTuple_TxidCVec_C2Tuple_u32ScriptZZZ.mjs");
parcelHelpers.exportAll(_twoTupleTxidCVecC2TupleU32ScriptZZZMjs, exports);
var _paymentPurposeMjs = require("./structs/PaymentPurpose.mjs");
parcelHelpers.exportAll(_paymentPurposeMjs, exports);
var _optionU64ZMjs = require("./structs/Option_u64Z.mjs");
parcelHelpers.exportAll(_optionU64ZMjs, exports);
var _channelUpdateMjs = require("./structs/ChannelUpdate.mjs");
parcelHelpers.exportAll(_channelUpdateMjs, exports);
var _networkUpdateMjs = require("./structs/NetworkUpdate.mjs");
parcelHelpers.exportAll(_networkUpdateMjs, exports);
var _optionNetworkUpdateZMjs = require("./structs/Option_NetworkUpdateZ.mjs");
parcelHelpers.exportAll(_optionNetworkUpdateZMjs, exports);
var _routeHopMjs = require("./structs/RouteHop.mjs");
parcelHelpers.exportAll(_routeHopMjs, exports);
var _routeParametersMjs = require("./structs/RouteParameters.mjs");
parcelHelpers.exportAll(_routeParametersMjs, exports);
var _delayedPaymentOutputDescriptorMjs = require("./structs/DelayedPaymentOutputDescriptor.mjs");
parcelHelpers.exportAll(_delayedPaymentOutputDescriptorMjs, exports);
var _staticPaymentOutputDescriptorMjs = require("./structs/StaticPaymentOutputDescriptor.mjs");
parcelHelpers.exportAll(_staticPaymentOutputDescriptorMjs, exports);
var _spendableOutputDescriptorMjs = require("./structs/SpendableOutputDescriptor.mjs");
parcelHelpers.exportAll(_spendableOutputDescriptorMjs, exports);
var _closureReasonMjs = require("./structs/ClosureReason.mjs");
parcelHelpers.exportAll(_closureReasonMjs, exports);
var _eventMjs = require("./structs/Event.mjs");
parcelHelpers.exportAll(_eventMjs, exports);
var _twoTupleUsizeTransactionZMjs = require("./structs/TwoTuple_usizeTransactionZ.mjs");
parcelHelpers.exportAll(_twoTupleUsizeTransactionZMjs, exports);
var _twoTupleU32TxOutZMjs = require("./structs/TwoTuple_u32TxOutZ.mjs");
parcelHelpers.exportAll(_twoTupleU32TxOutZMjs, exports);
var _twoTupleTxidCVecC2TupleU32TxOutZZZMjs = require("./structs/TwoTuple_TxidCVec_C2Tuple_u32TxOutZZZ.mjs");
parcelHelpers.exportAll(_twoTupleTxidCVecC2TupleU32TxOutZZZMjs, exports);
var _balanceMjs = require("./structs/Balance.mjs");
parcelHelpers.exportAll(_balanceMjs, exports);
var _twoTupleSignatureCVecSignatureZZMjs = require("./structs/TwoTuple_SignatureCVec_SignatureZZ.mjs");
parcelHelpers.exportAll(_twoTupleSignatureCVecSignatureZZMjs, exports);
var _resultC2TupleSignatureCVecSignatureZZNoneZMjs = require("./structs/Result_C2Tuple_SignatureCVec_SignatureZZNoneZ.mjs");
parcelHelpers.exportAll(_resultC2TupleSignatureCVecSignatureZZNoneZMjs, exports);
var _resultSignatureNoneZMjs = require("./structs/Result_SignatureNoneZ.mjs");
parcelHelpers.exportAll(_resultSignatureNoneZMjs, exports);
var _closingTransactionMjs = require("./structs/ClosingTransaction.mjs");
parcelHelpers.exportAll(_closingTransactionMjs, exports);
var _unsignedChannelAnnouncementMjs = require("./structs/UnsignedChannelAnnouncement.mjs");
parcelHelpers.exportAll(_unsignedChannelAnnouncementMjs, exports);
var _baseSignMjs = require("./structs/BaseSign.mjs");
parcelHelpers.exportAll(_baseSignMjs, exports);
var _signMjs = require("./structs/Sign.mjs");
parcelHelpers.exportAll(_signMjs, exports);
var _channelMonitorMjs = require("./structs/ChannelMonitor.mjs");
parcelHelpers.exportAll(_channelMonitorMjs, exports);
var _twoTupleBlockHashChannelMonitorZMjs = require("./structs/TwoTuple_BlockHashChannelMonitorZ.mjs");
parcelHelpers.exportAll(_twoTupleBlockHashChannelMonitorZMjs, exports);
var _resultC2TupleBlockHashChannelMonitorZDecodeErrorZMjs = require("./structs/Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultC2TupleBlockHashChannelMonitorZDecodeErrorZMjs, exports);
var _resultRouteHopDecodeErrorZMjs = require("./structs/Result_RouteHopDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultRouteHopDecodeErrorZMjs, exports);
var _routeMjs = require("./structs/Route.mjs");
parcelHelpers.exportAll(_routeMjs, exports);
var _resultRouteDecodeErrorZMjs = require("./structs/Result_RouteDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultRouteDecodeErrorZMjs, exports);
var _resultRouteParametersDecodeErrorZMjs = require("./structs/Result_RouteParametersDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultRouteParametersDecodeErrorZMjs, exports);
var _routeHintMjs = require("./structs/RouteHint.mjs");
parcelHelpers.exportAll(_routeHintMjs, exports);
var _payeeMjs = require("./structs/Payee.mjs");
parcelHelpers.exportAll(_payeeMjs, exports);
var _resultPayeeDecodeErrorZMjs = require("./structs/Result_PayeeDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultPayeeDecodeErrorZMjs, exports);
var _routeHintHopMjs = require("./structs/RouteHintHop.mjs");
parcelHelpers.exportAll(_routeHintHopMjs, exports);
var _resultRouteHintDecodeErrorZMjs = require("./structs/Result_RouteHintDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultRouteHintDecodeErrorZMjs, exports);
var _resultRouteHintHopDecodeErrorZMjs = require("./structs/Result_RouteHintHopDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultRouteHintHopDecodeErrorZMjs, exports);
var _channelDetailsMjs = require("./structs/ChannelDetails.mjs");
parcelHelpers.exportAll(_channelDetailsMjs, exports);
var _lightningErrorMjs = require("./structs/LightningError.mjs");
parcelHelpers.exportAll(_lightningErrorMjs, exports);
var _resultRouteLightningErrorZMjs = require("./structs/Result_RouteLightningErrorZ.mjs");
parcelHelpers.exportAll(_resultRouteLightningErrorZMjs, exports);
var _resultNoneLightningErrorZMjs = require("./structs/Result_NoneLightningErrorZ.mjs");
parcelHelpers.exportAll(_resultNoneLightningErrorZMjs, exports);
var _twoTuplePublicKeyTypeZMjs = require("./structs/TwoTuple_PublicKeyTypeZ.mjs");
parcelHelpers.exportAll(_twoTuplePublicKeyTypeZMjs, exports);
var _acceptChannelMjs = require("./structs/AcceptChannel.mjs");
parcelHelpers.exportAll(_acceptChannelMjs, exports);
var _openChannelMjs = require("./structs/OpenChannel.mjs");
parcelHelpers.exportAll(_openChannelMjs, exports);
var _fundingCreatedMjs = require("./structs/FundingCreated.mjs");
parcelHelpers.exportAll(_fundingCreatedMjs, exports);
var _fundingSignedMjs = require("./structs/FundingSigned.mjs");
parcelHelpers.exportAll(_fundingSignedMjs, exports);
var _fundingLockedMjs = require("./structs/FundingLocked.mjs");
parcelHelpers.exportAll(_fundingLockedMjs, exports);
var _announcementSignaturesMjs = require("./structs/AnnouncementSignatures.mjs");
parcelHelpers.exportAll(_announcementSignaturesMjs, exports);
var _commitmentUpdateMjs = require("./structs/CommitmentUpdate.mjs");
parcelHelpers.exportAll(_commitmentUpdateMjs, exports);
var _revokeAndACKMjs = require("./structs/RevokeAndACK.mjs");
parcelHelpers.exportAll(_revokeAndACKMjs, exports);
var _closingSignedMjs = require("./structs/ClosingSigned.mjs");
parcelHelpers.exportAll(_closingSignedMjs, exports);
var _shutdownMjs = require("./structs/Shutdown.mjs");
parcelHelpers.exportAll(_shutdownMjs, exports);
var _channelReestablishMjs = require("./structs/ChannelReestablish.mjs");
parcelHelpers.exportAll(_channelReestablishMjs, exports);
var _channelAnnouncementMjs = require("./structs/ChannelAnnouncement.mjs");
parcelHelpers.exportAll(_channelAnnouncementMjs, exports);
var _nodeAnnouncementMjs = require("./structs/NodeAnnouncement.mjs");
parcelHelpers.exportAll(_nodeAnnouncementMjs, exports);
var _errorMessageMjs = require("./structs/ErrorMessage.mjs");
parcelHelpers.exportAll(_errorMessageMjs, exports);
var _errorActionMjs = require("./structs/ErrorAction.mjs");
parcelHelpers.exportAll(_errorActionMjs, exports);
var _queryChannelRangeMjs = require("./structs/QueryChannelRange.mjs");
parcelHelpers.exportAll(_queryChannelRangeMjs, exports);
var _queryShortChannelIdsMjs = require("./structs/QueryShortChannelIds.mjs");
parcelHelpers.exportAll(_queryShortChannelIdsMjs, exports);
var _replyChannelRangeMjs = require("./structs/ReplyChannelRange.mjs");
parcelHelpers.exportAll(_replyChannelRangeMjs, exports);
var _messageSendEventMjs = require("./structs/MessageSendEvent.mjs");
parcelHelpers.exportAll(_messageSendEventMjs, exports);
var _resultBoolLightningErrorZMjs = require("./structs/Result_boolLightningErrorZ.mjs");
parcelHelpers.exportAll(_resultBoolLightningErrorZMjs, exports);
var _threeTupleChannelAnnouncementChannelUpdateChannelUpdateZMjs = require("./structs/ThreeTuple_ChannelAnnouncementChannelUpdateChannelUpdateZ.mjs");
parcelHelpers.exportAll(_threeTupleChannelAnnouncementChannelUpdateChannelUpdateZMjs, exports);
var _peerHandleErrorMjs = require("./structs/PeerHandleError.mjs");
parcelHelpers.exportAll(_peerHandleErrorMjs, exports);
var _resultCVecU8ZPeerHandleErrorZMjs = require("./structs/Result_CVec_u8ZPeerHandleErrorZ.mjs");
parcelHelpers.exportAll(_resultCVecU8ZPeerHandleErrorZMjs, exports);
var _resultNonePeerHandleErrorZMjs = require("./structs/Result_NonePeerHandleErrorZ.mjs");
parcelHelpers.exportAll(_resultNonePeerHandleErrorZMjs, exports);
var _resultBoolPeerHandleErrorZMjs = require("./structs/Result_boolPeerHandleErrorZ.mjs");
parcelHelpers.exportAll(_resultBoolPeerHandleErrorZMjs, exports);
var _resultTxOutAccessErrorZMjs = require("./structs/Result_TxOutAccessErrorZ.mjs");
parcelHelpers.exportAll(_resultTxOutAccessErrorZMjs, exports);
var _resultNoneChannelMonitorUpdateErrZMjs = require("./structs/Result_NoneChannelMonitorUpdateErrZ.mjs");
parcelHelpers.exportAll(_resultNoneChannelMonitorUpdateErrZMjs, exports);
var _optionC2TupleUsizeTransactionZZMjs = require("./structs/Option_C2Tuple_usizeTransactionZZ.mjs");
parcelHelpers.exportAll(_optionC2TupleUsizeTransactionZZMjs, exports);
var _optionClosureReasonZMjs = require("./structs/Option_ClosureReasonZ.mjs");
parcelHelpers.exportAll(_optionClosureReasonZMjs, exports);
var _resultCOptionClosureReasonZDecodeErrorZMjs = require("./structs/Result_COption_ClosureReasonZDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultCOptionClosureReasonZDecodeErrorZMjs, exports);
var _optionEventZMjs = require("./structs/Option_EventZ.mjs");
parcelHelpers.exportAll(_optionEventZMjs, exports);
var _resultCOptionEventZDecodeErrorZMjs = require("./structs/Result_COption_EventZDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultCOptionEventZDecodeErrorZMjs, exports);
var _nodeIdMjs = require("./structs/NodeId.mjs");
parcelHelpers.exportAll(_nodeIdMjs, exports);
var _resultNodeIdDecodeErrorZMjs = require("./structs/Result_NodeIdDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultNodeIdDecodeErrorZMjs, exports);
var _resultCOptionNetworkUpdateZDecodeErrorZMjs = require("./structs/Result_COption_NetworkUpdateZDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultCOptionNetworkUpdateZDecodeErrorZMjs, exports);
var _accessMjs = require("./structs/Access.mjs");
parcelHelpers.exportAll(_accessMjs, exports);
var _optionAccessZMjs = require("./structs/Option_AccessZ.mjs");
parcelHelpers.exportAll(_optionAccessZMjs, exports);
var _directionalChannelInfoMjs = require("./structs/DirectionalChannelInfo.mjs");
parcelHelpers.exportAll(_directionalChannelInfoMjs, exports);
var _resultDirectionalChannelInfoDecodeErrorZMjs = require("./structs/Result_DirectionalChannelInfoDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultDirectionalChannelInfoDecodeErrorZMjs, exports);
var _channelInfoMjs = require("./structs/ChannelInfo.mjs");
parcelHelpers.exportAll(_channelInfoMjs, exports);
var _resultChannelInfoDecodeErrorZMjs = require("./structs/Result_ChannelInfoDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultChannelInfoDecodeErrorZMjs, exports);
var _routingFeesMjs = require("./structs/RoutingFees.mjs");
parcelHelpers.exportAll(_routingFeesMjs, exports);
var _resultRoutingFeesDecodeErrorZMjs = require("./structs/Result_RoutingFeesDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultRoutingFeesDecodeErrorZMjs, exports);
var _netAddressMjs = require("./structs/NetAddress.mjs");
parcelHelpers.exportAll(_netAddressMjs, exports);
var _nodeAnnouncementInfoMjs = require("./structs/NodeAnnouncementInfo.mjs");
parcelHelpers.exportAll(_nodeAnnouncementInfoMjs, exports);
var _resultNodeAnnouncementInfoDecodeErrorZMjs = require("./structs/Result_NodeAnnouncementInfoDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultNodeAnnouncementInfoDecodeErrorZMjs, exports);
var _nodeInfoMjs = require("./structs/NodeInfo.mjs");
parcelHelpers.exportAll(_nodeInfoMjs, exports);
var _resultNodeInfoDecodeErrorZMjs = require("./structs/Result_NodeInfoDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultNodeInfoDecodeErrorZMjs, exports);
var _networkGraphMjs = require("./structs/NetworkGraph.mjs");
parcelHelpers.exportAll(_networkGraphMjs, exports);
var _resultNetworkGraphDecodeErrorZMjs = require("./structs/Result_NetworkGraphDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultNetworkGraphDecodeErrorZMjs, exports);
var _optionCVecNetAddressZZMjs = require("./structs/Option_CVec_NetAddressZZ.mjs");
parcelHelpers.exportAll(_optionCVecNetAddressZZMjs, exports);
var _scoringParametersMjs = require("./structs/ScoringParameters.mjs");
parcelHelpers.exportAll(_scoringParametersMjs, exports);
var _resultScoringParametersDecodeErrorZMjs = require("./structs/Result_ScoringParametersDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultScoringParametersDecodeErrorZMjs, exports);
var _initFeaturesMjs = require("./structs/InitFeatures.mjs");
parcelHelpers.exportAll(_initFeaturesMjs, exports);
var _resultInitFeaturesDecodeErrorZMjs = require("./structs/Result_InitFeaturesDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultInitFeaturesDecodeErrorZMjs, exports);
var _channelFeaturesMjs = require("./structs/ChannelFeatures.mjs");
parcelHelpers.exportAll(_channelFeaturesMjs, exports);
var _resultChannelFeaturesDecodeErrorZMjs = require("./structs/Result_ChannelFeaturesDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultChannelFeaturesDecodeErrorZMjs, exports);
var _nodeFeaturesMjs = require("./structs/NodeFeatures.mjs");
parcelHelpers.exportAll(_nodeFeaturesMjs, exports);
var _resultNodeFeaturesDecodeErrorZMjs = require("./structs/Result_NodeFeaturesDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultNodeFeaturesDecodeErrorZMjs, exports);
var _invoiceFeaturesMjs = require("./structs/InvoiceFeatures.mjs");
parcelHelpers.exportAll(_invoiceFeaturesMjs, exports);
var _resultInvoiceFeaturesDecodeErrorZMjs = require("./structs/Result_InvoiceFeaturesDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultInvoiceFeaturesDecodeErrorZMjs, exports);
var _channelTypeFeaturesMjs = require("./structs/ChannelTypeFeatures.mjs");
parcelHelpers.exportAll(_channelTypeFeaturesMjs, exports);
var _resultChannelTypeFeaturesDecodeErrorZMjs = require("./structs/Result_ChannelTypeFeaturesDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultChannelTypeFeaturesDecodeErrorZMjs, exports);
var _resultNetAddressDecodeErrorZMjs = require("./structs/Result_NetAddressDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultNetAddressDecodeErrorZMjs, exports);
var _updateAddHTLCMjs = require("./structs/UpdateAddHTLC.mjs");
parcelHelpers.exportAll(_updateAddHTLCMjs, exports);
var _updateFulfillHTLCMjs = require("./structs/UpdateFulfillHTLC.mjs");
parcelHelpers.exportAll(_updateFulfillHTLCMjs, exports);
var _updateFailHTLCMjs = require("./structs/UpdateFailHTLC.mjs");
parcelHelpers.exportAll(_updateFailHTLCMjs, exports);
var _updateFailMalformedHTLCMjs = require("./structs/UpdateFailMalformedHTLC.mjs");
parcelHelpers.exportAll(_updateFailMalformedHTLCMjs, exports);
var _resultAcceptChannelDecodeErrorZMjs = require("./structs/Result_AcceptChannelDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultAcceptChannelDecodeErrorZMjs, exports);
var _resultAnnouncementSignaturesDecodeErrorZMjs = require("./structs/Result_AnnouncementSignaturesDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultAnnouncementSignaturesDecodeErrorZMjs, exports);
var _resultChannelReestablishDecodeErrorZMjs = require("./structs/Result_ChannelReestablishDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultChannelReestablishDecodeErrorZMjs, exports);
var _resultClosingSignedDecodeErrorZMjs = require("./structs/Result_ClosingSignedDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultClosingSignedDecodeErrorZMjs, exports);
var _closingSignedFeeRangeMjs = require("./structs/ClosingSignedFeeRange.mjs");
parcelHelpers.exportAll(_closingSignedFeeRangeMjs, exports);
var _resultClosingSignedFeeRangeDecodeErrorZMjs = require("./structs/Result_ClosingSignedFeeRangeDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultClosingSignedFeeRangeDecodeErrorZMjs, exports);
var _commitmentSignedMjs = require("./structs/CommitmentSigned.mjs");
parcelHelpers.exportAll(_commitmentSignedMjs, exports);
var _resultCommitmentSignedDecodeErrorZMjs = require("./structs/Result_CommitmentSignedDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultCommitmentSignedDecodeErrorZMjs, exports);
var _resultFundingCreatedDecodeErrorZMjs = require("./structs/Result_FundingCreatedDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultFundingCreatedDecodeErrorZMjs, exports);
var _resultFundingSignedDecodeErrorZMjs = require("./structs/Result_FundingSignedDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultFundingSignedDecodeErrorZMjs, exports);
var _resultFundingLockedDecodeErrorZMjs = require("./structs/Result_FundingLockedDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultFundingLockedDecodeErrorZMjs, exports);
var _initMjs = require("./structs/Init.mjs");
parcelHelpers.exportAll(_initMjs, exports);
var _resultInitDecodeErrorZMjs = require("./structs/Result_InitDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultInitDecodeErrorZMjs, exports);
var _resultOpenChannelDecodeErrorZMjs = require("./structs/Result_OpenChannelDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultOpenChannelDecodeErrorZMjs, exports);
var _resultRevokeAndACKDecodeErrorZMjs = require("./structs/Result_RevokeAndACKDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultRevokeAndACKDecodeErrorZMjs, exports);
var _resultShutdownDecodeErrorZMjs = require("./structs/Result_ShutdownDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultShutdownDecodeErrorZMjs, exports);
var _resultUpdateFailHTLCDecodeErrorZMjs = require("./structs/Result_UpdateFailHTLCDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultUpdateFailHTLCDecodeErrorZMjs, exports);
var _resultUpdateFailMalformedHTLCDecodeErrorZMjs = require("./structs/Result_UpdateFailMalformedHTLCDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultUpdateFailMalformedHTLCDecodeErrorZMjs, exports);
var _updateFeeMjs = require("./structs/UpdateFee.mjs");
parcelHelpers.exportAll(_updateFeeMjs, exports);
var _resultUpdateFeeDecodeErrorZMjs = require("./structs/Result_UpdateFeeDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultUpdateFeeDecodeErrorZMjs, exports);
var _resultUpdateFulfillHTLCDecodeErrorZMjs = require("./structs/Result_UpdateFulfillHTLCDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultUpdateFulfillHTLCDecodeErrorZMjs, exports);
var _resultUpdateAddHTLCDecodeErrorZMjs = require("./structs/Result_UpdateAddHTLCDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultUpdateAddHTLCDecodeErrorZMjs, exports);
var _pingMjs = require("./structs/Ping.mjs");
parcelHelpers.exportAll(_pingMjs, exports);
var _resultPingDecodeErrorZMjs = require("./structs/Result_PingDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultPingDecodeErrorZMjs, exports);
var _pongMjs = require("./structs/Pong.mjs");
parcelHelpers.exportAll(_pongMjs, exports);
var _resultPongDecodeErrorZMjs = require("./structs/Result_PongDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultPongDecodeErrorZMjs, exports);
var _resultUnsignedChannelAnnouncementDecodeErrorZMjs = require("./structs/Result_UnsignedChannelAnnouncementDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultUnsignedChannelAnnouncementDecodeErrorZMjs, exports);
var _resultChannelAnnouncementDecodeErrorZMjs = require("./structs/Result_ChannelAnnouncementDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultChannelAnnouncementDecodeErrorZMjs, exports);
var _unsignedChannelUpdateMjs = require("./structs/UnsignedChannelUpdate.mjs");
parcelHelpers.exportAll(_unsignedChannelUpdateMjs, exports);
var _resultUnsignedChannelUpdateDecodeErrorZMjs = require("./structs/Result_UnsignedChannelUpdateDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultUnsignedChannelUpdateDecodeErrorZMjs, exports);
var _resultChannelUpdateDecodeErrorZMjs = require("./structs/Result_ChannelUpdateDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultChannelUpdateDecodeErrorZMjs, exports);
var _resultErrorMessageDecodeErrorZMjs = require("./structs/Result_ErrorMessageDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultErrorMessageDecodeErrorZMjs, exports);
var _unsignedNodeAnnouncementMjs = require("./structs/UnsignedNodeAnnouncement.mjs");
parcelHelpers.exportAll(_unsignedNodeAnnouncementMjs, exports);
var _resultUnsignedNodeAnnouncementDecodeErrorZMjs = require("./structs/Result_UnsignedNodeAnnouncementDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultUnsignedNodeAnnouncementDecodeErrorZMjs, exports);
var _resultNodeAnnouncementDecodeErrorZMjs = require("./structs/Result_NodeAnnouncementDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultNodeAnnouncementDecodeErrorZMjs, exports);
var _resultQueryShortChannelIdsDecodeErrorZMjs = require("./structs/Result_QueryShortChannelIdsDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultQueryShortChannelIdsDecodeErrorZMjs, exports);
var _replyShortChannelIdsEndMjs = require("./structs/ReplyShortChannelIdsEnd.mjs");
parcelHelpers.exportAll(_replyShortChannelIdsEndMjs, exports);
var _resultReplyShortChannelIdsEndDecodeErrorZMjs = require("./structs/Result_ReplyShortChannelIdsEndDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultReplyShortChannelIdsEndDecodeErrorZMjs, exports);
var _resultQueryChannelRangeDecodeErrorZMjs = require("./structs/Result_QueryChannelRangeDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultQueryChannelRangeDecodeErrorZMjs, exports);
var _resultReplyChannelRangeDecodeErrorZMjs = require("./structs/Result_ReplyChannelRangeDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultReplyChannelRangeDecodeErrorZMjs, exports);
var _gossipTimestampFilterMjs = require("./structs/GossipTimestampFilter.mjs");
parcelHelpers.exportAll(_gossipTimestampFilterMjs, exports);
var _resultGossipTimestampFilterDecodeErrorZMjs = require("./structs/Result_GossipTimestampFilterDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultGossipTimestampFilterDecodeErrorZMjs, exports);
var _resultDelayedPaymentOutputDescriptorDecodeErrorZMjs = require("./structs/Result_DelayedPaymentOutputDescriptorDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultDelayedPaymentOutputDescriptorDecodeErrorZMjs, exports);
var _resultStaticPaymentOutputDescriptorDecodeErrorZMjs = require("./structs/Result_StaticPaymentOutputDescriptorDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultStaticPaymentOutputDescriptorDecodeErrorZMjs, exports);
var _resultSpendableOutputDescriptorDecodeErrorZMjs = require("./structs/Result_SpendableOutputDescriptorDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultSpendableOutputDescriptorDecodeErrorZMjs, exports);
var _resultSignDecodeErrorZMjs = require("./structs/Result_SignDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultSignDecodeErrorZMjs, exports);
var _resultRecoverableSignatureNoneZMjs = require("./structs/Result_RecoverableSignatureNoneZ.mjs");
parcelHelpers.exportAll(_resultRecoverableSignatureNoneZMjs, exports);
var _resultCVecCVecU8ZZNoneZMjs = require("./structs/Result_CVec_CVec_u8ZZNoneZ.mjs");
parcelHelpers.exportAll(_resultCVecCVecU8ZZNoneZMjs, exports);
var _inMemorySignerMjs = require("./structs/InMemorySigner.mjs");
parcelHelpers.exportAll(_inMemorySignerMjs, exports);
var _resultInMemorySignerDecodeErrorZMjs = require("./structs/Result_InMemorySignerDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultInMemorySignerDecodeErrorZMjs, exports);
var _resultTransactionNoneZMjs = require("./structs/Result_TransactionNoneZ.mjs");
parcelHelpers.exportAll(_resultTransactionNoneZMjs, exports);
var _watchedOutputMjs = require("./structs/WatchedOutput.mjs");
parcelHelpers.exportAll(_watchedOutputMjs, exports);
var _filterMjs = require("./structs/Filter.mjs");
parcelHelpers.exportAll(_filterMjs, exports);
var _optionFilterZMjs = require("./structs/Option_FilterZ.mjs");
parcelHelpers.exportAll(_optionFilterZMjs, exports);
var _lockedChannelMonitorMjs = require("./structs/LockedChannelMonitor.mjs");
parcelHelpers.exportAll(_lockedChannelMonitorMjs, exports);
var _resultLockedChannelMonitorNoneZMjs = require("./structs/Result_LockedChannelMonitorNoneZ.mjs");
parcelHelpers.exportAll(_resultLockedChannelMonitorNoneZMjs, exports);
var _apierrorMjs = require("./structs/APIError.mjs");
parcelHelpers.exportAll(_apierrorMjs, exports);
var _resultNoneAPIErrorZMjs = require("./structs/Result_NoneAPIErrorZ.mjs");
parcelHelpers.exportAll(_resultNoneAPIErrorZMjs, exports);
var _optionU16ZMjs = require("./structs/Option_u16Z.mjs");
parcelHelpers.exportAll(_optionU16ZMjs, exports);
var _resultU832APIErrorZMjs = require("./structs/Result__u832APIErrorZ.mjs");
parcelHelpers.exportAll(_resultU832APIErrorZMjs, exports);
var _paymentSendFailureMjs = require("./structs/PaymentSendFailure.mjs");
parcelHelpers.exportAll(_paymentSendFailureMjs, exports);
var _resultPaymentIdPaymentSendFailureZMjs = require("./structs/Result_PaymentIdPaymentSendFailureZ.mjs");
parcelHelpers.exportAll(_resultPaymentIdPaymentSendFailureZMjs, exports);
var _resultNonePaymentSendFailureZMjs = require("./structs/Result_NonePaymentSendFailureZ.mjs");
parcelHelpers.exportAll(_resultNonePaymentSendFailureZMjs, exports);
var _twoTuplePaymentHashPaymentIdZMjs = require("./structs/TwoTuple_PaymentHashPaymentIdZ.mjs");
parcelHelpers.exportAll(_twoTuplePaymentHashPaymentIdZMjs, exports);
var _resultC2TuplePaymentHashPaymentIdZPaymentSendFailureZMjs = require("./structs/Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ.mjs");
parcelHelpers.exportAll(_resultC2TuplePaymentHashPaymentIdZPaymentSendFailureZMjs, exports);
var _twoTuplePaymentHashPaymentSecretZMjs = require("./structs/TwoTuple_PaymentHashPaymentSecretZ.mjs");
parcelHelpers.exportAll(_twoTuplePaymentHashPaymentSecretZMjs, exports);
var _resultC2TuplePaymentHashPaymentSecretZNoneZMjs = require("./structs/Result_C2Tuple_PaymentHashPaymentSecretZNoneZ.mjs");
parcelHelpers.exportAll(_resultC2TuplePaymentHashPaymentSecretZNoneZMjs, exports);
var _resultC2TuplePaymentHashPaymentSecretZAPIErrorZMjs = require("./structs/Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ.mjs");
parcelHelpers.exportAll(_resultC2TuplePaymentHashPaymentSecretZAPIErrorZMjs, exports);
var _resultPaymentSecretNoneZMjs = require("./structs/Result_PaymentSecretNoneZ.mjs");
parcelHelpers.exportAll(_resultPaymentSecretNoneZMjs, exports);
var _resultPaymentSecretAPIErrorZMjs = require("./structs/Result_PaymentSecretAPIErrorZ.mjs");
parcelHelpers.exportAll(_resultPaymentSecretAPIErrorZMjs, exports);
var _resultPaymentPreimageAPIErrorZMjs = require("./structs/Result_PaymentPreimageAPIErrorZ.mjs");
parcelHelpers.exportAll(_resultPaymentPreimageAPIErrorZMjs, exports);
var _watchMjs = require("./structs/Watch.mjs");
parcelHelpers.exportAll(_watchMjs, exports);
var _broadcasterInterfaceMjs = require("./structs/BroadcasterInterface.mjs");
parcelHelpers.exportAll(_broadcasterInterfaceMjs, exports);
var _keysInterfaceMjs = require("./structs/KeysInterface.mjs");
parcelHelpers.exportAll(_keysInterfaceMjs, exports);
var _feeEstimatorMjs = require("./structs/FeeEstimator.mjs");
parcelHelpers.exportAll(_feeEstimatorMjs, exports);
var _recordMjs = require("./structs/Record.mjs");
parcelHelpers.exportAll(_recordMjs, exports);
var _loggerMjs = require("./structs/Logger.mjs");
parcelHelpers.exportAll(_loggerMjs, exports);
var _channelManagerMjs = require("./structs/ChannelManager.mjs");
parcelHelpers.exportAll(_channelManagerMjs, exports);
var _twoTupleBlockHashChannelManagerZMjs = require("./structs/TwoTuple_BlockHashChannelManagerZ.mjs");
parcelHelpers.exportAll(_twoTupleBlockHashChannelManagerZMjs, exports);
var _resultC2TupleBlockHashChannelManagerZDecodeErrorZMjs = require("./structs/Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ.mjs");
parcelHelpers.exportAll(_resultC2TupleBlockHashChannelManagerZDecodeErrorZMjs, exports);
var _messageSendEventsProviderMjs = require("./structs/MessageSendEventsProvider.mjs");
parcelHelpers.exportAll(_messageSendEventsProviderMjs, exports);
var _eventHandlerMjs = require("./structs/EventHandler.mjs");
parcelHelpers.exportAll(_eventHandlerMjs, exports);
var _eventsProviderMjs = require("./structs/EventsProvider.mjs");
parcelHelpers.exportAll(_eventsProviderMjs, exports);
var _channelHandshakeConfigMjs = require("./structs/ChannelHandshakeConfig.mjs");
parcelHelpers.exportAll(_channelHandshakeConfigMjs, exports);
var _channelHandshakeLimitsMjs = require("./structs/ChannelHandshakeLimits.mjs");
parcelHelpers.exportAll(_channelHandshakeLimitsMjs, exports);
var _userConfigMjs = require("./structs/UserConfig.mjs");
parcelHelpers.exportAll(_userConfigMjs, exports);
var _bestBlockMjs = require("./structs/BestBlock.mjs");
parcelHelpers.exportAll(_bestBlockMjs, exports);
var _listenMjs = require("./structs/Listen.mjs");
parcelHelpers.exportAll(_listenMjs, exports);
var _confirmMjs = require("./structs/Confirm.mjs");
parcelHelpers.exportAll(_confirmMjs, exports);
var _monitorUpdateIdMjs = require("./structs/MonitorUpdateId.mjs");
parcelHelpers.exportAll(_monitorUpdateIdMjs, exports);
var _persistMjs = require("./structs/Persist.mjs");
parcelHelpers.exportAll(_persistMjs, exports);
var _chainMonitorMjs = require("./structs/ChainMonitor.mjs");
parcelHelpers.exportAll(_chainMonitorMjs, exports);
var _keysManagerMjs = require("./structs/KeysManager.mjs");
parcelHelpers.exportAll(_keysManagerMjs, exports);
var _chainParametersMjs = require("./structs/ChainParameters.mjs");
parcelHelpers.exportAll(_chainParametersMjs, exports);
var _counterpartyForwardingInfoMjs = require("./structs/CounterpartyForwardingInfo.mjs");
parcelHelpers.exportAll(_counterpartyForwardingInfoMjs, exports);
var _channelCounterpartyMjs = require("./structs/ChannelCounterparty.mjs");
parcelHelpers.exportAll(_channelCounterpartyMjs, exports);
var _channelMessageHandlerMjs = require("./structs/ChannelMessageHandler.mjs");
parcelHelpers.exportAll(_channelMessageHandlerMjs, exports);
var _channelManagerReadArgsMjs = require("./structs/ChannelManagerReadArgs.mjs");
parcelHelpers.exportAll(_channelManagerReadArgsMjs, exports);
var _dataLossProtectMjs = require("./structs/DataLossProtect.mjs");
parcelHelpers.exportAll(_dataLossProtectMjs, exports);
var _routingMessageHandlerMjs = require("./structs/RoutingMessageHandler.mjs");
parcelHelpers.exportAll(_routingMessageHandlerMjs, exports);
var _customMessageReaderMjs = require("./structs/CustomMessageReader.mjs");
parcelHelpers.exportAll(_customMessageReaderMjs, exports);
var _customMessageHandlerMjs = require("./structs/CustomMessageHandler.mjs");
parcelHelpers.exportAll(_customMessageHandlerMjs, exports);
var _ignoringMessageHandlerMjs = require("./structs/IgnoringMessageHandler.mjs");
parcelHelpers.exportAll(_ignoringMessageHandlerMjs, exports);
var _erroringMessageHandlerMjs = require("./structs/ErroringMessageHandler.mjs");
parcelHelpers.exportAll(_erroringMessageHandlerMjs, exports);
var _messageHandlerMjs = require("./structs/MessageHandler.mjs");
parcelHelpers.exportAll(_messageHandlerMjs, exports);
var _socketDescriptorMjs = require("./structs/SocketDescriptor.mjs");
parcelHelpers.exportAll(_socketDescriptorMjs, exports);
var _peerManagerMjs = require("./structs/PeerManager.mjs");
parcelHelpers.exportAll(_peerManagerMjs, exports);
var _directedChannelTransactionParametersMjs = require("./structs/DirectedChannelTransactionParameters.mjs");
parcelHelpers.exportAll(_directedChannelTransactionParametersMjs, exports);
var _readOnlyNetworkGraphMjs = require("./structs/ReadOnlyNetworkGraph.mjs");
parcelHelpers.exportAll(_readOnlyNetworkGraphMjs, exports);
var _netGraphMsgHandlerMjs = require("./structs/NetGraphMsgHandler.mjs");
parcelHelpers.exportAll(_netGraphMsgHandlerMjs, exports);
var _scoreMjs = require("./structs/Score.mjs");
parcelHelpers.exportAll(_scoreMjs, exports);
var _lockableScoreMjs = require("./structs/LockableScore.mjs");
parcelHelpers.exportAll(_lockableScoreMjs, exports);
var _multiThreadedLockableScoreMjs = require("./structs/MultiThreadedLockableScore.mjs"); //# sourceMappingURL=index.mjs.map
parcelHelpers.exportAll(_multiThreadedLockableScoreMjs, exports);
async function initializeWasmWebFetch(uri) {
    await _bindingsMjs.initializeWasmFetch(uri);
}
async function initializeWasmFromBinary(bin) {
    await _bindingsMjs.initializeWasmFromUint8Array(bin);
}

},{"./bindings.mjs":"eLHXZ","./structs/TxOut.mjs":"3syDw","./enums/AccessError.mjs":"3kb7t","./enums/COption_NoneZ.mjs":"9Z99Z","./enums/ChannelMonitorUpdateErr.mjs":"hUh9l","./enums/ConfirmationTarget.mjs":"6CzjF","./enums/Level.mjs":"bJcVy","./enums/Network.mjs":"az8qe","./enums/Secp256k1Error.mjs":"43LX4","./structs/ChannelConfig.mjs":"VmnNM","./structs/DecodeError.mjs":"5KlBi","./structs/Result_ChannelConfigDecodeErrorZ.mjs":"3QTMW","./structs/OutPoint.mjs":"9FTof","./structs/Result_OutPointDecodeErrorZ.mjs":"15rzH","./structs/Result_SecretKeyErrorZ.mjs":"2bthA","./structs/Result_PublicKeyErrorZ.mjs":"dMi2Z","./structs/TxCreationKeys.mjs":"gH4iE","./structs/Result_TxCreationKeysDecodeErrorZ.mjs":"4ig3m","./structs/ChannelPublicKeys.mjs":"a8cA2","./structs/Result_ChannelPublicKeysDecodeErrorZ.mjs":"k3vsR","./structs/Result_TxCreationKeysErrorZ.mjs":"5TrKt","./structs/Option_u32Z.mjs":"iQp9f","./structs/HTLCOutputInCommitment.mjs":"9o6Rh","./structs/Result_HTLCOutputInCommitmentDecodeErrorZ.mjs":"lOokA","./structs/CounterpartyChannelTransactionParameters.mjs":"cJkQt","./structs/Result_CounterpartyChannelTransactionParametersDecodeErrorZ.mjs":"2LLTo","./structs/ChannelTransactionParameters.mjs":"dkG9C","./structs/Result_ChannelTransactionParametersDecodeErrorZ.mjs":"aP1RM","./structs/HolderCommitmentTransaction.mjs":"gvilr","./structs/Result_HolderCommitmentTransactionDecodeErrorZ.mjs":"9ufPL","./structs/BuiltCommitmentTransaction.mjs":"32tCI","./structs/Result_BuiltCommitmentTransactionDecodeErrorZ.mjs":"iI9jh","./structs/TrustedClosingTransaction.mjs":"czsNn","./structs/Result_TrustedClosingTransactionNoneZ.mjs":"aFYlU","./structs/CommitmentTransaction.mjs":"jcnCV","./structs/Result_CommitmentTransactionDecodeErrorZ.mjs":"6bKwL","./structs/TrustedCommitmentTransaction.mjs":"j4RrW","./structs/Result_TrustedCommitmentTransactionNoneZ.mjs":"21NFv","./structs/Result_CVec_SignatureZNoneZ.mjs":"8ZcEN","./structs/ShutdownScript.mjs":"gHaa6","./structs/Result_ShutdownScriptDecodeErrorZ.mjs":"gfkPB","./structs/InvalidShutdownScript.mjs":"asKI3","./structs/Result_ShutdownScriptInvalidShutdownScriptZ.mjs":"hMLZ1","./structs/Type.mjs":"co77s","./structs/Option_TypeZ.mjs":"dNsZ3","./structs/Result_COption_TypeZDecodeErrorZ.mjs":"72w3O","./structs/Result_StringErrorZ.mjs":"bx85V","./structs/ChannelMonitorUpdate.mjs":"gEeSd","./structs/Result_ChannelMonitorUpdateDecodeErrorZ.mjs":"5tNQK","./structs/HTLCUpdate.mjs":"feVhj","./structs/MonitorEvent.mjs":"jGH1U","./structs/Option_MonitorEventZ.mjs":"9PM41","./structs/Result_COption_MonitorEventZDecodeErrorZ.mjs":"7wIuE","./structs/Result_HTLCUpdateDecodeErrorZ.mjs":"4Ug4F","./structs/Result_NoneNoneZ.mjs":"1QnVF","./structs/TwoTuple_OutPointScriptZ.mjs":"loLPb","./structs/TwoTuple_u32ScriptZ.mjs":"kzt6p","./structs/TwoTuple_TxidCVec_C2Tuple_u32ScriptZZZ.mjs":"fDovr","./structs/PaymentPurpose.mjs":"2gW5M","./structs/Option_u64Z.mjs":"8VC1Q","./structs/ChannelUpdate.mjs":"kLaF6","./structs/NetworkUpdate.mjs":"heqLn","./structs/Option_NetworkUpdateZ.mjs":"3mbkX","./structs/RouteHop.mjs":"hQQ4g","./structs/RouteParameters.mjs":"2hS5b","./structs/DelayedPaymentOutputDescriptor.mjs":"jKE2O","./structs/StaticPaymentOutputDescriptor.mjs":"1ffRO","./structs/SpendableOutputDescriptor.mjs":"gZn9J","./structs/ClosureReason.mjs":"fttbR","./structs/Event.mjs":"g2Zcr","./structs/TwoTuple_usizeTransactionZ.mjs":"k0qa9","./structs/TwoTuple_u32TxOutZ.mjs":"cb1IO","./structs/TwoTuple_TxidCVec_C2Tuple_u32TxOutZZZ.mjs":"fieS2","./structs/Balance.mjs":"jbcIa","./structs/TwoTuple_SignatureCVec_SignatureZZ.mjs":"73KUF","./structs/Result_C2Tuple_SignatureCVec_SignatureZZNoneZ.mjs":"l32sF","./structs/Result_SignatureNoneZ.mjs":"g8rmm","./structs/ClosingTransaction.mjs":"6WJpv","./structs/UnsignedChannelAnnouncement.mjs":"bwq1O","./structs/BaseSign.mjs":"4dNuw","./structs/Sign.mjs":"jgkjb","./structs/ChannelMonitor.mjs":"ebdYy","./structs/TwoTuple_BlockHashChannelMonitorZ.mjs":"hqqnc","./structs/Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ.mjs":"jDvbr","./structs/Result_RouteHopDecodeErrorZ.mjs":"dvgVM","./structs/Route.mjs":"eZydB","./structs/Result_RouteDecodeErrorZ.mjs":"2RBQ3","./structs/Result_RouteParametersDecodeErrorZ.mjs":"hCItn","./structs/RouteHint.mjs":"bvyYI","./structs/Payee.mjs":"3fxcr","./structs/Result_PayeeDecodeErrorZ.mjs":"g3cP6","./structs/RouteHintHop.mjs":"FzGCI","./structs/Result_RouteHintDecodeErrorZ.mjs":"fW09Z","./structs/Result_RouteHintHopDecodeErrorZ.mjs":"8SWYJ","./structs/ChannelDetails.mjs":"bIXdf","./structs/LightningError.mjs":"TGHq7","./structs/Result_RouteLightningErrorZ.mjs":"fWmwa","./structs/Result_NoneLightningErrorZ.mjs":"TA9p3","./structs/TwoTuple_PublicKeyTypeZ.mjs":"cA97j","./structs/AcceptChannel.mjs":"7niKR","./structs/OpenChannel.mjs":"36LuB","./structs/FundingCreated.mjs":"5WOqU","./structs/FundingSigned.mjs":"jlNPc","./structs/FundingLocked.mjs":"kN90K","./structs/AnnouncementSignatures.mjs":"lrgLp","./structs/CommitmentUpdate.mjs":"21YmD","./structs/RevokeAndACK.mjs":"hocx7","./structs/ClosingSigned.mjs":"drMrL","./structs/Shutdown.mjs":"3oLVK","./structs/ChannelReestablish.mjs":"1pMS7","./structs/ChannelAnnouncement.mjs":"5JqYl","./structs/NodeAnnouncement.mjs":"549dY","./structs/ErrorMessage.mjs":"9WeY0","./structs/ErrorAction.mjs":"fezfr","./structs/QueryChannelRange.mjs":"83Xki","./structs/QueryShortChannelIds.mjs":"1G6O6","./structs/ReplyChannelRange.mjs":"l9iKG","./structs/MessageSendEvent.mjs":"hFzDz","./structs/Result_boolLightningErrorZ.mjs":"9hmM8","./structs/ThreeTuple_ChannelAnnouncementChannelUpdateChannelUpdateZ.mjs":"jVg18","./structs/PeerHandleError.mjs":"csQwF","./structs/Result_CVec_u8ZPeerHandleErrorZ.mjs":"82ISC","./structs/Result_NonePeerHandleErrorZ.mjs":"dB41b","./structs/Result_boolPeerHandleErrorZ.mjs":"aFPZ5","./structs/Result_TxOutAccessErrorZ.mjs":"61a3E","./structs/Result_NoneChannelMonitorUpdateErrZ.mjs":"icmE6","./structs/Option_C2Tuple_usizeTransactionZZ.mjs":"g9upi","./structs/Option_ClosureReasonZ.mjs":"4nYjo","./structs/Result_COption_ClosureReasonZDecodeErrorZ.mjs":"6EKIv","./structs/Option_EventZ.mjs":"h6X8M","./structs/Result_COption_EventZDecodeErrorZ.mjs":"asgnu","./structs/NodeId.mjs":"kiqkR","./structs/Result_NodeIdDecodeErrorZ.mjs":"jRfFu","./structs/Result_COption_NetworkUpdateZDecodeErrorZ.mjs":"lqUkx","./structs/Access.mjs":"geLNM","./structs/Option_AccessZ.mjs":"8VxOd","./structs/DirectionalChannelInfo.mjs":"dB08I","./structs/Result_DirectionalChannelInfoDecodeErrorZ.mjs":"aIJiV","./structs/ChannelInfo.mjs":"kbkCq","./structs/Result_ChannelInfoDecodeErrorZ.mjs":"02iub","./structs/RoutingFees.mjs":"7CDJ9","./structs/Result_RoutingFeesDecodeErrorZ.mjs":"fxfD8","./structs/NetAddress.mjs":"dIj09","./structs/NodeAnnouncementInfo.mjs":"1pwML","./structs/Result_NodeAnnouncementInfoDecodeErrorZ.mjs":"db4MW","./structs/NodeInfo.mjs":"jcUte","./structs/Result_NodeInfoDecodeErrorZ.mjs":"eby6q","./structs/NetworkGraph.mjs":"j3hPx","./structs/Result_NetworkGraphDecodeErrorZ.mjs":"3MMjD","./structs/Option_CVec_NetAddressZZ.mjs":"auEdx","./structs/ScoringParameters.mjs":"lGxgx","./structs/Result_ScoringParametersDecodeErrorZ.mjs":"flqBk","./structs/InitFeatures.mjs":"iilSK","./structs/Result_InitFeaturesDecodeErrorZ.mjs":"eyRVn","./structs/ChannelFeatures.mjs":"89gCD","./structs/Result_ChannelFeaturesDecodeErrorZ.mjs":"6Sjo8","./structs/NodeFeatures.mjs":"8eCA6","./structs/Result_NodeFeaturesDecodeErrorZ.mjs":"kdMHz","./structs/InvoiceFeatures.mjs":"1EI2T","./structs/Result_InvoiceFeaturesDecodeErrorZ.mjs":"1uVDE","./structs/ChannelTypeFeatures.mjs":"7Mxrh","./structs/Result_ChannelTypeFeaturesDecodeErrorZ.mjs":"5tfos","./structs/Result_NetAddressDecodeErrorZ.mjs":"kzql0","./structs/UpdateAddHTLC.mjs":"9vrgO","./structs/UpdateFulfillHTLC.mjs":"cr92W","./structs/UpdateFailHTLC.mjs":"4WevC","./structs/UpdateFailMalformedHTLC.mjs":"jLR8a","./structs/Result_AcceptChannelDecodeErrorZ.mjs":"jqWMH","./structs/Result_AnnouncementSignaturesDecodeErrorZ.mjs":"ly0FJ","./structs/Result_ChannelReestablishDecodeErrorZ.mjs":"c5iVY","./structs/Result_ClosingSignedDecodeErrorZ.mjs":"3GrS9","./structs/ClosingSignedFeeRange.mjs":"dcrS6","./structs/Result_ClosingSignedFeeRangeDecodeErrorZ.mjs":"ljdvx","./structs/CommitmentSigned.mjs":"fowBl","./structs/Result_CommitmentSignedDecodeErrorZ.mjs":"8d2oW","./structs/Result_FundingCreatedDecodeErrorZ.mjs":"fpj9X","./structs/Result_FundingSignedDecodeErrorZ.mjs":"jFbb5","./structs/Result_FundingLockedDecodeErrorZ.mjs":"dR30H","./structs/Init.mjs":"9tT7T","./structs/Result_InitDecodeErrorZ.mjs":"c70DB","./structs/Result_OpenChannelDecodeErrorZ.mjs":"9EnEs","./structs/Result_RevokeAndACKDecodeErrorZ.mjs":"5nbNc","./structs/Result_ShutdownDecodeErrorZ.mjs":"4YNVE","./structs/Result_UpdateFailHTLCDecodeErrorZ.mjs":"h4ypb","./structs/Result_UpdateFailMalformedHTLCDecodeErrorZ.mjs":"6xLv3","./structs/UpdateFee.mjs":"8XTZ4","./structs/Result_UpdateFeeDecodeErrorZ.mjs":"f8zxh","./structs/Result_UpdateFulfillHTLCDecodeErrorZ.mjs":"a6EKN","./structs/Result_UpdateAddHTLCDecodeErrorZ.mjs":"bxIFB","./structs/Ping.mjs":"4s5GI","./structs/Result_PingDecodeErrorZ.mjs":"9manO","./structs/Pong.mjs":"1hCvO","./structs/Result_PongDecodeErrorZ.mjs":"3JaYG","./structs/Result_UnsignedChannelAnnouncementDecodeErrorZ.mjs":"eHuvZ","./structs/Result_ChannelAnnouncementDecodeErrorZ.mjs":"8Xlge","./structs/UnsignedChannelUpdate.mjs":"7IUgV","./structs/Result_UnsignedChannelUpdateDecodeErrorZ.mjs":"lnLMt","./structs/Result_ChannelUpdateDecodeErrorZ.mjs":"33S6G","./structs/Result_ErrorMessageDecodeErrorZ.mjs":"6l86i","./structs/UnsignedNodeAnnouncement.mjs":"7Y2hY","./structs/Result_UnsignedNodeAnnouncementDecodeErrorZ.mjs":"45jo9","./structs/Result_NodeAnnouncementDecodeErrorZ.mjs":"4ZWeG","./structs/Result_QueryShortChannelIdsDecodeErrorZ.mjs":"8cJrP","./structs/ReplyShortChannelIdsEnd.mjs":"02mnG","./structs/Result_ReplyShortChannelIdsEndDecodeErrorZ.mjs":"aHsDd","./structs/Result_QueryChannelRangeDecodeErrorZ.mjs":"iNK5Y","./structs/Result_ReplyChannelRangeDecodeErrorZ.mjs":"7VeWG","./structs/GossipTimestampFilter.mjs":"9UwfR","./structs/Result_GossipTimestampFilterDecodeErrorZ.mjs":"b1Rk4","./structs/Result_DelayedPaymentOutputDescriptorDecodeErrorZ.mjs":"fhjv6","./structs/Result_StaticPaymentOutputDescriptorDecodeErrorZ.mjs":"ijsLz","./structs/Result_SpendableOutputDescriptorDecodeErrorZ.mjs":"9SI3U","./structs/Result_SignDecodeErrorZ.mjs":"htjqc","./structs/Result_RecoverableSignatureNoneZ.mjs":"34rca","./structs/Result_CVec_CVec_u8ZZNoneZ.mjs":"i9PFL","./structs/InMemorySigner.mjs":"3SgwF","./structs/Result_InMemorySignerDecodeErrorZ.mjs":"aBfbh","./structs/Result_TransactionNoneZ.mjs":"7rxwz","./structs/WatchedOutput.mjs":"1mlut","./structs/Filter.mjs":"jd0MV","./structs/Option_FilterZ.mjs":"dOShc","./structs/LockedChannelMonitor.mjs":"49wgo","./structs/Result_LockedChannelMonitorNoneZ.mjs":"gIfQI","./structs/APIError.mjs":"8o4gh","./structs/Result_NoneAPIErrorZ.mjs":"56Ohf","./structs/Option_u16Z.mjs":"fDG4a","./structs/Result__u832APIErrorZ.mjs":"fcmUI","./structs/PaymentSendFailure.mjs":"hGJR4","./structs/Result_PaymentIdPaymentSendFailureZ.mjs":"eQJEs","./structs/Result_NonePaymentSendFailureZ.mjs":"4uCl5","./structs/TwoTuple_PaymentHashPaymentIdZ.mjs":"iLcVy","./structs/Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ.mjs":"jM82N","./structs/TwoTuple_PaymentHashPaymentSecretZ.mjs":"bXLDZ","./structs/Result_C2Tuple_PaymentHashPaymentSecretZNoneZ.mjs":"f6YT4","./structs/Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ.mjs":"dwFq0","./structs/Result_PaymentSecretNoneZ.mjs":"2khSV","./structs/Result_PaymentSecretAPIErrorZ.mjs":"ggvA5","./structs/Result_PaymentPreimageAPIErrorZ.mjs":"17jBi","./structs/Watch.mjs":"2Clil","./structs/BroadcasterInterface.mjs":"6EF7s","./structs/KeysInterface.mjs":"2q459","./structs/FeeEstimator.mjs":"b4XTq","./structs/Record.mjs":"goJtG","./structs/Logger.mjs":"2M89o","./structs/ChannelManager.mjs":"7XhoG","./structs/TwoTuple_BlockHashChannelManagerZ.mjs":"3cHhx","./structs/Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ.mjs":"gOv1Q","./structs/MessageSendEventsProvider.mjs":"U83N1","./structs/EventHandler.mjs":"iL3gQ","./structs/EventsProvider.mjs":"9x0e4","./structs/ChannelHandshakeConfig.mjs":"dYMV3","./structs/ChannelHandshakeLimits.mjs":"lB06s","./structs/UserConfig.mjs":"io87u","./structs/BestBlock.mjs":"1czxO","./structs/Listen.mjs":"7mGRx","./structs/Confirm.mjs":"gHOTY","./structs/MonitorUpdateId.mjs":"oIO2x","./structs/Persist.mjs":"fLLJT","./structs/ChainMonitor.mjs":"jDiTx","./structs/KeysManager.mjs":"7PYeI","./structs/ChainParameters.mjs":"fBsTy","./structs/CounterpartyForwardingInfo.mjs":"aroHM","./structs/ChannelCounterparty.mjs":"VkgBn","./structs/ChannelMessageHandler.mjs":"dr4Tk","./structs/ChannelManagerReadArgs.mjs":"1uaUq","./structs/DataLossProtect.mjs":"f6CxA","./structs/RoutingMessageHandler.mjs":"fuLD4","./structs/CustomMessageReader.mjs":"4zR6V","./structs/CustomMessageHandler.mjs":"go7eV","./structs/IgnoringMessageHandler.mjs":"4poqg","./structs/ErroringMessageHandler.mjs":"6dE1s","./structs/MessageHandler.mjs":"9A6Xs","./structs/SocketDescriptor.mjs":"iE7AM","./structs/PeerManager.mjs":"1i5fd","./structs/DirectedChannelTransactionParameters.mjs":"3x7rH","./structs/ReadOnlyNetworkGraph.mjs":"loBye","./structs/NetGraphMsgHandler.mjs":"gfr2u","./structs/Score.mjs":"2lXHD","./structs/LockableScore.mjs":"9DVut","./structs/MultiThreadedLockableScore.mjs":"2o3PR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eLHXZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* @internal */ parcelHelpers.export(exports, "initializeWasmFromUint8Array", ()=>initializeWasmFromUint8Array
);
/* @internal */ parcelHelpers.export(exports, "initializeWasmFetch", ()=>initializeWasmFetch
);
/* @internal */ parcelHelpers.export(exports, "encodeUint8Array", ()=>encodeUint8Array
);
/* @internal */ parcelHelpers.export(exports, "encodeUint32Array", ()=>encodeUint32Array
);
/* @internal */ parcelHelpers.export(exports, "encodeUint64Array", ()=>encodeUint64Array
);
/* @internal */ parcelHelpers.export(exports, "check_arr_len", ()=>check_arr_len
);
/* @internal */ parcelHelpers.export(exports, "getArrayLength", ()=>getArrayLength
);
/* @internal */ parcelHelpers.export(exports, "decodeUint8Array", ()=>decodeUint8Array
);
parcelHelpers.export(exports, "freeWasmMemory", ()=>freeWasmMemory
);
/* @internal */ parcelHelpers.export(exports, "getU32ArrayElem", ()=>getU32ArrayElem
);
/* @internal */ parcelHelpers.export(exports, "encodeString", ()=>encodeString
);
/* @internal */ parcelHelpers.export(exports, "decodeString", ()=>decodeString
);
/* @internal */ parcelHelpers.export(exports, "getRemainingAllocationCount", ()=>getRemainingAllocationCount
);
/* @internal */ parcelHelpers.export(exports, "debugPrintRemainingAllocs", ()=>debugPrintRemainingAllocs
);
parcelHelpers.export(exports, "AccessError", ()=>AccessError
);
parcelHelpers.export(exports, "COption_NoneZ", ()=>COption_NoneZ
);
parcelHelpers.export(exports, "ChannelMonitorUpdateErr", ()=>ChannelMonitorUpdateErr
);
parcelHelpers.export(exports, "ConfirmationTarget", ()=>ConfirmationTarget
);
parcelHelpers.export(exports, "Level", ()=>Level
);
parcelHelpers.export(exports, "Network", ()=>Network
);
parcelHelpers.export(exports, "Secp256k1Error", ()=>Secp256k1Error
);
// struct LDKCVec_u8Z TxOut_get_script_pubkey (struct LDKTxOut* thing)
/* @internal */ parcelHelpers.export(exports, "TxOut_get_script_pubkey", ()=>TxOut_get_script_pubkey
);
// uint64_t TxOut_get_value (struct LDKTxOut* thing)
/* @internal */ parcelHelpers.export(exports, "TxOut_get_value", ()=>TxOut_get_value
);
// struct LDKChannelConfig CResult_ChannelConfigDecodeErrorZ_get_ok(LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelConfigDecodeErrorZ_get_ok", ()=>CResult_ChannelConfigDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ChannelConfigDecodeErrorZ_get_err(LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelConfigDecodeErrorZ_get_err", ()=>CResult_ChannelConfigDecodeErrorZ_get_err
);
// struct LDKOutPoint CResult_OutPointDecodeErrorZ_get_ok(LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_OutPointDecodeErrorZ_get_ok", ()=>CResult_OutPointDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_OutPointDecodeErrorZ_get_err(LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_OutPointDecodeErrorZ_get_err", ()=>CResult_OutPointDecodeErrorZ_get_err
);
// struct LDKSecretKey CResult_SecretKeyErrorZ_get_ok(LDKCResult_SecretKeyErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_SecretKeyErrorZ_get_ok", ()=>CResult_SecretKeyErrorZ_get_ok
);
// enum LDKSecp256k1Error CResult_SecretKeyErrorZ_get_err(LDKCResult_SecretKeyErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_SecretKeyErrorZ_get_err", ()=>CResult_SecretKeyErrorZ_get_err
);
// struct LDKPublicKey CResult_PublicKeyErrorZ_get_ok(LDKCResult_PublicKeyErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_PublicKeyErrorZ_get_ok", ()=>CResult_PublicKeyErrorZ_get_ok
);
// enum LDKSecp256k1Error CResult_PublicKeyErrorZ_get_err(LDKCResult_PublicKeyErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_PublicKeyErrorZ_get_err", ()=>CResult_PublicKeyErrorZ_get_err
);
// struct LDKTxCreationKeys CResult_TxCreationKeysDecodeErrorZ_get_ok(LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_TxCreationKeysDecodeErrorZ_get_ok", ()=>CResult_TxCreationKeysDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_TxCreationKeysDecodeErrorZ_get_err(LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_TxCreationKeysDecodeErrorZ_get_err", ()=>CResult_TxCreationKeysDecodeErrorZ_get_err
);
// struct LDKChannelPublicKeys CResult_ChannelPublicKeysDecodeErrorZ_get_ok(LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelPublicKeysDecodeErrorZ_get_ok", ()=>CResult_ChannelPublicKeysDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ChannelPublicKeysDecodeErrorZ_get_err(LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelPublicKeysDecodeErrorZ_get_err", ()=>CResult_ChannelPublicKeysDecodeErrorZ_get_err
);
// struct LDKTxCreationKeys CResult_TxCreationKeysErrorZ_get_ok(LDKCResult_TxCreationKeysErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_TxCreationKeysErrorZ_get_ok", ()=>CResult_TxCreationKeysErrorZ_get_ok
);
// enum LDKSecp256k1Error CResult_TxCreationKeysErrorZ_get_err(LDKCResult_TxCreationKeysErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_TxCreationKeysErrorZ_get_err", ()=>CResult_TxCreationKeysErrorZ_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_u32Z", ()=>LDKCOption_u32Z
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_u32Z_ty_from_ptr", ()=>LDKCOption_u32Z_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_u32Z_Some_get_some", ()=>LDKCOption_u32Z_Some_get_some
);
// struct LDKHTLCOutputInCommitment CResult_HTLCOutputInCommitmentDecodeErrorZ_get_ok(LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_HTLCOutputInCommitmentDecodeErrorZ_get_ok", ()=>CResult_HTLCOutputInCommitmentDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_HTLCOutputInCommitmentDecodeErrorZ_get_err(LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_HTLCOutputInCommitmentDecodeErrorZ_get_err", ()=>CResult_HTLCOutputInCommitmentDecodeErrorZ_get_err
);
// struct LDKCounterpartyChannelTransactionParameters CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_ok(LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_ok", ()=>CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_err(LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_err", ()=>CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_err
);
// struct LDKChannelTransactionParameters CResult_ChannelTransactionParametersDecodeErrorZ_get_ok(LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelTransactionParametersDecodeErrorZ_get_ok", ()=>CResult_ChannelTransactionParametersDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ChannelTransactionParametersDecodeErrorZ_get_err(LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelTransactionParametersDecodeErrorZ_get_err", ()=>CResult_ChannelTransactionParametersDecodeErrorZ_get_err
);
// struct LDKHolderCommitmentTransaction CResult_HolderCommitmentTransactionDecodeErrorZ_get_ok(LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_HolderCommitmentTransactionDecodeErrorZ_get_ok", ()=>CResult_HolderCommitmentTransactionDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_HolderCommitmentTransactionDecodeErrorZ_get_err(LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_HolderCommitmentTransactionDecodeErrorZ_get_err", ()=>CResult_HolderCommitmentTransactionDecodeErrorZ_get_err
);
// struct LDKBuiltCommitmentTransaction CResult_BuiltCommitmentTransactionDecodeErrorZ_get_ok(LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_BuiltCommitmentTransactionDecodeErrorZ_get_ok", ()=>CResult_BuiltCommitmentTransactionDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_BuiltCommitmentTransactionDecodeErrorZ_get_err(LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_BuiltCommitmentTransactionDecodeErrorZ_get_err", ()=>CResult_BuiltCommitmentTransactionDecodeErrorZ_get_err
);
// struct LDKTrustedClosingTransaction *CResult_TrustedClosingTransactionNoneZ_get_ok(LDKCResult_TrustedClosingTransactionNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_TrustedClosingTransactionNoneZ_get_ok", ()=>CResult_TrustedClosingTransactionNoneZ_get_ok
);
// void CResult_TrustedClosingTransactionNoneZ_get_err(LDKCResult_TrustedClosingTransactionNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_TrustedClosingTransactionNoneZ_get_err", ()=>CResult_TrustedClosingTransactionNoneZ_get_err
);
// struct LDKCommitmentTransaction CResult_CommitmentTransactionDecodeErrorZ_get_ok(LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_CommitmentTransactionDecodeErrorZ_get_ok", ()=>CResult_CommitmentTransactionDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_CommitmentTransactionDecodeErrorZ_get_err(LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_CommitmentTransactionDecodeErrorZ_get_err", ()=>CResult_CommitmentTransactionDecodeErrorZ_get_err
);
// struct LDKTrustedCommitmentTransaction *CResult_TrustedCommitmentTransactionNoneZ_get_ok(LDKCResult_TrustedCommitmentTransactionNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_TrustedCommitmentTransactionNoneZ_get_ok", ()=>CResult_TrustedCommitmentTransactionNoneZ_get_ok
);
// void CResult_TrustedCommitmentTransactionNoneZ_get_err(LDKCResult_TrustedCommitmentTransactionNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_TrustedCommitmentTransactionNoneZ_get_err", ()=>CResult_TrustedCommitmentTransactionNoneZ_get_err
);
// struct LDKCVec_SignatureZ CResult_CVec_SignatureZNoneZ_get_ok(LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_SignatureZNoneZ_get_ok", ()=>CResult_CVec_SignatureZNoneZ_get_ok
);
// void CResult_CVec_SignatureZNoneZ_get_err(LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_SignatureZNoneZ_get_err", ()=>CResult_CVec_SignatureZNoneZ_get_err
);
// struct LDKShutdownScript CResult_ShutdownScriptDecodeErrorZ_get_ok(LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownScriptDecodeErrorZ_get_ok", ()=>CResult_ShutdownScriptDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ShutdownScriptDecodeErrorZ_get_err(LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownScriptDecodeErrorZ_get_err", ()=>CResult_ShutdownScriptDecodeErrorZ_get_err
);
// struct LDKShutdownScript CResult_ShutdownScriptInvalidShutdownScriptZ_get_ok(LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownScriptInvalidShutdownScriptZ_get_ok", ()=>CResult_ShutdownScriptInvalidShutdownScriptZ_get_ok
);
// struct LDKInvalidShutdownScript CResult_ShutdownScriptInvalidShutdownScriptZ_get_err(LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownScriptInvalidShutdownScriptZ_get_err", ()=>CResult_ShutdownScriptInvalidShutdownScriptZ_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKType_new", ()=>LDKType_new
);
// uint16_t Type_type_id LDKType *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "Type_type_id", ()=>Type_type_id
);
// LDKStr Type_debug_str LDKType *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "Type_debug_str", ()=>Type_debug_str
);
// LDKCVec_u8Z Type_write LDKType *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "Type_write", ()=>Type_write
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_TypeZ", ()=>LDKCOption_TypeZ
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_TypeZ_ty_from_ptr", ()=>LDKCOption_TypeZ_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_TypeZ_Some_get_some", ()=>LDKCOption_TypeZ_Some_get_some
);
// struct LDKCOption_TypeZ CResult_COption_TypeZDecodeErrorZ_get_ok(LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_TypeZDecodeErrorZ_get_ok", ()=>CResult_COption_TypeZDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_COption_TypeZDecodeErrorZ_get_err(LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_TypeZDecodeErrorZ_get_err", ()=>CResult_COption_TypeZDecodeErrorZ_get_err
);
// struct LDKStr CResult_StringErrorZ_get_ok(LDKCResult_StringErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_StringErrorZ_get_ok", ()=>CResult_StringErrorZ_get_ok
);
// enum LDKSecp256k1Error CResult_StringErrorZ_get_err(LDKCResult_StringErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_StringErrorZ_get_err", ()=>CResult_StringErrorZ_get_err
);
// struct LDKChannelMonitorUpdate CResult_ChannelMonitorUpdateDecodeErrorZ_get_ok(LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelMonitorUpdateDecodeErrorZ_get_ok", ()=>CResult_ChannelMonitorUpdateDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ChannelMonitorUpdateDecodeErrorZ_get_err(LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelMonitorUpdateDecodeErrorZ_get_err", ()=>CResult_ChannelMonitorUpdateDecodeErrorZ_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKMonitorEvent", ()=>LDKMonitorEvent
);
/* @internal */ parcelHelpers.export(exports, "LDKMonitorEvent_ty_from_ptr", ()=>LDKMonitorEvent_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKMonitorEvent_HTLCEvent_get_htlc_event", ()=>LDKMonitorEvent_HTLCEvent_get_htlc_event
);
/* @internal */ parcelHelpers.export(exports, "LDKMonitorEvent_CommitmentTxConfirmed_get_commitment_tx_confirmed", ()=>LDKMonitorEvent_CommitmentTxConfirmed_get_commitment_tx_confirmed
);
/* @internal */ parcelHelpers.export(exports, "LDKMonitorEvent_UpdateCompleted_get_funding_txo", ()=>LDKMonitorEvent_UpdateCompleted_get_funding_txo
);
/* @internal */ parcelHelpers.export(exports, "LDKMonitorEvent_UpdateCompleted_get_monitor_update_id", ()=>LDKMonitorEvent_UpdateCompleted_get_monitor_update_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMonitorEvent_UpdateFailed_get_update_failed", ()=>LDKMonitorEvent_UpdateFailed_get_update_failed
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_MonitorEventZ", ()=>LDKCOption_MonitorEventZ
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_MonitorEventZ_ty_from_ptr", ()=>LDKCOption_MonitorEventZ_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_MonitorEventZ_Some_get_some", ()=>LDKCOption_MonitorEventZ_Some_get_some
);
// struct LDKCOption_MonitorEventZ CResult_COption_MonitorEventZDecodeErrorZ_get_ok(LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_MonitorEventZDecodeErrorZ_get_ok", ()=>CResult_COption_MonitorEventZDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_COption_MonitorEventZDecodeErrorZ_get_err(LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_MonitorEventZDecodeErrorZ_get_err", ()=>CResult_COption_MonitorEventZDecodeErrorZ_get_err
);
// struct LDKHTLCUpdate CResult_HTLCUpdateDecodeErrorZ_get_ok(LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_HTLCUpdateDecodeErrorZ_get_ok", ()=>CResult_HTLCUpdateDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_HTLCUpdateDecodeErrorZ_get_err(LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_HTLCUpdateDecodeErrorZ_get_err", ()=>CResult_HTLCUpdateDecodeErrorZ_get_err
);
// void CResult_NoneNoneZ_get_ok(LDKCResult_NoneNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneNoneZ_get_ok", ()=>CResult_NoneNoneZ_get_ok
);
// void CResult_NoneNoneZ_get_err(LDKCResult_NoneNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneNoneZ_get_err", ()=>CResult_NoneNoneZ_get_err
);
// struct LDKOutPoint C2Tuple_OutPointScriptZ_get_a(LDKC2Tuple_OutPointScriptZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_OutPointScriptZ_get_a", ()=>C2Tuple_OutPointScriptZ_get_a
);
// struct LDKCVec_u8Z C2Tuple_OutPointScriptZ_get_b(LDKC2Tuple_OutPointScriptZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_OutPointScriptZ_get_b", ()=>C2Tuple_OutPointScriptZ_get_b
);
// uint32_t C2Tuple_u32ScriptZ_get_a(LDKC2Tuple_u32ScriptZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_u32ScriptZ_get_a", ()=>C2Tuple_u32ScriptZ_get_a
);
// struct LDKCVec_u8Z C2Tuple_u32ScriptZ_get_b(LDKC2Tuple_u32ScriptZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_u32ScriptZ_get_b", ()=>C2Tuple_u32ScriptZ_get_b
);
// struct LDKThirtyTwoBytes C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_a(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_a", ()=>C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_a
);
// struct LDKCVec_C2Tuple_u32ScriptZZ C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_b(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_b", ()=>C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_b
);
/* @internal */ parcelHelpers.export(exports, "LDKPaymentPurpose", ()=>LDKPaymentPurpose
);
/* @internal */ parcelHelpers.export(exports, "LDKPaymentPurpose_ty_from_ptr", ()=>LDKPaymentPurpose_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKPaymentPurpose_InvoicePayment_get_payment_preimage", ()=>LDKPaymentPurpose_InvoicePayment_get_payment_preimage
);
/* @internal */ parcelHelpers.export(exports, "LDKPaymentPurpose_InvoicePayment_get_payment_secret", ()=>LDKPaymentPurpose_InvoicePayment_get_payment_secret
);
/* @internal */ parcelHelpers.export(exports, "LDKPaymentPurpose_SpontaneousPayment_get_spontaneous_payment", ()=>LDKPaymentPurpose_SpontaneousPayment_get_spontaneous_payment
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_u64Z", ()=>LDKCOption_u64Z
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_u64Z_ty_from_ptr", ()=>LDKCOption_u64Z_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_u64Z_Some_get_some", ()=>LDKCOption_u64Z_Some_get_some
);
/* @internal */ parcelHelpers.export(exports, "LDKNetworkUpdate", ()=>LDKNetworkUpdate
);
/* @internal */ parcelHelpers.export(exports, "LDKNetworkUpdate_ty_from_ptr", ()=>LDKNetworkUpdate_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKNetworkUpdate_ChannelUpdateMessage_get_msg", ()=>LDKNetworkUpdate_ChannelUpdateMessage_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKNetworkUpdate_ChannelClosed_get_short_channel_id", ()=>LDKNetworkUpdate_ChannelClosed_get_short_channel_id
);
/* @internal */ parcelHelpers.export(exports, "LDKNetworkUpdate_ChannelClosed_get_is_permanent", ()=>LDKNetworkUpdate_ChannelClosed_get_is_permanent
);
/* @internal */ parcelHelpers.export(exports, "LDKNetworkUpdate_NodeFailure_get_node_id", ()=>LDKNetworkUpdate_NodeFailure_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKNetworkUpdate_NodeFailure_get_is_permanent", ()=>LDKNetworkUpdate_NodeFailure_get_is_permanent
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_NetworkUpdateZ", ()=>LDKCOption_NetworkUpdateZ
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_NetworkUpdateZ_ty_from_ptr", ()=>LDKCOption_NetworkUpdateZ_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_NetworkUpdateZ_Some_get_some", ()=>LDKCOption_NetworkUpdateZ_Some_get_some
);
/* @internal */ parcelHelpers.export(exports, "LDKSpendableOutputDescriptor", ()=>LDKSpendableOutputDescriptor
);
/* @internal */ parcelHelpers.export(exports, "LDKSpendableOutputDescriptor_ty_from_ptr", ()=>LDKSpendableOutputDescriptor_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKSpendableOutputDescriptor_StaticOutput_get_outpoint", ()=>LDKSpendableOutputDescriptor_StaticOutput_get_outpoint
);
/* @internal */ parcelHelpers.export(exports, "LDKSpendableOutputDescriptor_StaticOutput_get_output", ()=>LDKSpendableOutputDescriptor_StaticOutput_get_output
);
/* @internal */ parcelHelpers.export(exports, "LDKSpendableOutputDescriptor_DelayedPaymentOutput_get_delayed_payment_output", ()=>LDKSpendableOutputDescriptor_DelayedPaymentOutput_get_delayed_payment_output
);
/* @internal */ parcelHelpers.export(exports, "LDKSpendableOutputDescriptor_StaticPaymentOutput_get_static_payment_output", ()=>LDKSpendableOutputDescriptor_StaticPaymentOutput_get_static_payment_output
);
/* @internal */ parcelHelpers.export(exports, "LDKClosureReason", ()=>LDKClosureReason
);
/* @internal */ parcelHelpers.export(exports, "LDKClosureReason_ty_from_ptr", ()=>LDKClosureReason_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKClosureReason_CounterpartyForceClosed_get_peer_msg", ()=>LDKClosureReason_CounterpartyForceClosed_get_peer_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKClosureReason_ProcessingError_get_err", ()=>LDKClosureReason_ProcessingError_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent", ()=>LDKEvent
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_ty_from_ptr", ()=>LDKEvent_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_FundingGenerationReady_get_temporary_channel_id", ()=>LDKEvent_FundingGenerationReady_get_temporary_channel_id
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_FundingGenerationReady_get_channel_value_satoshis", ()=>LDKEvent_FundingGenerationReady_get_channel_value_satoshis
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_FundingGenerationReady_get_output_script", ()=>LDKEvent_FundingGenerationReady_get_output_script
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_FundingGenerationReady_get_user_channel_id", ()=>LDKEvent_FundingGenerationReady_get_user_channel_id
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentReceived_get_payment_hash", ()=>LDKEvent_PaymentReceived_get_payment_hash
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentReceived_get_amt", ()=>LDKEvent_PaymentReceived_get_amt
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentReceived_get_purpose", ()=>LDKEvent_PaymentReceived_get_purpose
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentSent_get_payment_id", ()=>LDKEvent_PaymentSent_get_payment_id
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentSent_get_payment_preimage", ()=>LDKEvent_PaymentSent_get_payment_preimage
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentSent_get_payment_hash", ()=>LDKEvent_PaymentSent_get_payment_hash
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentSent_get_fee_paid_msat", ()=>LDKEvent_PaymentSent_get_fee_paid_msat
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentPathFailed_get_payment_id", ()=>LDKEvent_PaymentPathFailed_get_payment_id
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentPathFailed_get_payment_hash", ()=>LDKEvent_PaymentPathFailed_get_payment_hash
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentPathFailed_get_rejected_by_dest", ()=>LDKEvent_PaymentPathFailed_get_rejected_by_dest
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentPathFailed_get_network_update", ()=>LDKEvent_PaymentPathFailed_get_network_update
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentPathFailed_get_all_paths_failed", ()=>LDKEvent_PaymentPathFailed_get_all_paths_failed
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentPathFailed_get_path", ()=>LDKEvent_PaymentPathFailed_get_path
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentPathFailed_get_short_channel_id", ()=>LDKEvent_PaymentPathFailed_get_short_channel_id
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentPathFailed_get_retry", ()=>LDKEvent_PaymentPathFailed_get_retry
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentFailed_get_payment_id", ()=>LDKEvent_PaymentFailed_get_payment_id
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentFailed_get_payment_hash", ()=>LDKEvent_PaymentFailed_get_payment_hash
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PendingHTLCsForwardable_get_time_forwardable", ()=>LDKEvent_PendingHTLCsForwardable_get_time_forwardable
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_SpendableOutputs_get_outputs", ()=>LDKEvent_SpendableOutputs_get_outputs
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentForwarded_get_fee_earned_msat", ()=>LDKEvent_PaymentForwarded_get_fee_earned_msat
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentForwarded_get_claim_from_onchain_tx", ()=>LDKEvent_PaymentForwarded_get_claim_from_onchain_tx
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_ChannelClosed_get_channel_id", ()=>LDKEvent_ChannelClosed_get_channel_id
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_ChannelClosed_get_user_channel_id", ()=>LDKEvent_ChannelClosed_get_user_channel_id
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_ChannelClosed_get_reason", ()=>LDKEvent_ChannelClosed_get_reason
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_DiscardFunding_get_channel_id", ()=>LDKEvent_DiscardFunding_get_channel_id
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_DiscardFunding_get_transaction", ()=>LDKEvent_DiscardFunding_get_transaction
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentPathSuccessful_get_payment_id", ()=>LDKEvent_PaymentPathSuccessful_get_payment_id
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentPathSuccessful_get_payment_hash", ()=>LDKEvent_PaymentPathSuccessful_get_payment_hash
);
/* @internal */ parcelHelpers.export(exports, "LDKEvent_PaymentPathSuccessful_get_path", ()=>LDKEvent_PaymentPathSuccessful_get_path
);
// uintptr_t C2Tuple_usizeTransactionZ_get_a(LDKC2Tuple_usizeTransactionZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_usizeTransactionZ_get_a", ()=>C2Tuple_usizeTransactionZ_get_a
);
// struct LDKTransaction C2Tuple_usizeTransactionZ_get_b(LDKC2Tuple_usizeTransactionZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_usizeTransactionZ_get_b", ()=>C2Tuple_usizeTransactionZ_get_b
);
// uint32_t C2Tuple_u32TxOutZ_get_a(LDKC2Tuple_u32TxOutZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_u32TxOutZ_get_a", ()=>C2Tuple_u32TxOutZ_get_a
);
// struct LDKTxOut C2Tuple_u32TxOutZ_get_b(LDKC2Tuple_u32TxOutZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_u32TxOutZ_get_b", ()=>C2Tuple_u32TxOutZ_get_b
);
// struct LDKThirtyTwoBytes C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_a(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_a", ()=>C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_a
);
// struct LDKCVec_C2Tuple_u32TxOutZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_b(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_b", ()=>C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_b
);
/* @internal */ parcelHelpers.export(exports, "LDKBalance", ()=>LDKBalance
);
/* @internal */ parcelHelpers.export(exports, "LDKBalance_ty_from_ptr", ()=>LDKBalance_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKBalance_ClaimableOnChannelClose_get_claimable_amount_satoshis", ()=>LDKBalance_ClaimableOnChannelClose_get_claimable_amount_satoshis
);
/* @internal */ parcelHelpers.export(exports, "LDKBalance_ClaimableAwaitingConfirmations_get_claimable_amount_satoshis", ()=>LDKBalance_ClaimableAwaitingConfirmations_get_claimable_amount_satoshis
);
/* @internal */ parcelHelpers.export(exports, "LDKBalance_ClaimableAwaitingConfirmations_get_confirmation_height", ()=>LDKBalance_ClaimableAwaitingConfirmations_get_confirmation_height
);
/* @internal */ parcelHelpers.export(exports, "LDKBalance_ContentiousClaimable_get_claimable_amount_satoshis", ()=>LDKBalance_ContentiousClaimable_get_claimable_amount_satoshis
);
/* @internal */ parcelHelpers.export(exports, "LDKBalance_ContentiousClaimable_get_timeout_height", ()=>LDKBalance_ContentiousClaimable_get_timeout_height
);
/* @internal */ parcelHelpers.export(exports, "LDKBalance_MaybeClaimableHTLCAwaitingTimeout_get_claimable_amount_satoshis", ()=>LDKBalance_MaybeClaimableHTLCAwaitingTimeout_get_claimable_amount_satoshis
);
/* @internal */ parcelHelpers.export(exports, "LDKBalance_MaybeClaimableHTLCAwaitingTimeout_get_claimable_height", ()=>LDKBalance_MaybeClaimableHTLCAwaitingTimeout_get_claimable_height
);
// struct LDKSignature C2Tuple_SignatureCVec_SignatureZZ_get_a(LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_SignatureCVec_SignatureZZ_get_a", ()=>C2Tuple_SignatureCVec_SignatureZZ_get_a
);
// struct LDKCVec_SignatureZ C2Tuple_SignatureCVec_SignatureZZ_get_b(LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_SignatureCVec_SignatureZZ_get_b", ()=>C2Tuple_SignatureCVec_SignatureZZ_get_b
);
// struct LDKC2Tuple_SignatureCVec_SignatureZZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_ok(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_ok", ()=>CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_ok
);
// void CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_err(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_err", ()=>CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_err
);
// struct LDKSignature CResult_SignatureNoneZ_get_ok(LDKCResult_SignatureNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_SignatureNoneZ_get_ok", ()=>CResult_SignatureNoneZ_get_ok
);
// void CResult_SignatureNoneZ_get_err(LDKCResult_SignatureNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_SignatureNoneZ_get_err", ()=>CResult_SignatureNoneZ_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKBaseSign_new", ()=>LDKBaseSign_new
);
// LDKPublicKey BaseSign_get_per_commitment_point LDKBaseSign *NONNULL_PTR this_arg, uint64_t idx
/* @internal */ parcelHelpers.export(exports, "BaseSign_get_per_commitment_point", ()=>BaseSign_get_per_commitment_point
);
// LDKThirtyTwoBytes BaseSign_release_commitment_secret LDKBaseSign *NONNULL_PTR this_arg, uint64_t idx
/* @internal */ parcelHelpers.export(exports, "BaseSign_release_commitment_secret", ()=>BaseSign_release_commitment_secret
);
// LDKCResult_NoneNoneZ BaseSign_validate_holder_commitment LDKBaseSign *NONNULL_PTR this_arg, const struct LDKHolderCommitmentTransaction *NONNULL_PTR holder_tx
/* @internal */ parcelHelpers.export(exports, "BaseSign_validate_holder_commitment", ()=>BaseSign_validate_holder_commitment
);
// LDKThirtyTwoBytes BaseSign_channel_keys_id LDKBaseSign *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "BaseSign_channel_keys_id", ()=>BaseSign_channel_keys_id
);
// LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ BaseSign_sign_counterparty_commitment LDKBaseSign *NONNULL_PTR this_arg, const struct LDKCommitmentTransaction *NONNULL_PTR commitment_tx
/* @internal */ parcelHelpers.export(exports, "BaseSign_sign_counterparty_commitment", ()=>BaseSign_sign_counterparty_commitment
);
// LDKCResult_NoneNoneZ BaseSign_validate_counterparty_revocation LDKBaseSign *NONNULL_PTR this_arg, uint64_t idx, const uint8_t (*secret)[32]
/* @internal */ parcelHelpers.export(exports, "BaseSign_validate_counterparty_revocation", ()=>BaseSign_validate_counterparty_revocation
);
// LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ BaseSign_sign_holder_commitment_and_htlcs LDKBaseSign *NONNULL_PTR this_arg, const struct LDKHolderCommitmentTransaction *NONNULL_PTR commitment_tx
/* @internal */ parcelHelpers.export(exports, "BaseSign_sign_holder_commitment_and_htlcs", ()=>BaseSign_sign_holder_commitment_and_htlcs
);
// LDKCResult_SignatureNoneZ BaseSign_sign_justice_revoked_output LDKBaseSign *NONNULL_PTR this_arg, struct LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (*per_commitment_key)[32]
/* @internal */ parcelHelpers.export(exports, "BaseSign_sign_justice_revoked_output", ()=>BaseSign_sign_justice_revoked_output
);
// LDKCResult_SignatureNoneZ BaseSign_sign_justice_revoked_htlc LDKBaseSign *NONNULL_PTR this_arg, struct LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (*per_commitment_key)[32], const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc
/* @internal */ parcelHelpers.export(exports, "BaseSign_sign_justice_revoked_htlc", ()=>BaseSign_sign_justice_revoked_htlc
);
// LDKCResult_SignatureNoneZ BaseSign_sign_counterparty_htlc_transaction LDKBaseSign *NONNULL_PTR this_arg, struct LDKTransaction htlc_tx, uintptr_t input, uint64_t amount, struct LDKPublicKey per_commitment_point, const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc
/* @internal */ parcelHelpers.export(exports, "BaseSign_sign_counterparty_htlc_transaction", ()=>BaseSign_sign_counterparty_htlc_transaction
);
// LDKCResult_SignatureNoneZ BaseSign_sign_closing_transaction LDKBaseSign *NONNULL_PTR this_arg, const struct LDKClosingTransaction *NONNULL_PTR closing_tx
/* @internal */ parcelHelpers.export(exports, "BaseSign_sign_closing_transaction", ()=>BaseSign_sign_closing_transaction
);
// LDKCResult_SignatureNoneZ BaseSign_sign_channel_announcement LDKBaseSign *NONNULL_PTR this_arg, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "BaseSign_sign_channel_announcement", ()=>BaseSign_sign_channel_announcement
);
// void BaseSign_ready_channel LDKBaseSign *NONNULL_PTR this_arg, const struct LDKChannelTransactionParameters *NONNULL_PTR channel_parameters
/* @internal */ parcelHelpers.export(exports, "BaseSign_ready_channel", ()=>BaseSign_ready_channel
);
// LDKChannelPublicKeys BaseSign_get_pubkeys LDKBaseSign *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "BaseSign_get_pubkeys", ()=>BaseSign_get_pubkeys
);
/* @internal */ parcelHelpers.export(exports, "LDKSign_new", ()=>LDKSign_new
);
// LDKCVec_u8Z Sign_write LDKSign *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "Sign_write", ()=>Sign_write
);
// struct LDKThirtyTwoBytes C2Tuple_BlockHashChannelMonitorZ_get_a(LDKC2Tuple_BlockHashChannelMonitorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_BlockHashChannelMonitorZ_get_a", ()=>C2Tuple_BlockHashChannelMonitorZ_get_a
);
// struct LDKChannelMonitor C2Tuple_BlockHashChannelMonitorZ_get_b(LDKC2Tuple_BlockHashChannelMonitorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_BlockHashChannelMonitorZ_get_b", ()=>C2Tuple_BlockHashChannelMonitorZ_get_b
);
// struct LDKC2Tuple_BlockHashChannelMonitorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_ok(LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_ok", ()=>CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_err(LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_err", ()=>CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_err
);
// struct LDKRouteHop CResult_RouteHopDecodeErrorZ_get_ok(LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHopDecodeErrorZ_get_ok", ()=>CResult_RouteHopDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_RouteHopDecodeErrorZ_get_err(LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHopDecodeErrorZ_get_err", ()=>CResult_RouteHopDecodeErrorZ_get_err
);
// struct LDKRoute CResult_RouteDecodeErrorZ_get_ok(LDKCResult_RouteDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteDecodeErrorZ_get_ok", ()=>CResult_RouteDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_RouteDecodeErrorZ_get_err(LDKCResult_RouteDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteDecodeErrorZ_get_err", ()=>CResult_RouteDecodeErrorZ_get_err
);
// struct LDKRouteParameters CResult_RouteParametersDecodeErrorZ_get_ok(LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteParametersDecodeErrorZ_get_ok", ()=>CResult_RouteParametersDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_RouteParametersDecodeErrorZ_get_err(LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteParametersDecodeErrorZ_get_err", ()=>CResult_RouteParametersDecodeErrorZ_get_err
);
// struct LDKPayee CResult_PayeeDecodeErrorZ_get_ok(LDKCResult_PayeeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_PayeeDecodeErrorZ_get_ok", ()=>CResult_PayeeDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_PayeeDecodeErrorZ_get_err(LDKCResult_PayeeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_PayeeDecodeErrorZ_get_err", ()=>CResult_PayeeDecodeErrorZ_get_err
);
// struct LDKRouteHint CResult_RouteHintDecodeErrorZ_get_ok(LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHintDecodeErrorZ_get_ok", ()=>CResult_RouteHintDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_RouteHintDecodeErrorZ_get_err(LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHintDecodeErrorZ_get_err", ()=>CResult_RouteHintDecodeErrorZ_get_err
);
// struct LDKRouteHintHop CResult_RouteHintHopDecodeErrorZ_get_ok(LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHintHopDecodeErrorZ_get_ok", ()=>CResult_RouteHintHopDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_RouteHintHopDecodeErrorZ_get_err(LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHintHopDecodeErrorZ_get_err", ()=>CResult_RouteHintHopDecodeErrorZ_get_err
);
// struct LDKRoute CResult_RouteLightningErrorZ_get_ok(LDKCResult_RouteLightningErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteLightningErrorZ_get_ok", ()=>CResult_RouteLightningErrorZ_get_ok
);
// struct LDKLightningError CResult_RouteLightningErrorZ_get_err(LDKCResult_RouteLightningErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteLightningErrorZ_get_err", ()=>CResult_RouteLightningErrorZ_get_err
);
// void CResult_NoneLightningErrorZ_get_ok(LDKCResult_NoneLightningErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneLightningErrorZ_get_ok", ()=>CResult_NoneLightningErrorZ_get_ok
);
// struct LDKLightningError CResult_NoneLightningErrorZ_get_err(LDKCResult_NoneLightningErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneLightningErrorZ_get_err", ()=>CResult_NoneLightningErrorZ_get_err
);
// struct LDKPublicKey C2Tuple_PublicKeyTypeZ_get_a(LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PublicKeyTypeZ_get_a", ()=>C2Tuple_PublicKeyTypeZ_get_a
);
// struct LDKType C2Tuple_PublicKeyTypeZ_get_b(LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PublicKeyTypeZ_get_b", ()=>C2Tuple_PublicKeyTypeZ_get_b
);
/* @internal */ parcelHelpers.export(exports, "LDKErrorAction", ()=>LDKErrorAction
);
/* @internal */ parcelHelpers.export(exports, "LDKErrorAction_ty_from_ptr", ()=>LDKErrorAction_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKErrorAction_DisconnectPeer_get_msg", ()=>LDKErrorAction_DisconnectPeer_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKErrorAction_IgnoreAndLog_get_ignore_and_log", ()=>LDKErrorAction_IgnoreAndLog_get_ignore_and_log
);
/* @internal */ parcelHelpers.export(exports, "LDKErrorAction_SendErrorMessage_get_msg", ()=>LDKErrorAction_SendErrorMessage_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent", ()=>LDKMessageSendEvent
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_ty_from_ptr", ()=>LDKMessageSendEvent_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendAcceptChannel_get_node_id", ()=>LDKMessageSendEvent_SendAcceptChannel_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendAcceptChannel_get_msg", ()=>LDKMessageSendEvent_SendAcceptChannel_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendOpenChannel_get_node_id", ()=>LDKMessageSendEvent_SendOpenChannel_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendOpenChannel_get_msg", ()=>LDKMessageSendEvent_SendOpenChannel_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendFundingCreated_get_node_id", ()=>LDKMessageSendEvent_SendFundingCreated_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendFundingCreated_get_msg", ()=>LDKMessageSendEvent_SendFundingCreated_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendFundingSigned_get_node_id", ()=>LDKMessageSendEvent_SendFundingSigned_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendFundingSigned_get_msg", ()=>LDKMessageSendEvent_SendFundingSigned_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendFundingLocked_get_node_id", ()=>LDKMessageSendEvent_SendFundingLocked_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendFundingLocked_get_msg", ()=>LDKMessageSendEvent_SendFundingLocked_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendAnnouncementSignatures_get_node_id", ()=>LDKMessageSendEvent_SendAnnouncementSignatures_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendAnnouncementSignatures_get_msg", ()=>LDKMessageSendEvent_SendAnnouncementSignatures_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_UpdateHTLCs_get_node_id", ()=>LDKMessageSendEvent_UpdateHTLCs_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_UpdateHTLCs_get_updates", ()=>LDKMessageSendEvent_UpdateHTLCs_get_updates
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendRevokeAndACK_get_node_id", ()=>LDKMessageSendEvent_SendRevokeAndACK_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendRevokeAndACK_get_msg", ()=>LDKMessageSendEvent_SendRevokeAndACK_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendClosingSigned_get_node_id", ()=>LDKMessageSendEvent_SendClosingSigned_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendClosingSigned_get_msg", ()=>LDKMessageSendEvent_SendClosingSigned_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendShutdown_get_node_id", ()=>LDKMessageSendEvent_SendShutdown_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendShutdown_get_msg", ()=>LDKMessageSendEvent_SendShutdown_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendChannelReestablish_get_node_id", ()=>LDKMessageSendEvent_SendChannelReestablish_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendChannelReestablish_get_msg", ()=>LDKMessageSendEvent_SendChannelReestablish_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_BroadcastChannelAnnouncement_get_msg", ()=>LDKMessageSendEvent_BroadcastChannelAnnouncement_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_BroadcastChannelAnnouncement_get_update_msg", ()=>LDKMessageSendEvent_BroadcastChannelAnnouncement_get_update_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_BroadcastNodeAnnouncement_get_msg", ()=>LDKMessageSendEvent_BroadcastNodeAnnouncement_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_BroadcastChannelUpdate_get_msg", ()=>LDKMessageSendEvent_BroadcastChannelUpdate_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendChannelUpdate_get_node_id", ()=>LDKMessageSendEvent_SendChannelUpdate_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendChannelUpdate_get_msg", ()=>LDKMessageSendEvent_SendChannelUpdate_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_HandleError_get_node_id", ()=>LDKMessageSendEvent_HandleError_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_HandleError_get_action", ()=>LDKMessageSendEvent_HandleError_get_action
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendChannelRangeQuery_get_node_id", ()=>LDKMessageSendEvent_SendChannelRangeQuery_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendChannelRangeQuery_get_msg", ()=>LDKMessageSendEvent_SendChannelRangeQuery_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendShortIdsQuery_get_node_id", ()=>LDKMessageSendEvent_SendShortIdsQuery_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendShortIdsQuery_get_msg", ()=>LDKMessageSendEvent_SendShortIdsQuery_get_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendReplyChannelRange_get_node_id", ()=>LDKMessageSendEvent_SendReplyChannelRange_get_node_id
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEvent_SendReplyChannelRange_get_msg", ()=>LDKMessageSendEvent_SendReplyChannelRange_get_msg
);
// bool CResult_boolLightningErrorZ_get_ok(LDKCResult_boolLightningErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_boolLightningErrorZ_get_ok", ()=>CResult_boolLightningErrorZ_get_ok
);
// struct LDKLightningError CResult_boolLightningErrorZ_get_err(LDKCResult_boolLightningErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_boolLightningErrorZ_get_err", ()=>CResult_boolLightningErrorZ_get_err
);
// struct LDKChannelAnnouncement C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_a(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_a", ()=>C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_a
);
// struct LDKChannelUpdate C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_b(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_b", ()=>C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_b
);
// struct LDKChannelUpdate C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_c(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_c", ()=>C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_c
);
// struct LDKCVec_u8Z CResult_CVec_u8ZPeerHandleErrorZ_get_ok(LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_u8ZPeerHandleErrorZ_get_ok", ()=>CResult_CVec_u8ZPeerHandleErrorZ_get_ok
);
// struct LDKPeerHandleError CResult_CVec_u8ZPeerHandleErrorZ_get_err(LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_u8ZPeerHandleErrorZ_get_err", ()=>CResult_CVec_u8ZPeerHandleErrorZ_get_err
);
// void CResult_NonePeerHandleErrorZ_get_ok(LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NonePeerHandleErrorZ_get_ok", ()=>CResult_NonePeerHandleErrorZ_get_ok
);
// struct LDKPeerHandleError CResult_NonePeerHandleErrorZ_get_err(LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NonePeerHandleErrorZ_get_err", ()=>CResult_NonePeerHandleErrorZ_get_err
);
// bool CResult_boolPeerHandleErrorZ_get_ok(LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_boolPeerHandleErrorZ_get_ok", ()=>CResult_boolPeerHandleErrorZ_get_ok
);
// struct LDKPeerHandleError CResult_boolPeerHandleErrorZ_get_err(LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_boolPeerHandleErrorZ_get_err", ()=>CResult_boolPeerHandleErrorZ_get_err
);
// struct LDKTxOut CResult_TxOutAccessErrorZ_get_ok(LDKCResult_TxOutAccessErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_TxOutAccessErrorZ_get_ok", ()=>CResult_TxOutAccessErrorZ_get_ok
);
// enum LDKAccessError CResult_TxOutAccessErrorZ_get_err(LDKCResult_TxOutAccessErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_TxOutAccessErrorZ_get_err", ()=>CResult_TxOutAccessErrorZ_get_err
);
// void CResult_NoneChannelMonitorUpdateErrZ_get_ok(LDKCResult_NoneChannelMonitorUpdateErrZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneChannelMonitorUpdateErrZ_get_ok", ()=>CResult_NoneChannelMonitorUpdateErrZ_get_ok
);
// enum LDKChannelMonitorUpdateErr CResult_NoneChannelMonitorUpdateErrZ_get_err(LDKCResult_NoneChannelMonitorUpdateErrZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneChannelMonitorUpdateErrZ_get_err", ()=>CResult_NoneChannelMonitorUpdateErrZ_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_C2Tuple_usizeTransactionZZ", ()=>LDKCOption_C2Tuple_usizeTransactionZZ
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_C2Tuple_usizeTransactionZZ_ty_from_ptr", ()=>LDKCOption_C2Tuple_usizeTransactionZZ_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_C2Tuple_usizeTransactionZZ_Some_get_some", ()=>LDKCOption_C2Tuple_usizeTransactionZZ_Some_get_some
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_ClosureReasonZ", ()=>LDKCOption_ClosureReasonZ
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_ClosureReasonZ_ty_from_ptr", ()=>LDKCOption_ClosureReasonZ_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_ClosureReasonZ_Some_get_some", ()=>LDKCOption_ClosureReasonZ_Some_get_some
);
// struct LDKCOption_ClosureReasonZ CResult_COption_ClosureReasonZDecodeErrorZ_get_ok(LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_ClosureReasonZDecodeErrorZ_get_ok", ()=>CResult_COption_ClosureReasonZDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_COption_ClosureReasonZDecodeErrorZ_get_err(LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_ClosureReasonZDecodeErrorZ_get_err", ()=>CResult_COption_ClosureReasonZDecodeErrorZ_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_EventZ", ()=>LDKCOption_EventZ
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_EventZ_ty_from_ptr", ()=>LDKCOption_EventZ_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_EventZ_Some_get_some", ()=>LDKCOption_EventZ_Some_get_some
);
// struct LDKCOption_EventZ CResult_COption_EventZDecodeErrorZ_get_ok(LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_EventZDecodeErrorZ_get_ok", ()=>CResult_COption_EventZDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_COption_EventZDecodeErrorZ_get_err(LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_EventZDecodeErrorZ_get_err", ()=>CResult_COption_EventZDecodeErrorZ_get_err
);
// struct LDKNodeId CResult_NodeIdDecodeErrorZ_get_ok(LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeIdDecodeErrorZ_get_ok", ()=>CResult_NodeIdDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_NodeIdDecodeErrorZ_get_err(LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeIdDecodeErrorZ_get_err", ()=>CResult_NodeIdDecodeErrorZ_get_err
);
// struct LDKCOption_NetworkUpdateZ CResult_COption_NetworkUpdateZDecodeErrorZ_get_ok(LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_NetworkUpdateZDecodeErrorZ_get_ok", ()=>CResult_COption_NetworkUpdateZDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_COption_NetworkUpdateZDecodeErrorZ_get_err(LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_NetworkUpdateZDecodeErrorZ_get_err", ()=>CResult_COption_NetworkUpdateZDecodeErrorZ_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKAccess_new", ()=>LDKAccess_new
);
// LDKCResult_TxOutAccessErrorZ Access_get_utxo LDKAccess *NONNULL_PTR this_arg, const uint8_t (*genesis_hash)[32], uint64_t short_channel_id
/* @internal */ parcelHelpers.export(exports, "Access_get_utxo", ()=>Access_get_utxo
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_AccessZ", ()=>LDKCOption_AccessZ
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_AccessZ_ty_from_ptr", ()=>LDKCOption_AccessZ_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_AccessZ_Some_get_some", ()=>LDKCOption_AccessZ_Some_get_some
);
// struct LDKDirectionalChannelInfo CResult_DirectionalChannelInfoDecodeErrorZ_get_ok(LDKCResult_DirectionalChannelInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_DirectionalChannelInfoDecodeErrorZ_get_ok", ()=>CResult_DirectionalChannelInfoDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_DirectionalChannelInfoDecodeErrorZ_get_err(LDKCResult_DirectionalChannelInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_DirectionalChannelInfoDecodeErrorZ_get_err", ()=>CResult_DirectionalChannelInfoDecodeErrorZ_get_err
);
// struct LDKChannelInfo CResult_ChannelInfoDecodeErrorZ_get_ok(LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelInfoDecodeErrorZ_get_ok", ()=>CResult_ChannelInfoDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ChannelInfoDecodeErrorZ_get_err(LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelInfoDecodeErrorZ_get_err", ()=>CResult_ChannelInfoDecodeErrorZ_get_err
);
// struct LDKRoutingFees CResult_RoutingFeesDecodeErrorZ_get_ok(LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RoutingFeesDecodeErrorZ_get_ok", ()=>CResult_RoutingFeesDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_RoutingFeesDecodeErrorZ_get_err(LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RoutingFeesDecodeErrorZ_get_err", ()=>CResult_RoutingFeesDecodeErrorZ_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKNetAddress", ()=>LDKNetAddress
);
/* @internal */ parcelHelpers.export(exports, "LDKNetAddress_ty_from_ptr", ()=>LDKNetAddress_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKNetAddress_IPv4_get_addr", ()=>LDKNetAddress_IPv4_get_addr
);
/* @internal */ parcelHelpers.export(exports, "LDKNetAddress_IPv4_get_port", ()=>LDKNetAddress_IPv4_get_port
);
/* @internal */ parcelHelpers.export(exports, "LDKNetAddress_IPv6_get_addr", ()=>LDKNetAddress_IPv6_get_addr
);
/* @internal */ parcelHelpers.export(exports, "LDKNetAddress_IPv6_get_port", ()=>LDKNetAddress_IPv6_get_port
);
/* @internal */ parcelHelpers.export(exports, "LDKNetAddress_OnionV2_get_onion_v2", ()=>LDKNetAddress_OnionV2_get_onion_v2
);
/* @internal */ parcelHelpers.export(exports, "LDKNetAddress_OnionV3_get_ed25519_pubkey", ()=>LDKNetAddress_OnionV3_get_ed25519_pubkey
);
/* @internal */ parcelHelpers.export(exports, "LDKNetAddress_OnionV3_get_checksum", ()=>LDKNetAddress_OnionV3_get_checksum
);
/* @internal */ parcelHelpers.export(exports, "LDKNetAddress_OnionV3_get_version", ()=>LDKNetAddress_OnionV3_get_version
);
/* @internal */ parcelHelpers.export(exports, "LDKNetAddress_OnionV3_get_port", ()=>LDKNetAddress_OnionV3_get_port
);
// struct LDKNodeAnnouncementInfo CResult_NodeAnnouncementInfoDecodeErrorZ_get_ok(LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeAnnouncementInfoDecodeErrorZ_get_ok", ()=>CResult_NodeAnnouncementInfoDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_NodeAnnouncementInfoDecodeErrorZ_get_err(LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeAnnouncementInfoDecodeErrorZ_get_err", ()=>CResult_NodeAnnouncementInfoDecodeErrorZ_get_err
);
// struct LDKNodeInfo CResult_NodeInfoDecodeErrorZ_get_ok(LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeInfoDecodeErrorZ_get_ok", ()=>CResult_NodeInfoDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_NodeInfoDecodeErrorZ_get_err(LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeInfoDecodeErrorZ_get_err", ()=>CResult_NodeInfoDecodeErrorZ_get_err
);
// struct LDKNetworkGraph CResult_NetworkGraphDecodeErrorZ_get_ok(LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NetworkGraphDecodeErrorZ_get_ok", ()=>CResult_NetworkGraphDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_NetworkGraphDecodeErrorZ_get_err(LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NetworkGraphDecodeErrorZ_get_err", ()=>CResult_NetworkGraphDecodeErrorZ_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_CVec_NetAddressZZ", ()=>LDKCOption_CVec_NetAddressZZ
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_CVec_NetAddressZZ_ty_from_ptr", ()=>LDKCOption_CVec_NetAddressZZ_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_CVec_NetAddressZZ_Some_get_some", ()=>LDKCOption_CVec_NetAddressZZ_Some_get_some
);
// struct LDKScoringParameters *CResult_ScoringParametersDecodeErrorZ_get_ok(LDKCResult_ScoringParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ScoringParametersDecodeErrorZ_get_ok", ()=>CResult_ScoringParametersDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ScoringParametersDecodeErrorZ_get_err(LDKCResult_ScoringParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ScoringParametersDecodeErrorZ_get_err", ()=>CResult_ScoringParametersDecodeErrorZ_get_err
);
// struct LDKInitFeatures CResult_InitFeaturesDecodeErrorZ_get_ok(LDKCResult_InitFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_InitFeaturesDecodeErrorZ_get_ok", ()=>CResult_InitFeaturesDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_InitFeaturesDecodeErrorZ_get_err(LDKCResult_InitFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_InitFeaturesDecodeErrorZ_get_err", ()=>CResult_InitFeaturesDecodeErrorZ_get_err
);
// struct LDKChannelFeatures CResult_ChannelFeaturesDecodeErrorZ_get_ok(LDKCResult_ChannelFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelFeaturesDecodeErrorZ_get_ok", ()=>CResult_ChannelFeaturesDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ChannelFeaturesDecodeErrorZ_get_err(LDKCResult_ChannelFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelFeaturesDecodeErrorZ_get_err", ()=>CResult_ChannelFeaturesDecodeErrorZ_get_err
);
// struct LDKNodeFeatures CResult_NodeFeaturesDecodeErrorZ_get_ok(LDKCResult_NodeFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeFeaturesDecodeErrorZ_get_ok", ()=>CResult_NodeFeaturesDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_NodeFeaturesDecodeErrorZ_get_err(LDKCResult_NodeFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeFeaturesDecodeErrorZ_get_err", ()=>CResult_NodeFeaturesDecodeErrorZ_get_err
);
// struct LDKInvoiceFeatures CResult_InvoiceFeaturesDecodeErrorZ_get_ok(LDKCResult_InvoiceFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_InvoiceFeaturesDecodeErrorZ_get_ok", ()=>CResult_InvoiceFeaturesDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_InvoiceFeaturesDecodeErrorZ_get_err(LDKCResult_InvoiceFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_InvoiceFeaturesDecodeErrorZ_get_err", ()=>CResult_InvoiceFeaturesDecodeErrorZ_get_err
);
// struct LDKChannelTypeFeatures CResult_ChannelTypeFeaturesDecodeErrorZ_get_ok(LDKCResult_ChannelTypeFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelTypeFeaturesDecodeErrorZ_get_ok", ()=>CResult_ChannelTypeFeaturesDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ChannelTypeFeaturesDecodeErrorZ_get_err(LDKCResult_ChannelTypeFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelTypeFeaturesDecodeErrorZ_get_err", ()=>CResult_ChannelTypeFeaturesDecodeErrorZ_get_err
);
// struct LDKNetAddress CResult_NetAddressDecodeErrorZ_get_ok(LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NetAddressDecodeErrorZ_get_ok", ()=>CResult_NetAddressDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_NetAddressDecodeErrorZ_get_err(LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NetAddressDecodeErrorZ_get_err", ()=>CResult_NetAddressDecodeErrorZ_get_err
);
// struct LDKAcceptChannel CResult_AcceptChannelDecodeErrorZ_get_ok(LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_AcceptChannelDecodeErrorZ_get_ok", ()=>CResult_AcceptChannelDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_AcceptChannelDecodeErrorZ_get_err(LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_AcceptChannelDecodeErrorZ_get_err", ()=>CResult_AcceptChannelDecodeErrorZ_get_err
);
// struct LDKAnnouncementSignatures CResult_AnnouncementSignaturesDecodeErrorZ_get_ok(LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_AnnouncementSignaturesDecodeErrorZ_get_ok", ()=>CResult_AnnouncementSignaturesDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_AnnouncementSignaturesDecodeErrorZ_get_err(LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_AnnouncementSignaturesDecodeErrorZ_get_err", ()=>CResult_AnnouncementSignaturesDecodeErrorZ_get_err
);
// struct LDKChannelReestablish CResult_ChannelReestablishDecodeErrorZ_get_ok(LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelReestablishDecodeErrorZ_get_ok", ()=>CResult_ChannelReestablishDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ChannelReestablishDecodeErrorZ_get_err(LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelReestablishDecodeErrorZ_get_err", ()=>CResult_ChannelReestablishDecodeErrorZ_get_err
);
// struct LDKClosingSigned CResult_ClosingSignedDecodeErrorZ_get_ok(LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ClosingSignedDecodeErrorZ_get_ok", ()=>CResult_ClosingSignedDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ClosingSignedDecodeErrorZ_get_err(LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ClosingSignedDecodeErrorZ_get_err", ()=>CResult_ClosingSignedDecodeErrorZ_get_err
);
// struct LDKClosingSignedFeeRange CResult_ClosingSignedFeeRangeDecodeErrorZ_get_ok(LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ClosingSignedFeeRangeDecodeErrorZ_get_ok", ()=>CResult_ClosingSignedFeeRangeDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ClosingSignedFeeRangeDecodeErrorZ_get_err(LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ClosingSignedFeeRangeDecodeErrorZ_get_err", ()=>CResult_ClosingSignedFeeRangeDecodeErrorZ_get_err
);
// struct LDKCommitmentSigned CResult_CommitmentSignedDecodeErrorZ_get_ok(LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_CommitmentSignedDecodeErrorZ_get_ok", ()=>CResult_CommitmentSignedDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_CommitmentSignedDecodeErrorZ_get_err(LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_CommitmentSignedDecodeErrorZ_get_err", ()=>CResult_CommitmentSignedDecodeErrorZ_get_err
);
// struct LDKFundingCreated CResult_FundingCreatedDecodeErrorZ_get_ok(LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingCreatedDecodeErrorZ_get_ok", ()=>CResult_FundingCreatedDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_FundingCreatedDecodeErrorZ_get_err(LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingCreatedDecodeErrorZ_get_err", ()=>CResult_FundingCreatedDecodeErrorZ_get_err
);
// struct LDKFundingSigned CResult_FundingSignedDecodeErrorZ_get_ok(LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingSignedDecodeErrorZ_get_ok", ()=>CResult_FundingSignedDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_FundingSignedDecodeErrorZ_get_err(LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingSignedDecodeErrorZ_get_err", ()=>CResult_FundingSignedDecodeErrorZ_get_err
);
// struct LDKFundingLocked CResult_FundingLockedDecodeErrorZ_get_ok(LDKCResult_FundingLockedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingLockedDecodeErrorZ_get_ok", ()=>CResult_FundingLockedDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_FundingLockedDecodeErrorZ_get_err(LDKCResult_FundingLockedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingLockedDecodeErrorZ_get_err", ()=>CResult_FundingLockedDecodeErrorZ_get_err
);
// struct LDKInit CResult_InitDecodeErrorZ_get_ok(LDKCResult_InitDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_InitDecodeErrorZ_get_ok", ()=>CResult_InitDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_InitDecodeErrorZ_get_err(LDKCResult_InitDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_InitDecodeErrorZ_get_err", ()=>CResult_InitDecodeErrorZ_get_err
);
// struct LDKOpenChannel CResult_OpenChannelDecodeErrorZ_get_ok(LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_OpenChannelDecodeErrorZ_get_ok", ()=>CResult_OpenChannelDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_OpenChannelDecodeErrorZ_get_err(LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_OpenChannelDecodeErrorZ_get_err", ()=>CResult_OpenChannelDecodeErrorZ_get_err
);
// struct LDKRevokeAndACK CResult_RevokeAndACKDecodeErrorZ_get_ok(LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RevokeAndACKDecodeErrorZ_get_ok", ()=>CResult_RevokeAndACKDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_RevokeAndACKDecodeErrorZ_get_err(LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RevokeAndACKDecodeErrorZ_get_err", ()=>CResult_RevokeAndACKDecodeErrorZ_get_err
);
// struct LDKShutdown CResult_ShutdownDecodeErrorZ_get_ok(LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownDecodeErrorZ_get_ok", ()=>CResult_ShutdownDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ShutdownDecodeErrorZ_get_err(LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownDecodeErrorZ_get_err", ()=>CResult_ShutdownDecodeErrorZ_get_err
);
// struct LDKUpdateFailHTLC CResult_UpdateFailHTLCDecodeErrorZ_get_ok(LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFailHTLCDecodeErrorZ_get_ok", ()=>CResult_UpdateFailHTLCDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_UpdateFailHTLCDecodeErrorZ_get_err(LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFailHTLCDecodeErrorZ_get_err", ()=>CResult_UpdateFailHTLCDecodeErrorZ_get_err
);
// struct LDKUpdateFailMalformedHTLC CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_ok(LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_ok", ()=>CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_err(LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_err", ()=>CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_err
);
// struct LDKUpdateFee CResult_UpdateFeeDecodeErrorZ_get_ok(LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFeeDecodeErrorZ_get_ok", ()=>CResult_UpdateFeeDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_UpdateFeeDecodeErrorZ_get_err(LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFeeDecodeErrorZ_get_err", ()=>CResult_UpdateFeeDecodeErrorZ_get_err
);
// struct LDKUpdateFulfillHTLC CResult_UpdateFulfillHTLCDecodeErrorZ_get_ok(LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFulfillHTLCDecodeErrorZ_get_ok", ()=>CResult_UpdateFulfillHTLCDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_UpdateFulfillHTLCDecodeErrorZ_get_err(LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFulfillHTLCDecodeErrorZ_get_err", ()=>CResult_UpdateFulfillHTLCDecodeErrorZ_get_err
);
// struct LDKUpdateAddHTLC CResult_UpdateAddHTLCDecodeErrorZ_get_ok(LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateAddHTLCDecodeErrorZ_get_ok", ()=>CResult_UpdateAddHTLCDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_UpdateAddHTLCDecodeErrorZ_get_err(LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateAddHTLCDecodeErrorZ_get_err", ()=>CResult_UpdateAddHTLCDecodeErrorZ_get_err
);
// struct LDKPing CResult_PingDecodeErrorZ_get_ok(LDKCResult_PingDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_PingDecodeErrorZ_get_ok", ()=>CResult_PingDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_PingDecodeErrorZ_get_err(LDKCResult_PingDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_PingDecodeErrorZ_get_err", ()=>CResult_PingDecodeErrorZ_get_err
);
// struct LDKPong CResult_PongDecodeErrorZ_get_ok(LDKCResult_PongDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_PongDecodeErrorZ_get_ok", ()=>CResult_PongDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_PongDecodeErrorZ_get_err(LDKCResult_PongDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_PongDecodeErrorZ_get_err", ()=>CResult_PongDecodeErrorZ_get_err
);
// struct LDKUnsignedChannelAnnouncement CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_ok(LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_ok", ()=>CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_err(LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_err", ()=>CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_err
);
// struct LDKChannelAnnouncement CResult_ChannelAnnouncementDecodeErrorZ_get_ok(LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelAnnouncementDecodeErrorZ_get_ok", ()=>CResult_ChannelAnnouncementDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ChannelAnnouncementDecodeErrorZ_get_err(LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelAnnouncementDecodeErrorZ_get_err", ()=>CResult_ChannelAnnouncementDecodeErrorZ_get_err
);
// struct LDKUnsignedChannelUpdate CResult_UnsignedChannelUpdateDecodeErrorZ_get_ok(LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedChannelUpdateDecodeErrorZ_get_ok", ()=>CResult_UnsignedChannelUpdateDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_UnsignedChannelUpdateDecodeErrorZ_get_err(LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedChannelUpdateDecodeErrorZ_get_err", ()=>CResult_UnsignedChannelUpdateDecodeErrorZ_get_err
);
// struct LDKChannelUpdate CResult_ChannelUpdateDecodeErrorZ_get_ok(LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelUpdateDecodeErrorZ_get_ok", ()=>CResult_ChannelUpdateDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ChannelUpdateDecodeErrorZ_get_err(LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelUpdateDecodeErrorZ_get_err", ()=>CResult_ChannelUpdateDecodeErrorZ_get_err
);
// struct LDKErrorMessage CResult_ErrorMessageDecodeErrorZ_get_ok(LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ErrorMessageDecodeErrorZ_get_ok", ()=>CResult_ErrorMessageDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ErrorMessageDecodeErrorZ_get_err(LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ErrorMessageDecodeErrorZ_get_err", ()=>CResult_ErrorMessageDecodeErrorZ_get_err
);
// struct LDKUnsignedNodeAnnouncement CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_ok(LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_ok", ()=>CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_err(LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_err", ()=>CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_err
);
// struct LDKNodeAnnouncement CResult_NodeAnnouncementDecodeErrorZ_get_ok(LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeAnnouncementDecodeErrorZ_get_ok", ()=>CResult_NodeAnnouncementDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_NodeAnnouncementDecodeErrorZ_get_err(LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeAnnouncementDecodeErrorZ_get_err", ()=>CResult_NodeAnnouncementDecodeErrorZ_get_err
);
// struct LDKQueryShortChannelIds CResult_QueryShortChannelIdsDecodeErrorZ_get_ok(LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_QueryShortChannelIdsDecodeErrorZ_get_ok", ()=>CResult_QueryShortChannelIdsDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_QueryShortChannelIdsDecodeErrorZ_get_err(LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_QueryShortChannelIdsDecodeErrorZ_get_err", ()=>CResult_QueryShortChannelIdsDecodeErrorZ_get_err
);
// struct LDKReplyShortChannelIdsEnd CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_ok(LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_ok", ()=>CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_err(LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_err", ()=>CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_err
);
// struct LDKQueryChannelRange CResult_QueryChannelRangeDecodeErrorZ_get_ok(LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_QueryChannelRangeDecodeErrorZ_get_ok", ()=>CResult_QueryChannelRangeDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_QueryChannelRangeDecodeErrorZ_get_err(LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_QueryChannelRangeDecodeErrorZ_get_err", ()=>CResult_QueryChannelRangeDecodeErrorZ_get_err
);
// struct LDKReplyChannelRange CResult_ReplyChannelRangeDecodeErrorZ_get_ok(LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ReplyChannelRangeDecodeErrorZ_get_ok", ()=>CResult_ReplyChannelRangeDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_ReplyChannelRangeDecodeErrorZ_get_err(LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_ReplyChannelRangeDecodeErrorZ_get_err", ()=>CResult_ReplyChannelRangeDecodeErrorZ_get_err
);
// struct LDKGossipTimestampFilter CResult_GossipTimestampFilterDecodeErrorZ_get_ok(LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_GossipTimestampFilterDecodeErrorZ_get_ok", ()=>CResult_GossipTimestampFilterDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_GossipTimestampFilterDecodeErrorZ_get_err(LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_GossipTimestampFilterDecodeErrorZ_get_err", ()=>CResult_GossipTimestampFilterDecodeErrorZ_get_err
);
// struct LDKDelayedPaymentOutputDescriptor CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_ok(LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_ok", ()=>CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_err(LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_err", ()=>CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_err
);
// struct LDKStaticPaymentOutputDescriptor CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_ok(LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_ok", ()=>CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_err(LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_err", ()=>CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_err
);
// struct LDKSpendableOutputDescriptor CResult_SpendableOutputDescriptorDecodeErrorZ_get_ok(LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_SpendableOutputDescriptorDecodeErrorZ_get_ok", ()=>CResult_SpendableOutputDescriptorDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_SpendableOutputDescriptorDecodeErrorZ_get_err(LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_SpendableOutputDescriptorDecodeErrorZ_get_err", ()=>CResult_SpendableOutputDescriptorDecodeErrorZ_get_err
);
// struct LDKSign CResult_SignDecodeErrorZ_get_ok(LDKCResult_SignDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_SignDecodeErrorZ_get_ok", ()=>CResult_SignDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_SignDecodeErrorZ_get_err(LDKCResult_SignDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_SignDecodeErrorZ_get_err", ()=>CResult_SignDecodeErrorZ_get_err
);
// struct LDKRecoverableSignature CResult_RecoverableSignatureNoneZ_get_ok(LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RecoverableSignatureNoneZ_get_ok", ()=>CResult_RecoverableSignatureNoneZ_get_ok
);
// void CResult_RecoverableSignatureNoneZ_get_err(LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_RecoverableSignatureNoneZ_get_err", ()=>CResult_RecoverableSignatureNoneZ_get_err
);
// struct LDKCVec_CVec_u8ZZ CResult_CVec_CVec_u8ZZNoneZ_get_ok(LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_CVec_u8ZZNoneZ_get_ok", ()=>CResult_CVec_CVec_u8ZZNoneZ_get_ok
);
// void CResult_CVec_CVec_u8ZZNoneZ_get_err(LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_CVec_u8ZZNoneZ_get_err", ()=>CResult_CVec_CVec_u8ZZNoneZ_get_err
);
// struct LDKInMemorySigner CResult_InMemorySignerDecodeErrorZ_get_ok(LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_InMemorySignerDecodeErrorZ_get_ok", ()=>CResult_InMemorySignerDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_InMemorySignerDecodeErrorZ_get_err(LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_InMemorySignerDecodeErrorZ_get_err", ()=>CResult_InMemorySignerDecodeErrorZ_get_err
);
// struct LDKTransaction CResult_TransactionNoneZ_get_ok(LDKCResult_TransactionNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_TransactionNoneZ_get_ok", ()=>CResult_TransactionNoneZ_get_ok
);
// void CResult_TransactionNoneZ_get_err(LDKCResult_TransactionNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_TransactionNoneZ_get_err", ()=>CResult_TransactionNoneZ_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKFilter_new", ()=>LDKFilter_new
);
// void Filter_register_tx LDKFilter *NONNULL_PTR this_arg, const uint8_t (*txid)[32], struct LDKu8slice script_pubkey
/* @internal */ parcelHelpers.export(exports, "Filter_register_tx", ()=>Filter_register_tx
);
// LDKCOption_C2Tuple_usizeTransactionZZ Filter_register_output LDKFilter *NONNULL_PTR this_arg, struct LDKWatchedOutput output
/* @internal */ parcelHelpers.export(exports, "Filter_register_output", ()=>Filter_register_output
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_FilterZ", ()=>LDKCOption_FilterZ
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_FilterZ_ty_from_ptr", ()=>LDKCOption_FilterZ_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_FilterZ_Some_get_some", ()=>LDKCOption_FilterZ_Some_get_some
);
// struct LDKLockedChannelMonitor *CResult_LockedChannelMonitorNoneZ_get_ok(LDKCResult_LockedChannelMonitorNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_LockedChannelMonitorNoneZ_get_ok", ()=>CResult_LockedChannelMonitorNoneZ_get_ok
);
// void CResult_LockedChannelMonitorNoneZ_get_err(LDKCResult_LockedChannelMonitorNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_LockedChannelMonitorNoneZ_get_err", ()=>CResult_LockedChannelMonitorNoneZ_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKAPIError", ()=>LDKAPIError
);
/* @internal */ parcelHelpers.export(exports, "LDKAPIError_ty_from_ptr", ()=>LDKAPIError_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKAPIError_APIMisuseError_get_err", ()=>LDKAPIError_APIMisuseError_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKAPIError_FeeRateTooHigh_get_err", ()=>LDKAPIError_FeeRateTooHigh_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKAPIError_FeeRateTooHigh_get_feerate", ()=>LDKAPIError_FeeRateTooHigh_get_feerate
);
/* @internal */ parcelHelpers.export(exports, "LDKAPIError_RouteError_get_err", ()=>LDKAPIError_RouteError_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKAPIError_ChannelUnavailable_get_err", ()=>LDKAPIError_ChannelUnavailable_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKAPIError_IncompatibleShutdownScript_get_script", ()=>LDKAPIError_IncompatibleShutdownScript_get_script
);
// void CResult_NoneAPIErrorZ_get_ok(LDKCResult_NoneAPIErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneAPIErrorZ_get_ok", ()=>CResult_NoneAPIErrorZ_get_ok
);
// struct LDKAPIError CResult_NoneAPIErrorZ_get_err(LDKCResult_NoneAPIErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneAPIErrorZ_get_err", ()=>CResult_NoneAPIErrorZ_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_u16Z", ()=>LDKCOption_u16Z
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_u16Z_ty_from_ptr", ()=>LDKCOption_u16Z_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKCOption_u16Z_Some_get_some", ()=>LDKCOption_u16Z_Some_get_some
);
// struct LDKThirtyTwoBytes CResult__u832APIErrorZ_get_ok(LDKCResult__u832APIErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult__u832APIErrorZ_get_ok", ()=>CResult__u832APIErrorZ_get_ok
);
// struct LDKAPIError CResult__u832APIErrorZ_get_err(LDKCResult__u832APIErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult__u832APIErrorZ_get_err", ()=>CResult__u832APIErrorZ_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKPaymentSendFailure", ()=>LDKPaymentSendFailure
);
/* @internal */ parcelHelpers.export(exports, "LDKPaymentSendFailure_ty_from_ptr", ()=>LDKPaymentSendFailure_ty_from_ptr
);
/* @internal */ parcelHelpers.export(exports, "LDKPaymentSendFailure_ParameterError_get_parameter_error", ()=>LDKPaymentSendFailure_ParameterError_get_parameter_error
);
/* @internal */ parcelHelpers.export(exports, "LDKPaymentSendFailure_PathParameterError_get_path_parameter_error", ()=>LDKPaymentSendFailure_PathParameterError_get_path_parameter_error
);
/* @internal */ parcelHelpers.export(exports, "LDKPaymentSendFailure_AllFailedRetrySafe_get_all_failed_retry_safe", ()=>LDKPaymentSendFailure_AllFailedRetrySafe_get_all_failed_retry_safe
);
/* @internal */ parcelHelpers.export(exports, "LDKPaymentSendFailure_PartialFailure_get_results", ()=>LDKPaymentSendFailure_PartialFailure_get_results
);
/* @internal */ parcelHelpers.export(exports, "LDKPaymentSendFailure_PartialFailure_get_failed_paths_retry", ()=>LDKPaymentSendFailure_PartialFailure_get_failed_paths_retry
);
/* @internal */ parcelHelpers.export(exports, "LDKPaymentSendFailure_PartialFailure_get_payment_id", ()=>LDKPaymentSendFailure_PartialFailure_get_payment_id
);
// struct LDKThirtyTwoBytes CResult_PaymentIdPaymentSendFailureZ_get_ok(LDKCResult_PaymentIdPaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentIdPaymentSendFailureZ_get_ok", ()=>CResult_PaymentIdPaymentSendFailureZ_get_ok
);
// struct LDKPaymentSendFailure CResult_PaymentIdPaymentSendFailureZ_get_err(LDKCResult_PaymentIdPaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentIdPaymentSendFailureZ_get_err", ()=>CResult_PaymentIdPaymentSendFailureZ_get_err
);
// void CResult_NonePaymentSendFailureZ_get_ok(LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NonePaymentSendFailureZ_get_ok", ()=>CResult_NonePaymentSendFailureZ_get_ok
);
// struct LDKPaymentSendFailure CResult_NonePaymentSendFailureZ_get_err(LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_NonePaymentSendFailureZ_get_err", ()=>CResult_NonePaymentSendFailureZ_get_err
);
// struct LDKThirtyTwoBytes C2Tuple_PaymentHashPaymentIdZ_get_a(LDKC2Tuple_PaymentHashPaymentIdZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PaymentHashPaymentIdZ_get_a", ()=>C2Tuple_PaymentHashPaymentIdZ_get_a
);
// struct LDKThirtyTwoBytes C2Tuple_PaymentHashPaymentIdZ_get_b(LDKC2Tuple_PaymentHashPaymentIdZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PaymentHashPaymentIdZ_get_b", ()=>C2Tuple_PaymentHashPaymentIdZ_get_b
);
// struct LDKC2Tuple_PaymentHashPaymentIdZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_ok(LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_ok", ()=>CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_ok
);
// struct LDKPaymentSendFailure CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_err(LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_err", ()=>CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_err
);
// struct LDKThirtyTwoBytes C2Tuple_PaymentHashPaymentSecretZ_get_a(LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PaymentHashPaymentSecretZ_get_a", ()=>C2Tuple_PaymentHashPaymentSecretZ_get_a
);
// struct LDKThirtyTwoBytes C2Tuple_PaymentHashPaymentSecretZ_get_b(LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PaymentHashPaymentSecretZ_get_b", ()=>C2Tuple_PaymentHashPaymentSecretZ_get_b
);
// struct LDKC2Tuple_PaymentHashPaymentSecretZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_ok(LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_ok", ()=>CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_ok
);
// void CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_err(LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_err", ()=>CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_err
);
// struct LDKC2Tuple_PaymentHashPaymentSecretZ CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_ok(LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_ok", ()=>CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_ok
);
// struct LDKAPIError CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_err(LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_err", ()=>CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_err
);
// struct LDKThirtyTwoBytes CResult_PaymentSecretNoneZ_get_ok(LDKCResult_PaymentSecretNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentSecretNoneZ_get_ok", ()=>CResult_PaymentSecretNoneZ_get_ok
);
// void CResult_PaymentSecretNoneZ_get_err(LDKCResult_PaymentSecretNoneZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentSecretNoneZ_get_err", ()=>CResult_PaymentSecretNoneZ_get_err
);
// struct LDKThirtyTwoBytes CResult_PaymentSecretAPIErrorZ_get_ok(LDKCResult_PaymentSecretAPIErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentSecretAPIErrorZ_get_ok", ()=>CResult_PaymentSecretAPIErrorZ_get_ok
);
// struct LDKAPIError CResult_PaymentSecretAPIErrorZ_get_err(LDKCResult_PaymentSecretAPIErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentSecretAPIErrorZ_get_err", ()=>CResult_PaymentSecretAPIErrorZ_get_err
);
// struct LDKThirtyTwoBytes CResult_PaymentPreimageAPIErrorZ_get_ok(LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentPreimageAPIErrorZ_get_ok", ()=>CResult_PaymentPreimageAPIErrorZ_get_ok
);
// struct LDKAPIError CResult_PaymentPreimageAPIErrorZ_get_err(LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentPreimageAPIErrorZ_get_err", ()=>CResult_PaymentPreimageAPIErrorZ_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKWatch_new", ()=>LDKWatch_new
);
// LDKCResult_NoneChannelMonitorUpdateErrZ Watch_watch_channel LDKWatch *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo, struct LDKChannelMonitor monitor
/* @internal */ parcelHelpers.export(exports, "Watch_watch_channel", ()=>Watch_watch_channel
);
// LDKCResult_NoneChannelMonitorUpdateErrZ Watch_update_channel LDKWatch *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo, struct LDKChannelMonitorUpdate update
/* @internal */ parcelHelpers.export(exports, "Watch_update_channel", ()=>Watch_update_channel
);
// LDKCVec_MonitorEventZ Watch_release_pending_monitor_events LDKWatch *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "Watch_release_pending_monitor_events", ()=>Watch_release_pending_monitor_events
);
/* @internal */ parcelHelpers.export(exports, "LDKBroadcasterInterface_new", ()=>LDKBroadcasterInterface_new
);
// void BroadcasterInterface_broadcast_transaction LDKBroadcasterInterface *NONNULL_PTR this_arg, struct LDKTransaction tx
/* @internal */ parcelHelpers.export(exports, "BroadcasterInterface_broadcast_transaction", ()=>BroadcasterInterface_broadcast_transaction
);
/* @internal */ parcelHelpers.export(exports, "LDKKeysInterface_new", ()=>LDKKeysInterface_new
);
// LDKSecretKey KeysInterface_get_node_secret LDKKeysInterface *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "KeysInterface_get_node_secret", ()=>KeysInterface_get_node_secret
);
// LDKCVec_u8Z KeysInterface_get_destination_script LDKKeysInterface *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "KeysInterface_get_destination_script", ()=>KeysInterface_get_destination_script
);
// LDKShutdownScript KeysInterface_get_shutdown_scriptpubkey LDKKeysInterface *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "KeysInterface_get_shutdown_scriptpubkey", ()=>KeysInterface_get_shutdown_scriptpubkey
);
// LDKSign KeysInterface_get_channel_signer LDKKeysInterface *NONNULL_PTR this_arg, bool inbound, uint64_t channel_value_satoshis
/* @internal */ parcelHelpers.export(exports, "KeysInterface_get_channel_signer", ()=>KeysInterface_get_channel_signer
);
// LDKThirtyTwoBytes KeysInterface_get_secure_random_bytes LDKKeysInterface *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "KeysInterface_get_secure_random_bytes", ()=>KeysInterface_get_secure_random_bytes
);
// LDKCResult_SignDecodeErrorZ KeysInterface_read_chan_signer LDKKeysInterface *NONNULL_PTR this_arg, struct LDKu8slice reader
/* @internal */ parcelHelpers.export(exports, "KeysInterface_read_chan_signer", ()=>KeysInterface_read_chan_signer
);
// LDKCResult_RecoverableSignatureNoneZ KeysInterface_sign_invoice LDKKeysInterface *NONNULL_PTR this_arg, struct LDKCVec_u8Z invoice_preimage
/* @internal */ parcelHelpers.export(exports, "KeysInterface_sign_invoice", ()=>KeysInterface_sign_invoice
);
// LDKThirtyTwoBytes KeysInterface_get_inbound_payment_key_material LDKKeysInterface *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "KeysInterface_get_inbound_payment_key_material", ()=>KeysInterface_get_inbound_payment_key_material
);
/* @internal */ parcelHelpers.export(exports, "LDKFeeEstimator_new", ()=>LDKFeeEstimator_new
);
// uint32_t FeeEstimator_get_est_sat_per_1000_weight LDKFeeEstimator *NONNULL_PTR this_arg, enum LDKConfirmationTarget confirmation_target
/* @internal */ parcelHelpers.export(exports, "FeeEstimator_get_est_sat_per_1000_weight", ()=>FeeEstimator_get_est_sat_per_1000_weight
);
/* @internal */ parcelHelpers.export(exports, "LDKLogger_new", ()=>LDKLogger_new
);
// struct LDKThirtyTwoBytes C2Tuple_BlockHashChannelManagerZ_get_a(LDKC2Tuple_BlockHashChannelManagerZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_BlockHashChannelManagerZ_get_a", ()=>C2Tuple_BlockHashChannelManagerZ_get_a
);
// struct LDKChannelManager *C2Tuple_BlockHashChannelManagerZ_get_b(LDKC2Tuple_BlockHashChannelManagerZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_BlockHashChannelManagerZ_get_b", ()=>C2Tuple_BlockHashChannelManagerZ_get_b
);
// struct LDKC2Tuple_BlockHashChannelManagerZ *CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_ok(LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_ok", ()=>CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_ok
);
// struct LDKDecodeError CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_err(LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_err", ()=>CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_err
);
/* @internal */ parcelHelpers.export(exports, "LDKMessageSendEventsProvider_new", ()=>LDKMessageSendEventsProvider_new
);
// LDKCVec_MessageSendEventZ MessageSendEventsProvider_get_and_clear_pending_msg_events LDKMessageSendEventsProvider *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "MessageSendEventsProvider_get_and_clear_pending_msg_events", ()=>MessageSendEventsProvider_get_and_clear_pending_msg_events
);
/* @internal */ parcelHelpers.export(exports, "LDKEventHandler_new", ()=>LDKEventHandler_new
);
// void EventHandler_handle_event LDKEventHandler *NONNULL_PTR this_arg, const struct LDKEvent *NONNULL_PTR event
/* @internal */ parcelHelpers.export(exports, "EventHandler_handle_event", ()=>EventHandler_handle_event
);
/* @internal */ parcelHelpers.export(exports, "LDKEventsProvider_new", ()=>LDKEventsProvider_new
);
// void EventsProvider_process_pending_events LDKEventsProvider *NONNULL_PTR this_arg, struct LDKEventHandler handler
/* @internal */ parcelHelpers.export(exports, "EventsProvider_process_pending_events", ()=>EventsProvider_process_pending_events
);
/* @internal */ parcelHelpers.export(exports, "LDKListen_new", ()=>LDKListen_new
);
// void Listen_block_connected LDKListen *NONNULL_PTR this_arg, struct LDKu8slice block, uint32_t height
/* @internal */ parcelHelpers.export(exports, "Listen_block_connected", ()=>Listen_block_connected
);
// void Listen_block_disconnected LDKListen *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height
/* @internal */ parcelHelpers.export(exports, "Listen_block_disconnected", ()=>Listen_block_disconnected
);
/* @internal */ parcelHelpers.export(exports, "LDKConfirm_new", ()=>LDKConfirm_new
);
// void Confirm_transactions_confirmed LDKConfirm *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height
/* @internal */ parcelHelpers.export(exports, "Confirm_transactions_confirmed", ()=>Confirm_transactions_confirmed
);
// void Confirm_transaction_unconfirmed LDKConfirm *NONNULL_PTR this_arg, const uint8_t (*txid)[32]
/* @internal */ parcelHelpers.export(exports, "Confirm_transaction_unconfirmed", ()=>Confirm_transaction_unconfirmed
);
// void Confirm_best_block_updated LDKConfirm *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height
/* @internal */ parcelHelpers.export(exports, "Confirm_best_block_updated", ()=>Confirm_best_block_updated
);
// LDKCVec_TxidZ Confirm_get_relevant_txids LDKConfirm *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "Confirm_get_relevant_txids", ()=>Confirm_get_relevant_txids
);
/* @internal */ parcelHelpers.export(exports, "LDKPersist_new", ()=>LDKPersist_new
);
// LDKCResult_NoneChannelMonitorUpdateErrZ Persist_persist_new_channel LDKPersist *NONNULL_PTR this_arg, struct LDKOutPoint channel_id, const struct LDKChannelMonitor *NONNULL_PTR data, struct LDKMonitorUpdateId update_id
/* @internal */ parcelHelpers.export(exports, "Persist_persist_new_channel", ()=>Persist_persist_new_channel
);
// LDKCResult_NoneChannelMonitorUpdateErrZ Persist_update_persisted_channel LDKPersist *NONNULL_PTR this_arg, struct LDKOutPoint channel_id, const struct LDKChannelMonitorUpdate *NONNULL_PTR update, const struct LDKChannelMonitor *NONNULL_PTR data, struct LDKMonitorUpdateId update_id
/* @internal */ parcelHelpers.export(exports, "Persist_update_persisted_channel", ()=>Persist_update_persisted_channel
);
/* @internal */ parcelHelpers.export(exports, "LDKChannelMessageHandler_new", ()=>LDKChannelMessageHandler_new
);
// void ChannelMessageHandler_handle_open_channel LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKInitFeatures their_features, const struct LDKOpenChannel *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_open_channel", ()=>ChannelMessageHandler_handle_open_channel
);
// void ChannelMessageHandler_handle_accept_channel LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKInitFeatures their_features, const struct LDKAcceptChannel *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_accept_channel", ()=>ChannelMessageHandler_handle_accept_channel
);
// void ChannelMessageHandler_handle_funding_created LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingCreated *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_funding_created", ()=>ChannelMessageHandler_handle_funding_created
);
// void ChannelMessageHandler_handle_funding_signed LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingSigned *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_funding_signed", ()=>ChannelMessageHandler_handle_funding_signed
);
// void ChannelMessageHandler_handle_funding_locked LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingLocked *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_funding_locked", ()=>ChannelMessageHandler_handle_funding_locked
);
// void ChannelMessageHandler_handle_shutdown LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKInitFeatures *NONNULL_PTR their_features, const struct LDKShutdown *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_shutdown", ()=>ChannelMessageHandler_handle_shutdown
);
// void ChannelMessageHandler_handle_closing_signed LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKClosingSigned *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_closing_signed", ()=>ChannelMessageHandler_handle_closing_signed
);
// void ChannelMessageHandler_handle_update_add_htlc LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateAddHTLC *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_update_add_htlc", ()=>ChannelMessageHandler_handle_update_add_htlc
);
// void ChannelMessageHandler_handle_update_fulfill_htlc LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFulfillHTLC *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_update_fulfill_htlc", ()=>ChannelMessageHandler_handle_update_fulfill_htlc
);
// void ChannelMessageHandler_handle_update_fail_htlc LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFailHTLC *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_update_fail_htlc", ()=>ChannelMessageHandler_handle_update_fail_htlc
);
// void ChannelMessageHandler_handle_update_fail_malformed_htlc LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_update_fail_malformed_htlc", ()=>ChannelMessageHandler_handle_update_fail_malformed_htlc
);
// void ChannelMessageHandler_handle_commitment_signed LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKCommitmentSigned *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_commitment_signed", ()=>ChannelMessageHandler_handle_commitment_signed
);
// void ChannelMessageHandler_handle_revoke_and_ack LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKRevokeAndACK *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_revoke_and_ack", ()=>ChannelMessageHandler_handle_revoke_and_ack
);
// void ChannelMessageHandler_handle_update_fee LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFee *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_update_fee", ()=>ChannelMessageHandler_handle_update_fee
);
// void ChannelMessageHandler_handle_announcement_signatures LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKAnnouncementSignatures *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_announcement_signatures", ()=>ChannelMessageHandler_handle_announcement_signatures
);
// void ChannelMessageHandler_peer_disconnected LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, bool no_connection_possible
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_peer_disconnected", ()=>ChannelMessageHandler_peer_disconnected
);
// void ChannelMessageHandler_peer_connected LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_peer_connected", ()=>ChannelMessageHandler_peer_connected
);
// void ChannelMessageHandler_handle_channel_reestablish LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelReestablish *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_channel_reestablish", ()=>ChannelMessageHandler_handle_channel_reestablish
);
// void ChannelMessageHandler_handle_channel_update LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelUpdate *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_channel_update", ()=>ChannelMessageHandler_handle_channel_update
);
// void ChannelMessageHandler_handle_error LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKErrorMessage *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_handle_error", ()=>ChannelMessageHandler_handle_error
);
/* @internal */ parcelHelpers.export(exports, "LDKRoutingMessageHandler_new", ()=>LDKRoutingMessageHandler_new
);
// LDKCResult_boolLightningErrorZ RoutingMessageHandler_handle_node_announcement LDKRoutingMessageHandler *NONNULL_PTR this_arg, const struct LDKNodeAnnouncement *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "RoutingMessageHandler_handle_node_announcement", ()=>RoutingMessageHandler_handle_node_announcement
);
// LDKCResult_boolLightningErrorZ RoutingMessageHandler_handle_channel_announcement LDKRoutingMessageHandler *NONNULL_PTR this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "RoutingMessageHandler_handle_channel_announcement", ()=>RoutingMessageHandler_handle_channel_announcement
);
// LDKCResult_boolLightningErrorZ RoutingMessageHandler_handle_channel_update LDKRoutingMessageHandler *NONNULL_PTR this_arg, const struct LDKChannelUpdate *NONNULL_PTR msg
/* @internal */ parcelHelpers.export(exports, "RoutingMessageHandler_handle_channel_update", ()=>RoutingMessageHandler_handle_channel_update
);
// LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ RoutingMessageHandler_get_next_channel_announcements LDKRoutingMessageHandler *NONNULL_PTR this_arg, uint64_t starting_point, uint8_t batch_amount
/* @internal */ parcelHelpers.export(exports, "RoutingMessageHandler_get_next_channel_announcements", ()=>RoutingMessageHandler_get_next_channel_announcements
);
// LDKCVec_NodeAnnouncementZ RoutingMessageHandler_get_next_node_announcements LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey starting_point, uint8_t batch_amount
/* @internal */ parcelHelpers.export(exports, "RoutingMessageHandler_get_next_node_announcements", ()=>RoutingMessageHandler_get_next_node_announcements
);
// void RoutingMessageHandler_sync_routing_table LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR init
/* @internal */ parcelHelpers.export(exports, "RoutingMessageHandler_sync_routing_table", ()=>RoutingMessageHandler_sync_routing_table
);
// LDKCResult_NoneLightningErrorZ RoutingMessageHandler_handle_reply_channel_range LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKReplyChannelRange msg
/* @internal */ parcelHelpers.export(exports, "RoutingMessageHandler_handle_reply_channel_range", ()=>RoutingMessageHandler_handle_reply_channel_range
);
// LDKCResult_NoneLightningErrorZ RoutingMessageHandler_handle_reply_short_channel_ids_end LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKReplyShortChannelIdsEnd msg
/* @internal */ parcelHelpers.export(exports, "RoutingMessageHandler_handle_reply_short_channel_ids_end", ()=>RoutingMessageHandler_handle_reply_short_channel_ids_end
);
// LDKCResult_NoneLightningErrorZ RoutingMessageHandler_handle_query_channel_range LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKQueryChannelRange msg
/* @internal */ parcelHelpers.export(exports, "RoutingMessageHandler_handle_query_channel_range", ()=>RoutingMessageHandler_handle_query_channel_range
);
// LDKCResult_NoneLightningErrorZ RoutingMessageHandler_handle_query_short_channel_ids LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKQueryShortChannelIds msg
/* @internal */ parcelHelpers.export(exports, "RoutingMessageHandler_handle_query_short_channel_ids", ()=>RoutingMessageHandler_handle_query_short_channel_ids
);
/* @internal */ parcelHelpers.export(exports, "LDKCustomMessageReader_new", ()=>LDKCustomMessageReader_new
);
// LDKCResult_COption_TypeZDecodeErrorZ CustomMessageReader_read LDKCustomMessageReader *NONNULL_PTR this_arg, uint16_t message_type, struct LDKu8slice buffer
/* @internal */ parcelHelpers.export(exports, "CustomMessageReader_read", ()=>CustomMessageReader_read
);
/* @internal */ parcelHelpers.export(exports, "LDKCustomMessageHandler_new", ()=>LDKCustomMessageHandler_new
);
// LDKCResult_NoneLightningErrorZ CustomMessageHandler_handle_custom_message LDKCustomMessageHandler *NONNULL_PTR this_arg, struct LDKType msg, struct LDKPublicKey sender_node_id
/* @internal */ parcelHelpers.export(exports, "CustomMessageHandler_handle_custom_message", ()=>CustomMessageHandler_handle_custom_message
);
// LDKCVec_C2Tuple_PublicKeyTypeZZ CustomMessageHandler_get_and_clear_pending_msg LDKCustomMessageHandler *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "CustomMessageHandler_get_and_clear_pending_msg", ()=>CustomMessageHandler_get_and_clear_pending_msg
);
/* @internal */ parcelHelpers.export(exports, "LDKSocketDescriptor_new", ()=>LDKSocketDescriptor_new
);
// uintptr_t SocketDescriptor_send_data LDKSocketDescriptor *NONNULL_PTR this_arg, struct LDKu8slice data, bool resume_read
/* @internal */ parcelHelpers.export(exports, "SocketDescriptor_send_data", ()=>SocketDescriptor_send_data
);
// void SocketDescriptor_disconnect_socket LDKSocketDescriptor *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "SocketDescriptor_disconnect_socket", ()=>SocketDescriptor_disconnect_socket
);
// uint64_t SocketDescriptor_hash LDKSocketDescriptor *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "SocketDescriptor_hash", ()=>SocketDescriptor_hash
);
/* @internal */ parcelHelpers.export(exports, "LDKScore_new", ()=>LDKScore_new
);
// uint64_t Score_channel_penalty_msat LDKScore *NONNULL_PTR this_arg, uint64_t short_channel_id, uint64_t send_amt_msat, struct LDKCOption_u64Z channel_capacity_msat, const struct LDKNodeId *NONNULL_PTR source, const struct LDKNodeId *NONNULL_PTR target
/* @internal */ parcelHelpers.export(exports, "Score_channel_penalty_msat", ()=>Score_channel_penalty_msat
);
// void Score_payment_path_failed LDKScore *NONNULL_PTR this_arg, struct LDKCVec_RouteHopZ path, uint64_t short_channel_id
/* @internal */ parcelHelpers.export(exports, "Score_payment_path_failed", ()=>Score_payment_path_failed
);
// void Score_payment_path_successful LDKScore *NONNULL_PTR this_arg, struct LDKCVec_RouteHopZ path
/* @internal */ parcelHelpers.export(exports, "Score_payment_path_successful", ()=>Score_payment_path_successful
);
// LDKCVec_u8Z Score_write LDKScore *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "Score_write", ()=>Score_write
);
/* @internal */ parcelHelpers.export(exports, "LDKLockableScore_new", ()=>LDKLockableScore_new
);
// LDKScore LockableScore_lock LDKLockableScore *NONNULL_PTR this_arg
/* @internal */ parcelHelpers.export(exports, "LockableScore_lock", ()=>LockableScore_lock
);
// struct LDKStr _ldk_get_compiled_version(void);
/* @internal */ parcelHelpers.export(exports, "_ldk_get_compiled_version", ()=>_ldk_get_compiled_version
);
// struct LDKStr _ldk_c_bindings_get_compiled_version(void);
/* @internal */ parcelHelpers.export(exports, "_ldk_c_bindings_get_compiled_version", ()=>_ldk_c_bindings_get_compiled_version
);
// void Transaction_free(struct LDKTransaction _res);
/* @internal */ parcelHelpers.export(exports, "Transaction_free", ()=>Transaction_free
);
// struct LDKTxOut TxOut_new(struct LDKCVec_u8Z script_pubkey, uint64_t value);
/* @internal */ parcelHelpers.export(exports, "TxOut_new", ()=>TxOut_new
);
// void TxOut_free(struct LDKTxOut _res);
/* @internal */ parcelHelpers.export(exports, "TxOut_free", ()=>TxOut_free
);
// uintptr_t TxOut_clone_ptr(LDKTxOut *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "TxOut_clone_ptr", ()=>TxOut_clone_ptr
);
// struct LDKTxOut TxOut_clone(const struct LDKTxOut *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "TxOut_clone", ()=>TxOut_clone
);
// void Str_free(struct LDKStr _res);
/* @internal */ parcelHelpers.export(exports, "Str_free", ()=>Str_free
);
// struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_ok(struct LDKChannelConfig o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelConfigDecodeErrorZ_ok", ()=>CResult_ChannelConfigDecodeErrorZ_ok
);
// struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelConfigDecodeErrorZ_err", ()=>CResult_ChannelConfigDecodeErrorZ_err
);
// bool CResult_ChannelConfigDecodeErrorZ_is_ok(const struct LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelConfigDecodeErrorZ_is_ok", ()=>CResult_ChannelConfigDecodeErrorZ_is_ok
);
// void CResult_ChannelConfigDecodeErrorZ_free(struct LDKCResult_ChannelConfigDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelConfigDecodeErrorZ_free", ()=>CResult_ChannelConfigDecodeErrorZ_free
);
// uintptr_t CResult_ChannelConfigDecodeErrorZ_clone_ptr(LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelConfigDecodeErrorZ_clone_ptr", ()=>CResult_ChannelConfigDecodeErrorZ_clone_ptr
);
// struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_clone(const struct LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelConfigDecodeErrorZ_clone", ()=>CResult_ChannelConfigDecodeErrorZ_clone
);
// struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_ok(struct LDKOutPoint o);
/* @internal */ parcelHelpers.export(exports, "CResult_OutPointDecodeErrorZ_ok", ()=>CResult_OutPointDecodeErrorZ_ok
);
// struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_OutPointDecodeErrorZ_err", ()=>CResult_OutPointDecodeErrorZ_err
);
// bool CResult_OutPointDecodeErrorZ_is_ok(const struct LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_OutPointDecodeErrorZ_is_ok", ()=>CResult_OutPointDecodeErrorZ_is_ok
);
// void CResult_OutPointDecodeErrorZ_free(struct LDKCResult_OutPointDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_OutPointDecodeErrorZ_free", ()=>CResult_OutPointDecodeErrorZ_free
);
// uintptr_t CResult_OutPointDecodeErrorZ_clone_ptr(LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_OutPointDecodeErrorZ_clone_ptr", ()=>CResult_OutPointDecodeErrorZ_clone_ptr
);
// struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_clone(const struct LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_OutPointDecodeErrorZ_clone", ()=>CResult_OutPointDecodeErrorZ_clone
);
// struct LDKCResult_SecretKeyErrorZ CResult_SecretKeyErrorZ_ok(struct LDKSecretKey o);
/* @internal */ parcelHelpers.export(exports, "CResult_SecretKeyErrorZ_ok", ()=>CResult_SecretKeyErrorZ_ok
);
// struct LDKCResult_SecretKeyErrorZ CResult_SecretKeyErrorZ_err(enum LDKSecp256k1Error e);
/* @internal */ parcelHelpers.export(exports, "CResult_SecretKeyErrorZ_err", ()=>CResult_SecretKeyErrorZ_err
);
// bool CResult_SecretKeyErrorZ_is_ok(const struct LDKCResult_SecretKeyErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_SecretKeyErrorZ_is_ok", ()=>CResult_SecretKeyErrorZ_is_ok
);
// void CResult_SecretKeyErrorZ_free(struct LDKCResult_SecretKeyErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_SecretKeyErrorZ_free", ()=>CResult_SecretKeyErrorZ_free
);
// struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_ok(struct LDKPublicKey o);
/* @internal */ parcelHelpers.export(exports, "CResult_PublicKeyErrorZ_ok", ()=>CResult_PublicKeyErrorZ_ok
);
// struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_err(enum LDKSecp256k1Error e);
/* @internal */ parcelHelpers.export(exports, "CResult_PublicKeyErrorZ_err", ()=>CResult_PublicKeyErrorZ_err
);
// bool CResult_PublicKeyErrorZ_is_ok(const struct LDKCResult_PublicKeyErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_PublicKeyErrorZ_is_ok", ()=>CResult_PublicKeyErrorZ_is_ok
);
// void CResult_PublicKeyErrorZ_free(struct LDKCResult_PublicKeyErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_PublicKeyErrorZ_free", ()=>CResult_PublicKeyErrorZ_free
);
// uintptr_t CResult_PublicKeyErrorZ_clone_ptr(LDKCResult_PublicKeyErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_PublicKeyErrorZ_clone_ptr", ()=>CResult_PublicKeyErrorZ_clone_ptr
);
// struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_clone(const struct LDKCResult_PublicKeyErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_PublicKeyErrorZ_clone", ()=>CResult_PublicKeyErrorZ_clone
);
// struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_ok(struct LDKTxCreationKeys o);
/* @internal */ parcelHelpers.export(exports, "CResult_TxCreationKeysDecodeErrorZ_ok", ()=>CResult_TxCreationKeysDecodeErrorZ_ok
);
// struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_TxCreationKeysDecodeErrorZ_err", ()=>CResult_TxCreationKeysDecodeErrorZ_err
);
// bool CResult_TxCreationKeysDecodeErrorZ_is_ok(const struct LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_TxCreationKeysDecodeErrorZ_is_ok", ()=>CResult_TxCreationKeysDecodeErrorZ_is_ok
);
// void CResult_TxCreationKeysDecodeErrorZ_free(struct LDKCResult_TxCreationKeysDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_TxCreationKeysDecodeErrorZ_free", ()=>CResult_TxCreationKeysDecodeErrorZ_free
);
// uintptr_t CResult_TxCreationKeysDecodeErrorZ_clone_ptr(LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_TxCreationKeysDecodeErrorZ_clone_ptr", ()=>CResult_TxCreationKeysDecodeErrorZ_clone_ptr
);
// struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_clone(const struct LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_TxCreationKeysDecodeErrorZ_clone", ()=>CResult_TxCreationKeysDecodeErrorZ_clone
);
// struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_ok(struct LDKChannelPublicKeys o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelPublicKeysDecodeErrorZ_ok", ()=>CResult_ChannelPublicKeysDecodeErrorZ_ok
);
// struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelPublicKeysDecodeErrorZ_err", ()=>CResult_ChannelPublicKeysDecodeErrorZ_err
);
// bool CResult_ChannelPublicKeysDecodeErrorZ_is_ok(const struct LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelPublicKeysDecodeErrorZ_is_ok", ()=>CResult_ChannelPublicKeysDecodeErrorZ_is_ok
);
// void CResult_ChannelPublicKeysDecodeErrorZ_free(struct LDKCResult_ChannelPublicKeysDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelPublicKeysDecodeErrorZ_free", ()=>CResult_ChannelPublicKeysDecodeErrorZ_free
);
// uintptr_t CResult_ChannelPublicKeysDecodeErrorZ_clone_ptr(LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelPublicKeysDecodeErrorZ_clone_ptr", ()=>CResult_ChannelPublicKeysDecodeErrorZ_clone_ptr
);
// struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_clone(const struct LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelPublicKeysDecodeErrorZ_clone", ()=>CResult_ChannelPublicKeysDecodeErrorZ_clone
);
// struct LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_ok(struct LDKTxCreationKeys o);
/* @internal */ parcelHelpers.export(exports, "CResult_TxCreationKeysErrorZ_ok", ()=>CResult_TxCreationKeysErrorZ_ok
);
// struct LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_err(enum LDKSecp256k1Error e);
/* @internal */ parcelHelpers.export(exports, "CResult_TxCreationKeysErrorZ_err", ()=>CResult_TxCreationKeysErrorZ_err
);
// bool CResult_TxCreationKeysErrorZ_is_ok(const struct LDKCResult_TxCreationKeysErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_TxCreationKeysErrorZ_is_ok", ()=>CResult_TxCreationKeysErrorZ_is_ok
);
// void CResult_TxCreationKeysErrorZ_free(struct LDKCResult_TxCreationKeysErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_TxCreationKeysErrorZ_free", ()=>CResult_TxCreationKeysErrorZ_free
);
// uintptr_t CResult_TxCreationKeysErrorZ_clone_ptr(LDKCResult_TxCreationKeysErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_TxCreationKeysErrorZ_clone_ptr", ()=>CResult_TxCreationKeysErrorZ_clone_ptr
);
// struct LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_clone(const struct LDKCResult_TxCreationKeysErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_TxCreationKeysErrorZ_clone", ()=>CResult_TxCreationKeysErrorZ_clone
);
// struct LDKCOption_u32Z COption_u32Z_some(uint32_t o);
/* @internal */ parcelHelpers.export(exports, "COption_u32Z_some", ()=>COption_u32Z_some
);
// struct LDKCOption_u32Z COption_u32Z_none(void);
/* @internal */ parcelHelpers.export(exports, "COption_u32Z_none", ()=>COption_u32Z_none
);
// void COption_u32Z_free(struct LDKCOption_u32Z _res);
/* @internal */ parcelHelpers.export(exports, "COption_u32Z_free", ()=>COption_u32Z_free
);
// uintptr_t COption_u32Z_clone_ptr(LDKCOption_u32Z *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "COption_u32Z_clone_ptr", ()=>COption_u32Z_clone_ptr
);
// struct LDKCOption_u32Z COption_u32Z_clone(const struct LDKCOption_u32Z *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "COption_u32Z_clone", ()=>COption_u32Z_clone
);
// struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(struct LDKHTLCOutputInCommitment o);
/* @internal */ parcelHelpers.export(exports, "CResult_HTLCOutputInCommitmentDecodeErrorZ_ok", ()=>CResult_HTLCOutputInCommitmentDecodeErrorZ_ok
);
// struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_HTLCOutputInCommitmentDecodeErrorZ_err", ()=>CResult_HTLCOutputInCommitmentDecodeErrorZ_err
);
// bool CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(const struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok", ()=>CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok
);
// void CResult_HTLCOutputInCommitmentDecodeErrorZ_free(struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_HTLCOutputInCommitmentDecodeErrorZ_free", ()=>CResult_HTLCOutputInCommitmentDecodeErrorZ_free
);
// uintptr_t CResult_HTLCOutputInCommitmentDecodeErrorZ_clone_ptr(LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_HTLCOutputInCommitmentDecodeErrorZ_clone_ptr", ()=>CResult_HTLCOutputInCommitmentDecodeErrorZ_clone_ptr
);
// struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(const struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_HTLCOutputInCommitmentDecodeErrorZ_clone", ()=>CResult_HTLCOutputInCommitmentDecodeErrorZ_clone
);
// enum LDKCOption_NoneZ COption_NoneZ_some(void);
/* @internal */ parcelHelpers.export(exports, "COption_NoneZ_some", ()=>COption_NoneZ_some
);
// enum LDKCOption_NoneZ COption_NoneZ_none(void);
/* @internal */ parcelHelpers.export(exports, "COption_NoneZ_none", ()=>COption_NoneZ_none
);
// void COption_NoneZ_free(enum LDKCOption_NoneZ _res);
/* @internal */ parcelHelpers.export(exports, "COption_NoneZ_free", ()=>COption_NoneZ_free
);
// struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(struct LDKCounterpartyChannelTransactionParameters o);
/* @internal */ parcelHelpers.export(exports, "CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok", ()=>CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok
);
// struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err", ()=>CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err
);
// bool CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(const struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok", ()=>CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok
);
// void CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free", ()=>CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free
);
// uintptr_t CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone_ptr(LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone_ptr", ()=>CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone_ptr
);
// struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(const struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone", ()=>CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone
);
// struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_ok(struct LDKChannelTransactionParameters o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelTransactionParametersDecodeErrorZ_ok", ()=>CResult_ChannelTransactionParametersDecodeErrorZ_ok
);
// struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelTransactionParametersDecodeErrorZ_err", ()=>CResult_ChannelTransactionParametersDecodeErrorZ_err
);
// bool CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(const struct LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelTransactionParametersDecodeErrorZ_is_ok", ()=>CResult_ChannelTransactionParametersDecodeErrorZ_is_ok
);
// void CResult_ChannelTransactionParametersDecodeErrorZ_free(struct LDKCResult_ChannelTransactionParametersDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelTransactionParametersDecodeErrorZ_free", ()=>CResult_ChannelTransactionParametersDecodeErrorZ_free
);
// uintptr_t CResult_ChannelTransactionParametersDecodeErrorZ_clone_ptr(LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelTransactionParametersDecodeErrorZ_clone_ptr", ()=>CResult_ChannelTransactionParametersDecodeErrorZ_clone_ptr
);
// struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_clone(const struct LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelTransactionParametersDecodeErrorZ_clone", ()=>CResult_ChannelTransactionParametersDecodeErrorZ_clone
);
// void CVec_SignatureZ_free(struct LDKCVec_SignatureZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_SignatureZ_free", ()=>CVec_SignatureZ_free
);
// struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_ok(struct LDKHolderCommitmentTransaction o);
/* @internal */ parcelHelpers.export(exports, "CResult_HolderCommitmentTransactionDecodeErrorZ_ok", ()=>CResult_HolderCommitmentTransactionDecodeErrorZ_ok
);
// struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_HolderCommitmentTransactionDecodeErrorZ_err", ()=>CResult_HolderCommitmentTransactionDecodeErrorZ_err
);
// bool CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok", ()=>CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok
);
// void CResult_HolderCommitmentTransactionDecodeErrorZ_free(struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_HolderCommitmentTransactionDecodeErrorZ_free", ()=>CResult_HolderCommitmentTransactionDecodeErrorZ_free
);
// uintptr_t CResult_HolderCommitmentTransactionDecodeErrorZ_clone_ptr(LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_HolderCommitmentTransactionDecodeErrorZ_clone_ptr", ()=>CResult_HolderCommitmentTransactionDecodeErrorZ_clone_ptr
);
// struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_HolderCommitmentTransactionDecodeErrorZ_clone", ()=>CResult_HolderCommitmentTransactionDecodeErrorZ_clone
);
// struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(struct LDKBuiltCommitmentTransaction o);
/* @internal */ parcelHelpers.export(exports, "CResult_BuiltCommitmentTransactionDecodeErrorZ_ok", ()=>CResult_BuiltCommitmentTransactionDecodeErrorZ_ok
);
// struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_BuiltCommitmentTransactionDecodeErrorZ_err", ()=>CResult_BuiltCommitmentTransactionDecodeErrorZ_err
);
// bool CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok", ()=>CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok
);
// void CResult_BuiltCommitmentTransactionDecodeErrorZ_free(struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_BuiltCommitmentTransactionDecodeErrorZ_free", ()=>CResult_BuiltCommitmentTransactionDecodeErrorZ_free
);
// uintptr_t CResult_BuiltCommitmentTransactionDecodeErrorZ_clone_ptr(LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_BuiltCommitmentTransactionDecodeErrorZ_clone_ptr", ()=>CResult_BuiltCommitmentTransactionDecodeErrorZ_clone_ptr
);
// struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_BuiltCommitmentTransactionDecodeErrorZ_clone", ()=>CResult_BuiltCommitmentTransactionDecodeErrorZ_clone
);
// struct LDKCResult_TrustedClosingTransactionNoneZ CResult_TrustedClosingTransactionNoneZ_ok(struct LDKTrustedClosingTransaction o);
/* @internal */ parcelHelpers.export(exports, "CResult_TrustedClosingTransactionNoneZ_ok", ()=>CResult_TrustedClosingTransactionNoneZ_ok
);
// struct LDKCResult_TrustedClosingTransactionNoneZ CResult_TrustedClosingTransactionNoneZ_err(void);
/* @internal */ parcelHelpers.export(exports, "CResult_TrustedClosingTransactionNoneZ_err", ()=>CResult_TrustedClosingTransactionNoneZ_err
);
// bool CResult_TrustedClosingTransactionNoneZ_is_ok(const struct LDKCResult_TrustedClosingTransactionNoneZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_TrustedClosingTransactionNoneZ_is_ok", ()=>CResult_TrustedClosingTransactionNoneZ_is_ok
);
// void CResult_TrustedClosingTransactionNoneZ_free(struct LDKCResult_TrustedClosingTransactionNoneZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_TrustedClosingTransactionNoneZ_free", ()=>CResult_TrustedClosingTransactionNoneZ_free
);
// struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_ok(struct LDKCommitmentTransaction o);
/* @internal */ parcelHelpers.export(exports, "CResult_CommitmentTransactionDecodeErrorZ_ok", ()=>CResult_CommitmentTransactionDecodeErrorZ_ok
);
// struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_CommitmentTransactionDecodeErrorZ_err", ()=>CResult_CommitmentTransactionDecodeErrorZ_err
);
// bool CResult_CommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_CommitmentTransactionDecodeErrorZ_is_ok", ()=>CResult_CommitmentTransactionDecodeErrorZ_is_ok
);
// void CResult_CommitmentTransactionDecodeErrorZ_free(struct LDKCResult_CommitmentTransactionDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_CommitmentTransactionDecodeErrorZ_free", ()=>CResult_CommitmentTransactionDecodeErrorZ_free
);
// uintptr_t CResult_CommitmentTransactionDecodeErrorZ_clone_ptr(LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_CommitmentTransactionDecodeErrorZ_clone_ptr", ()=>CResult_CommitmentTransactionDecodeErrorZ_clone_ptr
);
// struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_CommitmentTransactionDecodeErrorZ_clone", ()=>CResult_CommitmentTransactionDecodeErrorZ_clone
);
// struct LDKCResult_TrustedCommitmentTransactionNoneZ CResult_TrustedCommitmentTransactionNoneZ_ok(struct LDKTrustedCommitmentTransaction o);
/* @internal */ parcelHelpers.export(exports, "CResult_TrustedCommitmentTransactionNoneZ_ok", ()=>CResult_TrustedCommitmentTransactionNoneZ_ok
);
// struct LDKCResult_TrustedCommitmentTransactionNoneZ CResult_TrustedCommitmentTransactionNoneZ_err(void);
/* @internal */ parcelHelpers.export(exports, "CResult_TrustedCommitmentTransactionNoneZ_err", ()=>CResult_TrustedCommitmentTransactionNoneZ_err
);
// bool CResult_TrustedCommitmentTransactionNoneZ_is_ok(const struct LDKCResult_TrustedCommitmentTransactionNoneZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_TrustedCommitmentTransactionNoneZ_is_ok", ()=>CResult_TrustedCommitmentTransactionNoneZ_is_ok
);
// void CResult_TrustedCommitmentTransactionNoneZ_free(struct LDKCResult_TrustedCommitmentTransactionNoneZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_TrustedCommitmentTransactionNoneZ_free", ()=>CResult_TrustedCommitmentTransactionNoneZ_free
);
// struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_ok(struct LDKCVec_SignatureZ o);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_SignatureZNoneZ_ok", ()=>CResult_CVec_SignatureZNoneZ_ok
);
// struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_err(void);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_SignatureZNoneZ_err", ()=>CResult_CVec_SignatureZNoneZ_err
);
// bool CResult_CVec_SignatureZNoneZ_is_ok(const struct LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_SignatureZNoneZ_is_ok", ()=>CResult_CVec_SignatureZNoneZ_is_ok
);
// void CResult_CVec_SignatureZNoneZ_free(struct LDKCResult_CVec_SignatureZNoneZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_SignatureZNoneZ_free", ()=>CResult_CVec_SignatureZNoneZ_free
);
// uintptr_t CResult_CVec_SignatureZNoneZ_clone_ptr(LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_SignatureZNoneZ_clone_ptr", ()=>CResult_CVec_SignatureZNoneZ_clone_ptr
);
// struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_clone(const struct LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_SignatureZNoneZ_clone", ()=>CResult_CVec_SignatureZNoneZ_clone
);
// struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_ok(struct LDKShutdownScript o);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownScriptDecodeErrorZ_ok", ()=>CResult_ShutdownScriptDecodeErrorZ_ok
);
// struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownScriptDecodeErrorZ_err", ()=>CResult_ShutdownScriptDecodeErrorZ_err
);
// bool CResult_ShutdownScriptDecodeErrorZ_is_ok(const struct LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownScriptDecodeErrorZ_is_ok", ()=>CResult_ShutdownScriptDecodeErrorZ_is_ok
);
// void CResult_ShutdownScriptDecodeErrorZ_free(struct LDKCResult_ShutdownScriptDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownScriptDecodeErrorZ_free", ()=>CResult_ShutdownScriptDecodeErrorZ_free
);
// uintptr_t CResult_ShutdownScriptDecodeErrorZ_clone_ptr(LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownScriptDecodeErrorZ_clone_ptr", ()=>CResult_ShutdownScriptDecodeErrorZ_clone_ptr
);
// struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_clone(const struct LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownScriptDecodeErrorZ_clone", ()=>CResult_ShutdownScriptDecodeErrorZ_clone
);
// struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_ok(struct LDKShutdownScript o);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownScriptInvalidShutdownScriptZ_ok", ()=>CResult_ShutdownScriptInvalidShutdownScriptZ_ok
);
// struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_err(struct LDKInvalidShutdownScript e);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownScriptInvalidShutdownScriptZ_err", ()=>CResult_ShutdownScriptInvalidShutdownScriptZ_err
);
// bool CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(const struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok", ()=>CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok
);
// void CResult_ShutdownScriptInvalidShutdownScriptZ_free(struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownScriptInvalidShutdownScriptZ_free", ()=>CResult_ShutdownScriptInvalidShutdownScriptZ_free
);
// uintptr_t CResult_ShutdownScriptInvalidShutdownScriptZ_clone_ptr(LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownScriptInvalidShutdownScriptZ_clone_ptr", ()=>CResult_ShutdownScriptInvalidShutdownScriptZ_clone_ptr
);
// struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_clone(const struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownScriptInvalidShutdownScriptZ_clone", ()=>CResult_ShutdownScriptInvalidShutdownScriptZ_clone
);
// struct LDKCOption_TypeZ COption_TypeZ_some(struct LDKType o);
/* @internal */ parcelHelpers.export(exports, "COption_TypeZ_some", ()=>COption_TypeZ_some
);
// struct LDKCOption_TypeZ COption_TypeZ_none(void);
/* @internal */ parcelHelpers.export(exports, "COption_TypeZ_none", ()=>COption_TypeZ_none
);
// void COption_TypeZ_free(struct LDKCOption_TypeZ _res);
/* @internal */ parcelHelpers.export(exports, "COption_TypeZ_free", ()=>COption_TypeZ_free
);
// uintptr_t COption_TypeZ_clone_ptr(LDKCOption_TypeZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "COption_TypeZ_clone_ptr", ()=>COption_TypeZ_clone_ptr
);
// struct LDKCOption_TypeZ COption_TypeZ_clone(const struct LDKCOption_TypeZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "COption_TypeZ_clone", ()=>COption_TypeZ_clone
);
// struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_ok(struct LDKCOption_TypeZ o);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_TypeZDecodeErrorZ_ok", ()=>CResult_COption_TypeZDecodeErrorZ_ok
);
// struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_TypeZDecodeErrorZ_err", ()=>CResult_COption_TypeZDecodeErrorZ_err
);
// bool CResult_COption_TypeZDecodeErrorZ_is_ok(const struct LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_TypeZDecodeErrorZ_is_ok", ()=>CResult_COption_TypeZDecodeErrorZ_is_ok
);
// void CResult_COption_TypeZDecodeErrorZ_free(struct LDKCResult_COption_TypeZDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_TypeZDecodeErrorZ_free", ()=>CResult_COption_TypeZDecodeErrorZ_free
);
// uintptr_t CResult_COption_TypeZDecodeErrorZ_clone_ptr(LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_TypeZDecodeErrorZ_clone_ptr", ()=>CResult_COption_TypeZDecodeErrorZ_clone_ptr
);
// struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_clone(const struct LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_TypeZDecodeErrorZ_clone", ()=>CResult_COption_TypeZDecodeErrorZ_clone
);
// struct LDKCResult_StringErrorZ CResult_StringErrorZ_ok(struct LDKStr o);
/* @internal */ parcelHelpers.export(exports, "CResult_StringErrorZ_ok", ()=>CResult_StringErrorZ_ok
);
// struct LDKCResult_StringErrorZ CResult_StringErrorZ_err(enum LDKSecp256k1Error e);
/* @internal */ parcelHelpers.export(exports, "CResult_StringErrorZ_err", ()=>CResult_StringErrorZ_err
);
// bool CResult_StringErrorZ_is_ok(const struct LDKCResult_StringErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_StringErrorZ_is_ok", ()=>CResult_StringErrorZ_is_ok
);
// void CResult_StringErrorZ_free(struct LDKCResult_StringErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_StringErrorZ_free", ()=>CResult_StringErrorZ_free
);
// struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_ok(struct LDKChannelMonitorUpdate o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelMonitorUpdateDecodeErrorZ_ok", ()=>CResult_ChannelMonitorUpdateDecodeErrorZ_ok
);
// struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelMonitorUpdateDecodeErrorZ_err", ()=>CResult_ChannelMonitorUpdateDecodeErrorZ_err
);
// bool CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(const struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok", ()=>CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok
);
// void CResult_ChannelMonitorUpdateDecodeErrorZ_free(struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelMonitorUpdateDecodeErrorZ_free", ()=>CResult_ChannelMonitorUpdateDecodeErrorZ_free
);
// uintptr_t CResult_ChannelMonitorUpdateDecodeErrorZ_clone_ptr(LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelMonitorUpdateDecodeErrorZ_clone_ptr", ()=>CResult_ChannelMonitorUpdateDecodeErrorZ_clone_ptr
);
// struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_clone(const struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelMonitorUpdateDecodeErrorZ_clone", ()=>CResult_ChannelMonitorUpdateDecodeErrorZ_clone
);
// struct LDKCOption_MonitorEventZ COption_MonitorEventZ_some(struct LDKMonitorEvent o);
/* @internal */ parcelHelpers.export(exports, "COption_MonitorEventZ_some", ()=>COption_MonitorEventZ_some
);
// struct LDKCOption_MonitorEventZ COption_MonitorEventZ_none(void);
/* @internal */ parcelHelpers.export(exports, "COption_MonitorEventZ_none", ()=>COption_MonitorEventZ_none
);
// void COption_MonitorEventZ_free(struct LDKCOption_MonitorEventZ _res);
/* @internal */ parcelHelpers.export(exports, "COption_MonitorEventZ_free", ()=>COption_MonitorEventZ_free
);
// uintptr_t COption_MonitorEventZ_clone_ptr(LDKCOption_MonitorEventZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "COption_MonitorEventZ_clone_ptr", ()=>COption_MonitorEventZ_clone_ptr
);
// struct LDKCOption_MonitorEventZ COption_MonitorEventZ_clone(const struct LDKCOption_MonitorEventZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "COption_MonitorEventZ_clone", ()=>COption_MonitorEventZ_clone
);
// struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_ok(struct LDKCOption_MonitorEventZ o);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_MonitorEventZDecodeErrorZ_ok", ()=>CResult_COption_MonitorEventZDecodeErrorZ_ok
);
// struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_MonitorEventZDecodeErrorZ_err", ()=>CResult_COption_MonitorEventZDecodeErrorZ_err
);
// bool CResult_COption_MonitorEventZDecodeErrorZ_is_ok(const struct LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_MonitorEventZDecodeErrorZ_is_ok", ()=>CResult_COption_MonitorEventZDecodeErrorZ_is_ok
);
// void CResult_COption_MonitorEventZDecodeErrorZ_free(struct LDKCResult_COption_MonitorEventZDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_MonitorEventZDecodeErrorZ_free", ()=>CResult_COption_MonitorEventZDecodeErrorZ_free
);
// uintptr_t CResult_COption_MonitorEventZDecodeErrorZ_clone_ptr(LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_MonitorEventZDecodeErrorZ_clone_ptr", ()=>CResult_COption_MonitorEventZDecodeErrorZ_clone_ptr
);
// struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_clone(const struct LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_MonitorEventZDecodeErrorZ_clone", ()=>CResult_COption_MonitorEventZDecodeErrorZ_clone
);
// struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_ok(struct LDKHTLCUpdate o);
/* @internal */ parcelHelpers.export(exports, "CResult_HTLCUpdateDecodeErrorZ_ok", ()=>CResult_HTLCUpdateDecodeErrorZ_ok
);
// struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_HTLCUpdateDecodeErrorZ_err", ()=>CResult_HTLCUpdateDecodeErrorZ_err
);
// bool CResult_HTLCUpdateDecodeErrorZ_is_ok(const struct LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_HTLCUpdateDecodeErrorZ_is_ok", ()=>CResult_HTLCUpdateDecodeErrorZ_is_ok
);
// void CResult_HTLCUpdateDecodeErrorZ_free(struct LDKCResult_HTLCUpdateDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_HTLCUpdateDecodeErrorZ_free", ()=>CResult_HTLCUpdateDecodeErrorZ_free
);
// uintptr_t CResult_HTLCUpdateDecodeErrorZ_clone_ptr(LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_HTLCUpdateDecodeErrorZ_clone_ptr", ()=>CResult_HTLCUpdateDecodeErrorZ_clone_ptr
);
// struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_clone(const struct LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_HTLCUpdateDecodeErrorZ_clone", ()=>CResult_HTLCUpdateDecodeErrorZ_clone
);
// struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_ok(void);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneNoneZ_ok", ()=>CResult_NoneNoneZ_ok
);
// struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_err(void);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneNoneZ_err", ()=>CResult_NoneNoneZ_err
);
// bool CResult_NoneNoneZ_is_ok(const struct LDKCResult_NoneNoneZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneNoneZ_is_ok", ()=>CResult_NoneNoneZ_is_ok
);
// void CResult_NoneNoneZ_free(struct LDKCResult_NoneNoneZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneNoneZ_free", ()=>CResult_NoneNoneZ_free
);
// uintptr_t CResult_NoneNoneZ_clone_ptr(LDKCResult_NoneNoneZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneNoneZ_clone_ptr", ()=>CResult_NoneNoneZ_clone_ptr
);
// struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_clone(const struct LDKCResult_NoneNoneZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneNoneZ_clone", ()=>CResult_NoneNoneZ_clone
);
// struct LDKC2Tuple_OutPointScriptZ C2Tuple_OutPointScriptZ_new(struct LDKOutPoint a, struct LDKCVec_u8Z b);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_OutPointScriptZ_new", ()=>C2Tuple_OutPointScriptZ_new
);
// void C2Tuple_OutPointScriptZ_free(struct LDKC2Tuple_OutPointScriptZ _res);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_OutPointScriptZ_free", ()=>C2Tuple_OutPointScriptZ_free
);
// struct LDKC2Tuple_u32ScriptZ C2Tuple_u32ScriptZ_new(uint32_t a, struct LDKCVec_u8Z b);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_u32ScriptZ_new", ()=>C2Tuple_u32ScriptZ_new
);
// void C2Tuple_u32ScriptZ_free(struct LDKC2Tuple_u32ScriptZ _res);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_u32ScriptZ_free", ()=>C2Tuple_u32ScriptZ_free
);
// void CVec_C2Tuple_u32ScriptZZ_free(struct LDKCVec_C2Tuple_u32ScriptZZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_C2Tuple_u32ScriptZZ_free", ()=>CVec_C2Tuple_u32ScriptZZ_free
);
// struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(struct LDKThirtyTwoBytes a, struct LDKCVec_C2Tuple_u32ScriptZZ b);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new", ()=>C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new
);
// void C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free(struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ _res);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free", ()=>C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free
);
// void CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free(struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free", ()=>CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free
);
// void CVec_MonitorEventZ_free(struct LDKCVec_MonitorEventZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_MonitorEventZ_free", ()=>CVec_MonitorEventZ_free
);
// void CVec_EventZ_free(struct LDKCVec_EventZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_EventZ_free", ()=>CVec_EventZ_free
);
// void CVec_TransactionZ_free(struct LDKCVec_TransactionZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_TransactionZ_free", ()=>CVec_TransactionZ_free
);
// uintptr_t C2Tuple_usizeTransactionZ_clone_ptr(LDKC2Tuple_usizeTransactionZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_usizeTransactionZ_clone_ptr", ()=>C2Tuple_usizeTransactionZ_clone_ptr
);
// struct LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_clone(const struct LDKC2Tuple_usizeTransactionZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_usizeTransactionZ_clone", ()=>C2Tuple_usizeTransactionZ_clone
);
// struct LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_new(uintptr_t a, struct LDKTransaction b);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_usizeTransactionZ_new", ()=>C2Tuple_usizeTransactionZ_new
);
// void C2Tuple_usizeTransactionZ_free(struct LDKC2Tuple_usizeTransactionZ _res);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_usizeTransactionZ_free", ()=>C2Tuple_usizeTransactionZ_free
);
// void CVec_C2Tuple_usizeTransactionZZ_free(struct LDKCVec_C2Tuple_usizeTransactionZZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_C2Tuple_usizeTransactionZZ_free", ()=>CVec_C2Tuple_usizeTransactionZZ_free
);
// uintptr_t C2Tuple_u32TxOutZ_clone_ptr(LDKC2Tuple_u32TxOutZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_u32TxOutZ_clone_ptr", ()=>C2Tuple_u32TxOutZ_clone_ptr
);
// struct LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_clone(const struct LDKC2Tuple_u32TxOutZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_u32TxOutZ_clone", ()=>C2Tuple_u32TxOutZ_clone
);
// struct LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_new(uint32_t a, struct LDKTxOut b);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_u32TxOutZ_new", ()=>C2Tuple_u32TxOutZ_new
);
// void C2Tuple_u32TxOutZ_free(struct LDKC2Tuple_u32TxOutZ _res);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_u32TxOutZ_free", ()=>C2Tuple_u32TxOutZ_free
);
// void CVec_C2Tuple_u32TxOutZZ_free(struct LDKCVec_C2Tuple_u32TxOutZZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_C2Tuple_u32TxOutZZ_free", ()=>CVec_C2Tuple_u32TxOutZZ_free
);
// uintptr_t C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone_ptr(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone_ptr", ()=>C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone_ptr
);
// struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(const struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone", ()=>C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone
);
// struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(struct LDKThirtyTwoBytes a, struct LDKCVec_C2Tuple_u32TxOutZZ b);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new", ()=>C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new
);
// void C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free(struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ _res);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free", ()=>C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free
);
// void CVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ_free(struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ_free", ()=>CVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ_free
);
// void CVec_TxidZ_free(struct LDKCVec_TxidZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_TxidZ_free", ()=>CVec_TxidZ_free
);
// void CVec_BalanceZ_free(struct LDKCVec_BalanceZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_BalanceZ_free", ()=>CVec_BalanceZ_free
);
// uintptr_t C2Tuple_BlockHashChannelMonitorZ_clone_ptr(LDKC2Tuple_BlockHashChannelMonitorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_BlockHashChannelMonitorZ_clone_ptr", ()=>C2Tuple_BlockHashChannelMonitorZ_clone_ptr
);
// struct LDKC2Tuple_BlockHashChannelMonitorZ C2Tuple_BlockHashChannelMonitorZ_clone(const struct LDKC2Tuple_BlockHashChannelMonitorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_BlockHashChannelMonitorZ_clone", ()=>C2Tuple_BlockHashChannelMonitorZ_clone
);
// struct LDKC2Tuple_BlockHashChannelMonitorZ C2Tuple_BlockHashChannelMonitorZ_new(struct LDKThirtyTwoBytes a, struct LDKChannelMonitor b);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_BlockHashChannelMonitorZ_new", ()=>C2Tuple_BlockHashChannelMonitorZ_new
);
// void C2Tuple_BlockHashChannelMonitorZ_free(struct LDKC2Tuple_BlockHashChannelMonitorZ _res);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_BlockHashChannelMonitorZ_free", ()=>C2Tuple_BlockHashChannelMonitorZ_free
);
// struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(struct LDKC2Tuple_BlockHashChannelMonitorZ o);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok", ()=>CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok
);
// struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err", ()=>CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err
);
// bool CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok(const struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok", ()=>CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok
);
// void CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free(struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free", ()=>CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free
);
// uintptr_t CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone_ptr(LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone_ptr", ()=>CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone_ptr
);
// struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone(const struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone", ()=>CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone
);
// struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_ok(struct LDKRouteHop o);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHopDecodeErrorZ_ok", ()=>CResult_RouteHopDecodeErrorZ_ok
);
// struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHopDecodeErrorZ_err", ()=>CResult_RouteHopDecodeErrorZ_err
);
// bool CResult_RouteHopDecodeErrorZ_is_ok(const struct LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHopDecodeErrorZ_is_ok", ()=>CResult_RouteHopDecodeErrorZ_is_ok
);
// void CResult_RouteHopDecodeErrorZ_free(struct LDKCResult_RouteHopDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHopDecodeErrorZ_free", ()=>CResult_RouteHopDecodeErrorZ_free
);
// uintptr_t CResult_RouteHopDecodeErrorZ_clone_ptr(LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHopDecodeErrorZ_clone_ptr", ()=>CResult_RouteHopDecodeErrorZ_clone_ptr
);
// struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_clone(const struct LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHopDecodeErrorZ_clone", ()=>CResult_RouteHopDecodeErrorZ_clone
);
// void CVec_RouteHopZ_free(struct LDKCVec_RouteHopZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_RouteHopZ_free", ()=>CVec_RouteHopZ_free
);
// void CVec_CVec_RouteHopZZ_free(struct LDKCVec_CVec_RouteHopZZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_CVec_RouteHopZZ_free", ()=>CVec_CVec_RouteHopZZ_free
);
// struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_ok(struct LDKRoute o);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteDecodeErrorZ_ok", ()=>CResult_RouteDecodeErrorZ_ok
);
// struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteDecodeErrorZ_err", ()=>CResult_RouteDecodeErrorZ_err
);
// bool CResult_RouteDecodeErrorZ_is_ok(const struct LDKCResult_RouteDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteDecodeErrorZ_is_ok", ()=>CResult_RouteDecodeErrorZ_is_ok
);
// void CResult_RouteDecodeErrorZ_free(struct LDKCResult_RouteDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteDecodeErrorZ_free", ()=>CResult_RouteDecodeErrorZ_free
);
// uintptr_t CResult_RouteDecodeErrorZ_clone_ptr(LDKCResult_RouteDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteDecodeErrorZ_clone_ptr", ()=>CResult_RouteDecodeErrorZ_clone_ptr
);
// struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_clone(const struct LDKCResult_RouteDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteDecodeErrorZ_clone", ()=>CResult_RouteDecodeErrorZ_clone
);
// struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_ok(struct LDKRouteParameters o);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteParametersDecodeErrorZ_ok", ()=>CResult_RouteParametersDecodeErrorZ_ok
);
// struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteParametersDecodeErrorZ_err", ()=>CResult_RouteParametersDecodeErrorZ_err
);
// bool CResult_RouteParametersDecodeErrorZ_is_ok(const struct LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteParametersDecodeErrorZ_is_ok", ()=>CResult_RouteParametersDecodeErrorZ_is_ok
);
// void CResult_RouteParametersDecodeErrorZ_free(struct LDKCResult_RouteParametersDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteParametersDecodeErrorZ_free", ()=>CResult_RouteParametersDecodeErrorZ_free
);
// uintptr_t CResult_RouteParametersDecodeErrorZ_clone_ptr(LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteParametersDecodeErrorZ_clone_ptr", ()=>CResult_RouteParametersDecodeErrorZ_clone_ptr
);
// struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_clone(const struct LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteParametersDecodeErrorZ_clone", ()=>CResult_RouteParametersDecodeErrorZ_clone
);
// void CVec_RouteHintZ_free(struct LDKCVec_RouteHintZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_RouteHintZ_free", ()=>CVec_RouteHintZ_free
);
// struct LDKCOption_u64Z COption_u64Z_some(uint64_t o);
/* @internal */ parcelHelpers.export(exports, "COption_u64Z_some", ()=>COption_u64Z_some
);
// struct LDKCOption_u64Z COption_u64Z_none(void);
/* @internal */ parcelHelpers.export(exports, "COption_u64Z_none", ()=>COption_u64Z_none
);
// void COption_u64Z_free(struct LDKCOption_u64Z _res);
/* @internal */ parcelHelpers.export(exports, "COption_u64Z_free", ()=>COption_u64Z_free
);
// uintptr_t COption_u64Z_clone_ptr(LDKCOption_u64Z *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "COption_u64Z_clone_ptr", ()=>COption_u64Z_clone_ptr
);
// struct LDKCOption_u64Z COption_u64Z_clone(const struct LDKCOption_u64Z *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "COption_u64Z_clone", ()=>COption_u64Z_clone
);
// struct LDKCResult_PayeeDecodeErrorZ CResult_PayeeDecodeErrorZ_ok(struct LDKPayee o);
/* @internal */ parcelHelpers.export(exports, "CResult_PayeeDecodeErrorZ_ok", ()=>CResult_PayeeDecodeErrorZ_ok
);
// struct LDKCResult_PayeeDecodeErrorZ CResult_PayeeDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_PayeeDecodeErrorZ_err", ()=>CResult_PayeeDecodeErrorZ_err
);
// bool CResult_PayeeDecodeErrorZ_is_ok(const struct LDKCResult_PayeeDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_PayeeDecodeErrorZ_is_ok", ()=>CResult_PayeeDecodeErrorZ_is_ok
);
// void CResult_PayeeDecodeErrorZ_free(struct LDKCResult_PayeeDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_PayeeDecodeErrorZ_free", ()=>CResult_PayeeDecodeErrorZ_free
);
// uintptr_t CResult_PayeeDecodeErrorZ_clone_ptr(LDKCResult_PayeeDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_PayeeDecodeErrorZ_clone_ptr", ()=>CResult_PayeeDecodeErrorZ_clone_ptr
);
// struct LDKCResult_PayeeDecodeErrorZ CResult_PayeeDecodeErrorZ_clone(const struct LDKCResult_PayeeDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_PayeeDecodeErrorZ_clone", ()=>CResult_PayeeDecodeErrorZ_clone
);
// void CVec_RouteHintHopZ_free(struct LDKCVec_RouteHintHopZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_RouteHintHopZ_free", ()=>CVec_RouteHintHopZ_free
);
// struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_ok(struct LDKRouteHint o);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHintDecodeErrorZ_ok", ()=>CResult_RouteHintDecodeErrorZ_ok
);
// struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHintDecodeErrorZ_err", ()=>CResult_RouteHintDecodeErrorZ_err
);
// bool CResult_RouteHintDecodeErrorZ_is_ok(const struct LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHintDecodeErrorZ_is_ok", ()=>CResult_RouteHintDecodeErrorZ_is_ok
);
// void CResult_RouteHintDecodeErrorZ_free(struct LDKCResult_RouteHintDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHintDecodeErrorZ_free", ()=>CResult_RouteHintDecodeErrorZ_free
);
// uintptr_t CResult_RouteHintDecodeErrorZ_clone_ptr(LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHintDecodeErrorZ_clone_ptr", ()=>CResult_RouteHintDecodeErrorZ_clone_ptr
);
// struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_clone(const struct LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHintDecodeErrorZ_clone", ()=>CResult_RouteHintDecodeErrorZ_clone
);
// struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_ok(struct LDKRouteHintHop o);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHintHopDecodeErrorZ_ok", ()=>CResult_RouteHintHopDecodeErrorZ_ok
);
// struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHintHopDecodeErrorZ_err", ()=>CResult_RouteHintHopDecodeErrorZ_err
);
// bool CResult_RouteHintHopDecodeErrorZ_is_ok(const struct LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHintHopDecodeErrorZ_is_ok", ()=>CResult_RouteHintHopDecodeErrorZ_is_ok
);
// void CResult_RouteHintHopDecodeErrorZ_free(struct LDKCResult_RouteHintHopDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHintHopDecodeErrorZ_free", ()=>CResult_RouteHintHopDecodeErrorZ_free
);
// uintptr_t CResult_RouteHintHopDecodeErrorZ_clone_ptr(LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHintHopDecodeErrorZ_clone_ptr", ()=>CResult_RouteHintHopDecodeErrorZ_clone_ptr
);
// struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_clone(const struct LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteHintHopDecodeErrorZ_clone", ()=>CResult_RouteHintHopDecodeErrorZ_clone
);
// void CVec_ChannelDetailsZ_free(struct LDKCVec_ChannelDetailsZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_ChannelDetailsZ_free", ()=>CVec_ChannelDetailsZ_free
);
// struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_ok(struct LDKRoute o);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteLightningErrorZ_ok", ()=>CResult_RouteLightningErrorZ_ok
);
// struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_err(struct LDKLightningError e);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteLightningErrorZ_err", ()=>CResult_RouteLightningErrorZ_err
);
// bool CResult_RouteLightningErrorZ_is_ok(const struct LDKCResult_RouteLightningErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteLightningErrorZ_is_ok", ()=>CResult_RouteLightningErrorZ_is_ok
);
// void CResult_RouteLightningErrorZ_free(struct LDKCResult_RouteLightningErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteLightningErrorZ_free", ()=>CResult_RouteLightningErrorZ_free
);
// uintptr_t CResult_RouteLightningErrorZ_clone_ptr(LDKCResult_RouteLightningErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteLightningErrorZ_clone_ptr", ()=>CResult_RouteLightningErrorZ_clone_ptr
);
// struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_clone(const struct LDKCResult_RouteLightningErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_RouteLightningErrorZ_clone", ()=>CResult_RouteLightningErrorZ_clone
);
// struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_ok(void);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneLightningErrorZ_ok", ()=>CResult_NoneLightningErrorZ_ok
);
// struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_err(struct LDKLightningError e);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneLightningErrorZ_err", ()=>CResult_NoneLightningErrorZ_err
);
// bool CResult_NoneLightningErrorZ_is_ok(const struct LDKCResult_NoneLightningErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneLightningErrorZ_is_ok", ()=>CResult_NoneLightningErrorZ_is_ok
);
// void CResult_NoneLightningErrorZ_free(struct LDKCResult_NoneLightningErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneLightningErrorZ_free", ()=>CResult_NoneLightningErrorZ_free
);
// uintptr_t CResult_NoneLightningErrorZ_clone_ptr(LDKCResult_NoneLightningErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneLightningErrorZ_clone_ptr", ()=>CResult_NoneLightningErrorZ_clone_ptr
);
// struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_clone(const struct LDKCResult_NoneLightningErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneLightningErrorZ_clone", ()=>CResult_NoneLightningErrorZ_clone
);
// uintptr_t C2Tuple_PublicKeyTypeZ_clone_ptr(LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PublicKeyTypeZ_clone_ptr", ()=>C2Tuple_PublicKeyTypeZ_clone_ptr
);
// struct LDKC2Tuple_PublicKeyTypeZ C2Tuple_PublicKeyTypeZ_clone(const struct LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PublicKeyTypeZ_clone", ()=>C2Tuple_PublicKeyTypeZ_clone
);
// struct LDKC2Tuple_PublicKeyTypeZ C2Tuple_PublicKeyTypeZ_new(struct LDKPublicKey a, struct LDKType b);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PublicKeyTypeZ_new", ()=>C2Tuple_PublicKeyTypeZ_new
);
// void C2Tuple_PublicKeyTypeZ_free(struct LDKC2Tuple_PublicKeyTypeZ _res);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PublicKeyTypeZ_free", ()=>C2Tuple_PublicKeyTypeZ_free
);
// void CVec_C2Tuple_PublicKeyTypeZZ_free(struct LDKCVec_C2Tuple_PublicKeyTypeZZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_C2Tuple_PublicKeyTypeZZ_free", ()=>CVec_C2Tuple_PublicKeyTypeZZ_free
);
// void CVec_MessageSendEventZ_free(struct LDKCVec_MessageSendEventZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_MessageSendEventZ_free", ()=>CVec_MessageSendEventZ_free
);
// struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_ok(bool o);
/* @internal */ parcelHelpers.export(exports, "CResult_boolLightningErrorZ_ok", ()=>CResult_boolLightningErrorZ_ok
);
// struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_err(struct LDKLightningError e);
/* @internal */ parcelHelpers.export(exports, "CResult_boolLightningErrorZ_err", ()=>CResult_boolLightningErrorZ_err
);
// bool CResult_boolLightningErrorZ_is_ok(const struct LDKCResult_boolLightningErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_boolLightningErrorZ_is_ok", ()=>CResult_boolLightningErrorZ_is_ok
);
// void CResult_boolLightningErrorZ_free(struct LDKCResult_boolLightningErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_boolLightningErrorZ_free", ()=>CResult_boolLightningErrorZ_free
);
// uintptr_t CResult_boolLightningErrorZ_clone_ptr(LDKCResult_boolLightningErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_boolLightningErrorZ_clone_ptr", ()=>CResult_boolLightningErrorZ_clone_ptr
);
// struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_clone(const struct LDKCResult_boolLightningErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_boolLightningErrorZ_clone", ()=>CResult_boolLightningErrorZ_clone
);
// uintptr_t C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone_ptr(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone_ptr", ()=>C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone_ptr
);
// struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(const struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone", ()=>C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone
);
// struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(struct LDKChannelAnnouncement a, struct LDKChannelUpdate b, struct LDKChannelUpdate c);
/* @internal */ parcelHelpers.export(exports, "C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new", ()=>C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new
);
// void C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ _res);
/* @internal */ parcelHelpers.export(exports, "C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free", ()=>C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free
);
// void CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(struct LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free", ()=>CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free
);
// void CVec_NodeAnnouncementZ_free(struct LDKCVec_NodeAnnouncementZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_NodeAnnouncementZ_free", ()=>CVec_NodeAnnouncementZ_free
);
// void CVec_PublicKeyZ_free(struct LDKCVec_PublicKeyZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_PublicKeyZ_free", ()=>CVec_PublicKeyZ_free
);
// void CVec_u8Z_free(struct LDKCVec_u8Z _res);
/* @internal */ parcelHelpers.export(exports, "CVec_u8Z_free", ()=>CVec_u8Z_free
);
// struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_ok(struct LDKCVec_u8Z o);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_u8ZPeerHandleErrorZ_ok", ()=>CResult_CVec_u8ZPeerHandleErrorZ_ok
);
// struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_err(struct LDKPeerHandleError e);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_u8ZPeerHandleErrorZ_err", ()=>CResult_CVec_u8ZPeerHandleErrorZ_err
);
// bool CResult_CVec_u8ZPeerHandleErrorZ_is_ok(const struct LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_u8ZPeerHandleErrorZ_is_ok", ()=>CResult_CVec_u8ZPeerHandleErrorZ_is_ok
);
// void CResult_CVec_u8ZPeerHandleErrorZ_free(struct LDKCResult_CVec_u8ZPeerHandleErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_u8ZPeerHandleErrorZ_free", ()=>CResult_CVec_u8ZPeerHandleErrorZ_free
);
// uintptr_t CResult_CVec_u8ZPeerHandleErrorZ_clone_ptr(LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_u8ZPeerHandleErrorZ_clone_ptr", ()=>CResult_CVec_u8ZPeerHandleErrorZ_clone_ptr
);
// struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_clone(const struct LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_u8ZPeerHandleErrorZ_clone", ()=>CResult_CVec_u8ZPeerHandleErrorZ_clone
);
// struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_ok(void);
/* @internal */ parcelHelpers.export(exports, "CResult_NonePeerHandleErrorZ_ok", ()=>CResult_NonePeerHandleErrorZ_ok
);
// struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_err(struct LDKPeerHandleError e);
/* @internal */ parcelHelpers.export(exports, "CResult_NonePeerHandleErrorZ_err", ()=>CResult_NonePeerHandleErrorZ_err
);
// bool CResult_NonePeerHandleErrorZ_is_ok(const struct LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_NonePeerHandleErrorZ_is_ok", ()=>CResult_NonePeerHandleErrorZ_is_ok
);
// void CResult_NonePeerHandleErrorZ_free(struct LDKCResult_NonePeerHandleErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_NonePeerHandleErrorZ_free", ()=>CResult_NonePeerHandleErrorZ_free
);
// uintptr_t CResult_NonePeerHandleErrorZ_clone_ptr(LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_NonePeerHandleErrorZ_clone_ptr", ()=>CResult_NonePeerHandleErrorZ_clone_ptr
);
// struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_clone(const struct LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_NonePeerHandleErrorZ_clone", ()=>CResult_NonePeerHandleErrorZ_clone
);
// struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_ok(bool o);
/* @internal */ parcelHelpers.export(exports, "CResult_boolPeerHandleErrorZ_ok", ()=>CResult_boolPeerHandleErrorZ_ok
);
// struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_err(struct LDKPeerHandleError e);
/* @internal */ parcelHelpers.export(exports, "CResult_boolPeerHandleErrorZ_err", ()=>CResult_boolPeerHandleErrorZ_err
);
// bool CResult_boolPeerHandleErrorZ_is_ok(const struct LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_boolPeerHandleErrorZ_is_ok", ()=>CResult_boolPeerHandleErrorZ_is_ok
);
// void CResult_boolPeerHandleErrorZ_free(struct LDKCResult_boolPeerHandleErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_boolPeerHandleErrorZ_free", ()=>CResult_boolPeerHandleErrorZ_free
);
// uintptr_t CResult_boolPeerHandleErrorZ_clone_ptr(LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_boolPeerHandleErrorZ_clone_ptr", ()=>CResult_boolPeerHandleErrorZ_clone_ptr
);
// struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_clone(const struct LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_boolPeerHandleErrorZ_clone", ()=>CResult_boolPeerHandleErrorZ_clone
);
// struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_ok(struct LDKTxOut o);
/* @internal */ parcelHelpers.export(exports, "CResult_TxOutAccessErrorZ_ok", ()=>CResult_TxOutAccessErrorZ_ok
);
// struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_err(enum LDKAccessError e);
/* @internal */ parcelHelpers.export(exports, "CResult_TxOutAccessErrorZ_err", ()=>CResult_TxOutAccessErrorZ_err
);
// bool CResult_TxOutAccessErrorZ_is_ok(const struct LDKCResult_TxOutAccessErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_TxOutAccessErrorZ_is_ok", ()=>CResult_TxOutAccessErrorZ_is_ok
);
// void CResult_TxOutAccessErrorZ_free(struct LDKCResult_TxOutAccessErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_TxOutAccessErrorZ_free", ()=>CResult_TxOutAccessErrorZ_free
);
// uintptr_t CResult_TxOutAccessErrorZ_clone_ptr(LDKCResult_TxOutAccessErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_TxOutAccessErrorZ_clone_ptr", ()=>CResult_TxOutAccessErrorZ_clone_ptr
);
// struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_clone(const struct LDKCResult_TxOutAccessErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_TxOutAccessErrorZ_clone", ()=>CResult_TxOutAccessErrorZ_clone
);
// struct LDKCResult_NoneChannelMonitorUpdateErrZ CResult_NoneChannelMonitorUpdateErrZ_ok(void);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneChannelMonitorUpdateErrZ_ok", ()=>CResult_NoneChannelMonitorUpdateErrZ_ok
);
// struct LDKCResult_NoneChannelMonitorUpdateErrZ CResult_NoneChannelMonitorUpdateErrZ_err(enum LDKChannelMonitorUpdateErr e);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneChannelMonitorUpdateErrZ_err", ()=>CResult_NoneChannelMonitorUpdateErrZ_err
);
// bool CResult_NoneChannelMonitorUpdateErrZ_is_ok(const struct LDKCResult_NoneChannelMonitorUpdateErrZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneChannelMonitorUpdateErrZ_is_ok", ()=>CResult_NoneChannelMonitorUpdateErrZ_is_ok
);
// void CResult_NoneChannelMonitorUpdateErrZ_free(struct LDKCResult_NoneChannelMonitorUpdateErrZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneChannelMonitorUpdateErrZ_free", ()=>CResult_NoneChannelMonitorUpdateErrZ_free
);
// uintptr_t CResult_NoneChannelMonitorUpdateErrZ_clone_ptr(LDKCResult_NoneChannelMonitorUpdateErrZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneChannelMonitorUpdateErrZ_clone_ptr", ()=>CResult_NoneChannelMonitorUpdateErrZ_clone_ptr
);
// struct LDKCResult_NoneChannelMonitorUpdateErrZ CResult_NoneChannelMonitorUpdateErrZ_clone(const struct LDKCResult_NoneChannelMonitorUpdateErrZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneChannelMonitorUpdateErrZ_clone", ()=>CResult_NoneChannelMonitorUpdateErrZ_clone
);
// struct LDKCOption_C2Tuple_usizeTransactionZZ COption_C2Tuple_usizeTransactionZZ_some(struct LDKC2Tuple_usizeTransactionZ o);
/* @internal */ parcelHelpers.export(exports, "COption_C2Tuple_usizeTransactionZZ_some", ()=>COption_C2Tuple_usizeTransactionZZ_some
);
// struct LDKCOption_C2Tuple_usizeTransactionZZ COption_C2Tuple_usizeTransactionZZ_none(void);
/* @internal */ parcelHelpers.export(exports, "COption_C2Tuple_usizeTransactionZZ_none", ()=>COption_C2Tuple_usizeTransactionZZ_none
);
// void COption_C2Tuple_usizeTransactionZZ_free(struct LDKCOption_C2Tuple_usizeTransactionZZ _res);
/* @internal */ parcelHelpers.export(exports, "COption_C2Tuple_usizeTransactionZZ_free", ()=>COption_C2Tuple_usizeTransactionZZ_free
);
// uintptr_t COption_C2Tuple_usizeTransactionZZ_clone_ptr(LDKCOption_C2Tuple_usizeTransactionZZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "COption_C2Tuple_usizeTransactionZZ_clone_ptr", ()=>COption_C2Tuple_usizeTransactionZZ_clone_ptr
);
// struct LDKCOption_C2Tuple_usizeTransactionZZ COption_C2Tuple_usizeTransactionZZ_clone(const struct LDKCOption_C2Tuple_usizeTransactionZZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "COption_C2Tuple_usizeTransactionZZ_clone", ()=>COption_C2Tuple_usizeTransactionZZ_clone
);
// struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_some(struct LDKClosureReason o);
/* @internal */ parcelHelpers.export(exports, "COption_ClosureReasonZ_some", ()=>COption_ClosureReasonZ_some
);
// struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_none(void);
/* @internal */ parcelHelpers.export(exports, "COption_ClosureReasonZ_none", ()=>COption_ClosureReasonZ_none
);
// void COption_ClosureReasonZ_free(struct LDKCOption_ClosureReasonZ _res);
/* @internal */ parcelHelpers.export(exports, "COption_ClosureReasonZ_free", ()=>COption_ClosureReasonZ_free
);
// uintptr_t COption_ClosureReasonZ_clone_ptr(LDKCOption_ClosureReasonZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "COption_ClosureReasonZ_clone_ptr", ()=>COption_ClosureReasonZ_clone_ptr
);
// struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_clone(const struct LDKCOption_ClosureReasonZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "COption_ClosureReasonZ_clone", ()=>COption_ClosureReasonZ_clone
);
// struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_ok(struct LDKCOption_ClosureReasonZ o);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_ClosureReasonZDecodeErrorZ_ok", ()=>CResult_COption_ClosureReasonZDecodeErrorZ_ok
);
// struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_ClosureReasonZDecodeErrorZ_err", ()=>CResult_COption_ClosureReasonZDecodeErrorZ_err
);
// bool CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(const struct LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_ClosureReasonZDecodeErrorZ_is_ok", ()=>CResult_COption_ClosureReasonZDecodeErrorZ_is_ok
);
// void CResult_COption_ClosureReasonZDecodeErrorZ_free(struct LDKCResult_COption_ClosureReasonZDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_ClosureReasonZDecodeErrorZ_free", ()=>CResult_COption_ClosureReasonZDecodeErrorZ_free
);
// uintptr_t CResult_COption_ClosureReasonZDecodeErrorZ_clone_ptr(LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_ClosureReasonZDecodeErrorZ_clone_ptr", ()=>CResult_COption_ClosureReasonZDecodeErrorZ_clone_ptr
);
// struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_clone(const struct LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_ClosureReasonZDecodeErrorZ_clone", ()=>CResult_COption_ClosureReasonZDecodeErrorZ_clone
);
// struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_some(struct LDKNetworkUpdate o);
/* @internal */ parcelHelpers.export(exports, "COption_NetworkUpdateZ_some", ()=>COption_NetworkUpdateZ_some
);
// struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_none(void);
/* @internal */ parcelHelpers.export(exports, "COption_NetworkUpdateZ_none", ()=>COption_NetworkUpdateZ_none
);
// void COption_NetworkUpdateZ_free(struct LDKCOption_NetworkUpdateZ _res);
/* @internal */ parcelHelpers.export(exports, "COption_NetworkUpdateZ_free", ()=>COption_NetworkUpdateZ_free
);
// uintptr_t COption_NetworkUpdateZ_clone_ptr(LDKCOption_NetworkUpdateZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "COption_NetworkUpdateZ_clone_ptr", ()=>COption_NetworkUpdateZ_clone_ptr
);
// struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_clone(const struct LDKCOption_NetworkUpdateZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "COption_NetworkUpdateZ_clone", ()=>COption_NetworkUpdateZ_clone
);
// void CVec_SpendableOutputDescriptorZ_free(struct LDKCVec_SpendableOutputDescriptorZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_SpendableOutputDescriptorZ_free", ()=>CVec_SpendableOutputDescriptorZ_free
);
// struct LDKCOption_EventZ COption_EventZ_some(struct LDKEvent o);
/* @internal */ parcelHelpers.export(exports, "COption_EventZ_some", ()=>COption_EventZ_some
);
// struct LDKCOption_EventZ COption_EventZ_none(void);
/* @internal */ parcelHelpers.export(exports, "COption_EventZ_none", ()=>COption_EventZ_none
);
// void COption_EventZ_free(struct LDKCOption_EventZ _res);
/* @internal */ parcelHelpers.export(exports, "COption_EventZ_free", ()=>COption_EventZ_free
);
// uintptr_t COption_EventZ_clone_ptr(LDKCOption_EventZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "COption_EventZ_clone_ptr", ()=>COption_EventZ_clone_ptr
);
// struct LDKCOption_EventZ COption_EventZ_clone(const struct LDKCOption_EventZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "COption_EventZ_clone", ()=>COption_EventZ_clone
);
// struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_ok(struct LDKCOption_EventZ o);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_EventZDecodeErrorZ_ok", ()=>CResult_COption_EventZDecodeErrorZ_ok
);
// struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_EventZDecodeErrorZ_err", ()=>CResult_COption_EventZDecodeErrorZ_err
);
// bool CResult_COption_EventZDecodeErrorZ_is_ok(const struct LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_EventZDecodeErrorZ_is_ok", ()=>CResult_COption_EventZDecodeErrorZ_is_ok
);
// void CResult_COption_EventZDecodeErrorZ_free(struct LDKCResult_COption_EventZDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_EventZDecodeErrorZ_free", ()=>CResult_COption_EventZDecodeErrorZ_free
);
// uintptr_t CResult_COption_EventZDecodeErrorZ_clone_ptr(LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_EventZDecodeErrorZ_clone_ptr", ()=>CResult_COption_EventZDecodeErrorZ_clone_ptr
);
// struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_clone(const struct LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_EventZDecodeErrorZ_clone", ()=>CResult_COption_EventZDecodeErrorZ_clone
);
// struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_ok(struct LDKNodeId o);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeIdDecodeErrorZ_ok", ()=>CResult_NodeIdDecodeErrorZ_ok
);
// struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeIdDecodeErrorZ_err", ()=>CResult_NodeIdDecodeErrorZ_err
);
// bool CResult_NodeIdDecodeErrorZ_is_ok(const struct LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeIdDecodeErrorZ_is_ok", ()=>CResult_NodeIdDecodeErrorZ_is_ok
);
// void CResult_NodeIdDecodeErrorZ_free(struct LDKCResult_NodeIdDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeIdDecodeErrorZ_free", ()=>CResult_NodeIdDecodeErrorZ_free
);
// uintptr_t CResult_NodeIdDecodeErrorZ_clone_ptr(LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeIdDecodeErrorZ_clone_ptr", ()=>CResult_NodeIdDecodeErrorZ_clone_ptr
);
// struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_clone(const struct LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeIdDecodeErrorZ_clone", ()=>CResult_NodeIdDecodeErrorZ_clone
);
// struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_ok(struct LDKCOption_NetworkUpdateZ o);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_NetworkUpdateZDecodeErrorZ_ok", ()=>CResult_COption_NetworkUpdateZDecodeErrorZ_ok
);
// struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_NetworkUpdateZDecodeErrorZ_err", ()=>CResult_COption_NetworkUpdateZDecodeErrorZ_err
);
// bool CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(const struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok", ()=>CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok
);
// void CResult_COption_NetworkUpdateZDecodeErrorZ_free(struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_NetworkUpdateZDecodeErrorZ_free", ()=>CResult_COption_NetworkUpdateZDecodeErrorZ_free
);
// uintptr_t CResult_COption_NetworkUpdateZDecodeErrorZ_clone_ptr(LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_NetworkUpdateZDecodeErrorZ_clone_ptr", ()=>CResult_COption_NetworkUpdateZDecodeErrorZ_clone_ptr
);
// struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_clone(const struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_COption_NetworkUpdateZDecodeErrorZ_clone", ()=>CResult_COption_NetworkUpdateZDecodeErrorZ_clone
);
// struct LDKCOption_AccessZ COption_AccessZ_some(struct LDKAccess o);
/* @internal */ parcelHelpers.export(exports, "COption_AccessZ_some", ()=>COption_AccessZ_some
);
// struct LDKCOption_AccessZ COption_AccessZ_none(void);
/* @internal */ parcelHelpers.export(exports, "COption_AccessZ_none", ()=>COption_AccessZ_none
);
// void COption_AccessZ_free(struct LDKCOption_AccessZ _res);
/* @internal */ parcelHelpers.export(exports, "COption_AccessZ_free", ()=>COption_AccessZ_free
);
// struct LDKCResult_DirectionalChannelInfoDecodeErrorZ CResult_DirectionalChannelInfoDecodeErrorZ_ok(struct LDKDirectionalChannelInfo o);
/* @internal */ parcelHelpers.export(exports, "CResult_DirectionalChannelInfoDecodeErrorZ_ok", ()=>CResult_DirectionalChannelInfoDecodeErrorZ_ok
);
// struct LDKCResult_DirectionalChannelInfoDecodeErrorZ CResult_DirectionalChannelInfoDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_DirectionalChannelInfoDecodeErrorZ_err", ()=>CResult_DirectionalChannelInfoDecodeErrorZ_err
);
// bool CResult_DirectionalChannelInfoDecodeErrorZ_is_ok(const struct LDKCResult_DirectionalChannelInfoDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_DirectionalChannelInfoDecodeErrorZ_is_ok", ()=>CResult_DirectionalChannelInfoDecodeErrorZ_is_ok
);
// void CResult_DirectionalChannelInfoDecodeErrorZ_free(struct LDKCResult_DirectionalChannelInfoDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_DirectionalChannelInfoDecodeErrorZ_free", ()=>CResult_DirectionalChannelInfoDecodeErrorZ_free
);
// uintptr_t CResult_DirectionalChannelInfoDecodeErrorZ_clone_ptr(LDKCResult_DirectionalChannelInfoDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_DirectionalChannelInfoDecodeErrorZ_clone_ptr", ()=>CResult_DirectionalChannelInfoDecodeErrorZ_clone_ptr
);
// struct LDKCResult_DirectionalChannelInfoDecodeErrorZ CResult_DirectionalChannelInfoDecodeErrorZ_clone(const struct LDKCResult_DirectionalChannelInfoDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_DirectionalChannelInfoDecodeErrorZ_clone", ()=>CResult_DirectionalChannelInfoDecodeErrorZ_clone
);
// struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_ok(struct LDKChannelInfo o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelInfoDecodeErrorZ_ok", ()=>CResult_ChannelInfoDecodeErrorZ_ok
);
// struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelInfoDecodeErrorZ_err", ()=>CResult_ChannelInfoDecodeErrorZ_err
);
// bool CResult_ChannelInfoDecodeErrorZ_is_ok(const struct LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelInfoDecodeErrorZ_is_ok", ()=>CResult_ChannelInfoDecodeErrorZ_is_ok
);
// void CResult_ChannelInfoDecodeErrorZ_free(struct LDKCResult_ChannelInfoDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelInfoDecodeErrorZ_free", ()=>CResult_ChannelInfoDecodeErrorZ_free
);
// uintptr_t CResult_ChannelInfoDecodeErrorZ_clone_ptr(LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelInfoDecodeErrorZ_clone_ptr", ()=>CResult_ChannelInfoDecodeErrorZ_clone_ptr
);
// struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_clone(const struct LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelInfoDecodeErrorZ_clone", ()=>CResult_ChannelInfoDecodeErrorZ_clone
);
// struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_ok(struct LDKRoutingFees o);
/* @internal */ parcelHelpers.export(exports, "CResult_RoutingFeesDecodeErrorZ_ok", ()=>CResult_RoutingFeesDecodeErrorZ_ok
);
// struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_RoutingFeesDecodeErrorZ_err", ()=>CResult_RoutingFeesDecodeErrorZ_err
);
// bool CResult_RoutingFeesDecodeErrorZ_is_ok(const struct LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_RoutingFeesDecodeErrorZ_is_ok", ()=>CResult_RoutingFeesDecodeErrorZ_is_ok
);
// void CResult_RoutingFeesDecodeErrorZ_free(struct LDKCResult_RoutingFeesDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_RoutingFeesDecodeErrorZ_free", ()=>CResult_RoutingFeesDecodeErrorZ_free
);
// uintptr_t CResult_RoutingFeesDecodeErrorZ_clone_ptr(LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_RoutingFeesDecodeErrorZ_clone_ptr", ()=>CResult_RoutingFeesDecodeErrorZ_clone_ptr
);
// struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_clone(const struct LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_RoutingFeesDecodeErrorZ_clone", ()=>CResult_RoutingFeesDecodeErrorZ_clone
);
// void CVec_NetAddressZ_free(struct LDKCVec_NetAddressZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_NetAddressZ_free", ()=>CVec_NetAddressZ_free
);
// struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_ok(struct LDKNodeAnnouncementInfo o);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeAnnouncementInfoDecodeErrorZ_ok", ()=>CResult_NodeAnnouncementInfoDecodeErrorZ_ok
);
// struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeAnnouncementInfoDecodeErrorZ_err", ()=>CResult_NodeAnnouncementInfoDecodeErrorZ_err
);
// bool CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(const struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok", ()=>CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok
);
// void CResult_NodeAnnouncementInfoDecodeErrorZ_free(struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeAnnouncementInfoDecodeErrorZ_free", ()=>CResult_NodeAnnouncementInfoDecodeErrorZ_free
);
// uintptr_t CResult_NodeAnnouncementInfoDecodeErrorZ_clone_ptr(LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeAnnouncementInfoDecodeErrorZ_clone_ptr", ()=>CResult_NodeAnnouncementInfoDecodeErrorZ_clone_ptr
);
// struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_clone(const struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeAnnouncementInfoDecodeErrorZ_clone", ()=>CResult_NodeAnnouncementInfoDecodeErrorZ_clone
);
// void CVec_u64Z_free(struct LDKCVec_u64Z _res);
/* @internal */ parcelHelpers.export(exports, "CVec_u64Z_free", ()=>CVec_u64Z_free
);
// struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_ok(struct LDKNodeInfo o);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeInfoDecodeErrorZ_ok", ()=>CResult_NodeInfoDecodeErrorZ_ok
);
// struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeInfoDecodeErrorZ_err", ()=>CResult_NodeInfoDecodeErrorZ_err
);
// bool CResult_NodeInfoDecodeErrorZ_is_ok(const struct LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeInfoDecodeErrorZ_is_ok", ()=>CResult_NodeInfoDecodeErrorZ_is_ok
);
// void CResult_NodeInfoDecodeErrorZ_free(struct LDKCResult_NodeInfoDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeInfoDecodeErrorZ_free", ()=>CResult_NodeInfoDecodeErrorZ_free
);
// uintptr_t CResult_NodeInfoDecodeErrorZ_clone_ptr(LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeInfoDecodeErrorZ_clone_ptr", ()=>CResult_NodeInfoDecodeErrorZ_clone_ptr
);
// struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_clone(const struct LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeInfoDecodeErrorZ_clone", ()=>CResult_NodeInfoDecodeErrorZ_clone
);
// struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_ok(struct LDKNetworkGraph o);
/* @internal */ parcelHelpers.export(exports, "CResult_NetworkGraphDecodeErrorZ_ok", ()=>CResult_NetworkGraphDecodeErrorZ_ok
);
// struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_NetworkGraphDecodeErrorZ_err", ()=>CResult_NetworkGraphDecodeErrorZ_err
);
// bool CResult_NetworkGraphDecodeErrorZ_is_ok(const struct LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_NetworkGraphDecodeErrorZ_is_ok", ()=>CResult_NetworkGraphDecodeErrorZ_is_ok
);
// void CResult_NetworkGraphDecodeErrorZ_free(struct LDKCResult_NetworkGraphDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_NetworkGraphDecodeErrorZ_free", ()=>CResult_NetworkGraphDecodeErrorZ_free
);
// uintptr_t CResult_NetworkGraphDecodeErrorZ_clone_ptr(LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_NetworkGraphDecodeErrorZ_clone_ptr", ()=>CResult_NetworkGraphDecodeErrorZ_clone_ptr
);
// struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_clone(const struct LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_NetworkGraphDecodeErrorZ_clone", ()=>CResult_NetworkGraphDecodeErrorZ_clone
);
// struct LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_some(struct LDKCVec_NetAddressZ o);
/* @internal */ parcelHelpers.export(exports, "COption_CVec_NetAddressZZ_some", ()=>COption_CVec_NetAddressZZ_some
);
// struct LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_none(void);
/* @internal */ parcelHelpers.export(exports, "COption_CVec_NetAddressZZ_none", ()=>COption_CVec_NetAddressZZ_none
);
// void COption_CVec_NetAddressZZ_free(struct LDKCOption_CVec_NetAddressZZ _res);
/* @internal */ parcelHelpers.export(exports, "COption_CVec_NetAddressZZ_free", ()=>COption_CVec_NetAddressZZ_free
);
// uintptr_t COption_CVec_NetAddressZZ_clone_ptr(LDKCOption_CVec_NetAddressZZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "COption_CVec_NetAddressZZ_clone_ptr", ()=>COption_CVec_NetAddressZZ_clone_ptr
);
// struct LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_clone(const struct LDKCOption_CVec_NetAddressZZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "COption_CVec_NetAddressZZ_clone", ()=>COption_CVec_NetAddressZZ_clone
);
// struct LDKCResult_ScoringParametersDecodeErrorZ CResult_ScoringParametersDecodeErrorZ_ok(struct LDKScoringParameters o);
/* @internal */ parcelHelpers.export(exports, "CResult_ScoringParametersDecodeErrorZ_ok", ()=>CResult_ScoringParametersDecodeErrorZ_ok
);
// struct LDKCResult_ScoringParametersDecodeErrorZ CResult_ScoringParametersDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ScoringParametersDecodeErrorZ_err", ()=>CResult_ScoringParametersDecodeErrorZ_err
);
// bool CResult_ScoringParametersDecodeErrorZ_is_ok(const struct LDKCResult_ScoringParametersDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ScoringParametersDecodeErrorZ_is_ok", ()=>CResult_ScoringParametersDecodeErrorZ_is_ok
);
// void CResult_ScoringParametersDecodeErrorZ_free(struct LDKCResult_ScoringParametersDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ScoringParametersDecodeErrorZ_free", ()=>CResult_ScoringParametersDecodeErrorZ_free
);
// struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_ok(struct LDKInitFeatures o);
/* @internal */ parcelHelpers.export(exports, "CResult_InitFeaturesDecodeErrorZ_ok", ()=>CResult_InitFeaturesDecodeErrorZ_ok
);
// struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_InitFeaturesDecodeErrorZ_err", ()=>CResult_InitFeaturesDecodeErrorZ_err
);
// bool CResult_InitFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_InitFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_InitFeaturesDecodeErrorZ_is_ok", ()=>CResult_InitFeaturesDecodeErrorZ_is_ok
);
// void CResult_InitFeaturesDecodeErrorZ_free(struct LDKCResult_InitFeaturesDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_InitFeaturesDecodeErrorZ_free", ()=>CResult_InitFeaturesDecodeErrorZ_free
);
// struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_ok(struct LDKChannelFeatures o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelFeaturesDecodeErrorZ_ok", ()=>CResult_ChannelFeaturesDecodeErrorZ_ok
);
// struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelFeaturesDecodeErrorZ_err", ()=>CResult_ChannelFeaturesDecodeErrorZ_err
);
// bool CResult_ChannelFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_ChannelFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelFeaturesDecodeErrorZ_is_ok", ()=>CResult_ChannelFeaturesDecodeErrorZ_is_ok
);
// void CResult_ChannelFeaturesDecodeErrorZ_free(struct LDKCResult_ChannelFeaturesDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelFeaturesDecodeErrorZ_free", ()=>CResult_ChannelFeaturesDecodeErrorZ_free
);
// struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_ok(struct LDKNodeFeatures o);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeFeaturesDecodeErrorZ_ok", ()=>CResult_NodeFeaturesDecodeErrorZ_ok
);
// struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeFeaturesDecodeErrorZ_err", ()=>CResult_NodeFeaturesDecodeErrorZ_err
);
// bool CResult_NodeFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_NodeFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeFeaturesDecodeErrorZ_is_ok", ()=>CResult_NodeFeaturesDecodeErrorZ_is_ok
);
// void CResult_NodeFeaturesDecodeErrorZ_free(struct LDKCResult_NodeFeaturesDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeFeaturesDecodeErrorZ_free", ()=>CResult_NodeFeaturesDecodeErrorZ_free
);
// struct LDKCResult_InvoiceFeaturesDecodeErrorZ CResult_InvoiceFeaturesDecodeErrorZ_ok(struct LDKInvoiceFeatures o);
/* @internal */ parcelHelpers.export(exports, "CResult_InvoiceFeaturesDecodeErrorZ_ok", ()=>CResult_InvoiceFeaturesDecodeErrorZ_ok
);
// struct LDKCResult_InvoiceFeaturesDecodeErrorZ CResult_InvoiceFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_InvoiceFeaturesDecodeErrorZ_err", ()=>CResult_InvoiceFeaturesDecodeErrorZ_err
);
// bool CResult_InvoiceFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_InvoiceFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_InvoiceFeaturesDecodeErrorZ_is_ok", ()=>CResult_InvoiceFeaturesDecodeErrorZ_is_ok
);
// void CResult_InvoiceFeaturesDecodeErrorZ_free(struct LDKCResult_InvoiceFeaturesDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_InvoiceFeaturesDecodeErrorZ_free", ()=>CResult_InvoiceFeaturesDecodeErrorZ_free
);
// struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ CResult_ChannelTypeFeaturesDecodeErrorZ_ok(struct LDKChannelTypeFeatures o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelTypeFeaturesDecodeErrorZ_ok", ()=>CResult_ChannelTypeFeaturesDecodeErrorZ_ok
);
// struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ CResult_ChannelTypeFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelTypeFeaturesDecodeErrorZ_err", ()=>CResult_ChannelTypeFeaturesDecodeErrorZ_err
);
// bool CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok", ()=>CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok
);
// void CResult_ChannelTypeFeaturesDecodeErrorZ_free(struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelTypeFeaturesDecodeErrorZ_free", ()=>CResult_ChannelTypeFeaturesDecodeErrorZ_free
);
// struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_ok(struct LDKNetAddress o);
/* @internal */ parcelHelpers.export(exports, "CResult_NetAddressDecodeErrorZ_ok", ()=>CResult_NetAddressDecodeErrorZ_ok
);
// struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_NetAddressDecodeErrorZ_err", ()=>CResult_NetAddressDecodeErrorZ_err
);
// bool CResult_NetAddressDecodeErrorZ_is_ok(const struct LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_NetAddressDecodeErrorZ_is_ok", ()=>CResult_NetAddressDecodeErrorZ_is_ok
);
// void CResult_NetAddressDecodeErrorZ_free(struct LDKCResult_NetAddressDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_NetAddressDecodeErrorZ_free", ()=>CResult_NetAddressDecodeErrorZ_free
);
// uintptr_t CResult_NetAddressDecodeErrorZ_clone_ptr(LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_NetAddressDecodeErrorZ_clone_ptr", ()=>CResult_NetAddressDecodeErrorZ_clone_ptr
);
// struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_clone(const struct LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_NetAddressDecodeErrorZ_clone", ()=>CResult_NetAddressDecodeErrorZ_clone
);
// void CVec_UpdateAddHTLCZ_free(struct LDKCVec_UpdateAddHTLCZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_UpdateAddHTLCZ_free", ()=>CVec_UpdateAddHTLCZ_free
);
// void CVec_UpdateFulfillHTLCZ_free(struct LDKCVec_UpdateFulfillHTLCZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_UpdateFulfillHTLCZ_free", ()=>CVec_UpdateFulfillHTLCZ_free
);
// void CVec_UpdateFailHTLCZ_free(struct LDKCVec_UpdateFailHTLCZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_UpdateFailHTLCZ_free", ()=>CVec_UpdateFailHTLCZ_free
);
// void CVec_UpdateFailMalformedHTLCZ_free(struct LDKCVec_UpdateFailMalformedHTLCZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_UpdateFailMalformedHTLCZ_free", ()=>CVec_UpdateFailMalformedHTLCZ_free
);
// struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_ok(struct LDKAcceptChannel o);
/* @internal */ parcelHelpers.export(exports, "CResult_AcceptChannelDecodeErrorZ_ok", ()=>CResult_AcceptChannelDecodeErrorZ_ok
);
// struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_AcceptChannelDecodeErrorZ_err", ()=>CResult_AcceptChannelDecodeErrorZ_err
);
// bool CResult_AcceptChannelDecodeErrorZ_is_ok(const struct LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_AcceptChannelDecodeErrorZ_is_ok", ()=>CResult_AcceptChannelDecodeErrorZ_is_ok
);
// void CResult_AcceptChannelDecodeErrorZ_free(struct LDKCResult_AcceptChannelDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_AcceptChannelDecodeErrorZ_free", ()=>CResult_AcceptChannelDecodeErrorZ_free
);
// uintptr_t CResult_AcceptChannelDecodeErrorZ_clone_ptr(LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_AcceptChannelDecodeErrorZ_clone_ptr", ()=>CResult_AcceptChannelDecodeErrorZ_clone_ptr
);
// struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_clone(const struct LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_AcceptChannelDecodeErrorZ_clone", ()=>CResult_AcceptChannelDecodeErrorZ_clone
);
// struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_ok(struct LDKAnnouncementSignatures o);
/* @internal */ parcelHelpers.export(exports, "CResult_AnnouncementSignaturesDecodeErrorZ_ok", ()=>CResult_AnnouncementSignaturesDecodeErrorZ_ok
);
// struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_AnnouncementSignaturesDecodeErrorZ_err", ()=>CResult_AnnouncementSignaturesDecodeErrorZ_err
);
// bool CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(const struct LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_AnnouncementSignaturesDecodeErrorZ_is_ok", ()=>CResult_AnnouncementSignaturesDecodeErrorZ_is_ok
);
// void CResult_AnnouncementSignaturesDecodeErrorZ_free(struct LDKCResult_AnnouncementSignaturesDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_AnnouncementSignaturesDecodeErrorZ_free", ()=>CResult_AnnouncementSignaturesDecodeErrorZ_free
);
// uintptr_t CResult_AnnouncementSignaturesDecodeErrorZ_clone_ptr(LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_AnnouncementSignaturesDecodeErrorZ_clone_ptr", ()=>CResult_AnnouncementSignaturesDecodeErrorZ_clone_ptr
);
// struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_clone(const struct LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_AnnouncementSignaturesDecodeErrorZ_clone", ()=>CResult_AnnouncementSignaturesDecodeErrorZ_clone
);
// struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_ok(struct LDKChannelReestablish o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelReestablishDecodeErrorZ_ok", ()=>CResult_ChannelReestablishDecodeErrorZ_ok
);
// struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelReestablishDecodeErrorZ_err", ()=>CResult_ChannelReestablishDecodeErrorZ_err
);
// bool CResult_ChannelReestablishDecodeErrorZ_is_ok(const struct LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelReestablishDecodeErrorZ_is_ok", ()=>CResult_ChannelReestablishDecodeErrorZ_is_ok
);
// void CResult_ChannelReestablishDecodeErrorZ_free(struct LDKCResult_ChannelReestablishDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelReestablishDecodeErrorZ_free", ()=>CResult_ChannelReestablishDecodeErrorZ_free
);
// uintptr_t CResult_ChannelReestablishDecodeErrorZ_clone_ptr(LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelReestablishDecodeErrorZ_clone_ptr", ()=>CResult_ChannelReestablishDecodeErrorZ_clone_ptr
);
// struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_clone(const struct LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelReestablishDecodeErrorZ_clone", ()=>CResult_ChannelReestablishDecodeErrorZ_clone
);
// struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_ok(struct LDKClosingSigned o);
/* @internal */ parcelHelpers.export(exports, "CResult_ClosingSignedDecodeErrorZ_ok", ()=>CResult_ClosingSignedDecodeErrorZ_ok
);
// struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ClosingSignedDecodeErrorZ_err", ()=>CResult_ClosingSignedDecodeErrorZ_err
);
// bool CResult_ClosingSignedDecodeErrorZ_is_ok(const struct LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ClosingSignedDecodeErrorZ_is_ok", ()=>CResult_ClosingSignedDecodeErrorZ_is_ok
);
// void CResult_ClosingSignedDecodeErrorZ_free(struct LDKCResult_ClosingSignedDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ClosingSignedDecodeErrorZ_free", ()=>CResult_ClosingSignedDecodeErrorZ_free
);
// uintptr_t CResult_ClosingSignedDecodeErrorZ_clone_ptr(LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_ClosingSignedDecodeErrorZ_clone_ptr", ()=>CResult_ClosingSignedDecodeErrorZ_clone_ptr
);
// struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_clone(const struct LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_ClosingSignedDecodeErrorZ_clone", ()=>CResult_ClosingSignedDecodeErrorZ_clone
);
// struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(struct LDKClosingSignedFeeRange o);
/* @internal */ parcelHelpers.export(exports, "CResult_ClosingSignedFeeRangeDecodeErrorZ_ok", ()=>CResult_ClosingSignedFeeRangeDecodeErrorZ_ok
);
// struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ClosingSignedFeeRangeDecodeErrorZ_err", ()=>CResult_ClosingSignedFeeRangeDecodeErrorZ_err
);
// bool CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(const struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok", ()=>CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok
);
// void CResult_ClosingSignedFeeRangeDecodeErrorZ_free(struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ClosingSignedFeeRangeDecodeErrorZ_free", ()=>CResult_ClosingSignedFeeRangeDecodeErrorZ_free
);
// uintptr_t CResult_ClosingSignedFeeRangeDecodeErrorZ_clone_ptr(LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_ClosingSignedFeeRangeDecodeErrorZ_clone_ptr", ()=>CResult_ClosingSignedFeeRangeDecodeErrorZ_clone_ptr
);
// struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(const struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_ClosingSignedFeeRangeDecodeErrorZ_clone", ()=>CResult_ClosingSignedFeeRangeDecodeErrorZ_clone
);
// struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_ok(struct LDKCommitmentSigned o);
/* @internal */ parcelHelpers.export(exports, "CResult_CommitmentSignedDecodeErrorZ_ok", ()=>CResult_CommitmentSignedDecodeErrorZ_ok
);
// struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_CommitmentSignedDecodeErrorZ_err", ()=>CResult_CommitmentSignedDecodeErrorZ_err
);
// bool CResult_CommitmentSignedDecodeErrorZ_is_ok(const struct LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_CommitmentSignedDecodeErrorZ_is_ok", ()=>CResult_CommitmentSignedDecodeErrorZ_is_ok
);
// void CResult_CommitmentSignedDecodeErrorZ_free(struct LDKCResult_CommitmentSignedDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_CommitmentSignedDecodeErrorZ_free", ()=>CResult_CommitmentSignedDecodeErrorZ_free
);
// uintptr_t CResult_CommitmentSignedDecodeErrorZ_clone_ptr(LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_CommitmentSignedDecodeErrorZ_clone_ptr", ()=>CResult_CommitmentSignedDecodeErrorZ_clone_ptr
);
// struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_clone(const struct LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_CommitmentSignedDecodeErrorZ_clone", ()=>CResult_CommitmentSignedDecodeErrorZ_clone
);
// struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_ok(struct LDKFundingCreated o);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingCreatedDecodeErrorZ_ok", ()=>CResult_FundingCreatedDecodeErrorZ_ok
);
// struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingCreatedDecodeErrorZ_err", ()=>CResult_FundingCreatedDecodeErrorZ_err
);
// bool CResult_FundingCreatedDecodeErrorZ_is_ok(const struct LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingCreatedDecodeErrorZ_is_ok", ()=>CResult_FundingCreatedDecodeErrorZ_is_ok
);
// void CResult_FundingCreatedDecodeErrorZ_free(struct LDKCResult_FundingCreatedDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingCreatedDecodeErrorZ_free", ()=>CResult_FundingCreatedDecodeErrorZ_free
);
// uintptr_t CResult_FundingCreatedDecodeErrorZ_clone_ptr(LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingCreatedDecodeErrorZ_clone_ptr", ()=>CResult_FundingCreatedDecodeErrorZ_clone_ptr
);
// struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_clone(const struct LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingCreatedDecodeErrorZ_clone", ()=>CResult_FundingCreatedDecodeErrorZ_clone
);
// struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_ok(struct LDKFundingSigned o);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingSignedDecodeErrorZ_ok", ()=>CResult_FundingSignedDecodeErrorZ_ok
);
// struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingSignedDecodeErrorZ_err", ()=>CResult_FundingSignedDecodeErrorZ_err
);
// bool CResult_FundingSignedDecodeErrorZ_is_ok(const struct LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingSignedDecodeErrorZ_is_ok", ()=>CResult_FundingSignedDecodeErrorZ_is_ok
);
// void CResult_FundingSignedDecodeErrorZ_free(struct LDKCResult_FundingSignedDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingSignedDecodeErrorZ_free", ()=>CResult_FundingSignedDecodeErrorZ_free
);
// uintptr_t CResult_FundingSignedDecodeErrorZ_clone_ptr(LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingSignedDecodeErrorZ_clone_ptr", ()=>CResult_FundingSignedDecodeErrorZ_clone_ptr
);
// struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_clone(const struct LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingSignedDecodeErrorZ_clone", ()=>CResult_FundingSignedDecodeErrorZ_clone
);
// struct LDKCResult_FundingLockedDecodeErrorZ CResult_FundingLockedDecodeErrorZ_ok(struct LDKFundingLocked o);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingLockedDecodeErrorZ_ok", ()=>CResult_FundingLockedDecodeErrorZ_ok
);
// struct LDKCResult_FundingLockedDecodeErrorZ CResult_FundingLockedDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingLockedDecodeErrorZ_err", ()=>CResult_FundingLockedDecodeErrorZ_err
);
// bool CResult_FundingLockedDecodeErrorZ_is_ok(const struct LDKCResult_FundingLockedDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingLockedDecodeErrorZ_is_ok", ()=>CResult_FundingLockedDecodeErrorZ_is_ok
);
// void CResult_FundingLockedDecodeErrorZ_free(struct LDKCResult_FundingLockedDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingLockedDecodeErrorZ_free", ()=>CResult_FundingLockedDecodeErrorZ_free
);
// uintptr_t CResult_FundingLockedDecodeErrorZ_clone_ptr(LDKCResult_FundingLockedDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingLockedDecodeErrorZ_clone_ptr", ()=>CResult_FundingLockedDecodeErrorZ_clone_ptr
);
// struct LDKCResult_FundingLockedDecodeErrorZ CResult_FundingLockedDecodeErrorZ_clone(const struct LDKCResult_FundingLockedDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_FundingLockedDecodeErrorZ_clone", ()=>CResult_FundingLockedDecodeErrorZ_clone
);
// struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_ok(struct LDKInit o);
/* @internal */ parcelHelpers.export(exports, "CResult_InitDecodeErrorZ_ok", ()=>CResult_InitDecodeErrorZ_ok
);
// struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_InitDecodeErrorZ_err", ()=>CResult_InitDecodeErrorZ_err
);
// bool CResult_InitDecodeErrorZ_is_ok(const struct LDKCResult_InitDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_InitDecodeErrorZ_is_ok", ()=>CResult_InitDecodeErrorZ_is_ok
);
// void CResult_InitDecodeErrorZ_free(struct LDKCResult_InitDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_InitDecodeErrorZ_free", ()=>CResult_InitDecodeErrorZ_free
);
// uintptr_t CResult_InitDecodeErrorZ_clone_ptr(LDKCResult_InitDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_InitDecodeErrorZ_clone_ptr", ()=>CResult_InitDecodeErrorZ_clone_ptr
);
// struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_clone(const struct LDKCResult_InitDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_InitDecodeErrorZ_clone", ()=>CResult_InitDecodeErrorZ_clone
);
// struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_ok(struct LDKOpenChannel o);
/* @internal */ parcelHelpers.export(exports, "CResult_OpenChannelDecodeErrorZ_ok", ()=>CResult_OpenChannelDecodeErrorZ_ok
);
// struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_OpenChannelDecodeErrorZ_err", ()=>CResult_OpenChannelDecodeErrorZ_err
);
// bool CResult_OpenChannelDecodeErrorZ_is_ok(const struct LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_OpenChannelDecodeErrorZ_is_ok", ()=>CResult_OpenChannelDecodeErrorZ_is_ok
);
// void CResult_OpenChannelDecodeErrorZ_free(struct LDKCResult_OpenChannelDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_OpenChannelDecodeErrorZ_free", ()=>CResult_OpenChannelDecodeErrorZ_free
);
// uintptr_t CResult_OpenChannelDecodeErrorZ_clone_ptr(LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_OpenChannelDecodeErrorZ_clone_ptr", ()=>CResult_OpenChannelDecodeErrorZ_clone_ptr
);
// struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_clone(const struct LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_OpenChannelDecodeErrorZ_clone", ()=>CResult_OpenChannelDecodeErrorZ_clone
);
// struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_ok(struct LDKRevokeAndACK o);
/* @internal */ parcelHelpers.export(exports, "CResult_RevokeAndACKDecodeErrorZ_ok", ()=>CResult_RevokeAndACKDecodeErrorZ_ok
);
// struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_RevokeAndACKDecodeErrorZ_err", ()=>CResult_RevokeAndACKDecodeErrorZ_err
);
// bool CResult_RevokeAndACKDecodeErrorZ_is_ok(const struct LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_RevokeAndACKDecodeErrorZ_is_ok", ()=>CResult_RevokeAndACKDecodeErrorZ_is_ok
);
// void CResult_RevokeAndACKDecodeErrorZ_free(struct LDKCResult_RevokeAndACKDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_RevokeAndACKDecodeErrorZ_free", ()=>CResult_RevokeAndACKDecodeErrorZ_free
);
// uintptr_t CResult_RevokeAndACKDecodeErrorZ_clone_ptr(LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_RevokeAndACKDecodeErrorZ_clone_ptr", ()=>CResult_RevokeAndACKDecodeErrorZ_clone_ptr
);
// struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_clone(const struct LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_RevokeAndACKDecodeErrorZ_clone", ()=>CResult_RevokeAndACKDecodeErrorZ_clone
);
// struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_ok(struct LDKShutdown o);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownDecodeErrorZ_ok", ()=>CResult_ShutdownDecodeErrorZ_ok
);
// struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownDecodeErrorZ_err", ()=>CResult_ShutdownDecodeErrorZ_err
);
// bool CResult_ShutdownDecodeErrorZ_is_ok(const struct LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownDecodeErrorZ_is_ok", ()=>CResult_ShutdownDecodeErrorZ_is_ok
);
// void CResult_ShutdownDecodeErrorZ_free(struct LDKCResult_ShutdownDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownDecodeErrorZ_free", ()=>CResult_ShutdownDecodeErrorZ_free
);
// uintptr_t CResult_ShutdownDecodeErrorZ_clone_ptr(LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownDecodeErrorZ_clone_ptr", ()=>CResult_ShutdownDecodeErrorZ_clone_ptr
);
// struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_clone(const struct LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_ShutdownDecodeErrorZ_clone", ()=>CResult_ShutdownDecodeErrorZ_clone
);
// struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_ok(struct LDKUpdateFailHTLC o);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFailHTLCDecodeErrorZ_ok", ()=>CResult_UpdateFailHTLCDecodeErrorZ_ok
);
// struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFailHTLCDecodeErrorZ_err", ()=>CResult_UpdateFailHTLCDecodeErrorZ_err
);
// bool CResult_UpdateFailHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFailHTLCDecodeErrorZ_is_ok", ()=>CResult_UpdateFailHTLCDecodeErrorZ_is_ok
);
// void CResult_UpdateFailHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFailHTLCDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFailHTLCDecodeErrorZ_free", ()=>CResult_UpdateFailHTLCDecodeErrorZ_free
);
// uintptr_t CResult_UpdateFailHTLCDecodeErrorZ_clone_ptr(LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFailHTLCDecodeErrorZ_clone_ptr", ()=>CResult_UpdateFailHTLCDecodeErrorZ_clone_ptr
);
// struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFailHTLCDecodeErrorZ_clone", ()=>CResult_UpdateFailHTLCDecodeErrorZ_clone
);
// struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(struct LDKUpdateFailMalformedHTLC o);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok", ()=>CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok
);
// struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFailMalformedHTLCDecodeErrorZ_err", ()=>CResult_UpdateFailMalformedHTLCDecodeErrorZ_err
);
// bool CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok", ()=>CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok
);
// void CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFailMalformedHTLCDecodeErrorZ_free", ()=>CResult_UpdateFailMalformedHTLCDecodeErrorZ_free
);
// uintptr_t CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone_ptr(LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone_ptr", ()=>CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone_ptr
);
// struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone", ()=>CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone
);
// struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_ok(struct LDKUpdateFee o);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFeeDecodeErrorZ_ok", ()=>CResult_UpdateFeeDecodeErrorZ_ok
);
// struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFeeDecodeErrorZ_err", ()=>CResult_UpdateFeeDecodeErrorZ_err
);
// bool CResult_UpdateFeeDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFeeDecodeErrorZ_is_ok", ()=>CResult_UpdateFeeDecodeErrorZ_is_ok
);
// void CResult_UpdateFeeDecodeErrorZ_free(struct LDKCResult_UpdateFeeDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFeeDecodeErrorZ_free", ()=>CResult_UpdateFeeDecodeErrorZ_free
);
// uintptr_t CResult_UpdateFeeDecodeErrorZ_clone_ptr(LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFeeDecodeErrorZ_clone_ptr", ()=>CResult_UpdateFeeDecodeErrorZ_clone_ptr
);
// struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_clone(const struct LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFeeDecodeErrorZ_clone", ()=>CResult_UpdateFeeDecodeErrorZ_clone
);
// struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_ok(struct LDKUpdateFulfillHTLC o);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFulfillHTLCDecodeErrorZ_ok", ()=>CResult_UpdateFulfillHTLCDecodeErrorZ_ok
);
// struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFulfillHTLCDecodeErrorZ_err", ()=>CResult_UpdateFulfillHTLCDecodeErrorZ_err
);
// bool CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok", ()=>CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok
);
// void CResult_UpdateFulfillHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFulfillHTLCDecodeErrorZ_free", ()=>CResult_UpdateFulfillHTLCDecodeErrorZ_free
);
// uintptr_t CResult_UpdateFulfillHTLCDecodeErrorZ_clone_ptr(LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFulfillHTLCDecodeErrorZ_clone_ptr", ()=>CResult_UpdateFulfillHTLCDecodeErrorZ_clone_ptr
);
// struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateFulfillHTLCDecodeErrorZ_clone", ()=>CResult_UpdateFulfillHTLCDecodeErrorZ_clone
);
// struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_ok(struct LDKUpdateAddHTLC o);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateAddHTLCDecodeErrorZ_ok", ()=>CResult_UpdateAddHTLCDecodeErrorZ_ok
);
// struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateAddHTLCDecodeErrorZ_err", ()=>CResult_UpdateAddHTLCDecodeErrorZ_err
);
// bool CResult_UpdateAddHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateAddHTLCDecodeErrorZ_is_ok", ()=>CResult_UpdateAddHTLCDecodeErrorZ_is_ok
);
// void CResult_UpdateAddHTLCDecodeErrorZ_free(struct LDKCResult_UpdateAddHTLCDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateAddHTLCDecodeErrorZ_free", ()=>CResult_UpdateAddHTLCDecodeErrorZ_free
);
// uintptr_t CResult_UpdateAddHTLCDecodeErrorZ_clone_ptr(LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateAddHTLCDecodeErrorZ_clone_ptr", ()=>CResult_UpdateAddHTLCDecodeErrorZ_clone_ptr
);
// struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_UpdateAddHTLCDecodeErrorZ_clone", ()=>CResult_UpdateAddHTLCDecodeErrorZ_clone
);
// struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_ok(struct LDKPing o);
/* @internal */ parcelHelpers.export(exports, "CResult_PingDecodeErrorZ_ok", ()=>CResult_PingDecodeErrorZ_ok
);
// struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_PingDecodeErrorZ_err", ()=>CResult_PingDecodeErrorZ_err
);
// bool CResult_PingDecodeErrorZ_is_ok(const struct LDKCResult_PingDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_PingDecodeErrorZ_is_ok", ()=>CResult_PingDecodeErrorZ_is_ok
);
// void CResult_PingDecodeErrorZ_free(struct LDKCResult_PingDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_PingDecodeErrorZ_free", ()=>CResult_PingDecodeErrorZ_free
);
// uintptr_t CResult_PingDecodeErrorZ_clone_ptr(LDKCResult_PingDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_PingDecodeErrorZ_clone_ptr", ()=>CResult_PingDecodeErrorZ_clone_ptr
);
// struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_clone(const struct LDKCResult_PingDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_PingDecodeErrorZ_clone", ()=>CResult_PingDecodeErrorZ_clone
);
// struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_ok(struct LDKPong o);
/* @internal */ parcelHelpers.export(exports, "CResult_PongDecodeErrorZ_ok", ()=>CResult_PongDecodeErrorZ_ok
);
// struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_PongDecodeErrorZ_err", ()=>CResult_PongDecodeErrorZ_err
);
// bool CResult_PongDecodeErrorZ_is_ok(const struct LDKCResult_PongDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_PongDecodeErrorZ_is_ok", ()=>CResult_PongDecodeErrorZ_is_ok
);
// void CResult_PongDecodeErrorZ_free(struct LDKCResult_PongDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_PongDecodeErrorZ_free", ()=>CResult_PongDecodeErrorZ_free
);
// uintptr_t CResult_PongDecodeErrorZ_clone_ptr(LDKCResult_PongDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_PongDecodeErrorZ_clone_ptr", ()=>CResult_PongDecodeErrorZ_clone_ptr
);
// struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_clone(const struct LDKCResult_PongDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_PongDecodeErrorZ_clone", ()=>CResult_PongDecodeErrorZ_clone
);
// struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(struct LDKUnsignedChannelAnnouncement o);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok", ()=>CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok
);
// struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedChannelAnnouncementDecodeErrorZ_err", ()=>CResult_UnsignedChannelAnnouncementDecodeErrorZ_err
);
// bool CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok", ()=>CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok
);
// void CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedChannelAnnouncementDecodeErrorZ_free", ()=>CResult_UnsignedChannelAnnouncementDecodeErrorZ_free
);
// uintptr_t CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone_ptr(LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone_ptr", ()=>CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone_ptr
);
// struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(const struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone", ()=>CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone
);
// struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_ok(struct LDKChannelAnnouncement o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelAnnouncementDecodeErrorZ_ok", ()=>CResult_ChannelAnnouncementDecodeErrorZ_ok
);
// struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelAnnouncementDecodeErrorZ_err", ()=>CResult_ChannelAnnouncementDecodeErrorZ_err
);
// bool CResult_ChannelAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelAnnouncementDecodeErrorZ_is_ok", ()=>CResult_ChannelAnnouncementDecodeErrorZ_is_ok
);
// void CResult_ChannelAnnouncementDecodeErrorZ_free(struct LDKCResult_ChannelAnnouncementDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelAnnouncementDecodeErrorZ_free", ()=>CResult_ChannelAnnouncementDecodeErrorZ_free
);
// uintptr_t CResult_ChannelAnnouncementDecodeErrorZ_clone_ptr(LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelAnnouncementDecodeErrorZ_clone_ptr", ()=>CResult_ChannelAnnouncementDecodeErrorZ_clone_ptr
);
// struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_clone(const struct LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelAnnouncementDecodeErrorZ_clone", ()=>CResult_ChannelAnnouncementDecodeErrorZ_clone
);
// struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_ok(struct LDKUnsignedChannelUpdate o);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedChannelUpdateDecodeErrorZ_ok", ()=>CResult_UnsignedChannelUpdateDecodeErrorZ_ok
);
// struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedChannelUpdateDecodeErrorZ_err", ()=>CResult_UnsignedChannelUpdateDecodeErrorZ_err
);
// bool CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok", ()=>CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok
);
// void CResult_UnsignedChannelUpdateDecodeErrorZ_free(struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedChannelUpdateDecodeErrorZ_free", ()=>CResult_UnsignedChannelUpdateDecodeErrorZ_free
);
// uintptr_t CResult_UnsignedChannelUpdateDecodeErrorZ_clone_ptr(LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedChannelUpdateDecodeErrorZ_clone_ptr", ()=>CResult_UnsignedChannelUpdateDecodeErrorZ_clone_ptr
);
// struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_clone(const struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedChannelUpdateDecodeErrorZ_clone", ()=>CResult_UnsignedChannelUpdateDecodeErrorZ_clone
);
// struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_ok(struct LDKChannelUpdate o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelUpdateDecodeErrorZ_ok", ()=>CResult_ChannelUpdateDecodeErrorZ_ok
);
// struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelUpdateDecodeErrorZ_err", ()=>CResult_ChannelUpdateDecodeErrorZ_err
);
// bool CResult_ChannelUpdateDecodeErrorZ_is_ok(const struct LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelUpdateDecodeErrorZ_is_ok", ()=>CResult_ChannelUpdateDecodeErrorZ_is_ok
);
// void CResult_ChannelUpdateDecodeErrorZ_free(struct LDKCResult_ChannelUpdateDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelUpdateDecodeErrorZ_free", ()=>CResult_ChannelUpdateDecodeErrorZ_free
);
// uintptr_t CResult_ChannelUpdateDecodeErrorZ_clone_ptr(LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelUpdateDecodeErrorZ_clone_ptr", ()=>CResult_ChannelUpdateDecodeErrorZ_clone_ptr
);
// struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_clone(const struct LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_ChannelUpdateDecodeErrorZ_clone", ()=>CResult_ChannelUpdateDecodeErrorZ_clone
);
// struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_ok(struct LDKErrorMessage o);
/* @internal */ parcelHelpers.export(exports, "CResult_ErrorMessageDecodeErrorZ_ok", ()=>CResult_ErrorMessageDecodeErrorZ_ok
);
// struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ErrorMessageDecodeErrorZ_err", ()=>CResult_ErrorMessageDecodeErrorZ_err
);
// bool CResult_ErrorMessageDecodeErrorZ_is_ok(const struct LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ErrorMessageDecodeErrorZ_is_ok", ()=>CResult_ErrorMessageDecodeErrorZ_is_ok
);
// void CResult_ErrorMessageDecodeErrorZ_free(struct LDKCResult_ErrorMessageDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ErrorMessageDecodeErrorZ_free", ()=>CResult_ErrorMessageDecodeErrorZ_free
);
// uintptr_t CResult_ErrorMessageDecodeErrorZ_clone_ptr(LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_ErrorMessageDecodeErrorZ_clone_ptr", ()=>CResult_ErrorMessageDecodeErrorZ_clone_ptr
);
// struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_clone(const struct LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_ErrorMessageDecodeErrorZ_clone", ()=>CResult_ErrorMessageDecodeErrorZ_clone
);
// struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(struct LDKUnsignedNodeAnnouncement o);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok", ()=>CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok
);
// struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedNodeAnnouncementDecodeErrorZ_err", ()=>CResult_UnsignedNodeAnnouncementDecodeErrorZ_err
);
// bool CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok", ()=>CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok
);
// void CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedNodeAnnouncementDecodeErrorZ_free", ()=>CResult_UnsignedNodeAnnouncementDecodeErrorZ_free
);
// uintptr_t CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone_ptr(LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone_ptr", ()=>CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone_ptr
);
// struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(const struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone", ()=>CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone
);
// struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_ok(struct LDKNodeAnnouncement o);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeAnnouncementDecodeErrorZ_ok", ()=>CResult_NodeAnnouncementDecodeErrorZ_ok
);
// struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeAnnouncementDecodeErrorZ_err", ()=>CResult_NodeAnnouncementDecodeErrorZ_err
);
// bool CResult_NodeAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeAnnouncementDecodeErrorZ_is_ok", ()=>CResult_NodeAnnouncementDecodeErrorZ_is_ok
);
// void CResult_NodeAnnouncementDecodeErrorZ_free(struct LDKCResult_NodeAnnouncementDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeAnnouncementDecodeErrorZ_free", ()=>CResult_NodeAnnouncementDecodeErrorZ_free
);
// uintptr_t CResult_NodeAnnouncementDecodeErrorZ_clone_ptr(LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeAnnouncementDecodeErrorZ_clone_ptr", ()=>CResult_NodeAnnouncementDecodeErrorZ_clone_ptr
);
// struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_clone(const struct LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_NodeAnnouncementDecodeErrorZ_clone", ()=>CResult_NodeAnnouncementDecodeErrorZ_clone
);
// struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_ok(struct LDKQueryShortChannelIds o);
/* @internal */ parcelHelpers.export(exports, "CResult_QueryShortChannelIdsDecodeErrorZ_ok", ()=>CResult_QueryShortChannelIdsDecodeErrorZ_ok
);
// struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_QueryShortChannelIdsDecodeErrorZ_err", ()=>CResult_QueryShortChannelIdsDecodeErrorZ_err
);
// bool CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(const struct LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_QueryShortChannelIdsDecodeErrorZ_is_ok", ()=>CResult_QueryShortChannelIdsDecodeErrorZ_is_ok
);
// void CResult_QueryShortChannelIdsDecodeErrorZ_free(struct LDKCResult_QueryShortChannelIdsDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_QueryShortChannelIdsDecodeErrorZ_free", ()=>CResult_QueryShortChannelIdsDecodeErrorZ_free
);
// uintptr_t CResult_QueryShortChannelIdsDecodeErrorZ_clone_ptr(LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_QueryShortChannelIdsDecodeErrorZ_clone_ptr", ()=>CResult_QueryShortChannelIdsDecodeErrorZ_clone_ptr
);
// struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_clone(const struct LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_QueryShortChannelIdsDecodeErrorZ_clone", ()=>CResult_QueryShortChannelIdsDecodeErrorZ_clone
);
// struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(struct LDKReplyShortChannelIdsEnd o);
/* @internal */ parcelHelpers.export(exports, "CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok", ()=>CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok
);
// struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ReplyShortChannelIdsEndDecodeErrorZ_err", ()=>CResult_ReplyShortChannelIdsEndDecodeErrorZ_err
);
// bool CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(const struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok", ()=>CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok
);
// void CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ReplyShortChannelIdsEndDecodeErrorZ_free", ()=>CResult_ReplyShortChannelIdsEndDecodeErrorZ_free
);
// uintptr_t CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone_ptr(LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone_ptr", ()=>CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone_ptr
);
// struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(const struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone", ()=>CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone
);
// struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_ok(struct LDKQueryChannelRange o);
/* @internal */ parcelHelpers.export(exports, "CResult_QueryChannelRangeDecodeErrorZ_ok", ()=>CResult_QueryChannelRangeDecodeErrorZ_ok
);
// struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_QueryChannelRangeDecodeErrorZ_err", ()=>CResult_QueryChannelRangeDecodeErrorZ_err
);
// bool CResult_QueryChannelRangeDecodeErrorZ_is_ok(const struct LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_QueryChannelRangeDecodeErrorZ_is_ok", ()=>CResult_QueryChannelRangeDecodeErrorZ_is_ok
);
// void CResult_QueryChannelRangeDecodeErrorZ_free(struct LDKCResult_QueryChannelRangeDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_QueryChannelRangeDecodeErrorZ_free", ()=>CResult_QueryChannelRangeDecodeErrorZ_free
);
// uintptr_t CResult_QueryChannelRangeDecodeErrorZ_clone_ptr(LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_QueryChannelRangeDecodeErrorZ_clone_ptr", ()=>CResult_QueryChannelRangeDecodeErrorZ_clone_ptr
);
// struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_clone(const struct LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_QueryChannelRangeDecodeErrorZ_clone", ()=>CResult_QueryChannelRangeDecodeErrorZ_clone
);
// struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_ok(struct LDKReplyChannelRange o);
/* @internal */ parcelHelpers.export(exports, "CResult_ReplyChannelRangeDecodeErrorZ_ok", ()=>CResult_ReplyChannelRangeDecodeErrorZ_ok
);
// struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_ReplyChannelRangeDecodeErrorZ_err", ()=>CResult_ReplyChannelRangeDecodeErrorZ_err
);
// bool CResult_ReplyChannelRangeDecodeErrorZ_is_ok(const struct LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_ReplyChannelRangeDecodeErrorZ_is_ok", ()=>CResult_ReplyChannelRangeDecodeErrorZ_is_ok
);
// void CResult_ReplyChannelRangeDecodeErrorZ_free(struct LDKCResult_ReplyChannelRangeDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_ReplyChannelRangeDecodeErrorZ_free", ()=>CResult_ReplyChannelRangeDecodeErrorZ_free
);
// uintptr_t CResult_ReplyChannelRangeDecodeErrorZ_clone_ptr(LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_ReplyChannelRangeDecodeErrorZ_clone_ptr", ()=>CResult_ReplyChannelRangeDecodeErrorZ_clone_ptr
);
// struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_clone(const struct LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_ReplyChannelRangeDecodeErrorZ_clone", ()=>CResult_ReplyChannelRangeDecodeErrorZ_clone
);
// struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_ok(struct LDKGossipTimestampFilter o);
/* @internal */ parcelHelpers.export(exports, "CResult_GossipTimestampFilterDecodeErrorZ_ok", ()=>CResult_GossipTimestampFilterDecodeErrorZ_ok
);
// struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_GossipTimestampFilterDecodeErrorZ_err", ()=>CResult_GossipTimestampFilterDecodeErrorZ_err
);
// bool CResult_GossipTimestampFilterDecodeErrorZ_is_ok(const struct LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_GossipTimestampFilterDecodeErrorZ_is_ok", ()=>CResult_GossipTimestampFilterDecodeErrorZ_is_ok
);
// void CResult_GossipTimestampFilterDecodeErrorZ_free(struct LDKCResult_GossipTimestampFilterDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_GossipTimestampFilterDecodeErrorZ_free", ()=>CResult_GossipTimestampFilterDecodeErrorZ_free
);
// uintptr_t CResult_GossipTimestampFilterDecodeErrorZ_clone_ptr(LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_GossipTimestampFilterDecodeErrorZ_clone_ptr", ()=>CResult_GossipTimestampFilterDecodeErrorZ_clone_ptr
);
// struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_clone(const struct LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_GossipTimestampFilterDecodeErrorZ_clone", ()=>CResult_GossipTimestampFilterDecodeErrorZ_clone
);
// struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(struct LDKDelayedPaymentOutputDescriptor o);
/* @internal */ parcelHelpers.export(exports, "CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok", ()=>CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok
);
// struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err", ()=>CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err
);
// bool CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok", ()=>CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok
);
// void CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free", ()=>CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free
);
// uintptr_t CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone_ptr(LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone_ptr", ()=>CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone_ptr
);
// struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone", ()=>CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone
);
// struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(struct LDKStaticPaymentOutputDescriptor o);
/* @internal */ parcelHelpers.export(exports, "CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok", ()=>CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok
);
// struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err", ()=>CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err
);
// bool CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok", ()=>CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok
);
// void CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free", ()=>CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free
);
// uintptr_t CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone_ptr(LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone_ptr", ()=>CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone_ptr
);
// struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone", ()=>CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone
);
// struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_ok(struct LDKSpendableOutputDescriptor o);
/* @internal */ parcelHelpers.export(exports, "CResult_SpendableOutputDescriptorDecodeErrorZ_ok", ()=>CResult_SpendableOutputDescriptorDecodeErrorZ_ok
);
// struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_SpendableOutputDescriptorDecodeErrorZ_err", ()=>CResult_SpendableOutputDescriptorDecodeErrorZ_err
);
// bool CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok", ()=>CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok
);
// void CResult_SpendableOutputDescriptorDecodeErrorZ_free(struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_SpendableOutputDescriptorDecodeErrorZ_free", ()=>CResult_SpendableOutputDescriptorDecodeErrorZ_free
);
// uintptr_t CResult_SpendableOutputDescriptorDecodeErrorZ_clone_ptr(LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_SpendableOutputDescriptorDecodeErrorZ_clone_ptr", ()=>CResult_SpendableOutputDescriptorDecodeErrorZ_clone_ptr
);
// struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_SpendableOutputDescriptorDecodeErrorZ_clone", ()=>CResult_SpendableOutputDescriptorDecodeErrorZ_clone
);
// uintptr_t C2Tuple_SignatureCVec_SignatureZZ_clone_ptr(LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_SignatureCVec_SignatureZZ_clone_ptr", ()=>C2Tuple_SignatureCVec_SignatureZZ_clone_ptr
);
// struct LDKC2Tuple_SignatureCVec_SignatureZZ C2Tuple_SignatureCVec_SignatureZZ_clone(const struct LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_SignatureCVec_SignatureZZ_clone", ()=>C2Tuple_SignatureCVec_SignatureZZ_clone
);
// struct LDKC2Tuple_SignatureCVec_SignatureZZ C2Tuple_SignatureCVec_SignatureZZ_new(struct LDKSignature a, struct LDKCVec_SignatureZ b);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_SignatureCVec_SignatureZZ_new", ()=>C2Tuple_SignatureCVec_SignatureZZ_new
);
// void C2Tuple_SignatureCVec_SignatureZZ_free(struct LDKC2Tuple_SignatureCVec_SignatureZZ _res);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_SignatureCVec_SignatureZZ_free", ()=>C2Tuple_SignatureCVec_SignatureZZ_free
);
// struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(struct LDKC2Tuple_SignatureCVec_SignatureZZ o);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok", ()=>CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok
);
// struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err(void);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err", ()=>CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err
);
// bool CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok(const struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok", ()=>CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok
);
// void CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free(struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free", ()=>CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free
);
// uintptr_t CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone_ptr(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone_ptr", ()=>CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone_ptr
);
// struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(const struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone", ()=>CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone
);
// struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_ok(struct LDKSignature o);
/* @internal */ parcelHelpers.export(exports, "CResult_SignatureNoneZ_ok", ()=>CResult_SignatureNoneZ_ok
);
// struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_err(void);
/* @internal */ parcelHelpers.export(exports, "CResult_SignatureNoneZ_err", ()=>CResult_SignatureNoneZ_err
);
// bool CResult_SignatureNoneZ_is_ok(const struct LDKCResult_SignatureNoneZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_SignatureNoneZ_is_ok", ()=>CResult_SignatureNoneZ_is_ok
);
// void CResult_SignatureNoneZ_free(struct LDKCResult_SignatureNoneZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_SignatureNoneZ_free", ()=>CResult_SignatureNoneZ_free
);
// uintptr_t CResult_SignatureNoneZ_clone_ptr(LDKCResult_SignatureNoneZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_SignatureNoneZ_clone_ptr", ()=>CResult_SignatureNoneZ_clone_ptr
);
// struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_clone(const struct LDKCResult_SignatureNoneZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_SignatureNoneZ_clone", ()=>CResult_SignatureNoneZ_clone
);
// struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_ok(struct LDKSign o);
/* @internal */ parcelHelpers.export(exports, "CResult_SignDecodeErrorZ_ok", ()=>CResult_SignDecodeErrorZ_ok
);
// struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_SignDecodeErrorZ_err", ()=>CResult_SignDecodeErrorZ_err
);
// bool CResult_SignDecodeErrorZ_is_ok(const struct LDKCResult_SignDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_SignDecodeErrorZ_is_ok", ()=>CResult_SignDecodeErrorZ_is_ok
);
// void CResult_SignDecodeErrorZ_free(struct LDKCResult_SignDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_SignDecodeErrorZ_free", ()=>CResult_SignDecodeErrorZ_free
);
// uintptr_t CResult_SignDecodeErrorZ_clone_ptr(LDKCResult_SignDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_SignDecodeErrorZ_clone_ptr", ()=>CResult_SignDecodeErrorZ_clone_ptr
);
// struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_clone(const struct LDKCResult_SignDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_SignDecodeErrorZ_clone", ()=>CResult_SignDecodeErrorZ_clone
);
// struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_ok(struct LDKRecoverableSignature o);
/* @internal */ parcelHelpers.export(exports, "CResult_RecoverableSignatureNoneZ_ok", ()=>CResult_RecoverableSignatureNoneZ_ok
);
// struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_err(void);
/* @internal */ parcelHelpers.export(exports, "CResult_RecoverableSignatureNoneZ_err", ()=>CResult_RecoverableSignatureNoneZ_err
);
// bool CResult_RecoverableSignatureNoneZ_is_ok(const struct LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_RecoverableSignatureNoneZ_is_ok", ()=>CResult_RecoverableSignatureNoneZ_is_ok
);
// void CResult_RecoverableSignatureNoneZ_free(struct LDKCResult_RecoverableSignatureNoneZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_RecoverableSignatureNoneZ_free", ()=>CResult_RecoverableSignatureNoneZ_free
);
// uintptr_t CResult_RecoverableSignatureNoneZ_clone_ptr(LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_RecoverableSignatureNoneZ_clone_ptr", ()=>CResult_RecoverableSignatureNoneZ_clone_ptr
);
// struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_clone(const struct LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_RecoverableSignatureNoneZ_clone", ()=>CResult_RecoverableSignatureNoneZ_clone
);
// void CVec_CVec_u8ZZ_free(struct LDKCVec_CVec_u8ZZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_CVec_u8ZZ_free", ()=>CVec_CVec_u8ZZ_free
);
// struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_ok(struct LDKCVec_CVec_u8ZZ o);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_CVec_u8ZZNoneZ_ok", ()=>CResult_CVec_CVec_u8ZZNoneZ_ok
);
// struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_err(void);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_CVec_u8ZZNoneZ_err", ()=>CResult_CVec_CVec_u8ZZNoneZ_err
);
// bool CResult_CVec_CVec_u8ZZNoneZ_is_ok(const struct LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_CVec_u8ZZNoneZ_is_ok", ()=>CResult_CVec_CVec_u8ZZNoneZ_is_ok
);
// void CResult_CVec_CVec_u8ZZNoneZ_free(struct LDKCResult_CVec_CVec_u8ZZNoneZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_CVec_u8ZZNoneZ_free", ()=>CResult_CVec_CVec_u8ZZNoneZ_free
);
// uintptr_t CResult_CVec_CVec_u8ZZNoneZ_clone_ptr(LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_CVec_u8ZZNoneZ_clone_ptr", ()=>CResult_CVec_CVec_u8ZZNoneZ_clone_ptr
);
// struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_clone(const struct LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_CVec_CVec_u8ZZNoneZ_clone", ()=>CResult_CVec_CVec_u8ZZNoneZ_clone
);
// struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_ok(struct LDKInMemorySigner o);
/* @internal */ parcelHelpers.export(exports, "CResult_InMemorySignerDecodeErrorZ_ok", ()=>CResult_InMemorySignerDecodeErrorZ_ok
);
// struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_InMemorySignerDecodeErrorZ_err", ()=>CResult_InMemorySignerDecodeErrorZ_err
);
// bool CResult_InMemorySignerDecodeErrorZ_is_ok(const struct LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_InMemorySignerDecodeErrorZ_is_ok", ()=>CResult_InMemorySignerDecodeErrorZ_is_ok
);
// void CResult_InMemorySignerDecodeErrorZ_free(struct LDKCResult_InMemorySignerDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_InMemorySignerDecodeErrorZ_free", ()=>CResult_InMemorySignerDecodeErrorZ_free
);
// uintptr_t CResult_InMemorySignerDecodeErrorZ_clone_ptr(LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_InMemorySignerDecodeErrorZ_clone_ptr", ()=>CResult_InMemorySignerDecodeErrorZ_clone_ptr
);
// struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_clone(const struct LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_InMemorySignerDecodeErrorZ_clone", ()=>CResult_InMemorySignerDecodeErrorZ_clone
);
// void CVec_TxOutZ_free(struct LDKCVec_TxOutZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_TxOutZ_free", ()=>CVec_TxOutZ_free
);
// struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_ok(struct LDKTransaction o);
/* @internal */ parcelHelpers.export(exports, "CResult_TransactionNoneZ_ok", ()=>CResult_TransactionNoneZ_ok
);
// struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_err(void);
/* @internal */ parcelHelpers.export(exports, "CResult_TransactionNoneZ_err", ()=>CResult_TransactionNoneZ_err
);
// bool CResult_TransactionNoneZ_is_ok(const struct LDKCResult_TransactionNoneZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_TransactionNoneZ_is_ok", ()=>CResult_TransactionNoneZ_is_ok
);
// void CResult_TransactionNoneZ_free(struct LDKCResult_TransactionNoneZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_TransactionNoneZ_free", ()=>CResult_TransactionNoneZ_free
);
// uintptr_t CResult_TransactionNoneZ_clone_ptr(LDKCResult_TransactionNoneZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_TransactionNoneZ_clone_ptr", ()=>CResult_TransactionNoneZ_clone_ptr
);
// struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_clone(const struct LDKCResult_TransactionNoneZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_TransactionNoneZ_clone", ()=>CResult_TransactionNoneZ_clone
);
// struct LDKCOption_FilterZ COption_FilterZ_some(struct LDKFilter o);
/* @internal */ parcelHelpers.export(exports, "COption_FilterZ_some", ()=>COption_FilterZ_some
);
// struct LDKCOption_FilterZ COption_FilterZ_none(void);
/* @internal */ parcelHelpers.export(exports, "COption_FilterZ_none", ()=>COption_FilterZ_none
);
// void COption_FilterZ_free(struct LDKCOption_FilterZ _res);
/* @internal */ parcelHelpers.export(exports, "COption_FilterZ_free", ()=>COption_FilterZ_free
);
// struct LDKCResult_LockedChannelMonitorNoneZ CResult_LockedChannelMonitorNoneZ_ok(struct LDKLockedChannelMonitor o);
/* @internal */ parcelHelpers.export(exports, "CResult_LockedChannelMonitorNoneZ_ok", ()=>CResult_LockedChannelMonitorNoneZ_ok
);
// struct LDKCResult_LockedChannelMonitorNoneZ CResult_LockedChannelMonitorNoneZ_err(void);
/* @internal */ parcelHelpers.export(exports, "CResult_LockedChannelMonitorNoneZ_err", ()=>CResult_LockedChannelMonitorNoneZ_err
);
// bool CResult_LockedChannelMonitorNoneZ_is_ok(const struct LDKCResult_LockedChannelMonitorNoneZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_LockedChannelMonitorNoneZ_is_ok", ()=>CResult_LockedChannelMonitorNoneZ_is_ok
);
// void CResult_LockedChannelMonitorNoneZ_free(struct LDKCResult_LockedChannelMonitorNoneZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_LockedChannelMonitorNoneZ_free", ()=>CResult_LockedChannelMonitorNoneZ_free
);
// void CVec_OutPointZ_free(struct LDKCVec_OutPointZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_OutPointZ_free", ()=>CVec_OutPointZ_free
);
// struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_ok(void);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneAPIErrorZ_ok", ()=>CResult_NoneAPIErrorZ_ok
);
// struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_err(struct LDKAPIError e);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneAPIErrorZ_err", ()=>CResult_NoneAPIErrorZ_err
);
// bool CResult_NoneAPIErrorZ_is_ok(const struct LDKCResult_NoneAPIErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneAPIErrorZ_is_ok", ()=>CResult_NoneAPIErrorZ_is_ok
);
// void CResult_NoneAPIErrorZ_free(struct LDKCResult_NoneAPIErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneAPIErrorZ_free", ()=>CResult_NoneAPIErrorZ_free
);
// uintptr_t CResult_NoneAPIErrorZ_clone_ptr(LDKCResult_NoneAPIErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneAPIErrorZ_clone_ptr", ()=>CResult_NoneAPIErrorZ_clone_ptr
);
// struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_clone(const struct LDKCResult_NoneAPIErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_NoneAPIErrorZ_clone", ()=>CResult_NoneAPIErrorZ_clone
);
// struct LDKCOption_u16Z COption_u16Z_some(uint16_t o);
/* @internal */ parcelHelpers.export(exports, "COption_u16Z_some", ()=>COption_u16Z_some
);
// struct LDKCOption_u16Z COption_u16Z_none(void);
/* @internal */ parcelHelpers.export(exports, "COption_u16Z_none", ()=>COption_u16Z_none
);
// void COption_u16Z_free(struct LDKCOption_u16Z _res);
/* @internal */ parcelHelpers.export(exports, "COption_u16Z_free", ()=>COption_u16Z_free
);
// uintptr_t COption_u16Z_clone_ptr(LDKCOption_u16Z *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "COption_u16Z_clone_ptr", ()=>COption_u16Z_clone_ptr
);
// struct LDKCOption_u16Z COption_u16Z_clone(const struct LDKCOption_u16Z *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "COption_u16Z_clone", ()=>COption_u16Z_clone
);
// void CVec_CResult_NoneAPIErrorZZ_free(struct LDKCVec_CResult_NoneAPIErrorZZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_CResult_NoneAPIErrorZZ_free", ()=>CVec_CResult_NoneAPIErrorZZ_free
);
// void CVec_APIErrorZ_free(struct LDKCVec_APIErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_APIErrorZ_free", ()=>CVec_APIErrorZ_free
);
// struct LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */ parcelHelpers.export(exports, "CResult__u832APIErrorZ_ok", ()=>CResult__u832APIErrorZ_ok
);
// struct LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_err(struct LDKAPIError e);
/* @internal */ parcelHelpers.export(exports, "CResult__u832APIErrorZ_err", ()=>CResult__u832APIErrorZ_err
);
// bool CResult__u832APIErrorZ_is_ok(const struct LDKCResult__u832APIErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult__u832APIErrorZ_is_ok", ()=>CResult__u832APIErrorZ_is_ok
);
// void CResult__u832APIErrorZ_free(struct LDKCResult__u832APIErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult__u832APIErrorZ_free", ()=>CResult__u832APIErrorZ_free
);
// uintptr_t CResult__u832APIErrorZ_clone_ptr(LDKCResult__u832APIErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult__u832APIErrorZ_clone_ptr", ()=>CResult__u832APIErrorZ_clone_ptr
);
// struct LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_clone(const struct LDKCResult__u832APIErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult__u832APIErrorZ_clone", ()=>CResult__u832APIErrorZ_clone
);
// struct LDKCResult_PaymentIdPaymentSendFailureZ CResult_PaymentIdPaymentSendFailureZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentIdPaymentSendFailureZ_ok", ()=>CResult_PaymentIdPaymentSendFailureZ_ok
);
// struct LDKCResult_PaymentIdPaymentSendFailureZ CResult_PaymentIdPaymentSendFailureZ_err(struct LDKPaymentSendFailure e);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentIdPaymentSendFailureZ_err", ()=>CResult_PaymentIdPaymentSendFailureZ_err
);
// bool CResult_PaymentIdPaymentSendFailureZ_is_ok(const struct LDKCResult_PaymentIdPaymentSendFailureZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentIdPaymentSendFailureZ_is_ok", ()=>CResult_PaymentIdPaymentSendFailureZ_is_ok
);
// void CResult_PaymentIdPaymentSendFailureZ_free(struct LDKCResult_PaymentIdPaymentSendFailureZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentIdPaymentSendFailureZ_free", ()=>CResult_PaymentIdPaymentSendFailureZ_free
);
// uintptr_t CResult_PaymentIdPaymentSendFailureZ_clone_ptr(LDKCResult_PaymentIdPaymentSendFailureZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentIdPaymentSendFailureZ_clone_ptr", ()=>CResult_PaymentIdPaymentSendFailureZ_clone_ptr
);
// struct LDKCResult_PaymentIdPaymentSendFailureZ CResult_PaymentIdPaymentSendFailureZ_clone(const struct LDKCResult_PaymentIdPaymentSendFailureZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentIdPaymentSendFailureZ_clone", ()=>CResult_PaymentIdPaymentSendFailureZ_clone
);
// struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_ok(void);
/* @internal */ parcelHelpers.export(exports, "CResult_NonePaymentSendFailureZ_ok", ()=>CResult_NonePaymentSendFailureZ_ok
);
// struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_err(struct LDKPaymentSendFailure e);
/* @internal */ parcelHelpers.export(exports, "CResult_NonePaymentSendFailureZ_err", ()=>CResult_NonePaymentSendFailureZ_err
);
// bool CResult_NonePaymentSendFailureZ_is_ok(const struct LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_NonePaymentSendFailureZ_is_ok", ()=>CResult_NonePaymentSendFailureZ_is_ok
);
// void CResult_NonePaymentSendFailureZ_free(struct LDKCResult_NonePaymentSendFailureZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_NonePaymentSendFailureZ_free", ()=>CResult_NonePaymentSendFailureZ_free
);
// uintptr_t CResult_NonePaymentSendFailureZ_clone_ptr(LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_NonePaymentSendFailureZ_clone_ptr", ()=>CResult_NonePaymentSendFailureZ_clone_ptr
);
// struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_clone(const struct LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_NonePaymentSendFailureZ_clone", ()=>CResult_NonePaymentSendFailureZ_clone
);
// uintptr_t C2Tuple_PaymentHashPaymentIdZ_clone_ptr(LDKC2Tuple_PaymentHashPaymentIdZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PaymentHashPaymentIdZ_clone_ptr", ()=>C2Tuple_PaymentHashPaymentIdZ_clone_ptr
);
// struct LDKC2Tuple_PaymentHashPaymentIdZ C2Tuple_PaymentHashPaymentIdZ_clone(const struct LDKC2Tuple_PaymentHashPaymentIdZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PaymentHashPaymentIdZ_clone", ()=>C2Tuple_PaymentHashPaymentIdZ_clone
);
// struct LDKC2Tuple_PaymentHashPaymentIdZ C2Tuple_PaymentHashPaymentIdZ_new(struct LDKThirtyTwoBytes a, struct LDKThirtyTwoBytes b);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PaymentHashPaymentIdZ_new", ()=>C2Tuple_PaymentHashPaymentIdZ_new
);
// void C2Tuple_PaymentHashPaymentIdZ_free(struct LDKC2Tuple_PaymentHashPaymentIdZ _res);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PaymentHashPaymentIdZ_free", ()=>C2Tuple_PaymentHashPaymentIdZ_free
);
// struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok(struct LDKC2Tuple_PaymentHashPaymentIdZ o);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok", ()=>CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok
);
// struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err(struct LDKPaymentSendFailure e);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err", ()=>CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err
);
// bool CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok(const struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok", ()=>CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok
);
// void CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free(struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free", ()=>CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free
);
// uintptr_t CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone_ptr(LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone_ptr", ()=>CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone_ptr
);
// struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone(const struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone", ()=>CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone
);
// uintptr_t C2Tuple_PaymentHashPaymentSecretZ_clone_ptr(LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PaymentHashPaymentSecretZ_clone_ptr", ()=>C2Tuple_PaymentHashPaymentSecretZ_clone_ptr
);
// struct LDKC2Tuple_PaymentHashPaymentSecretZ C2Tuple_PaymentHashPaymentSecretZ_clone(const struct LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PaymentHashPaymentSecretZ_clone", ()=>C2Tuple_PaymentHashPaymentSecretZ_clone
);
// struct LDKC2Tuple_PaymentHashPaymentSecretZ C2Tuple_PaymentHashPaymentSecretZ_new(struct LDKThirtyTwoBytes a, struct LDKThirtyTwoBytes b);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PaymentHashPaymentSecretZ_new", ()=>C2Tuple_PaymentHashPaymentSecretZ_new
);
// void C2Tuple_PaymentHashPaymentSecretZ_free(struct LDKC2Tuple_PaymentHashPaymentSecretZ _res);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_PaymentHashPaymentSecretZ_free", ()=>C2Tuple_PaymentHashPaymentSecretZ_free
);
// struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok(struct LDKC2Tuple_PaymentHashPaymentSecretZ o);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok", ()=>CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok
);
// struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err(void);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err", ()=>CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err
);
// bool CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok", ()=>CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok
);
// void CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free(struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free", ()=>CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free
);
// uintptr_t CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone_ptr(LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone_ptr", ()=>CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone_ptr
);
// struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone", ()=>CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone
);
// struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_ok(struct LDKC2Tuple_PaymentHashPaymentSecretZ o);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_ok", ()=>CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_ok
);
// struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_err(struct LDKAPIError e);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_err", ()=>CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_err
);
// bool CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_ok(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_ok", ()=>CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_ok
);
// void CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_free(struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_free", ()=>CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_free
);
// uintptr_t CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone_ptr(LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone_ptr", ()=>CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone_ptr
);
// struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone", ()=>CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone
);
// struct LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentSecretNoneZ_ok", ()=>CResult_PaymentSecretNoneZ_ok
);
// struct LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_err(void);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentSecretNoneZ_err", ()=>CResult_PaymentSecretNoneZ_err
);
// bool CResult_PaymentSecretNoneZ_is_ok(const struct LDKCResult_PaymentSecretNoneZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentSecretNoneZ_is_ok", ()=>CResult_PaymentSecretNoneZ_is_ok
);
// void CResult_PaymentSecretNoneZ_free(struct LDKCResult_PaymentSecretNoneZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentSecretNoneZ_free", ()=>CResult_PaymentSecretNoneZ_free
);
// uintptr_t CResult_PaymentSecretNoneZ_clone_ptr(LDKCResult_PaymentSecretNoneZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentSecretNoneZ_clone_ptr", ()=>CResult_PaymentSecretNoneZ_clone_ptr
);
// struct LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_clone(const struct LDKCResult_PaymentSecretNoneZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentSecretNoneZ_clone", ()=>CResult_PaymentSecretNoneZ_clone
);
// struct LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentSecretAPIErrorZ_ok", ()=>CResult_PaymentSecretAPIErrorZ_ok
);
// struct LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_err(struct LDKAPIError e);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentSecretAPIErrorZ_err", ()=>CResult_PaymentSecretAPIErrorZ_err
);
// bool CResult_PaymentSecretAPIErrorZ_is_ok(const struct LDKCResult_PaymentSecretAPIErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentSecretAPIErrorZ_is_ok", ()=>CResult_PaymentSecretAPIErrorZ_is_ok
);
// void CResult_PaymentSecretAPIErrorZ_free(struct LDKCResult_PaymentSecretAPIErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentSecretAPIErrorZ_free", ()=>CResult_PaymentSecretAPIErrorZ_free
);
// uintptr_t CResult_PaymentSecretAPIErrorZ_clone_ptr(LDKCResult_PaymentSecretAPIErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentSecretAPIErrorZ_clone_ptr", ()=>CResult_PaymentSecretAPIErrorZ_clone_ptr
);
// struct LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_clone(const struct LDKCResult_PaymentSecretAPIErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentSecretAPIErrorZ_clone", ()=>CResult_PaymentSecretAPIErrorZ_clone
);
// struct LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentPreimageAPIErrorZ_ok", ()=>CResult_PaymentPreimageAPIErrorZ_ok
);
// struct LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_err(struct LDKAPIError e);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentPreimageAPIErrorZ_err", ()=>CResult_PaymentPreimageAPIErrorZ_err
);
// bool CResult_PaymentPreimageAPIErrorZ_is_ok(const struct LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentPreimageAPIErrorZ_is_ok", ()=>CResult_PaymentPreimageAPIErrorZ_is_ok
);
// void CResult_PaymentPreimageAPIErrorZ_free(struct LDKCResult_PaymentPreimageAPIErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentPreimageAPIErrorZ_free", ()=>CResult_PaymentPreimageAPIErrorZ_free
);
// uintptr_t CResult_PaymentPreimageAPIErrorZ_clone_ptr(LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentPreimageAPIErrorZ_clone_ptr", ()=>CResult_PaymentPreimageAPIErrorZ_clone_ptr
);
// struct LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_clone(const struct LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CResult_PaymentPreimageAPIErrorZ_clone", ()=>CResult_PaymentPreimageAPIErrorZ_clone
);
// void CVec_ChannelMonitorZ_free(struct LDKCVec_ChannelMonitorZ _res);
/* @internal */ parcelHelpers.export(exports, "CVec_ChannelMonitorZ_free", ()=>CVec_ChannelMonitorZ_free
);
// struct LDKC2Tuple_BlockHashChannelManagerZ C2Tuple_BlockHashChannelManagerZ_new(struct LDKThirtyTwoBytes a, struct LDKChannelManager b);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_BlockHashChannelManagerZ_new", ()=>C2Tuple_BlockHashChannelManagerZ_new
);
// void C2Tuple_BlockHashChannelManagerZ_free(struct LDKC2Tuple_BlockHashChannelManagerZ _res);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_BlockHashChannelManagerZ_free", ()=>C2Tuple_BlockHashChannelManagerZ_free
);
// struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(struct LDKC2Tuple_BlockHashChannelManagerZ o);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok", ()=>CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok
);
// struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err", ()=>CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err
);
// bool CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok(const struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok", ()=>CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok
);
// void CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free(struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ _res);
/* @internal */ parcelHelpers.export(exports, "CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free", ()=>CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free
);
// void PaymentPurpose_free(struct LDKPaymentPurpose this_ptr);
/* @internal */ parcelHelpers.export(exports, "PaymentPurpose_free", ()=>PaymentPurpose_free
);
// uintptr_t PaymentPurpose_clone_ptr(LDKPaymentPurpose *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "PaymentPurpose_clone_ptr", ()=>PaymentPurpose_clone_ptr
);
// struct LDKPaymentPurpose PaymentPurpose_clone(const struct LDKPaymentPurpose *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "PaymentPurpose_clone", ()=>PaymentPurpose_clone
);
// struct LDKPaymentPurpose PaymentPurpose_invoice_payment(struct LDKThirtyTwoBytes payment_preimage, struct LDKThirtyTwoBytes payment_secret);
/* @internal */ parcelHelpers.export(exports, "PaymentPurpose_invoice_payment", ()=>PaymentPurpose_invoice_payment
);
// struct LDKPaymentPurpose PaymentPurpose_spontaneous_payment(struct LDKThirtyTwoBytes a);
/* @internal */ parcelHelpers.export(exports, "PaymentPurpose_spontaneous_payment", ()=>PaymentPurpose_spontaneous_payment
);
// void ClosureReason_free(struct LDKClosureReason this_ptr);
/* @internal */ parcelHelpers.export(exports, "ClosureReason_free", ()=>ClosureReason_free
);
// uintptr_t ClosureReason_clone_ptr(LDKClosureReason *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ClosureReason_clone_ptr", ()=>ClosureReason_clone_ptr
);
// struct LDKClosureReason ClosureReason_clone(const struct LDKClosureReason *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ClosureReason_clone", ()=>ClosureReason_clone
);
// struct LDKClosureReason ClosureReason_counterparty_force_closed(struct LDKStr peer_msg);
/* @internal */ parcelHelpers.export(exports, "ClosureReason_counterparty_force_closed", ()=>ClosureReason_counterparty_force_closed
);
// struct LDKClosureReason ClosureReason_holder_force_closed(void);
/* @internal */ parcelHelpers.export(exports, "ClosureReason_holder_force_closed", ()=>ClosureReason_holder_force_closed
);
// struct LDKClosureReason ClosureReason_cooperative_closure(void);
/* @internal */ parcelHelpers.export(exports, "ClosureReason_cooperative_closure", ()=>ClosureReason_cooperative_closure
);
// struct LDKClosureReason ClosureReason_commitment_tx_confirmed(void);
/* @internal */ parcelHelpers.export(exports, "ClosureReason_commitment_tx_confirmed", ()=>ClosureReason_commitment_tx_confirmed
);
// struct LDKClosureReason ClosureReason_funding_timed_out(void);
/* @internal */ parcelHelpers.export(exports, "ClosureReason_funding_timed_out", ()=>ClosureReason_funding_timed_out
);
// struct LDKClosureReason ClosureReason_processing_error(struct LDKStr err);
/* @internal */ parcelHelpers.export(exports, "ClosureReason_processing_error", ()=>ClosureReason_processing_error
);
// struct LDKClosureReason ClosureReason_disconnected_peer(void);
/* @internal */ parcelHelpers.export(exports, "ClosureReason_disconnected_peer", ()=>ClosureReason_disconnected_peer
);
// struct LDKClosureReason ClosureReason_outdated_channel_manager(void);
/* @internal */ parcelHelpers.export(exports, "ClosureReason_outdated_channel_manager", ()=>ClosureReason_outdated_channel_manager
);
// struct LDKCVec_u8Z ClosureReason_write(const struct LDKClosureReason *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ClosureReason_write", ()=>ClosureReason_write
);
// struct LDKCResult_COption_ClosureReasonZDecodeErrorZ ClosureReason_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ClosureReason_read", ()=>ClosureReason_read
);
// void Event_free(struct LDKEvent this_ptr);
/* @internal */ parcelHelpers.export(exports, "Event_free", ()=>Event_free
);
// uintptr_t Event_clone_ptr(LDKEvent *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "Event_clone_ptr", ()=>Event_clone_ptr
);
// struct LDKEvent Event_clone(const struct LDKEvent *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "Event_clone", ()=>Event_clone
);
// struct LDKEvent Event_funding_generation_ready(struct LDKThirtyTwoBytes temporary_channel_id, uint64_t channel_value_satoshis, struct LDKCVec_u8Z output_script, uint64_t user_channel_id);
/* @internal */ parcelHelpers.export(exports, "Event_funding_generation_ready", ()=>Event_funding_generation_ready
);
// struct LDKEvent Event_payment_received(struct LDKThirtyTwoBytes payment_hash, uint64_t amt, struct LDKPaymentPurpose purpose);
/* @internal */ parcelHelpers.export(exports, "Event_payment_received", ()=>Event_payment_received
);
// struct LDKEvent Event_payment_sent(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_preimage, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z fee_paid_msat);
/* @internal */ parcelHelpers.export(exports, "Event_payment_sent", ()=>Event_payment_sent
);
// struct LDKEvent Event_payment_path_failed(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, bool rejected_by_dest, struct LDKCOption_NetworkUpdateZ network_update, bool all_paths_failed, struct LDKCVec_RouteHopZ path, struct LDKCOption_u64Z short_channel_id, struct LDKRouteParameters retry);
/* @internal */ parcelHelpers.export(exports, "Event_payment_path_failed", ()=>Event_payment_path_failed
);
// struct LDKEvent Event_payment_failed(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash);
/* @internal */ parcelHelpers.export(exports, "Event_payment_failed", ()=>Event_payment_failed
);
// struct LDKEvent Event_pending_htlcs_forwardable(uint64_t time_forwardable);
/* @internal */ parcelHelpers.export(exports, "Event_pending_htlcs_forwardable", ()=>Event_pending_htlcs_forwardable
);
// struct LDKEvent Event_spendable_outputs(struct LDKCVec_SpendableOutputDescriptorZ outputs);
/* @internal */ parcelHelpers.export(exports, "Event_spendable_outputs", ()=>Event_spendable_outputs
);
// struct LDKEvent Event_payment_forwarded(struct LDKCOption_u64Z fee_earned_msat, bool claim_from_onchain_tx);
/* @internal */ parcelHelpers.export(exports, "Event_payment_forwarded", ()=>Event_payment_forwarded
);
// struct LDKEvent Event_channel_closed(struct LDKThirtyTwoBytes channel_id, uint64_t user_channel_id, struct LDKClosureReason reason);
/* @internal */ parcelHelpers.export(exports, "Event_channel_closed", ()=>Event_channel_closed
);
// struct LDKEvent Event_discard_funding(struct LDKThirtyTwoBytes channel_id, struct LDKTransaction transaction);
/* @internal */ parcelHelpers.export(exports, "Event_discard_funding", ()=>Event_discard_funding
);
// struct LDKEvent Event_payment_path_successful(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, struct LDKCVec_RouteHopZ path);
/* @internal */ parcelHelpers.export(exports, "Event_payment_path_successful", ()=>Event_payment_path_successful
);
// struct LDKCVec_u8Z Event_write(const struct LDKEvent *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "Event_write", ()=>Event_write
);
// struct LDKCResult_COption_EventZDecodeErrorZ Event_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "Event_read", ()=>Event_read
);
// void MessageSendEvent_free(struct LDKMessageSendEvent this_ptr);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_free", ()=>MessageSendEvent_free
);
// uintptr_t MessageSendEvent_clone_ptr(LDKMessageSendEvent *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_clone_ptr", ()=>MessageSendEvent_clone_ptr
);
// struct LDKMessageSendEvent MessageSendEvent_clone(const struct LDKMessageSendEvent *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_clone", ()=>MessageSendEvent_clone
);
// struct LDKMessageSendEvent MessageSendEvent_send_accept_channel(struct LDKPublicKey node_id, struct LDKAcceptChannel msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_send_accept_channel", ()=>MessageSendEvent_send_accept_channel
);
// struct LDKMessageSendEvent MessageSendEvent_send_open_channel(struct LDKPublicKey node_id, struct LDKOpenChannel msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_send_open_channel", ()=>MessageSendEvent_send_open_channel
);
// struct LDKMessageSendEvent MessageSendEvent_send_funding_created(struct LDKPublicKey node_id, struct LDKFundingCreated msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_send_funding_created", ()=>MessageSendEvent_send_funding_created
);
// struct LDKMessageSendEvent MessageSendEvent_send_funding_signed(struct LDKPublicKey node_id, struct LDKFundingSigned msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_send_funding_signed", ()=>MessageSendEvent_send_funding_signed
);
// struct LDKMessageSendEvent MessageSendEvent_send_funding_locked(struct LDKPublicKey node_id, struct LDKFundingLocked msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_send_funding_locked", ()=>MessageSendEvent_send_funding_locked
);
// struct LDKMessageSendEvent MessageSendEvent_send_announcement_signatures(struct LDKPublicKey node_id, struct LDKAnnouncementSignatures msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_send_announcement_signatures", ()=>MessageSendEvent_send_announcement_signatures
);
// struct LDKMessageSendEvent MessageSendEvent_update_htlcs(struct LDKPublicKey node_id, struct LDKCommitmentUpdate updates);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_update_htlcs", ()=>MessageSendEvent_update_htlcs
);
// struct LDKMessageSendEvent MessageSendEvent_send_revoke_and_ack(struct LDKPublicKey node_id, struct LDKRevokeAndACK msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_send_revoke_and_ack", ()=>MessageSendEvent_send_revoke_and_ack
);
// struct LDKMessageSendEvent MessageSendEvent_send_closing_signed(struct LDKPublicKey node_id, struct LDKClosingSigned msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_send_closing_signed", ()=>MessageSendEvent_send_closing_signed
);
// struct LDKMessageSendEvent MessageSendEvent_send_shutdown(struct LDKPublicKey node_id, struct LDKShutdown msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_send_shutdown", ()=>MessageSendEvent_send_shutdown
);
// struct LDKMessageSendEvent MessageSendEvent_send_channel_reestablish(struct LDKPublicKey node_id, struct LDKChannelReestablish msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_send_channel_reestablish", ()=>MessageSendEvent_send_channel_reestablish
);
// struct LDKMessageSendEvent MessageSendEvent_broadcast_channel_announcement(struct LDKChannelAnnouncement msg, struct LDKChannelUpdate update_msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_broadcast_channel_announcement", ()=>MessageSendEvent_broadcast_channel_announcement
);
// struct LDKMessageSendEvent MessageSendEvent_broadcast_node_announcement(struct LDKNodeAnnouncement msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_broadcast_node_announcement", ()=>MessageSendEvent_broadcast_node_announcement
);
// struct LDKMessageSendEvent MessageSendEvent_broadcast_channel_update(struct LDKChannelUpdate msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_broadcast_channel_update", ()=>MessageSendEvent_broadcast_channel_update
);
// struct LDKMessageSendEvent MessageSendEvent_send_channel_update(struct LDKPublicKey node_id, struct LDKChannelUpdate msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_send_channel_update", ()=>MessageSendEvent_send_channel_update
);
// struct LDKMessageSendEvent MessageSendEvent_handle_error(struct LDKPublicKey node_id, struct LDKErrorAction action);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_handle_error", ()=>MessageSendEvent_handle_error
);
// struct LDKMessageSendEvent MessageSendEvent_send_channel_range_query(struct LDKPublicKey node_id, struct LDKQueryChannelRange msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_send_channel_range_query", ()=>MessageSendEvent_send_channel_range_query
);
// struct LDKMessageSendEvent MessageSendEvent_send_short_ids_query(struct LDKPublicKey node_id, struct LDKQueryShortChannelIds msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_send_short_ids_query", ()=>MessageSendEvent_send_short_ids_query
);
// struct LDKMessageSendEvent MessageSendEvent_send_reply_channel_range(struct LDKPublicKey node_id, struct LDKReplyChannelRange msg);
/* @internal */ parcelHelpers.export(exports, "MessageSendEvent_send_reply_channel_range", ()=>MessageSendEvent_send_reply_channel_range
);
// void MessageSendEventsProvider_free(struct LDKMessageSendEventsProvider this_ptr);
/* @internal */ parcelHelpers.export(exports, "MessageSendEventsProvider_free", ()=>MessageSendEventsProvider_free
);
// void EventsProvider_free(struct LDKEventsProvider this_ptr);
/* @internal */ parcelHelpers.export(exports, "EventsProvider_free", ()=>EventsProvider_free
);
// void EventHandler_free(struct LDKEventHandler this_ptr);
/* @internal */ parcelHelpers.export(exports, "EventHandler_free", ()=>EventHandler_free
);
// void APIError_free(struct LDKAPIError this_ptr);
/* @internal */ parcelHelpers.export(exports, "APIError_free", ()=>APIError_free
);
// uintptr_t APIError_clone_ptr(LDKAPIError *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "APIError_clone_ptr", ()=>APIError_clone_ptr
);
// struct LDKAPIError APIError_clone(const struct LDKAPIError *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "APIError_clone", ()=>APIError_clone
);
// struct LDKAPIError APIError_apimisuse_error(struct LDKStr err);
/* @internal */ parcelHelpers.export(exports, "APIError_apimisuse_error", ()=>APIError_apimisuse_error
);
// struct LDKAPIError APIError_fee_rate_too_high(struct LDKStr err, uint32_t feerate);
/* @internal */ parcelHelpers.export(exports, "APIError_fee_rate_too_high", ()=>APIError_fee_rate_too_high
);
// struct LDKAPIError APIError_route_error(struct LDKStr err);
/* @internal */ parcelHelpers.export(exports, "APIError_route_error", ()=>APIError_route_error
);
// struct LDKAPIError APIError_channel_unavailable(struct LDKStr err);
/* @internal */ parcelHelpers.export(exports, "APIError_channel_unavailable", ()=>APIError_channel_unavailable
);
// struct LDKAPIError APIError_monitor_update_failed(void);
/* @internal */ parcelHelpers.export(exports, "APIError_monitor_update_failed", ()=>APIError_monitor_update_failed
);
// struct LDKAPIError APIError_incompatible_shutdown_script(struct LDKShutdownScript script);
/* @internal */ parcelHelpers.export(exports, "APIError_incompatible_shutdown_script", ()=>APIError_incompatible_shutdown_script
);
// struct LDKCResult_StringErrorZ sign(struct LDKu8slice msg, const uint8_t (*sk)[32]);
/* @internal */ parcelHelpers.export(exports, "sign", ()=>sign
);
// struct LDKCResult_PublicKeyErrorZ recover_pk(struct LDKu8slice msg, struct LDKStr sig);
/* @internal */ parcelHelpers.export(exports, "recover_pk", ()=>recover_pk
);
// bool verify(struct LDKu8slice msg, struct LDKStr sig, struct LDKPublicKey pk);
/* @internal */ parcelHelpers.export(exports, "verify", ()=>verify
);
// enum LDKLevel Level_clone(const enum LDKLevel *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "Level_clone", ()=>Level_clone
);
// enum LDKLevel Level_gossip(void);
/* @internal */ parcelHelpers.export(exports, "Level_gossip", ()=>Level_gossip
);
// enum LDKLevel Level_trace(void);
/* @internal */ parcelHelpers.export(exports, "Level_trace", ()=>Level_trace
);
// enum LDKLevel Level_debug(void);
/* @internal */ parcelHelpers.export(exports, "Level_debug", ()=>Level_debug
);
// enum LDKLevel Level_info(void);
/* @internal */ parcelHelpers.export(exports, "Level_info", ()=>Level_info
);
// enum LDKLevel Level_warn(void);
/* @internal */ parcelHelpers.export(exports, "Level_warn", ()=>Level_warn
);
// enum LDKLevel Level_error(void);
/* @internal */ parcelHelpers.export(exports, "Level_error", ()=>Level_error
);
// bool Level_eq(const enum LDKLevel *NONNULL_PTR a, const enum LDKLevel *NONNULL_PTR b);
/* @internal */ parcelHelpers.export(exports, "Level_eq", ()=>Level_eq
);
// uint64_t Level_hash(const enum LDKLevel *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "Level_hash", ()=>Level_hash
);
// MUST_USE_RES enum LDKLevel Level_max(void);
/* @internal */ parcelHelpers.export(exports, "Level_max", ()=>Level_max
);
// void Record_free(struct LDKRecord this_obj);
/* @internal */ parcelHelpers.export(exports, "Record_free", ()=>Record_free
);
// enum LDKLevel Record_get_level(const struct LDKRecord *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "Record_get_level", ()=>Record_get_level
);
// void Record_set_level(struct LDKRecord *NONNULL_PTR this_ptr, enum LDKLevel val);
/* @internal */ parcelHelpers.export(exports, "Record_set_level", ()=>Record_set_level
);
// struct LDKStr Record_get_args(const struct LDKRecord *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "Record_get_args", ()=>Record_get_args
);
// void Record_set_args(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */ parcelHelpers.export(exports, "Record_set_args", ()=>Record_set_args
);
// struct LDKStr Record_get_module_path(const struct LDKRecord *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "Record_get_module_path", ()=>Record_get_module_path
);
// void Record_set_module_path(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */ parcelHelpers.export(exports, "Record_set_module_path", ()=>Record_set_module_path
);
// struct LDKStr Record_get_file(const struct LDKRecord *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "Record_get_file", ()=>Record_get_file
);
// void Record_set_file(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */ parcelHelpers.export(exports, "Record_set_file", ()=>Record_set_file
);
// uint32_t Record_get_line(const struct LDKRecord *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "Record_get_line", ()=>Record_get_line
);
// void Record_set_line(struct LDKRecord *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "Record_set_line", ()=>Record_set_line
);
// uintptr_t Record_clone_ptr(LDKRecord *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "Record_clone_ptr", ()=>Record_clone_ptr
);
// struct LDKRecord Record_clone(const struct LDKRecord *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "Record_clone", ()=>Record_clone
);
// void Logger_free(struct LDKLogger this_ptr);
/* @internal */ parcelHelpers.export(exports, "Logger_free", ()=>Logger_free
);
// void ChannelHandshakeConfig_free(struct LDKChannelHandshakeConfig this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeConfig_free", ()=>ChannelHandshakeConfig_free
);
// uint32_t ChannelHandshakeConfig_get_minimum_depth(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeConfig_get_minimum_depth", ()=>ChannelHandshakeConfig_get_minimum_depth
);
// void ChannelHandshakeConfig_set_minimum_depth(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeConfig_set_minimum_depth", ()=>ChannelHandshakeConfig_set_minimum_depth
);
// uint16_t ChannelHandshakeConfig_get_our_to_self_delay(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeConfig_get_our_to_self_delay", ()=>ChannelHandshakeConfig_get_our_to_self_delay
);
// void ChannelHandshakeConfig_set_our_to_self_delay(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeConfig_set_our_to_self_delay", ()=>ChannelHandshakeConfig_set_our_to_self_delay
);
// uint64_t ChannelHandshakeConfig_get_our_htlc_minimum_msat(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeConfig_get_our_htlc_minimum_msat", ()=>ChannelHandshakeConfig_get_our_htlc_minimum_msat
);
// void ChannelHandshakeConfig_set_our_htlc_minimum_msat(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeConfig_set_our_htlc_minimum_msat", ()=>ChannelHandshakeConfig_set_our_htlc_minimum_msat
);
// MUST_USE_RES struct LDKChannelHandshakeConfig ChannelHandshakeConfig_new(uint32_t minimum_depth_arg, uint16_t our_to_self_delay_arg, uint64_t our_htlc_minimum_msat_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeConfig_new", ()=>ChannelHandshakeConfig_new
);
// uintptr_t ChannelHandshakeConfig_clone_ptr(LDKChannelHandshakeConfig *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeConfig_clone_ptr", ()=>ChannelHandshakeConfig_clone_ptr
);
// struct LDKChannelHandshakeConfig ChannelHandshakeConfig_clone(const struct LDKChannelHandshakeConfig *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeConfig_clone", ()=>ChannelHandshakeConfig_clone
);
// MUST_USE_RES struct LDKChannelHandshakeConfig ChannelHandshakeConfig_default(void);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeConfig_default", ()=>ChannelHandshakeConfig_default
);
// void ChannelHandshakeLimits_free(struct LDKChannelHandshakeLimits this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_free", ()=>ChannelHandshakeLimits_free
);
// uint64_t ChannelHandshakeLimits_get_min_funding_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_get_min_funding_satoshis", ()=>ChannelHandshakeLimits_get_min_funding_satoshis
);
// void ChannelHandshakeLimits_set_min_funding_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_set_min_funding_satoshis", ()=>ChannelHandshakeLimits_set_min_funding_satoshis
);
// uint64_t ChannelHandshakeLimits_get_max_htlc_minimum_msat(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_get_max_htlc_minimum_msat", ()=>ChannelHandshakeLimits_get_max_htlc_minimum_msat
);
// void ChannelHandshakeLimits_set_max_htlc_minimum_msat(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_set_max_htlc_minimum_msat", ()=>ChannelHandshakeLimits_set_max_htlc_minimum_msat
);
// uint64_t ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat", ()=>ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat
);
// void ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat", ()=>ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat
);
// uint64_t ChannelHandshakeLimits_get_max_channel_reserve_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_get_max_channel_reserve_satoshis", ()=>ChannelHandshakeLimits_get_max_channel_reserve_satoshis
);
// void ChannelHandshakeLimits_set_max_channel_reserve_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_set_max_channel_reserve_satoshis", ()=>ChannelHandshakeLimits_set_max_channel_reserve_satoshis
);
// uint16_t ChannelHandshakeLimits_get_min_max_accepted_htlcs(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_get_min_max_accepted_htlcs", ()=>ChannelHandshakeLimits_get_min_max_accepted_htlcs
);
// void ChannelHandshakeLimits_set_min_max_accepted_htlcs(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_set_min_max_accepted_htlcs", ()=>ChannelHandshakeLimits_set_min_max_accepted_htlcs
);
// uint32_t ChannelHandshakeLimits_get_max_minimum_depth(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_get_max_minimum_depth", ()=>ChannelHandshakeLimits_get_max_minimum_depth
);
// void ChannelHandshakeLimits_set_max_minimum_depth(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_set_max_minimum_depth", ()=>ChannelHandshakeLimits_set_max_minimum_depth
);
// bool ChannelHandshakeLimits_get_force_announced_channel_preference(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_get_force_announced_channel_preference", ()=>ChannelHandshakeLimits_get_force_announced_channel_preference
);
// void ChannelHandshakeLimits_set_force_announced_channel_preference(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, bool val);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_set_force_announced_channel_preference", ()=>ChannelHandshakeLimits_set_force_announced_channel_preference
);
// uint16_t ChannelHandshakeLimits_get_their_to_self_delay(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_get_their_to_self_delay", ()=>ChannelHandshakeLimits_get_their_to_self_delay
);
// void ChannelHandshakeLimits_set_their_to_self_delay(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_set_their_to_self_delay", ()=>ChannelHandshakeLimits_set_their_to_self_delay
);
// MUST_USE_RES struct LDKChannelHandshakeLimits ChannelHandshakeLimits_new(uint64_t min_funding_satoshis_arg, uint64_t max_htlc_minimum_msat_arg, uint64_t min_max_htlc_value_in_flight_msat_arg, uint64_t max_channel_reserve_satoshis_arg, uint16_t min_max_accepted_htlcs_arg, uint32_t max_minimum_depth_arg, bool force_announced_channel_preference_arg, uint16_t their_to_self_delay_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_new", ()=>ChannelHandshakeLimits_new
);
// uintptr_t ChannelHandshakeLimits_clone_ptr(LDKChannelHandshakeLimits *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_clone_ptr", ()=>ChannelHandshakeLimits_clone_ptr
);
// struct LDKChannelHandshakeLimits ChannelHandshakeLimits_clone(const struct LDKChannelHandshakeLimits *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_clone", ()=>ChannelHandshakeLimits_clone
);
// MUST_USE_RES struct LDKChannelHandshakeLimits ChannelHandshakeLimits_default(void);
/* @internal */ parcelHelpers.export(exports, "ChannelHandshakeLimits_default", ()=>ChannelHandshakeLimits_default
);
// void ChannelConfig_free(struct LDKChannelConfig this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_free", ()=>ChannelConfig_free
);
// uint32_t ChannelConfig_get_forwarding_fee_proportional_millionths(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_get_forwarding_fee_proportional_millionths", ()=>ChannelConfig_get_forwarding_fee_proportional_millionths
);
// void ChannelConfig_set_forwarding_fee_proportional_millionths(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_set_forwarding_fee_proportional_millionths", ()=>ChannelConfig_set_forwarding_fee_proportional_millionths
);
// uint32_t ChannelConfig_get_forwarding_fee_base_msat(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_get_forwarding_fee_base_msat", ()=>ChannelConfig_get_forwarding_fee_base_msat
);
// void ChannelConfig_set_forwarding_fee_base_msat(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_set_forwarding_fee_base_msat", ()=>ChannelConfig_set_forwarding_fee_base_msat
);
// uint16_t ChannelConfig_get_cltv_expiry_delta(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_get_cltv_expiry_delta", ()=>ChannelConfig_get_cltv_expiry_delta
);
// void ChannelConfig_set_cltv_expiry_delta(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_set_cltv_expiry_delta", ()=>ChannelConfig_set_cltv_expiry_delta
);
// bool ChannelConfig_get_announced_channel(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_get_announced_channel", ()=>ChannelConfig_get_announced_channel
);
// void ChannelConfig_set_announced_channel(struct LDKChannelConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_set_announced_channel", ()=>ChannelConfig_set_announced_channel
);
// bool ChannelConfig_get_commit_upfront_shutdown_pubkey(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_get_commit_upfront_shutdown_pubkey", ()=>ChannelConfig_get_commit_upfront_shutdown_pubkey
);
// void ChannelConfig_set_commit_upfront_shutdown_pubkey(struct LDKChannelConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_set_commit_upfront_shutdown_pubkey", ()=>ChannelConfig_set_commit_upfront_shutdown_pubkey
);
// uint64_t ChannelConfig_get_max_dust_htlc_exposure_msat(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_get_max_dust_htlc_exposure_msat", ()=>ChannelConfig_get_max_dust_htlc_exposure_msat
);
// void ChannelConfig_set_max_dust_htlc_exposure_msat(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_set_max_dust_htlc_exposure_msat", ()=>ChannelConfig_set_max_dust_htlc_exposure_msat
);
// uint64_t ChannelConfig_get_force_close_avoidance_max_fee_satoshis(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_get_force_close_avoidance_max_fee_satoshis", ()=>ChannelConfig_get_force_close_avoidance_max_fee_satoshis
);
// void ChannelConfig_set_force_close_avoidance_max_fee_satoshis(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_set_force_close_avoidance_max_fee_satoshis", ()=>ChannelConfig_set_force_close_avoidance_max_fee_satoshis
);
// MUST_USE_RES struct LDKChannelConfig ChannelConfig_new(uint32_t forwarding_fee_proportional_millionths_arg, uint32_t forwarding_fee_base_msat_arg, uint16_t cltv_expiry_delta_arg, bool announced_channel_arg, bool commit_upfront_shutdown_pubkey_arg, uint64_t max_dust_htlc_exposure_msat_arg, uint64_t force_close_avoidance_max_fee_satoshis_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_new", ()=>ChannelConfig_new
);
// uintptr_t ChannelConfig_clone_ptr(LDKChannelConfig *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_clone_ptr", ()=>ChannelConfig_clone_ptr
);
// struct LDKChannelConfig ChannelConfig_clone(const struct LDKChannelConfig *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_clone", ()=>ChannelConfig_clone
);
// MUST_USE_RES struct LDKChannelConfig ChannelConfig_default(void);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_default", ()=>ChannelConfig_default
);
// struct LDKCVec_u8Z ChannelConfig_write(const struct LDKChannelConfig *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_write", ()=>ChannelConfig_write
);
// struct LDKCResult_ChannelConfigDecodeErrorZ ChannelConfig_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ChannelConfig_read", ()=>ChannelConfig_read
);
// void UserConfig_free(struct LDKUserConfig this_obj);
/* @internal */ parcelHelpers.export(exports, "UserConfig_free", ()=>UserConfig_free
);
// struct LDKChannelHandshakeConfig UserConfig_get_own_channel_config(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UserConfig_get_own_channel_config", ()=>UserConfig_get_own_channel_config
);
// void UserConfig_set_own_channel_config(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelHandshakeConfig val);
/* @internal */ parcelHelpers.export(exports, "UserConfig_set_own_channel_config", ()=>UserConfig_set_own_channel_config
);
// struct LDKChannelHandshakeLimits UserConfig_get_peer_channel_config_limits(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UserConfig_get_peer_channel_config_limits", ()=>UserConfig_get_peer_channel_config_limits
);
// void UserConfig_set_peer_channel_config_limits(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelHandshakeLimits val);
/* @internal */ parcelHelpers.export(exports, "UserConfig_set_peer_channel_config_limits", ()=>UserConfig_set_peer_channel_config_limits
);
// struct LDKChannelConfig UserConfig_get_channel_options(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UserConfig_get_channel_options", ()=>UserConfig_get_channel_options
);
// void UserConfig_set_channel_options(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelConfig val);
/* @internal */ parcelHelpers.export(exports, "UserConfig_set_channel_options", ()=>UserConfig_set_channel_options
);
// bool UserConfig_get_accept_forwards_to_priv_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UserConfig_get_accept_forwards_to_priv_channels", ()=>UserConfig_get_accept_forwards_to_priv_channels
);
// void UserConfig_set_accept_forwards_to_priv_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */ parcelHelpers.export(exports, "UserConfig_set_accept_forwards_to_priv_channels", ()=>UserConfig_set_accept_forwards_to_priv_channels
);
// bool UserConfig_get_accept_inbound_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UserConfig_get_accept_inbound_channels", ()=>UserConfig_get_accept_inbound_channels
);
// void UserConfig_set_accept_inbound_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */ parcelHelpers.export(exports, "UserConfig_set_accept_inbound_channels", ()=>UserConfig_set_accept_inbound_channels
);
// MUST_USE_RES struct LDKUserConfig UserConfig_new(struct LDKChannelHandshakeConfig own_channel_config_arg, struct LDKChannelHandshakeLimits peer_channel_config_limits_arg, struct LDKChannelConfig channel_options_arg, bool accept_forwards_to_priv_channels_arg, bool accept_inbound_channels_arg);
/* @internal */ parcelHelpers.export(exports, "UserConfig_new", ()=>UserConfig_new
);
// uintptr_t UserConfig_clone_ptr(LDKUserConfig *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "UserConfig_clone_ptr", ()=>UserConfig_clone_ptr
);
// struct LDKUserConfig UserConfig_clone(const struct LDKUserConfig *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "UserConfig_clone", ()=>UserConfig_clone
);
// MUST_USE_RES struct LDKUserConfig UserConfig_default(void);
/* @internal */ parcelHelpers.export(exports, "UserConfig_default", ()=>UserConfig_default
);
// void BestBlock_free(struct LDKBestBlock this_obj);
/* @internal */ parcelHelpers.export(exports, "BestBlock_free", ()=>BestBlock_free
);
// uintptr_t BestBlock_clone_ptr(LDKBestBlock *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "BestBlock_clone_ptr", ()=>BestBlock_clone_ptr
);
// struct LDKBestBlock BestBlock_clone(const struct LDKBestBlock *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "BestBlock_clone", ()=>BestBlock_clone
);
// MUST_USE_RES struct LDKBestBlock BestBlock_from_genesis(enum LDKNetwork network);
/* @internal */ parcelHelpers.export(exports, "BestBlock_from_genesis", ()=>BestBlock_from_genesis
);
// MUST_USE_RES struct LDKBestBlock BestBlock_new(struct LDKThirtyTwoBytes block_hash, uint32_t height);
/* @internal */ parcelHelpers.export(exports, "BestBlock_new", ()=>BestBlock_new
);
// MUST_USE_RES struct LDKThirtyTwoBytes BestBlock_block_hash(const struct LDKBestBlock *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "BestBlock_block_hash", ()=>BestBlock_block_hash
);
// MUST_USE_RES uint32_t BestBlock_height(const struct LDKBestBlock *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "BestBlock_height", ()=>BestBlock_height
);
// enum LDKAccessError AccessError_clone(const enum LDKAccessError *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "AccessError_clone", ()=>AccessError_clone
);
// enum LDKAccessError AccessError_unknown_chain(void);
/* @internal */ parcelHelpers.export(exports, "AccessError_unknown_chain", ()=>AccessError_unknown_chain
);
// enum LDKAccessError AccessError_unknown_tx(void);
/* @internal */ parcelHelpers.export(exports, "AccessError_unknown_tx", ()=>AccessError_unknown_tx
);
// void Access_free(struct LDKAccess this_ptr);
/* @internal */ parcelHelpers.export(exports, "Access_free", ()=>Access_free
);
// void Listen_free(struct LDKListen this_ptr);
/* @internal */ parcelHelpers.export(exports, "Listen_free", ()=>Listen_free
);
// void Confirm_free(struct LDKConfirm this_ptr);
/* @internal */ parcelHelpers.export(exports, "Confirm_free", ()=>Confirm_free
);
// enum LDKChannelMonitorUpdateErr ChannelMonitorUpdateErr_clone(const enum LDKChannelMonitorUpdateErr *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitorUpdateErr_clone", ()=>ChannelMonitorUpdateErr_clone
);
// enum LDKChannelMonitorUpdateErr ChannelMonitorUpdateErr_temporary_failure(void);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitorUpdateErr_temporary_failure", ()=>ChannelMonitorUpdateErr_temporary_failure
);
// enum LDKChannelMonitorUpdateErr ChannelMonitorUpdateErr_permanent_failure(void);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitorUpdateErr_permanent_failure", ()=>ChannelMonitorUpdateErr_permanent_failure
);
// void Watch_free(struct LDKWatch this_ptr);
/* @internal */ parcelHelpers.export(exports, "Watch_free", ()=>Watch_free
);
// void Filter_free(struct LDKFilter this_ptr);
/* @internal */ parcelHelpers.export(exports, "Filter_free", ()=>Filter_free
);
// void WatchedOutput_free(struct LDKWatchedOutput this_obj);
/* @internal */ parcelHelpers.export(exports, "WatchedOutput_free", ()=>WatchedOutput_free
);
// struct LDKThirtyTwoBytes WatchedOutput_get_block_hash(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "WatchedOutput_get_block_hash", ()=>WatchedOutput_get_block_hash
);
// void WatchedOutput_set_block_hash(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "WatchedOutput_set_block_hash", ()=>WatchedOutput_set_block_hash
);
// struct LDKOutPoint WatchedOutput_get_outpoint(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "WatchedOutput_get_outpoint", ()=>WatchedOutput_get_outpoint
);
// void WatchedOutput_set_outpoint(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */ parcelHelpers.export(exports, "WatchedOutput_set_outpoint", ()=>WatchedOutput_set_outpoint
);
// struct LDKu8slice WatchedOutput_get_script_pubkey(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "WatchedOutput_get_script_pubkey", ()=>WatchedOutput_get_script_pubkey
);
// void WatchedOutput_set_script_pubkey(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);
/* @internal */ parcelHelpers.export(exports, "WatchedOutput_set_script_pubkey", ()=>WatchedOutput_set_script_pubkey
);
// MUST_USE_RES struct LDKWatchedOutput WatchedOutput_new(struct LDKThirtyTwoBytes block_hash_arg, struct LDKOutPoint outpoint_arg, struct LDKCVec_u8Z script_pubkey_arg);
/* @internal */ parcelHelpers.export(exports, "WatchedOutput_new", ()=>WatchedOutput_new
);
// uintptr_t WatchedOutput_clone_ptr(LDKWatchedOutput *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "WatchedOutput_clone_ptr", ()=>WatchedOutput_clone_ptr
);
// struct LDKWatchedOutput WatchedOutput_clone(const struct LDKWatchedOutput *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "WatchedOutput_clone", ()=>WatchedOutput_clone
);
// uint64_t WatchedOutput_hash(const struct LDKWatchedOutput *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "WatchedOutput_hash", ()=>WatchedOutput_hash
);
// void BroadcasterInterface_free(struct LDKBroadcasterInterface this_ptr);
/* @internal */ parcelHelpers.export(exports, "BroadcasterInterface_free", ()=>BroadcasterInterface_free
);
// enum LDKConfirmationTarget ConfirmationTarget_clone(const enum LDKConfirmationTarget *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ConfirmationTarget_clone", ()=>ConfirmationTarget_clone
);
// enum LDKConfirmationTarget ConfirmationTarget_background(void);
/* @internal */ parcelHelpers.export(exports, "ConfirmationTarget_background", ()=>ConfirmationTarget_background
);
// enum LDKConfirmationTarget ConfirmationTarget_normal(void);
/* @internal */ parcelHelpers.export(exports, "ConfirmationTarget_normal", ()=>ConfirmationTarget_normal
);
// enum LDKConfirmationTarget ConfirmationTarget_high_priority(void);
/* @internal */ parcelHelpers.export(exports, "ConfirmationTarget_high_priority", ()=>ConfirmationTarget_high_priority
);
// bool ConfirmationTarget_eq(const enum LDKConfirmationTarget *NONNULL_PTR a, const enum LDKConfirmationTarget *NONNULL_PTR b);
/* @internal */ parcelHelpers.export(exports, "ConfirmationTarget_eq", ()=>ConfirmationTarget_eq
);
// void FeeEstimator_free(struct LDKFeeEstimator this_ptr);
/* @internal */ parcelHelpers.export(exports, "FeeEstimator_free", ()=>FeeEstimator_free
);
// void MonitorUpdateId_free(struct LDKMonitorUpdateId this_obj);
/* @internal */ parcelHelpers.export(exports, "MonitorUpdateId_free", ()=>MonitorUpdateId_free
);
// uintptr_t MonitorUpdateId_clone_ptr(LDKMonitorUpdateId *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "MonitorUpdateId_clone_ptr", ()=>MonitorUpdateId_clone_ptr
);
// struct LDKMonitorUpdateId MonitorUpdateId_clone(const struct LDKMonitorUpdateId *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "MonitorUpdateId_clone", ()=>MonitorUpdateId_clone
);
// uint64_t MonitorUpdateId_hash(const struct LDKMonitorUpdateId *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "MonitorUpdateId_hash", ()=>MonitorUpdateId_hash
);
// bool MonitorUpdateId_eq(const struct LDKMonitorUpdateId *NONNULL_PTR a, const struct LDKMonitorUpdateId *NONNULL_PTR b);
/* @internal */ parcelHelpers.export(exports, "MonitorUpdateId_eq", ()=>MonitorUpdateId_eq
);
// void Persist_free(struct LDKPersist this_ptr);
/* @internal */ parcelHelpers.export(exports, "Persist_free", ()=>Persist_free
);
// void LockedChannelMonitor_free(struct LDKLockedChannelMonitor this_obj);
/* @internal */ parcelHelpers.export(exports, "LockedChannelMonitor_free", ()=>LockedChannelMonitor_free
);
// void ChainMonitor_free(struct LDKChainMonitor this_obj);
/* @internal */ parcelHelpers.export(exports, "ChainMonitor_free", ()=>ChainMonitor_free
);
// MUST_USE_RES struct LDKChainMonitor ChainMonitor_new(struct LDKCOption_FilterZ chain_source, struct LDKBroadcasterInterface broadcaster, struct LDKLogger logger, struct LDKFeeEstimator feeest, struct LDKPersist persister);
/* @internal */ parcelHelpers.export(exports, "ChainMonitor_new", ()=>ChainMonitor_new
);
// MUST_USE_RES struct LDKCVec_BalanceZ ChainMonitor_get_claimable_balances(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKCVec_ChannelDetailsZ ignored_channels);
/* @internal */ parcelHelpers.export(exports, "ChainMonitor_get_claimable_balances", ()=>ChainMonitor_get_claimable_balances
);
// MUST_USE_RES struct LDKCResult_LockedChannelMonitorNoneZ ChainMonitor_get_monitor(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo);
/* @internal */ parcelHelpers.export(exports, "ChainMonitor_get_monitor", ()=>ChainMonitor_get_monitor
);
// MUST_USE_RES struct LDKCVec_OutPointZ ChainMonitor_list_monitors(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChainMonitor_list_monitors", ()=>ChainMonitor_list_monitors
);
// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChainMonitor_channel_monitor_updated(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo, struct LDKMonitorUpdateId completed_update_id);
/* @internal */ parcelHelpers.export(exports, "ChainMonitor_channel_monitor_updated", ()=>ChainMonitor_channel_monitor_updated
);
// struct LDKListen ChainMonitor_as_Listen(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChainMonitor_as_Listen", ()=>ChainMonitor_as_Listen
);
// struct LDKConfirm ChainMonitor_as_Confirm(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChainMonitor_as_Confirm", ()=>ChainMonitor_as_Confirm
);
// struct LDKWatch ChainMonitor_as_Watch(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChainMonitor_as_Watch", ()=>ChainMonitor_as_Watch
);
// struct LDKEventsProvider ChainMonitor_as_EventsProvider(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChainMonitor_as_EventsProvider", ()=>ChainMonitor_as_EventsProvider
);
// void ChannelMonitorUpdate_free(struct LDKChannelMonitorUpdate this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitorUpdate_free", ()=>ChannelMonitorUpdate_free
);
// uint64_t ChannelMonitorUpdate_get_update_id(const struct LDKChannelMonitorUpdate *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitorUpdate_get_update_id", ()=>ChannelMonitorUpdate_get_update_id
);
// void ChannelMonitorUpdate_set_update_id(struct LDKChannelMonitorUpdate *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitorUpdate_set_update_id", ()=>ChannelMonitorUpdate_set_update_id
);
// uintptr_t ChannelMonitorUpdate_clone_ptr(LDKChannelMonitorUpdate *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitorUpdate_clone_ptr", ()=>ChannelMonitorUpdate_clone_ptr
);
// struct LDKChannelMonitorUpdate ChannelMonitorUpdate_clone(const struct LDKChannelMonitorUpdate *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitorUpdate_clone", ()=>ChannelMonitorUpdate_clone
);
// struct LDKCVec_u8Z ChannelMonitorUpdate_write(const struct LDKChannelMonitorUpdate *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitorUpdate_write", ()=>ChannelMonitorUpdate_write
);
// struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ ChannelMonitorUpdate_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitorUpdate_read", ()=>ChannelMonitorUpdate_read
);
// void MonitorEvent_free(struct LDKMonitorEvent this_ptr);
/* @internal */ parcelHelpers.export(exports, "MonitorEvent_free", ()=>MonitorEvent_free
);
// uintptr_t MonitorEvent_clone_ptr(LDKMonitorEvent *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "MonitorEvent_clone_ptr", ()=>MonitorEvent_clone_ptr
);
// struct LDKMonitorEvent MonitorEvent_clone(const struct LDKMonitorEvent *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "MonitorEvent_clone", ()=>MonitorEvent_clone
);
// struct LDKMonitorEvent MonitorEvent_htlcevent(struct LDKHTLCUpdate a);
/* @internal */ parcelHelpers.export(exports, "MonitorEvent_htlcevent", ()=>MonitorEvent_htlcevent
);
// struct LDKMonitorEvent MonitorEvent_commitment_tx_confirmed(struct LDKOutPoint a);
/* @internal */ parcelHelpers.export(exports, "MonitorEvent_commitment_tx_confirmed", ()=>MonitorEvent_commitment_tx_confirmed
);
// struct LDKMonitorEvent MonitorEvent_update_completed(struct LDKOutPoint funding_txo, uint64_t monitor_update_id);
/* @internal */ parcelHelpers.export(exports, "MonitorEvent_update_completed", ()=>MonitorEvent_update_completed
);
// struct LDKMonitorEvent MonitorEvent_update_failed(struct LDKOutPoint a);
/* @internal */ parcelHelpers.export(exports, "MonitorEvent_update_failed", ()=>MonitorEvent_update_failed
);
// struct LDKCVec_u8Z MonitorEvent_write(const struct LDKMonitorEvent *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "MonitorEvent_write", ()=>MonitorEvent_write
);
// struct LDKCResult_COption_MonitorEventZDecodeErrorZ MonitorEvent_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "MonitorEvent_read", ()=>MonitorEvent_read
);
// void HTLCUpdate_free(struct LDKHTLCUpdate this_obj);
/* @internal */ parcelHelpers.export(exports, "HTLCUpdate_free", ()=>HTLCUpdate_free
);
// uintptr_t HTLCUpdate_clone_ptr(LDKHTLCUpdate *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "HTLCUpdate_clone_ptr", ()=>HTLCUpdate_clone_ptr
);
// struct LDKHTLCUpdate HTLCUpdate_clone(const struct LDKHTLCUpdate *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "HTLCUpdate_clone", ()=>HTLCUpdate_clone
);
// struct LDKCVec_u8Z HTLCUpdate_write(const struct LDKHTLCUpdate *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "HTLCUpdate_write", ()=>HTLCUpdate_write
);
// struct LDKCResult_HTLCUpdateDecodeErrorZ HTLCUpdate_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "HTLCUpdate_read", ()=>HTLCUpdate_read
);
// void Balance_free(struct LDKBalance this_ptr);
/* @internal */ parcelHelpers.export(exports, "Balance_free", ()=>Balance_free
);
// uintptr_t Balance_clone_ptr(LDKBalance *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "Balance_clone_ptr", ()=>Balance_clone_ptr
);
// struct LDKBalance Balance_clone(const struct LDKBalance *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "Balance_clone", ()=>Balance_clone
);
// struct LDKBalance Balance_claimable_on_channel_close(uint64_t claimable_amount_satoshis);
/* @internal */ parcelHelpers.export(exports, "Balance_claimable_on_channel_close", ()=>Balance_claimable_on_channel_close
);
// struct LDKBalance Balance_claimable_awaiting_confirmations(uint64_t claimable_amount_satoshis, uint32_t confirmation_height);
/* @internal */ parcelHelpers.export(exports, "Balance_claimable_awaiting_confirmations", ()=>Balance_claimable_awaiting_confirmations
);
// struct LDKBalance Balance_contentious_claimable(uint64_t claimable_amount_satoshis, uint32_t timeout_height);
/* @internal */ parcelHelpers.export(exports, "Balance_contentious_claimable", ()=>Balance_contentious_claimable
);
// struct LDKBalance Balance_maybe_claimable_htlcawaiting_timeout(uint64_t claimable_amount_satoshis, uint32_t claimable_height);
/* @internal */ parcelHelpers.export(exports, "Balance_maybe_claimable_htlcawaiting_timeout", ()=>Balance_maybe_claimable_htlcawaiting_timeout
);
// bool Balance_eq(const struct LDKBalance *NONNULL_PTR a, const struct LDKBalance *NONNULL_PTR b);
/* @internal */ parcelHelpers.export(exports, "Balance_eq", ()=>Balance_eq
);
// void ChannelMonitor_free(struct LDKChannelMonitor this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_free", ()=>ChannelMonitor_free
);
// uintptr_t ChannelMonitor_clone_ptr(LDKChannelMonitor *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_clone_ptr", ()=>ChannelMonitor_clone_ptr
);
// struct LDKChannelMonitor ChannelMonitor_clone(const struct LDKChannelMonitor *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_clone", ()=>ChannelMonitor_clone
);
// struct LDKCVec_u8Z ChannelMonitor_write(const struct LDKChannelMonitor *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_write", ()=>ChannelMonitor_write
);
// MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelMonitor_update_monitor(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKChannelMonitorUpdate *NONNULL_PTR updates, const struct LDKBroadcasterInterface *NONNULL_PTR broadcaster, const struct LDKFeeEstimator *NONNULL_PTR fee_estimator, const struct LDKLogger *NONNULL_PTR logger);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_update_monitor", ()=>ChannelMonitor_update_monitor
);
// MUST_USE_RES uint64_t ChannelMonitor_get_latest_update_id(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_get_latest_update_id", ()=>ChannelMonitor_get_latest_update_id
);
// MUST_USE_RES struct LDKC2Tuple_OutPointScriptZ ChannelMonitor_get_funding_txo(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_get_funding_txo", ()=>ChannelMonitor_get_funding_txo
);
// MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ ChannelMonitor_get_outputs_to_watch(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_get_outputs_to_watch", ()=>ChannelMonitor_get_outputs_to_watch
);
// void ChannelMonitor_load_outputs_to_watch(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKFilter *NONNULL_PTR filter);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_load_outputs_to_watch", ()=>ChannelMonitor_load_outputs_to_watch
);
// MUST_USE_RES struct LDKCVec_MonitorEventZ ChannelMonitor_get_and_clear_pending_monitor_events(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_get_and_clear_pending_monitor_events", ()=>ChannelMonitor_get_and_clear_pending_monitor_events
);
// MUST_USE_RES struct LDKCVec_EventZ ChannelMonitor_get_and_clear_pending_events(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_get_and_clear_pending_events", ()=>ChannelMonitor_get_and_clear_pending_events
);
// MUST_USE_RES struct LDKCVec_TransactionZ ChannelMonitor_get_latest_holder_commitment_txn(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKLogger *NONNULL_PTR logger);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_get_latest_holder_commitment_txn", ()=>ChannelMonitor_get_latest_holder_commitment_txn
);
// MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ ChannelMonitor_block_connected(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_block_connected", ()=>ChannelMonitor_block_connected
);
// void ChannelMonitor_block_disconnected(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_block_disconnected", ()=>ChannelMonitor_block_disconnected
);
// MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ ChannelMonitor_transactions_confirmed(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_transactions_confirmed", ()=>ChannelMonitor_transactions_confirmed
);
// void ChannelMonitor_transaction_unconfirmed(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*txid)[32], struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_transaction_unconfirmed", ()=>ChannelMonitor_transaction_unconfirmed
);
// MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ ChannelMonitor_best_block_updated(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_best_block_updated", ()=>ChannelMonitor_best_block_updated
);
// MUST_USE_RES struct LDKCVec_TxidZ ChannelMonitor_get_relevant_txids(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_get_relevant_txids", ()=>ChannelMonitor_get_relevant_txids
);
// MUST_USE_RES struct LDKBestBlock ChannelMonitor_current_best_block(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_current_best_block", ()=>ChannelMonitor_current_best_block
);
// MUST_USE_RES struct LDKCVec_BalanceZ ChannelMonitor_get_claimable_balances(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelMonitor_get_claimable_balances", ()=>ChannelMonitor_get_claimable_balances
);
// struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ C2Tuple_BlockHashChannelMonitorZ_read(struct LDKu8slice ser, const struct LDKKeysInterface *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_BlockHashChannelMonitorZ_read", ()=>C2Tuple_BlockHashChannelMonitorZ_read
);
// void OutPoint_free(struct LDKOutPoint this_obj);
/* @internal */ parcelHelpers.export(exports, "OutPoint_free", ()=>OutPoint_free
);
// const uint8_t (*OutPoint_get_txid(const struct LDKOutPoint *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "OutPoint_get_txid", ()=>OutPoint_get_txid
);
// void OutPoint_set_txid(struct LDKOutPoint *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "OutPoint_set_txid", ()=>OutPoint_set_txid
);
// uint16_t OutPoint_get_index(const struct LDKOutPoint *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OutPoint_get_index", ()=>OutPoint_get_index
);
// void OutPoint_set_index(struct LDKOutPoint *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "OutPoint_set_index", ()=>OutPoint_set_index
);
// MUST_USE_RES struct LDKOutPoint OutPoint_new(struct LDKThirtyTwoBytes txid_arg, uint16_t index_arg);
/* @internal */ parcelHelpers.export(exports, "OutPoint_new", ()=>OutPoint_new
);
// uintptr_t OutPoint_clone_ptr(LDKOutPoint *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "OutPoint_clone_ptr", ()=>OutPoint_clone_ptr
);
// struct LDKOutPoint OutPoint_clone(const struct LDKOutPoint *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "OutPoint_clone", ()=>OutPoint_clone
);
// bool OutPoint_eq(const struct LDKOutPoint *NONNULL_PTR a, const struct LDKOutPoint *NONNULL_PTR b);
/* @internal */ parcelHelpers.export(exports, "OutPoint_eq", ()=>OutPoint_eq
);
// uint64_t OutPoint_hash(const struct LDKOutPoint *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "OutPoint_hash", ()=>OutPoint_hash
);
// MUST_USE_RES struct LDKThirtyTwoBytes OutPoint_to_channel_id(const struct LDKOutPoint *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "OutPoint_to_channel_id", ()=>OutPoint_to_channel_id
);
// struct LDKCVec_u8Z OutPoint_write(const struct LDKOutPoint *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "OutPoint_write", ()=>OutPoint_write
);
// struct LDKCResult_OutPointDecodeErrorZ OutPoint_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "OutPoint_read", ()=>OutPoint_read
);
// void DelayedPaymentOutputDescriptor_free(struct LDKDelayedPaymentOutputDescriptor this_obj);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_free", ()=>DelayedPaymentOutputDescriptor_free
);
// struct LDKOutPoint DelayedPaymentOutputDescriptor_get_outpoint(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_get_outpoint", ()=>DelayedPaymentOutputDescriptor_get_outpoint
);
// void DelayedPaymentOutputDescriptor_set_outpoint(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_set_outpoint", ()=>DelayedPaymentOutputDescriptor_set_outpoint
);
// struct LDKPublicKey DelayedPaymentOutputDescriptor_get_per_commitment_point(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_get_per_commitment_point", ()=>DelayedPaymentOutputDescriptor_get_per_commitment_point
);
// void DelayedPaymentOutputDescriptor_set_per_commitment_point(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_set_per_commitment_point", ()=>DelayedPaymentOutputDescriptor_set_per_commitment_point
);
// uint16_t DelayedPaymentOutputDescriptor_get_to_self_delay(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_get_to_self_delay", ()=>DelayedPaymentOutputDescriptor_get_to_self_delay
);
// void DelayedPaymentOutputDescriptor_set_to_self_delay(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_set_to_self_delay", ()=>DelayedPaymentOutputDescriptor_set_to_self_delay
);
// void DelayedPaymentOutputDescriptor_set_output(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKTxOut val);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_set_output", ()=>DelayedPaymentOutputDescriptor_set_output
);
// struct LDKPublicKey DelayedPaymentOutputDescriptor_get_revocation_pubkey(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_get_revocation_pubkey", ()=>DelayedPaymentOutputDescriptor_get_revocation_pubkey
);
// void DelayedPaymentOutputDescriptor_set_revocation_pubkey(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_set_revocation_pubkey", ()=>DelayedPaymentOutputDescriptor_set_revocation_pubkey
);
// const uint8_t (*DelayedPaymentOutputDescriptor_get_channel_keys_id(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_get_channel_keys_id", ()=>DelayedPaymentOutputDescriptor_get_channel_keys_id
);
// void DelayedPaymentOutputDescriptor_set_channel_keys_id(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_set_channel_keys_id", ()=>DelayedPaymentOutputDescriptor_set_channel_keys_id
);
// uint64_t DelayedPaymentOutputDescriptor_get_channel_value_satoshis(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_get_channel_value_satoshis", ()=>DelayedPaymentOutputDescriptor_get_channel_value_satoshis
);
// void DelayedPaymentOutputDescriptor_set_channel_value_satoshis(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_set_channel_value_satoshis", ()=>DelayedPaymentOutputDescriptor_set_channel_value_satoshis
);
// MUST_USE_RES struct LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_new(struct LDKOutPoint outpoint_arg, struct LDKPublicKey per_commitment_point_arg, uint16_t to_self_delay_arg, struct LDKTxOut output_arg, struct LDKPublicKey revocation_pubkey_arg, struct LDKThirtyTwoBytes channel_keys_id_arg, uint64_t channel_value_satoshis_arg);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_new", ()=>DelayedPaymentOutputDescriptor_new
);
// uintptr_t DelayedPaymentOutputDescriptor_clone_ptr(LDKDelayedPaymentOutputDescriptor *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_clone_ptr", ()=>DelayedPaymentOutputDescriptor_clone_ptr
);
// struct LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_clone(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_clone", ()=>DelayedPaymentOutputDescriptor_clone
);
// struct LDKCVec_u8Z DelayedPaymentOutputDescriptor_write(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_write", ()=>DelayedPaymentOutputDescriptor_write
);
// struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ DelayedPaymentOutputDescriptor_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor_read", ()=>DelayedPaymentOutputDescriptor_read
);
// void StaticPaymentOutputDescriptor_free(struct LDKStaticPaymentOutputDescriptor this_obj);
/* @internal */ parcelHelpers.export(exports, "StaticPaymentOutputDescriptor_free", ()=>StaticPaymentOutputDescriptor_free
);
// struct LDKOutPoint StaticPaymentOutputDescriptor_get_outpoint(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "StaticPaymentOutputDescriptor_get_outpoint", ()=>StaticPaymentOutputDescriptor_get_outpoint
);
// void StaticPaymentOutputDescriptor_set_outpoint(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */ parcelHelpers.export(exports, "StaticPaymentOutputDescriptor_set_outpoint", ()=>StaticPaymentOutputDescriptor_set_outpoint
);
// void StaticPaymentOutputDescriptor_set_output(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKTxOut val);
/* @internal */ parcelHelpers.export(exports, "StaticPaymentOutputDescriptor_set_output", ()=>StaticPaymentOutputDescriptor_set_output
);
// const uint8_t (*StaticPaymentOutputDescriptor_get_channel_keys_id(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "StaticPaymentOutputDescriptor_get_channel_keys_id", ()=>StaticPaymentOutputDescriptor_get_channel_keys_id
);
// void StaticPaymentOutputDescriptor_set_channel_keys_id(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "StaticPaymentOutputDescriptor_set_channel_keys_id", ()=>StaticPaymentOutputDescriptor_set_channel_keys_id
);
// uint64_t StaticPaymentOutputDescriptor_get_channel_value_satoshis(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "StaticPaymentOutputDescriptor_get_channel_value_satoshis", ()=>StaticPaymentOutputDescriptor_get_channel_value_satoshis
);
// void StaticPaymentOutputDescriptor_set_channel_value_satoshis(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "StaticPaymentOutputDescriptor_set_channel_value_satoshis", ()=>StaticPaymentOutputDescriptor_set_channel_value_satoshis
);
// MUST_USE_RES struct LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_new(struct LDKOutPoint outpoint_arg, struct LDKTxOut output_arg, struct LDKThirtyTwoBytes channel_keys_id_arg, uint64_t channel_value_satoshis_arg);
/* @internal */ parcelHelpers.export(exports, "StaticPaymentOutputDescriptor_new", ()=>StaticPaymentOutputDescriptor_new
);
// uintptr_t StaticPaymentOutputDescriptor_clone_ptr(LDKStaticPaymentOutputDescriptor *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "StaticPaymentOutputDescriptor_clone_ptr", ()=>StaticPaymentOutputDescriptor_clone_ptr
);
// struct LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_clone(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "StaticPaymentOutputDescriptor_clone", ()=>StaticPaymentOutputDescriptor_clone
);
// struct LDKCVec_u8Z StaticPaymentOutputDescriptor_write(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "StaticPaymentOutputDescriptor_write", ()=>StaticPaymentOutputDescriptor_write
);
// struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ StaticPaymentOutputDescriptor_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "StaticPaymentOutputDescriptor_read", ()=>StaticPaymentOutputDescriptor_read
);
// void SpendableOutputDescriptor_free(struct LDKSpendableOutputDescriptor this_ptr);
/* @internal */ parcelHelpers.export(exports, "SpendableOutputDescriptor_free", ()=>SpendableOutputDescriptor_free
);
// uintptr_t SpendableOutputDescriptor_clone_ptr(LDKSpendableOutputDescriptor *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "SpendableOutputDescriptor_clone_ptr", ()=>SpendableOutputDescriptor_clone_ptr
);
// struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_clone(const struct LDKSpendableOutputDescriptor *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "SpendableOutputDescriptor_clone", ()=>SpendableOutputDescriptor_clone
);
// struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_static_output(struct LDKOutPoint outpoint, struct LDKTxOut output);
/* @internal */ parcelHelpers.export(exports, "SpendableOutputDescriptor_static_output", ()=>SpendableOutputDescriptor_static_output
);
// struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_delayed_payment_output(struct LDKDelayedPaymentOutputDescriptor a);
/* @internal */ parcelHelpers.export(exports, "SpendableOutputDescriptor_delayed_payment_output", ()=>SpendableOutputDescriptor_delayed_payment_output
);
// struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_static_payment_output(struct LDKStaticPaymentOutputDescriptor a);
/* @internal */ parcelHelpers.export(exports, "SpendableOutputDescriptor_static_payment_output", ()=>SpendableOutputDescriptor_static_payment_output
);
// struct LDKCVec_u8Z SpendableOutputDescriptor_write(const struct LDKSpendableOutputDescriptor *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "SpendableOutputDescriptor_write", ()=>SpendableOutputDescriptor_write
);
// struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ SpendableOutputDescriptor_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "SpendableOutputDescriptor_read", ()=>SpendableOutputDescriptor_read
);
// void BaseSign_free(struct LDKBaseSign this_ptr);
/* @internal */ parcelHelpers.export(exports, "BaseSign_free", ()=>BaseSign_free
);
// uintptr_t Sign_clone_ptr(LDKSign *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "Sign_clone_ptr", ()=>Sign_clone_ptr
);
// struct LDKSign Sign_clone(const struct LDKSign *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "Sign_clone", ()=>Sign_clone
);
// void Sign_free(struct LDKSign this_ptr);
/* @internal */ parcelHelpers.export(exports, "Sign_free", ()=>Sign_free
);
// void KeysInterface_free(struct LDKKeysInterface this_ptr);
/* @internal */ parcelHelpers.export(exports, "KeysInterface_free", ()=>KeysInterface_free
);
// void InMemorySigner_free(struct LDKInMemorySigner this_obj);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_free", ()=>InMemorySigner_free
);
// const uint8_t (*InMemorySigner_get_funding_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_get_funding_key", ()=>InMemorySigner_get_funding_key
);
// void InMemorySigner_set_funding_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_set_funding_key", ()=>InMemorySigner_set_funding_key
);
// const uint8_t (*InMemorySigner_get_revocation_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_get_revocation_base_key", ()=>InMemorySigner_get_revocation_base_key
);
// void InMemorySigner_set_revocation_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_set_revocation_base_key", ()=>InMemorySigner_set_revocation_base_key
);
// const uint8_t (*InMemorySigner_get_payment_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_get_payment_key", ()=>InMemorySigner_get_payment_key
);
// void InMemorySigner_set_payment_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_set_payment_key", ()=>InMemorySigner_set_payment_key
);
// const uint8_t (*InMemorySigner_get_delayed_payment_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_get_delayed_payment_base_key", ()=>InMemorySigner_get_delayed_payment_base_key
);
// void InMemorySigner_set_delayed_payment_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_set_delayed_payment_base_key", ()=>InMemorySigner_set_delayed_payment_base_key
);
// const uint8_t (*InMemorySigner_get_htlc_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_get_htlc_base_key", ()=>InMemorySigner_get_htlc_base_key
);
// void InMemorySigner_set_htlc_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_set_htlc_base_key", ()=>InMemorySigner_set_htlc_base_key
);
// const uint8_t (*InMemorySigner_get_commitment_seed(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_get_commitment_seed", ()=>InMemorySigner_get_commitment_seed
);
// void InMemorySigner_set_commitment_seed(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_set_commitment_seed", ()=>InMemorySigner_set_commitment_seed
);
// uintptr_t InMemorySigner_clone_ptr(LDKInMemorySigner *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_clone_ptr", ()=>InMemorySigner_clone_ptr
);
// struct LDKInMemorySigner InMemorySigner_clone(const struct LDKInMemorySigner *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_clone", ()=>InMemorySigner_clone
);
// MUST_USE_RES struct LDKInMemorySigner InMemorySigner_new(struct LDKSecretKey funding_key, struct LDKSecretKey revocation_base_key, struct LDKSecretKey payment_key, struct LDKSecretKey delayed_payment_base_key, struct LDKSecretKey htlc_base_key, struct LDKThirtyTwoBytes commitment_seed, uint64_t channel_value_satoshis, struct LDKThirtyTwoBytes channel_keys_id);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_new", ()=>InMemorySigner_new
);
// MUST_USE_RES struct LDKChannelPublicKeys InMemorySigner_counterparty_pubkeys(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_counterparty_pubkeys", ()=>InMemorySigner_counterparty_pubkeys
);
// MUST_USE_RES uint16_t InMemorySigner_counterparty_selected_contest_delay(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_counterparty_selected_contest_delay", ()=>InMemorySigner_counterparty_selected_contest_delay
);
// MUST_USE_RES uint16_t InMemorySigner_holder_selected_contest_delay(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_holder_selected_contest_delay", ()=>InMemorySigner_holder_selected_contest_delay
);
// MUST_USE_RES bool InMemorySigner_is_outbound(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_is_outbound", ()=>InMemorySigner_is_outbound
);
// MUST_USE_RES struct LDKOutPoint InMemorySigner_funding_outpoint(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_funding_outpoint", ()=>InMemorySigner_funding_outpoint
);
// MUST_USE_RES struct LDKChannelTransactionParameters InMemorySigner_get_channel_parameters(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_get_channel_parameters", ()=>InMemorySigner_get_channel_parameters
);
// MUST_USE_RES bool InMemorySigner_opt_anchors(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_opt_anchors", ()=>InMemorySigner_opt_anchors
);
// MUST_USE_RES struct LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_counterparty_payment_input(const struct LDKInMemorySigner *NONNULL_PTR this_arg, struct LDKTransaction spend_tx, uintptr_t input_idx, const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR descriptor);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_sign_counterparty_payment_input", ()=>InMemorySigner_sign_counterparty_payment_input
);
// MUST_USE_RES struct LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_dynamic_p2wsh_input(const struct LDKInMemorySigner *NONNULL_PTR this_arg, struct LDKTransaction spend_tx, uintptr_t input_idx, const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR descriptor);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_sign_dynamic_p2wsh_input", ()=>InMemorySigner_sign_dynamic_p2wsh_input
);
// struct LDKBaseSign InMemorySigner_as_BaseSign(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_as_BaseSign", ()=>InMemorySigner_as_BaseSign
);
// struct LDKSign InMemorySigner_as_Sign(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_as_Sign", ()=>InMemorySigner_as_Sign
);
// struct LDKCVec_u8Z InMemorySigner_write(const struct LDKInMemorySigner *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_write", ()=>InMemorySigner_write
);
// struct LDKCResult_InMemorySignerDecodeErrorZ InMemorySigner_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "InMemorySigner_read", ()=>InMemorySigner_read
);
// void KeysManager_free(struct LDKKeysManager this_obj);
/* @internal */ parcelHelpers.export(exports, "KeysManager_free", ()=>KeysManager_free
);
// MUST_USE_RES struct LDKKeysManager KeysManager_new(const uint8_t (*seed)[32], uint64_t starting_time_secs, uint32_t starting_time_nanos);
/* @internal */ parcelHelpers.export(exports, "KeysManager_new", ()=>KeysManager_new
);
// MUST_USE_RES struct LDKInMemorySigner KeysManager_derive_channel_keys(const struct LDKKeysManager *NONNULL_PTR this_arg, uint64_t channel_value_satoshis, const uint8_t (*params)[32]);
/* @internal */ parcelHelpers.export(exports, "KeysManager_derive_channel_keys", ()=>KeysManager_derive_channel_keys
);
// MUST_USE_RES struct LDKCResult_TransactionNoneZ KeysManager_spend_spendable_outputs(const struct LDKKeysManager *NONNULL_PTR this_arg, struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_TxOutZ outputs, struct LDKCVec_u8Z change_destination_script, uint32_t feerate_sat_per_1000_weight);
/* @internal */ parcelHelpers.export(exports, "KeysManager_spend_spendable_outputs", ()=>KeysManager_spend_spendable_outputs
);
// struct LDKKeysInterface KeysManager_as_KeysInterface(const struct LDKKeysManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "KeysManager_as_KeysInterface", ()=>KeysManager_as_KeysInterface
);
// void ChannelManager_free(struct LDKChannelManager this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_free", ()=>ChannelManager_free
);
// void ChainParameters_free(struct LDKChainParameters this_obj);
/* @internal */ parcelHelpers.export(exports, "ChainParameters_free", ()=>ChainParameters_free
);
// enum LDKNetwork ChainParameters_get_network(const struct LDKChainParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChainParameters_get_network", ()=>ChainParameters_get_network
);
// void ChainParameters_set_network(struct LDKChainParameters *NONNULL_PTR this_ptr, enum LDKNetwork val);
/* @internal */ parcelHelpers.export(exports, "ChainParameters_set_network", ()=>ChainParameters_set_network
);
// struct LDKBestBlock ChainParameters_get_best_block(const struct LDKChainParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChainParameters_get_best_block", ()=>ChainParameters_get_best_block
);
// void ChainParameters_set_best_block(struct LDKChainParameters *NONNULL_PTR this_ptr, struct LDKBestBlock val);
/* @internal */ parcelHelpers.export(exports, "ChainParameters_set_best_block", ()=>ChainParameters_set_best_block
);
// MUST_USE_RES struct LDKChainParameters ChainParameters_new(enum LDKNetwork network_arg, struct LDKBestBlock best_block_arg);
/* @internal */ parcelHelpers.export(exports, "ChainParameters_new", ()=>ChainParameters_new
);
// uintptr_t ChainParameters_clone_ptr(LDKChainParameters *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ChainParameters_clone_ptr", ()=>ChainParameters_clone_ptr
);
// struct LDKChainParameters ChainParameters_clone(const struct LDKChainParameters *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChainParameters_clone", ()=>ChainParameters_clone
);
// void CounterpartyForwardingInfo_free(struct LDKCounterpartyForwardingInfo this_obj);
/* @internal */ parcelHelpers.export(exports, "CounterpartyForwardingInfo_free", ()=>CounterpartyForwardingInfo_free
);
// uint32_t CounterpartyForwardingInfo_get_fee_base_msat(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "CounterpartyForwardingInfo_get_fee_base_msat", ()=>CounterpartyForwardingInfo_get_fee_base_msat
);
// void CounterpartyForwardingInfo_set_fee_base_msat(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "CounterpartyForwardingInfo_set_fee_base_msat", ()=>CounterpartyForwardingInfo_set_fee_base_msat
);
// uint32_t CounterpartyForwardingInfo_get_fee_proportional_millionths(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "CounterpartyForwardingInfo_get_fee_proportional_millionths", ()=>CounterpartyForwardingInfo_get_fee_proportional_millionths
);
// void CounterpartyForwardingInfo_set_fee_proportional_millionths(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "CounterpartyForwardingInfo_set_fee_proportional_millionths", ()=>CounterpartyForwardingInfo_set_fee_proportional_millionths
);
// uint16_t CounterpartyForwardingInfo_get_cltv_expiry_delta(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "CounterpartyForwardingInfo_get_cltv_expiry_delta", ()=>CounterpartyForwardingInfo_get_cltv_expiry_delta
);
// void CounterpartyForwardingInfo_set_cltv_expiry_delta(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "CounterpartyForwardingInfo_set_cltv_expiry_delta", ()=>CounterpartyForwardingInfo_set_cltv_expiry_delta
);
// MUST_USE_RES struct LDKCounterpartyForwardingInfo CounterpartyForwardingInfo_new(uint32_t fee_base_msat_arg, uint32_t fee_proportional_millionths_arg, uint16_t cltv_expiry_delta_arg);
/* @internal */ parcelHelpers.export(exports, "CounterpartyForwardingInfo_new", ()=>CounterpartyForwardingInfo_new
);
// uintptr_t CounterpartyForwardingInfo_clone_ptr(LDKCounterpartyForwardingInfo *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CounterpartyForwardingInfo_clone_ptr", ()=>CounterpartyForwardingInfo_clone_ptr
);
// struct LDKCounterpartyForwardingInfo CounterpartyForwardingInfo_clone(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CounterpartyForwardingInfo_clone", ()=>CounterpartyForwardingInfo_clone
);
// void ChannelCounterparty_free(struct LDKChannelCounterparty this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelCounterparty_free", ()=>ChannelCounterparty_free
);
// struct LDKPublicKey ChannelCounterparty_get_node_id(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelCounterparty_get_node_id", ()=>ChannelCounterparty_get_node_id
);
// void ChannelCounterparty_set_node_id(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "ChannelCounterparty_set_node_id", ()=>ChannelCounterparty_set_node_id
);
// struct LDKInitFeatures ChannelCounterparty_get_features(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelCounterparty_get_features", ()=>ChannelCounterparty_get_features
);
// void ChannelCounterparty_set_features(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKInitFeatures val);
/* @internal */ parcelHelpers.export(exports, "ChannelCounterparty_set_features", ()=>ChannelCounterparty_set_features
);
// uint64_t ChannelCounterparty_get_unspendable_punishment_reserve(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelCounterparty_get_unspendable_punishment_reserve", ()=>ChannelCounterparty_get_unspendable_punishment_reserve
);
// void ChannelCounterparty_set_unspendable_punishment_reserve(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelCounterparty_set_unspendable_punishment_reserve", ()=>ChannelCounterparty_set_unspendable_punishment_reserve
);
// struct LDKCounterpartyForwardingInfo ChannelCounterparty_get_forwarding_info(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelCounterparty_get_forwarding_info", ()=>ChannelCounterparty_get_forwarding_info
);
// void ChannelCounterparty_set_forwarding_info(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKCounterpartyForwardingInfo val);
/* @internal */ parcelHelpers.export(exports, "ChannelCounterparty_set_forwarding_info", ()=>ChannelCounterparty_set_forwarding_info
);
// MUST_USE_RES struct LDKChannelCounterparty ChannelCounterparty_new(struct LDKPublicKey node_id_arg, struct LDKInitFeatures features_arg, uint64_t unspendable_punishment_reserve_arg, struct LDKCounterpartyForwardingInfo forwarding_info_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelCounterparty_new", ()=>ChannelCounterparty_new
);
// uintptr_t ChannelCounterparty_clone_ptr(LDKChannelCounterparty *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ChannelCounterparty_clone_ptr", ()=>ChannelCounterparty_clone_ptr
);
// struct LDKChannelCounterparty ChannelCounterparty_clone(const struct LDKChannelCounterparty *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChannelCounterparty_clone", ()=>ChannelCounterparty_clone
);
// void ChannelDetails_free(struct LDKChannelDetails this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_free", ()=>ChannelDetails_free
);
// const uint8_t (*ChannelDetails_get_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_get_channel_id", ()=>ChannelDetails_get_channel_id
);
// void ChannelDetails_set_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_set_channel_id", ()=>ChannelDetails_set_channel_id
);
// struct LDKChannelCounterparty ChannelDetails_get_counterparty(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_get_counterparty", ()=>ChannelDetails_get_counterparty
);
// void ChannelDetails_set_counterparty(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKChannelCounterparty val);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_set_counterparty", ()=>ChannelDetails_set_counterparty
);
// struct LDKOutPoint ChannelDetails_get_funding_txo(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_get_funding_txo", ()=>ChannelDetails_get_funding_txo
);
// void ChannelDetails_set_funding_txo(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_set_funding_txo", ()=>ChannelDetails_set_funding_txo
);
// struct LDKCOption_u64Z ChannelDetails_get_short_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_get_short_channel_id", ()=>ChannelDetails_get_short_channel_id
);
// void ChannelDetails_set_short_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_set_short_channel_id", ()=>ChannelDetails_set_short_channel_id
);
// uint64_t ChannelDetails_get_channel_value_satoshis(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_get_channel_value_satoshis", ()=>ChannelDetails_get_channel_value_satoshis
);
// void ChannelDetails_set_channel_value_satoshis(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_set_channel_value_satoshis", ()=>ChannelDetails_set_channel_value_satoshis
);
// struct LDKCOption_u64Z ChannelDetails_get_unspendable_punishment_reserve(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_get_unspendable_punishment_reserve", ()=>ChannelDetails_get_unspendable_punishment_reserve
);
// void ChannelDetails_set_unspendable_punishment_reserve(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_set_unspendable_punishment_reserve", ()=>ChannelDetails_set_unspendable_punishment_reserve
);
// uint64_t ChannelDetails_get_user_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_get_user_channel_id", ()=>ChannelDetails_get_user_channel_id
);
// void ChannelDetails_set_user_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_set_user_channel_id", ()=>ChannelDetails_set_user_channel_id
);
// uint64_t ChannelDetails_get_balance_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_get_balance_msat", ()=>ChannelDetails_get_balance_msat
);
// void ChannelDetails_set_balance_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_set_balance_msat", ()=>ChannelDetails_set_balance_msat
);
// uint64_t ChannelDetails_get_outbound_capacity_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_get_outbound_capacity_msat", ()=>ChannelDetails_get_outbound_capacity_msat
);
// void ChannelDetails_set_outbound_capacity_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_set_outbound_capacity_msat", ()=>ChannelDetails_set_outbound_capacity_msat
);
// uint64_t ChannelDetails_get_inbound_capacity_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_get_inbound_capacity_msat", ()=>ChannelDetails_get_inbound_capacity_msat
);
// void ChannelDetails_set_inbound_capacity_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_set_inbound_capacity_msat", ()=>ChannelDetails_set_inbound_capacity_msat
);
// struct LDKCOption_u32Z ChannelDetails_get_confirmations_required(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_get_confirmations_required", ()=>ChannelDetails_get_confirmations_required
);
// void ChannelDetails_set_confirmations_required(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_set_confirmations_required", ()=>ChannelDetails_set_confirmations_required
);
// struct LDKCOption_u16Z ChannelDetails_get_force_close_spend_delay(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_get_force_close_spend_delay", ()=>ChannelDetails_get_force_close_spend_delay
);
// void ChannelDetails_set_force_close_spend_delay(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u16Z val);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_set_force_close_spend_delay", ()=>ChannelDetails_set_force_close_spend_delay
);
// bool ChannelDetails_get_is_outbound(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_get_is_outbound", ()=>ChannelDetails_get_is_outbound
);
// void ChannelDetails_set_is_outbound(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_set_is_outbound", ()=>ChannelDetails_set_is_outbound
);
// bool ChannelDetails_get_is_funding_locked(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_get_is_funding_locked", ()=>ChannelDetails_get_is_funding_locked
);
// void ChannelDetails_set_is_funding_locked(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_set_is_funding_locked", ()=>ChannelDetails_set_is_funding_locked
);
// bool ChannelDetails_get_is_usable(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_get_is_usable", ()=>ChannelDetails_get_is_usable
);
// void ChannelDetails_set_is_usable(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_set_is_usable", ()=>ChannelDetails_set_is_usable
);
// bool ChannelDetails_get_is_public(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_get_is_public", ()=>ChannelDetails_get_is_public
);
// void ChannelDetails_set_is_public(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_set_is_public", ()=>ChannelDetails_set_is_public
);
// MUST_USE_RES struct LDKChannelDetails ChannelDetails_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKChannelCounterparty counterparty_arg, struct LDKOutPoint funding_txo_arg, struct LDKCOption_u64Z short_channel_id_arg, uint64_t channel_value_satoshis_arg, struct LDKCOption_u64Z unspendable_punishment_reserve_arg, uint64_t user_channel_id_arg, uint64_t balance_msat_arg, uint64_t outbound_capacity_msat_arg, uint64_t inbound_capacity_msat_arg, struct LDKCOption_u32Z confirmations_required_arg, struct LDKCOption_u16Z force_close_spend_delay_arg, bool is_outbound_arg, bool is_funding_locked_arg, bool is_usable_arg, bool is_public_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_new", ()=>ChannelDetails_new
);
// uintptr_t ChannelDetails_clone_ptr(LDKChannelDetails *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_clone_ptr", ()=>ChannelDetails_clone_ptr
);
// struct LDKChannelDetails ChannelDetails_clone(const struct LDKChannelDetails *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChannelDetails_clone", ()=>ChannelDetails_clone
);
// void PaymentSendFailure_free(struct LDKPaymentSendFailure this_ptr);
/* @internal */ parcelHelpers.export(exports, "PaymentSendFailure_free", ()=>PaymentSendFailure_free
);
// uintptr_t PaymentSendFailure_clone_ptr(LDKPaymentSendFailure *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "PaymentSendFailure_clone_ptr", ()=>PaymentSendFailure_clone_ptr
);
// struct LDKPaymentSendFailure PaymentSendFailure_clone(const struct LDKPaymentSendFailure *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "PaymentSendFailure_clone", ()=>PaymentSendFailure_clone
);
// struct LDKPaymentSendFailure PaymentSendFailure_parameter_error(struct LDKAPIError a);
/* @internal */ parcelHelpers.export(exports, "PaymentSendFailure_parameter_error", ()=>PaymentSendFailure_parameter_error
);
// struct LDKPaymentSendFailure PaymentSendFailure_path_parameter_error(struct LDKCVec_CResult_NoneAPIErrorZZ a);
/* @internal */ parcelHelpers.export(exports, "PaymentSendFailure_path_parameter_error", ()=>PaymentSendFailure_path_parameter_error
);
// struct LDKPaymentSendFailure PaymentSendFailure_all_failed_retry_safe(struct LDKCVec_APIErrorZ a);
/* @internal */ parcelHelpers.export(exports, "PaymentSendFailure_all_failed_retry_safe", ()=>PaymentSendFailure_all_failed_retry_safe
);
// struct LDKPaymentSendFailure PaymentSendFailure_partial_failure(struct LDKCVec_CResult_NoneAPIErrorZZ results, struct LDKRouteParameters failed_paths_retry, struct LDKThirtyTwoBytes payment_id);
/* @internal */ parcelHelpers.export(exports, "PaymentSendFailure_partial_failure", ()=>PaymentSendFailure_partial_failure
);
// MUST_USE_RES struct LDKChannelManager ChannelManager_new(struct LDKFeeEstimator fee_est, struct LDKWatch chain_monitor, struct LDKBroadcasterInterface tx_broadcaster, struct LDKLogger logger, struct LDKKeysInterface keys_manager, struct LDKUserConfig config, struct LDKChainParameters params);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_new", ()=>ChannelManager_new
);
// MUST_USE_RES struct LDKUserConfig ChannelManager_get_current_default_configuration(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_get_current_default_configuration", ()=>ChannelManager_get_current_default_configuration
);
// MUST_USE_RES struct LDKCResult__u832APIErrorZ ChannelManager_create_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPublicKey their_network_key, uint64_t channel_value_satoshis, uint64_t push_msat, uint64_t user_channel_id, struct LDKUserConfig override_config);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_create_channel", ()=>ChannelManager_create_channel
);
// MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_list_channels", ()=>ChannelManager_list_channels
);
// MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_usable_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_list_usable_channels", ()=>ChannelManager_list_usable_channels
);
// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_close_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32]);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_close_channel", ()=>ChannelManager_close_channel
);
// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_close_channel_with_target_feerate(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32], uint32_t target_feerate_sats_per_1000_weight);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_close_channel_with_target_feerate", ()=>ChannelManager_close_channel_with_target_feerate
);
// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_force_close_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32]);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_force_close_channel", ()=>ChannelManager_force_close_channel
);
// void ChannelManager_force_close_all_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_force_close_all_channels", ()=>ChannelManager_force_close_all_channels
);
// MUST_USE_RES struct LDKCResult_PaymentIdPaymentSendFailureZ ChannelManager_send_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_send_payment", ()=>ChannelManager_send_payment
);
// MUST_USE_RES struct LDKCResult_NonePaymentSendFailureZ ChannelManager_retry_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_id);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_retry_payment", ()=>ChannelManager_retry_payment
);
// void ChannelManager_abandon_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_id);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_abandon_payment", ()=>ChannelManager_abandon_payment
);
// MUST_USE_RES struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ ChannelManager_send_spontaneous_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_preimage);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_send_spontaneous_payment", ()=>ChannelManager_send_spontaneous_payment
);
// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_funding_transaction_generated(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*temporary_channel_id)[32], struct LDKTransaction funding_transaction);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_funding_transaction_generated", ()=>ChannelManager_funding_transaction_generated
);
// void ChannelManager_broadcast_node_announcement(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThreeBytes rgb, struct LDKThirtyTwoBytes alias, struct LDKCVec_NetAddressZ addresses);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_broadcast_node_announcement", ()=>ChannelManager_broadcast_node_announcement
);
// void ChannelManager_process_pending_htlc_forwards(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_process_pending_htlc_forwards", ()=>ChannelManager_process_pending_htlc_forwards
);
// void ChannelManager_timer_tick_occurred(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_timer_tick_occurred", ()=>ChannelManager_timer_tick_occurred
);
// MUST_USE_RES bool ChannelManager_fail_htlc_backwards(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*payment_hash)[32]);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_fail_htlc_backwards", ()=>ChannelManager_fail_htlc_backwards
);
// MUST_USE_RES bool ChannelManager_claim_funds(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_preimage);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_claim_funds", ()=>ChannelManager_claim_funds
);
// MUST_USE_RES struct LDKPublicKey ChannelManager_get_our_node_id(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_get_our_node_id", ()=>ChannelManager_get_our_node_id
);
// MUST_USE_RES struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ ChannelManager_create_inbound_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_create_inbound_payment", ()=>ChannelManager_create_inbound_payment
);
// MUST_USE_RES struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ ChannelManager_create_inbound_payment_legacy(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_create_inbound_payment_legacy", ()=>ChannelManager_create_inbound_payment_legacy
);
// MUST_USE_RES struct LDKCResult_PaymentSecretNoneZ ChannelManager_create_inbound_payment_for_hash(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_create_inbound_payment_for_hash", ()=>ChannelManager_create_inbound_payment_for_hash
);
// MUST_USE_RES struct LDKCResult_PaymentSecretAPIErrorZ ChannelManager_create_inbound_payment_for_hash_legacy(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_create_inbound_payment_for_hash_legacy", ()=>ChannelManager_create_inbound_payment_for_hash_legacy
);
// MUST_USE_RES struct LDKCResult_PaymentPreimageAPIErrorZ ChannelManager_get_payment_preimage(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_get_payment_preimage", ()=>ChannelManager_get_payment_preimage
);
// struct LDKMessageSendEventsProvider ChannelManager_as_MessageSendEventsProvider(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_as_MessageSendEventsProvider", ()=>ChannelManager_as_MessageSendEventsProvider
);
// struct LDKEventsProvider ChannelManager_as_EventsProvider(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_as_EventsProvider", ()=>ChannelManager_as_EventsProvider
);
// struct LDKListen ChannelManager_as_Listen(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_as_Listen", ()=>ChannelManager_as_Listen
);
// struct LDKConfirm ChannelManager_as_Confirm(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_as_Confirm", ()=>ChannelManager_as_Confirm
);
// void ChannelManager_await_persistable_update(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_await_persistable_update", ()=>ChannelManager_await_persistable_update
);
// MUST_USE_RES struct LDKBestBlock ChannelManager_current_best_block(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_current_best_block", ()=>ChannelManager_current_best_block
);
// struct LDKChannelMessageHandler ChannelManager_as_ChannelMessageHandler(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_as_ChannelMessageHandler", ()=>ChannelManager_as_ChannelMessageHandler
);
// struct LDKCVec_u8Z ChannelManager_write(const struct LDKChannelManager *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ChannelManager_write", ()=>ChannelManager_write
);
// void ChannelManagerReadArgs_free(struct LDKChannelManagerReadArgs this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelManagerReadArgs_free", ()=>ChannelManagerReadArgs_free
);
// const struct LDKKeysInterface *ChannelManagerReadArgs_get_keys_manager(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelManagerReadArgs_get_keys_manager", ()=>ChannelManagerReadArgs_get_keys_manager
);
// void ChannelManagerReadArgs_set_keys_manager(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKKeysInterface val);
/* @internal */ parcelHelpers.export(exports, "ChannelManagerReadArgs_set_keys_manager", ()=>ChannelManagerReadArgs_set_keys_manager
);
// const struct LDKFeeEstimator *ChannelManagerReadArgs_get_fee_estimator(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelManagerReadArgs_get_fee_estimator", ()=>ChannelManagerReadArgs_get_fee_estimator
);
// void ChannelManagerReadArgs_set_fee_estimator(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKFeeEstimator val);
/* @internal */ parcelHelpers.export(exports, "ChannelManagerReadArgs_set_fee_estimator", ()=>ChannelManagerReadArgs_set_fee_estimator
);
// const struct LDKWatch *ChannelManagerReadArgs_get_chain_monitor(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelManagerReadArgs_get_chain_monitor", ()=>ChannelManagerReadArgs_get_chain_monitor
);
// void ChannelManagerReadArgs_set_chain_monitor(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKWatch val);
/* @internal */ parcelHelpers.export(exports, "ChannelManagerReadArgs_set_chain_monitor", ()=>ChannelManagerReadArgs_set_chain_monitor
);
// const struct LDKBroadcasterInterface *ChannelManagerReadArgs_get_tx_broadcaster(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelManagerReadArgs_get_tx_broadcaster", ()=>ChannelManagerReadArgs_get_tx_broadcaster
);
// void ChannelManagerReadArgs_set_tx_broadcaster(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKBroadcasterInterface val);
/* @internal */ parcelHelpers.export(exports, "ChannelManagerReadArgs_set_tx_broadcaster", ()=>ChannelManagerReadArgs_set_tx_broadcaster
);
// const struct LDKLogger *ChannelManagerReadArgs_get_logger(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelManagerReadArgs_get_logger", ()=>ChannelManagerReadArgs_get_logger
);
// void ChannelManagerReadArgs_set_logger(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKLogger val);
/* @internal */ parcelHelpers.export(exports, "ChannelManagerReadArgs_set_logger", ()=>ChannelManagerReadArgs_set_logger
);
// struct LDKUserConfig ChannelManagerReadArgs_get_default_config(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelManagerReadArgs_get_default_config", ()=>ChannelManagerReadArgs_get_default_config
);
// void ChannelManagerReadArgs_set_default_config(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKUserConfig val);
/* @internal */ parcelHelpers.export(exports, "ChannelManagerReadArgs_set_default_config", ()=>ChannelManagerReadArgs_set_default_config
);
// MUST_USE_RES struct LDKChannelManagerReadArgs ChannelManagerReadArgs_new(struct LDKKeysInterface keys_manager, struct LDKFeeEstimator fee_estimator, struct LDKWatch chain_monitor, struct LDKBroadcasterInterface tx_broadcaster, struct LDKLogger logger, struct LDKUserConfig default_config, struct LDKCVec_ChannelMonitorZ channel_monitors);
/* @internal */ parcelHelpers.export(exports, "ChannelManagerReadArgs_new", ()=>ChannelManagerReadArgs_new
);
// struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ C2Tuple_BlockHashChannelManagerZ_read(struct LDKu8slice ser, struct LDKChannelManagerReadArgs arg);
/* @internal */ parcelHelpers.export(exports, "C2Tuple_BlockHashChannelManagerZ_read", ()=>C2Tuple_BlockHashChannelManagerZ_read
);
// void DecodeError_free(struct LDKDecodeError this_obj);
/* @internal */ parcelHelpers.export(exports, "DecodeError_free", ()=>DecodeError_free
);
// uintptr_t DecodeError_clone_ptr(LDKDecodeError *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "DecodeError_clone_ptr", ()=>DecodeError_clone_ptr
);
// struct LDKDecodeError DecodeError_clone(const struct LDKDecodeError *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "DecodeError_clone", ()=>DecodeError_clone
);
// void Init_free(struct LDKInit this_obj);
/* @internal */ parcelHelpers.export(exports, "Init_free", ()=>Init_free
);
// struct LDKInitFeatures Init_get_features(const struct LDKInit *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "Init_get_features", ()=>Init_get_features
);
// void Init_set_features(struct LDKInit *NONNULL_PTR this_ptr, struct LDKInitFeatures val);
/* @internal */ parcelHelpers.export(exports, "Init_set_features", ()=>Init_set_features
);
// MUST_USE_RES struct LDKInit Init_new(struct LDKInitFeatures features_arg);
/* @internal */ parcelHelpers.export(exports, "Init_new", ()=>Init_new
);
// uintptr_t Init_clone_ptr(LDKInit *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "Init_clone_ptr", ()=>Init_clone_ptr
);
// struct LDKInit Init_clone(const struct LDKInit *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "Init_clone", ()=>Init_clone
);
// void ErrorMessage_free(struct LDKErrorMessage this_obj);
/* @internal */ parcelHelpers.export(exports, "ErrorMessage_free", ()=>ErrorMessage_free
);
// const uint8_t (*ErrorMessage_get_channel_id(const struct LDKErrorMessage *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "ErrorMessage_get_channel_id", ()=>ErrorMessage_get_channel_id
);
// void ErrorMessage_set_channel_id(struct LDKErrorMessage *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "ErrorMessage_set_channel_id", ()=>ErrorMessage_set_channel_id
);
// struct LDKStr ErrorMessage_get_data(const struct LDKErrorMessage *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ErrorMessage_get_data", ()=>ErrorMessage_get_data
);
// void ErrorMessage_set_data(struct LDKErrorMessage *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */ parcelHelpers.export(exports, "ErrorMessage_set_data", ()=>ErrorMessage_set_data
);
// MUST_USE_RES struct LDKErrorMessage ErrorMessage_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKStr data_arg);
/* @internal */ parcelHelpers.export(exports, "ErrorMessage_new", ()=>ErrorMessage_new
);
// uintptr_t ErrorMessage_clone_ptr(LDKErrorMessage *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ErrorMessage_clone_ptr", ()=>ErrorMessage_clone_ptr
);
// struct LDKErrorMessage ErrorMessage_clone(const struct LDKErrorMessage *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ErrorMessage_clone", ()=>ErrorMessage_clone
);
// void Ping_free(struct LDKPing this_obj);
/* @internal */ parcelHelpers.export(exports, "Ping_free", ()=>Ping_free
);
// uint16_t Ping_get_ponglen(const struct LDKPing *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "Ping_get_ponglen", ()=>Ping_get_ponglen
);
// void Ping_set_ponglen(struct LDKPing *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "Ping_set_ponglen", ()=>Ping_set_ponglen
);
// uint16_t Ping_get_byteslen(const struct LDKPing *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "Ping_get_byteslen", ()=>Ping_get_byteslen
);
// void Ping_set_byteslen(struct LDKPing *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "Ping_set_byteslen", ()=>Ping_set_byteslen
);
// MUST_USE_RES struct LDKPing Ping_new(uint16_t ponglen_arg, uint16_t byteslen_arg);
/* @internal */ parcelHelpers.export(exports, "Ping_new", ()=>Ping_new
);
// uintptr_t Ping_clone_ptr(LDKPing *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "Ping_clone_ptr", ()=>Ping_clone_ptr
);
// struct LDKPing Ping_clone(const struct LDKPing *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "Ping_clone", ()=>Ping_clone
);
// void Pong_free(struct LDKPong this_obj);
/* @internal */ parcelHelpers.export(exports, "Pong_free", ()=>Pong_free
);
// uint16_t Pong_get_byteslen(const struct LDKPong *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "Pong_get_byteslen", ()=>Pong_get_byteslen
);
// void Pong_set_byteslen(struct LDKPong *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "Pong_set_byteslen", ()=>Pong_set_byteslen
);
// MUST_USE_RES struct LDKPong Pong_new(uint16_t byteslen_arg);
/* @internal */ parcelHelpers.export(exports, "Pong_new", ()=>Pong_new
);
// uintptr_t Pong_clone_ptr(LDKPong *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "Pong_clone_ptr", ()=>Pong_clone_ptr
);
// struct LDKPong Pong_clone(const struct LDKPong *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "Pong_clone", ()=>Pong_clone
);
// void OpenChannel_free(struct LDKOpenChannel this_obj);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_free", ()=>OpenChannel_free
);
// const uint8_t (*OpenChannel_get_chain_hash(const struct LDKOpenChannel *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_chain_hash", ()=>OpenChannel_get_chain_hash
);
// void OpenChannel_set_chain_hash(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_chain_hash", ()=>OpenChannel_set_chain_hash
);
// const uint8_t (*OpenChannel_get_temporary_channel_id(const struct LDKOpenChannel *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_temporary_channel_id", ()=>OpenChannel_get_temporary_channel_id
);
// void OpenChannel_set_temporary_channel_id(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_temporary_channel_id", ()=>OpenChannel_set_temporary_channel_id
);
// uint64_t OpenChannel_get_funding_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_funding_satoshis", ()=>OpenChannel_get_funding_satoshis
);
// void OpenChannel_set_funding_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_funding_satoshis", ()=>OpenChannel_set_funding_satoshis
);
// uint64_t OpenChannel_get_push_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_push_msat", ()=>OpenChannel_get_push_msat
);
// void OpenChannel_set_push_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_push_msat", ()=>OpenChannel_set_push_msat
);
// uint64_t OpenChannel_get_dust_limit_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_dust_limit_satoshis", ()=>OpenChannel_get_dust_limit_satoshis
);
// void OpenChannel_set_dust_limit_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_dust_limit_satoshis", ()=>OpenChannel_set_dust_limit_satoshis
);
// uint64_t OpenChannel_get_max_htlc_value_in_flight_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_max_htlc_value_in_flight_msat", ()=>OpenChannel_get_max_htlc_value_in_flight_msat
);
// void OpenChannel_set_max_htlc_value_in_flight_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_max_htlc_value_in_flight_msat", ()=>OpenChannel_set_max_htlc_value_in_flight_msat
);
// uint64_t OpenChannel_get_channel_reserve_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_channel_reserve_satoshis", ()=>OpenChannel_get_channel_reserve_satoshis
);
// void OpenChannel_set_channel_reserve_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_channel_reserve_satoshis", ()=>OpenChannel_set_channel_reserve_satoshis
);
// uint64_t OpenChannel_get_htlc_minimum_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_htlc_minimum_msat", ()=>OpenChannel_get_htlc_minimum_msat
);
// void OpenChannel_set_htlc_minimum_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_htlc_minimum_msat", ()=>OpenChannel_set_htlc_minimum_msat
);
// uint32_t OpenChannel_get_feerate_per_kw(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_feerate_per_kw", ()=>OpenChannel_get_feerate_per_kw
);
// void OpenChannel_set_feerate_per_kw(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_feerate_per_kw", ()=>OpenChannel_set_feerate_per_kw
);
// uint16_t OpenChannel_get_to_self_delay(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_to_self_delay", ()=>OpenChannel_get_to_self_delay
);
// void OpenChannel_set_to_self_delay(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_to_self_delay", ()=>OpenChannel_set_to_self_delay
);
// uint16_t OpenChannel_get_max_accepted_htlcs(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_max_accepted_htlcs", ()=>OpenChannel_get_max_accepted_htlcs
);
// void OpenChannel_set_max_accepted_htlcs(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_max_accepted_htlcs", ()=>OpenChannel_set_max_accepted_htlcs
);
// struct LDKPublicKey OpenChannel_get_funding_pubkey(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_funding_pubkey", ()=>OpenChannel_get_funding_pubkey
);
// void OpenChannel_set_funding_pubkey(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_funding_pubkey", ()=>OpenChannel_set_funding_pubkey
);
// struct LDKPublicKey OpenChannel_get_revocation_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_revocation_basepoint", ()=>OpenChannel_get_revocation_basepoint
);
// void OpenChannel_set_revocation_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_revocation_basepoint", ()=>OpenChannel_set_revocation_basepoint
);
// struct LDKPublicKey OpenChannel_get_payment_point(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_payment_point", ()=>OpenChannel_get_payment_point
);
// void OpenChannel_set_payment_point(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_payment_point", ()=>OpenChannel_set_payment_point
);
// struct LDKPublicKey OpenChannel_get_delayed_payment_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_delayed_payment_basepoint", ()=>OpenChannel_get_delayed_payment_basepoint
);
// void OpenChannel_set_delayed_payment_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_delayed_payment_basepoint", ()=>OpenChannel_set_delayed_payment_basepoint
);
// struct LDKPublicKey OpenChannel_get_htlc_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_htlc_basepoint", ()=>OpenChannel_get_htlc_basepoint
);
// void OpenChannel_set_htlc_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_htlc_basepoint", ()=>OpenChannel_set_htlc_basepoint
);
// struct LDKPublicKey OpenChannel_get_first_per_commitment_point(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_first_per_commitment_point", ()=>OpenChannel_get_first_per_commitment_point
);
// void OpenChannel_set_first_per_commitment_point(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_first_per_commitment_point", ()=>OpenChannel_set_first_per_commitment_point
);
// uint8_t OpenChannel_get_channel_flags(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_channel_flags", ()=>OpenChannel_get_channel_flags
);
// void OpenChannel_set_channel_flags(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint8_t val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_channel_flags", ()=>OpenChannel_set_channel_flags
);
// struct LDKChannelTypeFeatures OpenChannel_get_channel_type(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_get_channel_type", ()=>OpenChannel_get_channel_type
);
// void OpenChannel_set_channel_type(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_set_channel_type", ()=>OpenChannel_set_channel_type
);
// uintptr_t OpenChannel_clone_ptr(LDKOpenChannel *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_clone_ptr", ()=>OpenChannel_clone_ptr
);
// struct LDKOpenChannel OpenChannel_clone(const struct LDKOpenChannel *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_clone", ()=>OpenChannel_clone
);
// void AcceptChannel_free(struct LDKAcceptChannel this_obj);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_free", ()=>AcceptChannel_free
);
// const uint8_t (*AcceptChannel_get_temporary_channel_id(const struct LDKAcceptChannel *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_get_temporary_channel_id", ()=>AcceptChannel_get_temporary_channel_id
);
// void AcceptChannel_set_temporary_channel_id(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_set_temporary_channel_id", ()=>AcceptChannel_set_temporary_channel_id
);
// uint64_t AcceptChannel_get_dust_limit_satoshis(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_get_dust_limit_satoshis", ()=>AcceptChannel_get_dust_limit_satoshis
);
// void AcceptChannel_set_dust_limit_satoshis(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_set_dust_limit_satoshis", ()=>AcceptChannel_set_dust_limit_satoshis
);
// uint64_t AcceptChannel_get_max_htlc_value_in_flight_msat(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_get_max_htlc_value_in_flight_msat", ()=>AcceptChannel_get_max_htlc_value_in_flight_msat
);
// void AcceptChannel_set_max_htlc_value_in_flight_msat(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_set_max_htlc_value_in_flight_msat", ()=>AcceptChannel_set_max_htlc_value_in_flight_msat
);
// uint64_t AcceptChannel_get_channel_reserve_satoshis(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_get_channel_reserve_satoshis", ()=>AcceptChannel_get_channel_reserve_satoshis
);
// void AcceptChannel_set_channel_reserve_satoshis(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_set_channel_reserve_satoshis", ()=>AcceptChannel_set_channel_reserve_satoshis
);
// uint64_t AcceptChannel_get_htlc_minimum_msat(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_get_htlc_minimum_msat", ()=>AcceptChannel_get_htlc_minimum_msat
);
// void AcceptChannel_set_htlc_minimum_msat(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_set_htlc_minimum_msat", ()=>AcceptChannel_set_htlc_minimum_msat
);
// uint32_t AcceptChannel_get_minimum_depth(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_get_minimum_depth", ()=>AcceptChannel_get_minimum_depth
);
// void AcceptChannel_set_minimum_depth(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_set_minimum_depth", ()=>AcceptChannel_set_minimum_depth
);
// uint16_t AcceptChannel_get_to_self_delay(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_get_to_self_delay", ()=>AcceptChannel_get_to_self_delay
);
// void AcceptChannel_set_to_self_delay(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_set_to_self_delay", ()=>AcceptChannel_set_to_self_delay
);
// uint16_t AcceptChannel_get_max_accepted_htlcs(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_get_max_accepted_htlcs", ()=>AcceptChannel_get_max_accepted_htlcs
);
// void AcceptChannel_set_max_accepted_htlcs(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_set_max_accepted_htlcs", ()=>AcceptChannel_set_max_accepted_htlcs
);
// struct LDKPublicKey AcceptChannel_get_funding_pubkey(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_get_funding_pubkey", ()=>AcceptChannel_get_funding_pubkey
);
// void AcceptChannel_set_funding_pubkey(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_set_funding_pubkey", ()=>AcceptChannel_set_funding_pubkey
);
// struct LDKPublicKey AcceptChannel_get_revocation_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_get_revocation_basepoint", ()=>AcceptChannel_get_revocation_basepoint
);
// void AcceptChannel_set_revocation_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_set_revocation_basepoint", ()=>AcceptChannel_set_revocation_basepoint
);
// struct LDKPublicKey AcceptChannel_get_payment_point(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_get_payment_point", ()=>AcceptChannel_get_payment_point
);
// void AcceptChannel_set_payment_point(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_set_payment_point", ()=>AcceptChannel_set_payment_point
);
// struct LDKPublicKey AcceptChannel_get_delayed_payment_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_get_delayed_payment_basepoint", ()=>AcceptChannel_get_delayed_payment_basepoint
);
// void AcceptChannel_set_delayed_payment_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_set_delayed_payment_basepoint", ()=>AcceptChannel_set_delayed_payment_basepoint
);
// struct LDKPublicKey AcceptChannel_get_htlc_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_get_htlc_basepoint", ()=>AcceptChannel_get_htlc_basepoint
);
// void AcceptChannel_set_htlc_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_set_htlc_basepoint", ()=>AcceptChannel_set_htlc_basepoint
);
// struct LDKPublicKey AcceptChannel_get_first_per_commitment_point(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_get_first_per_commitment_point", ()=>AcceptChannel_get_first_per_commitment_point
);
// void AcceptChannel_set_first_per_commitment_point(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_set_first_per_commitment_point", ()=>AcceptChannel_set_first_per_commitment_point
);
// uintptr_t AcceptChannel_clone_ptr(LDKAcceptChannel *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_clone_ptr", ()=>AcceptChannel_clone_ptr
);
// struct LDKAcceptChannel AcceptChannel_clone(const struct LDKAcceptChannel *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_clone", ()=>AcceptChannel_clone
);
// void FundingCreated_free(struct LDKFundingCreated this_obj);
/* @internal */ parcelHelpers.export(exports, "FundingCreated_free", ()=>FundingCreated_free
);
// const uint8_t (*FundingCreated_get_temporary_channel_id(const struct LDKFundingCreated *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "FundingCreated_get_temporary_channel_id", ()=>FundingCreated_get_temporary_channel_id
);
// void FundingCreated_set_temporary_channel_id(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "FundingCreated_set_temporary_channel_id", ()=>FundingCreated_set_temporary_channel_id
);
// const uint8_t (*FundingCreated_get_funding_txid(const struct LDKFundingCreated *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "FundingCreated_get_funding_txid", ()=>FundingCreated_get_funding_txid
);
// void FundingCreated_set_funding_txid(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "FundingCreated_set_funding_txid", ()=>FundingCreated_set_funding_txid
);
// uint16_t FundingCreated_get_funding_output_index(const struct LDKFundingCreated *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "FundingCreated_get_funding_output_index", ()=>FundingCreated_get_funding_output_index
);
// void FundingCreated_set_funding_output_index(struct LDKFundingCreated *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "FundingCreated_set_funding_output_index", ()=>FundingCreated_set_funding_output_index
);
// struct LDKSignature FundingCreated_get_signature(const struct LDKFundingCreated *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "FundingCreated_get_signature", ()=>FundingCreated_get_signature
);
// void FundingCreated_set_signature(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */ parcelHelpers.export(exports, "FundingCreated_set_signature", ()=>FundingCreated_set_signature
);
// MUST_USE_RES struct LDKFundingCreated FundingCreated_new(struct LDKThirtyTwoBytes temporary_channel_id_arg, struct LDKThirtyTwoBytes funding_txid_arg, uint16_t funding_output_index_arg, struct LDKSignature signature_arg);
/* @internal */ parcelHelpers.export(exports, "FundingCreated_new", ()=>FundingCreated_new
);
// uintptr_t FundingCreated_clone_ptr(LDKFundingCreated *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "FundingCreated_clone_ptr", ()=>FundingCreated_clone_ptr
);
// struct LDKFundingCreated FundingCreated_clone(const struct LDKFundingCreated *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "FundingCreated_clone", ()=>FundingCreated_clone
);
// void FundingSigned_free(struct LDKFundingSigned this_obj);
/* @internal */ parcelHelpers.export(exports, "FundingSigned_free", ()=>FundingSigned_free
);
// const uint8_t (*FundingSigned_get_channel_id(const struct LDKFundingSigned *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "FundingSigned_get_channel_id", ()=>FundingSigned_get_channel_id
);
// void FundingSigned_set_channel_id(struct LDKFundingSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "FundingSigned_set_channel_id", ()=>FundingSigned_set_channel_id
);
// struct LDKSignature FundingSigned_get_signature(const struct LDKFundingSigned *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "FundingSigned_get_signature", ()=>FundingSigned_get_signature
);
// void FundingSigned_set_signature(struct LDKFundingSigned *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */ parcelHelpers.export(exports, "FundingSigned_set_signature", ()=>FundingSigned_set_signature
);
// MUST_USE_RES struct LDKFundingSigned FundingSigned_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKSignature signature_arg);
/* @internal */ parcelHelpers.export(exports, "FundingSigned_new", ()=>FundingSigned_new
);
// uintptr_t FundingSigned_clone_ptr(LDKFundingSigned *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "FundingSigned_clone_ptr", ()=>FundingSigned_clone_ptr
);
// struct LDKFundingSigned FundingSigned_clone(const struct LDKFundingSigned *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "FundingSigned_clone", ()=>FundingSigned_clone
);
// void FundingLocked_free(struct LDKFundingLocked this_obj);
/* @internal */ parcelHelpers.export(exports, "FundingLocked_free", ()=>FundingLocked_free
);
// const uint8_t (*FundingLocked_get_channel_id(const struct LDKFundingLocked *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "FundingLocked_get_channel_id", ()=>FundingLocked_get_channel_id
);
// void FundingLocked_set_channel_id(struct LDKFundingLocked *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "FundingLocked_set_channel_id", ()=>FundingLocked_set_channel_id
);
// struct LDKPublicKey FundingLocked_get_next_per_commitment_point(const struct LDKFundingLocked *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "FundingLocked_get_next_per_commitment_point", ()=>FundingLocked_get_next_per_commitment_point
);
// void FundingLocked_set_next_per_commitment_point(struct LDKFundingLocked *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "FundingLocked_set_next_per_commitment_point", ()=>FundingLocked_set_next_per_commitment_point
);
// MUST_USE_RES struct LDKFundingLocked FundingLocked_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKPublicKey next_per_commitment_point_arg);
/* @internal */ parcelHelpers.export(exports, "FundingLocked_new", ()=>FundingLocked_new
);
// uintptr_t FundingLocked_clone_ptr(LDKFundingLocked *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "FundingLocked_clone_ptr", ()=>FundingLocked_clone_ptr
);
// struct LDKFundingLocked FundingLocked_clone(const struct LDKFundingLocked *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "FundingLocked_clone", ()=>FundingLocked_clone
);
// void Shutdown_free(struct LDKShutdown this_obj);
/* @internal */ parcelHelpers.export(exports, "Shutdown_free", ()=>Shutdown_free
);
// const uint8_t (*Shutdown_get_channel_id(const struct LDKShutdown *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "Shutdown_get_channel_id", ()=>Shutdown_get_channel_id
);
// void Shutdown_set_channel_id(struct LDKShutdown *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "Shutdown_set_channel_id", ()=>Shutdown_set_channel_id
);
// struct LDKu8slice Shutdown_get_scriptpubkey(const struct LDKShutdown *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "Shutdown_get_scriptpubkey", ()=>Shutdown_get_scriptpubkey
);
// void Shutdown_set_scriptpubkey(struct LDKShutdown *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);
/* @internal */ parcelHelpers.export(exports, "Shutdown_set_scriptpubkey", ()=>Shutdown_set_scriptpubkey
);
// MUST_USE_RES struct LDKShutdown Shutdown_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKCVec_u8Z scriptpubkey_arg);
/* @internal */ parcelHelpers.export(exports, "Shutdown_new", ()=>Shutdown_new
);
// uintptr_t Shutdown_clone_ptr(LDKShutdown *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "Shutdown_clone_ptr", ()=>Shutdown_clone_ptr
);
// struct LDKShutdown Shutdown_clone(const struct LDKShutdown *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "Shutdown_clone", ()=>Shutdown_clone
);
// void ClosingSignedFeeRange_free(struct LDKClosingSignedFeeRange this_obj);
/* @internal */ parcelHelpers.export(exports, "ClosingSignedFeeRange_free", ()=>ClosingSignedFeeRange_free
);
// uint64_t ClosingSignedFeeRange_get_min_fee_satoshis(const struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ClosingSignedFeeRange_get_min_fee_satoshis", ()=>ClosingSignedFeeRange_get_min_fee_satoshis
);
// void ClosingSignedFeeRange_set_min_fee_satoshis(struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ClosingSignedFeeRange_set_min_fee_satoshis", ()=>ClosingSignedFeeRange_set_min_fee_satoshis
);
// uint64_t ClosingSignedFeeRange_get_max_fee_satoshis(const struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ClosingSignedFeeRange_get_max_fee_satoshis", ()=>ClosingSignedFeeRange_get_max_fee_satoshis
);
// void ClosingSignedFeeRange_set_max_fee_satoshis(struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ClosingSignedFeeRange_set_max_fee_satoshis", ()=>ClosingSignedFeeRange_set_max_fee_satoshis
);
// MUST_USE_RES struct LDKClosingSignedFeeRange ClosingSignedFeeRange_new(uint64_t min_fee_satoshis_arg, uint64_t max_fee_satoshis_arg);
/* @internal */ parcelHelpers.export(exports, "ClosingSignedFeeRange_new", ()=>ClosingSignedFeeRange_new
);
// uintptr_t ClosingSignedFeeRange_clone_ptr(LDKClosingSignedFeeRange *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ClosingSignedFeeRange_clone_ptr", ()=>ClosingSignedFeeRange_clone_ptr
);
// struct LDKClosingSignedFeeRange ClosingSignedFeeRange_clone(const struct LDKClosingSignedFeeRange *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ClosingSignedFeeRange_clone", ()=>ClosingSignedFeeRange_clone
);
// void ClosingSigned_free(struct LDKClosingSigned this_obj);
/* @internal */ parcelHelpers.export(exports, "ClosingSigned_free", ()=>ClosingSigned_free
);
// const uint8_t (*ClosingSigned_get_channel_id(const struct LDKClosingSigned *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "ClosingSigned_get_channel_id", ()=>ClosingSigned_get_channel_id
);
// void ClosingSigned_set_channel_id(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "ClosingSigned_set_channel_id", ()=>ClosingSigned_set_channel_id
);
// uint64_t ClosingSigned_get_fee_satoshis(const struct LDKClosingSigned *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ClosingSigned_get_fee_satoshis", ()=>ClosingSigned_get_fee_satoshis
);
// void ClosingSigned_set_fee_satoshis(struct LDKClosingSigned *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ClosingSigned_set_fee_satoshis", ()=>ClosingSigned_set_fee_satoshis
);
// struct LDKSignature ClosingSigned_get_signature(const struct LDKClosingSigned *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ClosingSigned_get_signature", ()=>ClosingSigned_get_signature
);
// void ClosingSigned_set_signature(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */ parcelHelpers.export(exports, "ClosingSigned_set_signature", ()=>ClosingSigned_set_signature
);
// struct LDKClosingSignedFeeRange ClosingSigned_get_fee_range(const struct LDKClosingSigned *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ClosingSigned_get_fee_range", ()=>ClosingSigned_get_fee_range
);
// void ClosingSigned_set_fee_range(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKClosingSignedFeeRange val);
/* @internal */ parcelHelpers.export(exports, "ClosingSigned_set_fee_range", ()=>ClosingSigned_set_fee_range
);
// MUST_USE_RES struct LDKClosingSigned ClosingSigned_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t fee_satoshis_arg, struct LDKSignature signature_arg, struct LDKClosingSignedFeeRange fee_range_arg);
/* @internal */ parcelHelpers.export(exports, "ClosingSigned_new", ()=>ClosingSigned_new
);
// uintptr_t ClosingSigned_clone_ptr(LDKClosingSigned *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ClosingSigned_clone_ptr", ()=>ClosingSigned_clone_ptr
);
// struct LDKClosingSigned ClosingSigned_clone(const struct LDKClosingSigned *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ClosingSigned_clone", ()=>ClosingSigned_clone
);
// void UpdateAddHTLC_free(struct LDKUpdateAddHTLC this_obj);
/* @internal */ parcelHelpers.export(exports, "UpdateAddHTLC_free", ()=>UpdateAddHTLC_free
);
// const uint8_t (*UpdateAddHTLC_get_channel_id(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "UpdateAddHTLC_get_channel_id", ()=>UpdateAddHTLC_get_channel_id
);
// void UpdateAddHTLC_set_channel_id(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "UpdateAddHTLC_set_channel_id", ()=>UpdateAddHTLC_set_channel_id
);
// uint64_t UpdateAddHTLC_get_htlc_id(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UpdateAddHTLC_get_htlc_id", ()=>UpdateAddHTLC_get_htlc_id
);
// void UpdateAddHTLC_set_htlc_id(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "UpdateAddHTLC_set_htlc_id", ()=>UpdateAddHTLC_set_htlc_id
);
// uint64_t UpdateAddHTLC_get_amount_msat(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UpdateAddHTLC_get_amount_msat", ()=>UpdateAddHTLC_get_amount_msat
);
// void UpdateAddHTLC_set_amount_msat(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "UpdateAddHTLC_set_amount_msat", ()=>UpdateAddHTLC_set_amount_msat
);
// const uint8_t (*UpdateAddHTLC_get_payment_hash(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "UpdateAddHTLC_get_payment_hash", ()=>UpdateAddHTLC_get_payment_hash
);
// void UpdateAddHTLC_set_payment_hash(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "UpdateAddHTLC_set_payment_hash", ()=>UpdateAddHTLC_set_payment_hash
);
// uint32_t UpdateAddHTLC_get_cltv_expiry(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UpdateAddHTLC_get_cltv_expiry", ()=>UpdateAddHTLC_get_cltv_expiry
);
// void UpdateAddHTLC_set_cltv_expiry(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "UpdateAddHTLC_set_cltv_expiry", ()=>UpdateAddHTLC_set_cltv_expiry
);
// uintptr_t UpdateAddHTLC_clone_ptr(LDKUpdateAddHTLC *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "UpdateAddHTLC_clone_ptr", ()=>UpdateAddHTLC_clone_ptr
);
// struct LDKUpdateAddHTLC UpdateAddHTLC_clone(const struct LDKUpdateAddHTLC *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "UpdateAddHTLC_clone", ()=>UpdateAddHTLC_clone
);
// void UpdateFulfillHTLC_free(struct LDKUpdateFulfillHTLC this_obj);
/* @internal */ parcelHelpers.export(exports, "UpdateFulfillHTLC_free", ()=>UpdateFulfillHTLC_free
);
// const uint8_t (*UpdateFulfillHTLC_get_channel_id(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "UpdateFulfillHTLC_get_channel_id", ()=>UpdateFulfillHTLC_get_channel_id
);
// void UpdateFulfillHTLC_set_channel_id(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "UpdateFulfillHTLC_set_channel_id", ()=>UpdateFulfillHTLC_set_channel_id
);
// uint64_t UpdateFulfillHTLC_get_htlc_id(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UpdateFulfillHTLC_get_htlc_id", ()=>UpdateFulfillHTLC_get_htlc_id
);
// void UpdateFulfillHTLC_set_htlc_id(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "UpdateFulfillHTLC_set_htlc_id", ()=>UpdateFulfillHTLC_set_htlc_id
);
// const uint8_t (*UpdateFulfillHTLC_get_payment_preimage(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "UpdateFulfillHTLC_get_payment_preimage", ()=>UpdateFulfillHTLC_get_payment_preimage
);
// void UpdateFulfillHTLC_set_payment_preimage(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "UpdateFulfillHTLC_set_payment_preimage", ()=>UpdateFulfillHTLC_set_payment_preimage
);
// MUST_USE_RES struct LDKUpdateFulfillHTLC UpdateFulfillHTLC_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t htlc_id_arg, struct LDKThirtyTwoBytes payment_preimage_arg);
/* @internal */ parcelHelpers.export(exports, "UpdateFulfillHTLC_new", ()=>UpdateFulfillHTLC_new
);
// uintptr_t UpdateFulfillHTLC_clone_ptr(LDKUpdateFulfillHTLC *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "UpdateFulfillHTLC_clone_ptr", ()=>UpdateFulfillHTLC_clone_ptr
);
// struct LDKUpdateFulfillHTLC UpdateFulfillHTLC_clone(const struct LDKUpdateFulfillHTLC *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "UpdateFulfillHTLC_clone", ()=>UpdateFulfillHTLC_clone
);
// void UpdateFailHTLC_free(struct LDKUpdateFailHTLC this_obj);
/* @internal */ parcelHelpers.export(exports, "UpdateFailHTLC_free", ()=>UpdateFailHTLC_free
);
// const uint8_t (*UpdateFailHTLC_get_channel_id(const struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "UpdateFailHTLC_get_channel_id", ()=>UpdateFailHTLC_get_channel_id
);
// void UpdateFailHTLC_set_channel_id(struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "UpdateFailHTLC_set_channel_id", ()=>UpdateFailHTLC_set_channel_id
);
// uint64_t UpdateFailHTLC_get_htlc_id(const struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UpdateFailHTLC_get_htlc_id", ()=>UpdateFailHTLC_get_htlc_id
);
// void UpdateFailHTLC_set_htlc_id(struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "UpdateFailHTLC_set_htlc_id", ()=>UpdateFailHTLC_set_htlc_id
);
// uintptr_t UpdateFailHTLC_clone_ptr(LDKUpdateFailHTLC *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "UpdateFailHTLC_clone_ptr", ()=>UpdateFailHTLC_clone_ptr
);
// struct LDKUpdateFailHTLC UpdateFailHTLC_clone(const struct LDKUpdateFailHTLC *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "UpdateFailHTLC_clone", ()=>UpdateFailHTLC_clone
);
// void UpdateFailMalformedHTLC_free(struct LDKUpdateFailMalformedHTLC this_obj);
/* @internal */ parcelHelpers.export(exports, "UpdateFailMalformedHTLC_free", ()=>UpdateFailMalformedHTLC_free
);
// const uint8_t (*UpdateFailMalformedHTLC_get_channel_id(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "UpdateFailMalformedHTLC_get_channel_id", ()=>UpdateFailMalformedHTLC_get_channel_id
);
// void UpdateFailMalformedHTLC_set_channel_id(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "UpdateFailMalformedHTLC_set_channel_id", ()=>UpdateFailMalformedHTLC_set_channel_id
);
// uint64_t UpdateFailMalformedHTLC_get_htlc_id(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UpdateFailMalformedHTLC_get_htlc_id", ()=>UpdateFailMalformedHTLC_get_htlc_id
);
// void UpdateFailMalformedHTLC_set_htlc_id(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "UpdateFailMalformedHTLC_set_htlc_id", ()=>UpdateFailMalformedHTLC_set_htlc_id
);
// uint16_t UpdateFailMalformedHTLC_get_failure_code(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UpdateFailMalformedHTLC_get_failure_code", ()=>UpdateFailMalformedHTLC_get_failure_code
);
// void UpdateFailMalformedHTLC_set_failure_code(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "UpdateFailMalformedHTLC_set_failure_code", ()=>UpdateFailMalformedHTLC_set_failure_code
);
// uintptr_t UpdateFailMalformedHTLC_clone_ptr(LDKUpdateFailMalformedHTLC *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "UpdateFailMalformedHTLC_clone_ptr", ()=>UpdateFailMalformedHTLC_clone_ptr
);
// struct LDKUpdateFailMalformedHTLC UpdateFailMalformedHTLC_clone(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "UpdateFailMalformedHTLC_clone", ()=>UpdateFailMalformedHTLC_clone
);
// void CommitmentSigned_free(struct LDKCommitmentSigned this_obj);
/* @internal */ parcelHelpers.export(exports, "CommitmentSigned_free", ()=>CommitmentSigned_free
);
// const uint8_t (*CommitmentSigned_get_channel_id(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "CommitmentSigned_get_channel_id", ()=>CommitmentSigned_get_channel_id
);
// void CommitmentSigned_set_channel_id(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "CommitmentSigned_set_channel_id", ()=>CommitmentSigned_set_channel_id
);
// struct LDKSignature CommitmentSigned_get_signature(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "CommitmentSigned_get_signature", ()=>CommitmentSigned_get_signature
);
// void CommitmentSigned_set_signature(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */ parcelHelpers.export(exports, "CommitmentSigned_set_signature", ()=>CommitmentSigned_set_signature
);
// void CommitmentSigned_set_htlc_signatures(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKCVec_SignatureZ val);
/* @internal */ parcelHelpers.export(exports, "CommitmentSigned_set_htlc_signatures", ()=>CommitmentSigned_set_htlc_signatures
);
// MUST_USE_RES struct LDKCommitmentSigned CommitmentSigned_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKSignature signature_arg, struct LDKCVec_SignatureZ htlc_signatures_arg);
/* @internal */ parcelHelpers.export(exports, "CommitmentSigned_new", ()=>CommitmentSigned_new
);
// uintptr_t CommitmentSigned_clone_ptr(LDKCommitmentSigned *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CommitmentSigned_clone_ptr", ()=>CommitmentSigned_clone_ptr
);
// struct LDKCommitmentSigned CommitmentSigned_clone(const struct LDKCommitmentSigned *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CommitmentSigned_clone", ()=>CommitmentSigned_clone
);
// void RevokeAndACK_free(struct LDKRevokeAndACK this_obj);
/* @internal */ parcelHelpers.export(exports, "RevokeAndACK_free", ()=>RevokeAndACK_free
);
// const uint8_t (*RevokeAndACK_get_channel_id(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "RevokeAndACK_get_channel_id", ()=>RevokeAndACK_get_channel_id
);
// void RevokeAndACK_set_channel_id(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "RevokeAndACK_set_channel_id", ()=>RevokeAndACK_set_channel_id
);
// const uint8_t (*RevokeAndACK_get_per_commitment_secret(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "RevokeAndACK_get_per_commitment_secret", ()=>RevokeAndACK_get_per_commitment_secret
);
// void RevokeAndACK_set_per_commitment_secret(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "RevokeAndACK_set_per_commitment_secret", ()=>RevokeAndACK_set_per_commitment_secret
);
// struct LDKPublicKey RevokeAndACK_get_next_per_commitment_point(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RevokeAndACK_get_next_per_commitment_point", ()=>RevokeAndACK_get_next_per_commitment_point
);
// void RevokeAndACK_set_next_per_commitment_point(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "RevokeAndACK_set_next_per_commitment_point", ()=>RevokeAndACK_set_next_per_commitment_point
);
// MUST_USE_RES struct LDKRevokeAndACK RevokeAndACK_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKThirtyTwoBytes per_commitment_secret_arg, struct LDKPublicKey next_per_commitment_point_arg);
/* @internal */ parcelHelpers.export(exports, "RevokeAndACK_new", ()=>RevokeAndACK_new
);
// uintptr_t RevokeAndACK_clone_ptr(LDKRevokeAndACK *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "RevokeAndACK_clone_ptr", ()=>RevokeAndACK_clone_ptr
);
// struct LDKRevokeAndACK RevokeAndACK_clone(const struct LDKRevokeAndACK *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "RevokeAndACK_clone", ()=>RevokeAndACK_clone
);
// void UpdateFee_free(struct LDKUpdateFee this_obj);
/* @internal */ parcelHelpers.export(exports, "UpdateFee_free", ()=>UpdateFee_free
);
// const uint8_t (*UpdateFee_get_channel_id(const struct LDKUpdateFee *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "UpdateFee_get_channel_id", ()=>UpdateFee_get_channel_id
);
// void UpdateFee_set_channel_id(struct LDKUpdateFee *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "UpdateFee_set_channel_id", ()=>UpdateFee_set_channel_id
);
// uint32_t UpdateFee_get_feerate_per_kw(const struct LDKUpdateFee *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UpdateFee_get_feerate_per_kw", ()=>UpdateFee_get_feerate_per_kw
);
// void UpdateFee_set_feerate_per_kw(struct LDKUpdateFee *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "UpdateFee_set_feerate_per_kw", ()=>UpdateFee_set_feerate_per_kw
);
// MUST_USE_RES struct LDKUpdateFee UpdateFee_new(struct LDKThirtyTwoBytes channel_id_arg, uint32_t feerate_per_kw_arg);
/* @internal */ parcelHelpers.export(exports, "UpdateFee_new", ()=>UpdateFee_new
);
// uintptr_t UpdateFee_clone_ptr(LDKUpdateFee *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "UpdateFee_clone_ptr", ()=>UpdateFee_clone_ptr
);
// struct LDKUpdateFee UpdateFee_clone(const struct LDKUpdateFee *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "UpdateFee_clone", ()=>UpdateFee_clone
);
// void DataLossProtect_free(struct LDKDataLossProtect this_obj);
/* @internal */ parcelHelpers.export(exports, "DataLossProtect_free", ()=>DataLossProtect_free
);
// const uint8_t (*DataLossProtect_get_your_last_per_commitment_secret(const struct LDKDataLossProtect *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "DataLossProtect_get_your_last_per_commitment_secret", ()=>DataLossProtect_get_your_last_per_commitment_secret
);
// void DataLossProtect_set_your_last_per_commitment_secret(struct LDKDataLossProtect *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "DataLossProtect_set_your_last_per_commitment_secret", ()=>DataLossProtect_set_your_last_per_commitment_secret
);
// struct LDKPublicKey DataLossProtect_get_my_current_per_commitment_point(const struct LDKDataLossProtect *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "DataLossProtect_get_my_current_per_commitment_point", ()=>DataLossProtect_get_my_current_per_commitment_point
);
// void DataLossProtect_set_my_current_per_commitment_point(struct LDKDataLossProtect *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "DataLossProtect_set_my_current_per_commitment_point", ()=>DataLossProtect_set_my_current_per_commitment_point
);
// MUST_USE_RES struct LDKDataLossProtect DataLossProtect_new(struct LDKThirtyTwoBytes your_last_per_commitment_secret_arg, struct LDKPublicKey my_current_per_commitment_point_arg);
/* @internal */ parcelHelpers.export(exports, "DataLossProtect_new", ()=>DataLossProtect_new
);
// uintptr_t DataLossProtect_clone_ptr(LDKDataLossProtect *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "DataLossProtect_clone_ptr", ()=>DataLossProtect_clone_ptr
);
// struct LDKDataLossProtect DataLossProtect_clone(const struct LDKDataLossProtect *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "DataLossProtect_clone", ()=>DataLossProtect_clone
);
// void ChannelReestablish_free(struct LDKChannelReestablish this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelReestablish_free", ()=>ChannelReestablish_free
);
// const uint8_t (*ChannelReestablish_get_channel_id(const struct LDKChannelReestablish *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "ChannelReestablish_get_channel_id", ()=>ChannelReestablish_get_channel_id
);
// void ChannelReestablish_set_channel_id(struct LDKChannelReestablish *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "ChannelReestablish_set_channel_id", ()=>ChannelReestablish_set_channel_id
);
// uint64_t ChannelReestablish_get_next_local_commitment_number(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelReestablish_get_next_local_commitment_number", ()=>ChannelReestablish_get_next_local_commitment_number
);
// void ChannelReestablish_set_next_local_commitment_number(struct LDKChannelReestablish *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelReestablish_set_next_local_commitment_number", ()=>ChannelReestablish_set_next_local_commitment_number
);
// uint64_t ChannelReestablish_get_next_remote_commitment_number(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelReestablish_get_next_remote_commitment_number", ()=>ChannelReestablish_get_next_remote_commitment_number
);
// void ChannelReestablish_set_next_remote_commitment_number(struct LDKChannelReestablish *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelReestablish_set_next_remote_commitment_number", ()=>ChannelReestablish_set_next_remote_commitment_number
);
// uintptr_t ChannelReestablish_clone_ptr(LDKChannelReestablish *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ChannelReestablish_clone_ptr", ()=>ChannelReestablish_clone_ptr
);
// struct LDKChannelReestablish ChannelReestablish_clone(const struct LDKChannelReestablish *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChannelReestablish_clone", ()=>ChannelReestablish_clone
);
// void AnnouncementSignatures_free(struct LDKAnnouncementSignatures this_obj);
/* @internal */ parcelHelpers.export(exports, "AnnouncementSignatures_free", ()=>AnnouncementSignatures_free
);
// const uint8_t (*AnnouncementSignatures_get_channel_id(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "AnnouncementSignatures_get_channel_id", ()=>AnnouncementSignatures_get_channel_id
);
// void AnnouncementSignatures_set_channel_id(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "AnnouncementSignatures_set_channel_id", ()=>AnnouncementSignatures_set_channel_id
);
// uint64_t AnnouncementSignatures_get_short_channel_id(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "AnnouncementSignatures_get_short_channel_id", ()=>AnnouncementSignatures_get_short_channel_id
);
// void AnnouncementSignatures_set_short_channel_id(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "AnnouncementSignatures_set_short_channel_id", ()=>AnnouncementSignatures_set_short_channel_id
);
// struct LDKSignature AnnouncementSignatures_get_node_signature(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "AnnouncementSignatures_get_node_signature", ()=>AnnouncementSignatures_get_node_signature
);
// void AnnouncementSignatures_set_node_signature(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */ parcelHelpers.export(exports, "AnnouncementSignatures_set_node_signature", ()=>AnnouncementSignatures_set_node_signature
);
// struct LDKSignature AnnouncementSignatures_get_bitcoin_signature(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "AnnouncementSignatures_get_bitcoin_signature", ()=>AnnouncementSignatures_get_bitcoin_signature
);
// void AnnouncementSignatures_set_bitcoin_signature(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */ parcelHelpers.export(exports, "AnnouncementSignatures_set_bitcoin_signature", ()=>AnnouncementSignatures_set_bitcoin_signature
);
// MUST_USE_RES struct LDKAnnouncementSignatures AnnouncementSignatures_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t short_channel_id_arg, struct LDKSignature node_signature_arg, struct LDKSignature bitcoin_signature_arg);
/* @internal */ parcelHelpers.export(exports, "AnnouncementSignatures_new", ()=>AnnouncementSignatures_new
);
// uintptr_t AnnouncementSignatures_clone_ptr(LDKAnnouncementSignatures *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "AnnouncementSignatures_clone_ptr", ()=>AnnouncementSignatures_clone_ptr
);
// struct LDKAnnouncementSignatures AnnouncementSignatures_clone(const struct LDKAnnouncementSignatures *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "AnnouncementSignatures_clone", ()=>AnnouncementSignatures_clone
);
// void NetAddress_free(struct LDKNetAddress this_ptr);
/* @internal */ parcelHelpers.export(exports, "NetAddress_free", ()=>NetAddress_free
);
// uintptr_t NetAddress_clone_ptr(LDKNetAddress *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "NetAddress_clone_ptr", ()=>NetAddress_clone_ptr
);
// struct LDKNetAddress NetAddress_clone(const struct LDKNetAddress *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "NetAddress_clone", ()=>NetAddress_clone
);
// struct LDKNetAddress NetAddress_ipv4(struct LDKFourBytes addr, uint16_t port);
/* @internal */ parcelHelpers.export(exports, "NetAddress_ipv4", ()=>NetAddress_ipv4
);
// struct LDKNetAddress NetAddress_ipv6(struct LDKSixteenBytes addr, uint16_t port);
/* @internal */ parcelHelpers.export(exports, "NetAddress_ipv6", ()=>NetAddress_ipv6
);
// struct LDKNetAddress NetAddress_onion_v2(struct LDKTwelveBytes a);
/* @internal */ parcelHelpers.export(exports, "NetAddress_onion_v2", ()=>NetAddress_onion_v2
);
// struct LDKNetAddress NetAddress_onion_v3(struct LDKThirtyTwoBytes ed25519_pubkey, uint16_t checksum, uint8_t version, uint16_t port);
/* @internal */ parcelHelpers.export(exports, "NetAddress_onion_v3", ()=>NetAddress_onion_v3
);
// struct LDKCVec_u8Z NetAddress_write(const struct LDKNetAddress *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "NetAddress_write", ()=>NetAddress_write
);
// struct LDKCResult_NetAddressDecodeErrorZ NetAddress_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "NetAddress_read", ()=>NetAddress_read
);
// void UnsignedNodeAnnouncement_free(struct LDKUnsignedNodeAnnouncement this_obj);
/* @internal */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement_free", ()=>UnsignedNodeAnnouncement_free
);
// struct LDKNodeFeatures UnsignedNodeAnnouncement_get_features(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement_get_features", ()=>UnsignedNodeAnnouncement_get_features
);
// void UnsignedNodeAnnouncement_set_features(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);
/* @internal */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement_set_features", ()=>UnsignedNodeAnnouncement_set_features
);
// uint32_t UnsignedNodeAnnouncement_get_timestamp(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement_get_timestamp", ()=>UnsignedNodeAnnouncement_get_timestamp
);
// void UnsignedNodeAnnouncement_set_timestamp(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement_set_timestamp", ()=>UnsignedNodeAnnouncement_set_timestamp
);
// struct LDKPublicKey UnsignedNodeAnnouncement_get_node_id(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement_get_node_id", ()=>UnsignedNodeAnnouncement_get_node_id
);
// void UnsignedNodeAnnouncement_set_node_id(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement_set_node_id", ()=>UnsignedNodeAnnouncement_set_node_id
);
// const uint8_t (*UnsignedNodeAnnouncement_get_rgb(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr))[3];
/* @internal */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement_get_rgb", ()=>UnsignedNodeAnnouncement_get_rgb
);
// void UnsignedNodeAnnouncement_set_rgb(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKThreeBytes val);
/* @internal */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement_set_rgb", ()=>UnsignedNodeAnnouncement_set_rgb
);
// const uint8_t (*UnsignedNodeAnnouncement_get_alias(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement_get_alias", ()=>UnsignedNodeAnnouncement_get_alias
);
// void UnsignedNodeAnnouncement_set_alias(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement_set_alias", ()=>UnsignedNodeAnnouncement_set_alias
);
// void UnsignedNodeAnnouncement_set_addresses(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKCVec_NetAddressZ val);
/* @internal */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement_set_addresses", ()=>UnsignedNodeAnnouncement_set_addresses
);
// uintptr_t UnsignedNodeAnnouncement_clone_ptr(LDKUnsignedNodeAnnouncement *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement_clone_ptr", ()=>UnsignedNodeAnnouncement_clone_ptr
);
// struct LDKUnsignedNodeAnnouncement UnsignedNodeAnnouncement_clone(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement_clone", ()=>UnsignedNodeAnnouncement_clone
);
// void NodeAnnouncement_free(struct LDKNodeAnnouncement this_obj);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncement_free", ()=>NodeAnnouncement_free
);
// struct LDKSignature NodeAnnouncement_get_signature(const struct LDKNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncement_get_signature", ()=>NodeAnnouncement_get_signature
);
// void NodeAnnouncement_set_signature(struct LDKNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncement_set_signature", ()=>NodeAnnouncement_set_signature
);
// struct LDKUnsignedNodeAnnouncement NodeAnnouncement_get_contents(const struct LDKNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncement_get_contents", ()=>NodeAnnouncement_get_contents
);
// void NodeAnnouncement_set_contents(struct LDKNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKUnsignedNodeAnnouncement val);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncement_set_contents", ()=>NodeAnnouncement_set_contents
);
// MUST_USE_RES struct LDKNodeAnnouncement NodeAnnouncement_new(struct LDKSignature signature_arg, struct LDKUnsignedNodeAnnouncement contents_arg);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncement_new", ()=>NodeAnnouncement_new
);
// uintptr_t NodeAnnouncement_clone_ptr(LDKNodeAnnouncement *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncement_clone_ptr", ()=>NodeAnnouncement_clone_ptr
);
// struct LDKNodeAnnouncement NodeAnnouncement_clone(const struct LDKNodeAnnouncement *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncement_clone", ()=>NodeAnnouncement_clone
);
// void UnsignedChannelAnnouncement_free(struct LDKUnsignedChannelAnnouncement this_obj);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_free", ()=>UnsignedChannelAnnouncement_free
);
// struct LDKChannelFeatures UnsignedChannelAnnouncement_get_features(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_get_features", ()=>UnsignedChannelAnnouncement_get_features
);
// void UnsignedChannelAnnouncement_set_features(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_set_features", ()=>UnsignedChannelAnnouncement_set_features
);
// const uint8_t (*UnsignedChannelAnnouncement_get_chain_hash(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_get_chain_hash", ()=>UnsignedChannelAnnouncement_get_chain_hash
);
// void UnsignedChannelAnnouncement_set_chain_hash(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_set_chain_hash", ()=>UnsignedChannelAnnouncement_set_chain_hash
);
// uint64_t UnsignedChannelAnnouncement_get_short_channel_id(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_get_short_channel_id", ()=>UnsignedChannelAnnouncement_get_short_channel_id
);
// void UnsignedChannelAnnouncement_set_short_channel_id(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_set_short_channel_id", ()=>UnsignedChannelAnnouncement_set_short_channel_id
);
// struct LDKPublicKey UnsignedChannelAnnouncement_get_node_id_1(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_get_node_id_1", ()=>UnsignedChannelAnnouncement_get_node_id_1
);
// void UnsignedChannelAnnouncement_set_node_id_1(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_set_node_id_1", ()=>UnsignedChannelAnnouncement_set_node_id_1
);
// struct LDKPublicKey UnsignedChannelAnnouncement_get_node_id_2(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_get_node_id_2", ()=>UnsignedChannelAnnouncement_get_node_id_2
);
// void UnsignedChannelAnnouncement_set_node_id_2(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_set_node_id_2", ()=>UnsignedChannelAnnouncement_set_node_id_2
);
// struct LDKPublicKey UnsignedChannelAnnouncement_get_bitcoin_key_1(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_get_bitcoin_key_1", ()=>UnsignedChannelAnnouncement_get_bitcoin_key_1
);
// void UnsignedChannelAnnouncement_set_bitcoin_key_1(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_set_bitcoin_key_1", ()=>UnsignedChannelAnnouncement_set_bitcoin_key_1
);
// struct LDKPublicKey UnsignedChannelAnnouncement_get_bitcoin_key_2(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_get_bitcoin_key_2", ()=>UnsignedChannelAnnouncement_get_bitcoin_key_2
);
// void UnsignedChannelAnnouncement_set_bitcoin_key_2(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_set_bitcoin_key_2", ()=>UnsignedChannelAnnouncement_set_bitcoin_key_2
);
// uintptr_t UnsignedChannelAnnouncement_clone_ptr(LDKUnsignedChannelAnnouncement *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_clone_ptr", ()=>UnsignedChannelAnnouncement_clone_ptr
);
// struct LDKUnsignedChannelAnnouncement UnsignedChannelAnnouncement_clone(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_clone", ()=>UnsignedChannelAnnouncement_clone
);
// void ChannelAnnouncement_free(struct LDKChannelAnnouncement this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelAnnouncement_free", ()=>ChannelAnnouncement_free
);
// struct LDKSignature ChannelAnnouncement_get_node_signature_1(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelAnnouncement_get_node_signature_1", ()=>ChannelAnnouncement_get_node_signature_1
);
// void ChannelAnnouncement_set_node_signature_1(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */ parcelHelpers.export(exports, "ChannelAnnouncement_set_node_signature_1", ()=>ChannelAnnouncement_set_node_signature_1
);
// struct LDKSignature ChannelAnnouncement_get_node_signature_2(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelAnnouncement_get_node_signature_2", ()=>ChannelAnnouncement_get_node_signature_2
);
// void ChannelAnnouncement_set_node_signature_2(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */ parcelHelpers.export(exports, "ChannelAnnouncement_set_node_signature_2", ()=>ChannelAnnouncement_set_node_signature_2
);
// struct LDKSignature ChannelAnnouncement_get_bitcoin_signature_1(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelAnnouncement_get_bitcoin_signature_1", ()=>ChannelAnnouncement_get_bitcoin_signature_1
);
// void ChannelAnnouncement_set_bitcoin_signature_1(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */ parcelHelpers.export(exports, "ChannelAnnouncement_set_bitcoin_signature_1", ()=>ChannelAnnouncement_set_bitcoin_signature_1
);
// struct LDKSignature ChannelAnnouncement_get_bitcoin_signature_2(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelAnnouncement_get_bitcoin_signature_2", ()=>ChannelAnnouncement_get_bitcoin_signature_2
);
// void ChannelAnnouncement_set_bitcoin_signature_2(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */ parcelHelpers.export(exports, "ChannelAnnouncement_set_bitcoin_signature_2", ()=>ChannelAnnouncement_set_bitcoin_signature_2
);
// struct LDKUnsignedChannelAnnouncement ChannelAnnouncement_get_contents(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelAnnouncement_get_contents", ()=>ChannelAnnouncement_get_contents
);
// void ChannelAnnouncement_set_contents(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKUnsignedChannelAnnouncement val);
/* @internal */ parcelHelpers.export(exports, "ChannelAnnouncement_set_contents", ()=>ChannelAnnouncement_set_contents
);
// MUST_USE_RES struct LDKChannelAnnouncement ChannelAnnouncement_new(struct LDKSignature node_signature_1_arg, struct LDKSignature node_signature_2_arg, struct LDKSignature bitcoin_signature_1_arg, struct LDKSignature bitcoin_signature_2_arg, struct LDKUnsignedChannelAnnouncement contents_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelAnnouncement_new", ()=>ChannelAnnouncement_new
);
// uintptr_t ChannelAnnouncement_clone_ptr(LDKChannelAnnouncement *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ChannelAnnouncement_clone_ptr", ()=>ChannelAnnouncement_clone_ptr
);
// struct LDKChannelAnnouncement ChannelAnnouncement_clone(const struct LDKChannelAnnouncement *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChannelAnnouncement_clone", ()=>ChannelAnnouncement_clone
);
// void UnsignedChannelUpdate_free(struct LDKUnsignedChannelUpdate this_obj);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_free", ()=>UnsignedChannelUpdate_free
);
// const uint8_t (*UnsignedChannelUpdate_get_chain_hash(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_get_chain_hash", ()=>UnsignedChannelUpdate_get_chain_hash
);
// void UnsignedChannelUpdate_set_chain_hash(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_set_chain_hash", ()=>UnsignedChannelUpdate_set_chain_hash
);
// uint64_t UnsignedChannelUpdate_get_short_channel_id(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_get_short_channel_id", ()=>UnsignedChannelUpdate_get_short_channel_id
);
// void UnsignedChannelUpdate_set_short_channel_id(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_set_short_channel_id", ()=>UnsignedChannelUpdate_set_short_channel_id
);
// uint32_t UnsignedChannelUpdate_get_timestamp(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_get_timestamp", ()=>UnsignedChannelUpdate_get_timestamp
);
// void UnsignedChannelUpdate_set_timestamp(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_set_timestamp", ()=>UnsignedChannelUpdate_set_timestamp
);
// uint8_t UnsignedChannelUpdate_get_flags(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_get_flags", ()=>UnsignedChannelUpdate_get_flags
);
// void UnsignedChannelUpdate_set_flags(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint8_t val);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_set_flags", ()=>UnsignedChannelUpdate_set_flags
);
// uint16_t UnsignedChannelUpdate_get_cltv_expiry_delta(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_get_cltv_expiry_delta", ()=>UnsignedChannelUpdate_get_cltv_expiry_delta
);
// void UnsignedChannelUpdate_set_cltv_expiry_delta(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_set_cltv_expiry_delta", ()=>UnsignedChannelUpdate_set_cltv_expiry_delta
);
// uint64_t UnsignedChannelUpdate_get_htlc_minimum_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_get_htlc_minimum_msat", ()=>UnsignedChannelUpdate_get_htlc_minimum_msat
);
// void UnsignedChannelUpdate_set_htlc_minimum_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_set_htlc_minimum_msat", ()=>UnsignedChannelUpdate_set_htlc_minimum_msat
);
// uint32_t UnsignedChannelUpdate_get_fee_base_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_get_fee_base_msat", ()=>UnsignedChannelUpdate_get_fee_base_msat
);
// void UnsignedChannelUpdate_set_fee_base_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_set_fee_base_msat", ()=>UnsignedChannelUpdate_set_fee_base_msat
);
// uint32_t UnsignedChannelUpdate_get_fee_proportional_millionths(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_get_fee_proportional_millionths", ()=>UnsignedChannelUpdate_get_fee_proportional_millionths
);
// void UnsignedChannelUpdate_set_fee_proportional_millionths(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_set_fee_proportional_millionths", ()=>UnsignedChannelUpdate_set_fee_proportional_millionths
);
// uintptr_t UnsignedChannelUpdate_clone_ptr(LDKUnsignedChannelUpdate *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_clone_ptr", ()=>UnsignedChannelUpdate_clone_ptr
);
// struct LDKUnsignedChannelUpdate UnsignedChannelUpdate_clone(const struct LDKUnsignedChannelUpdate *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_clone", ()=>UnsignedChannelUpdate_clone
);
// void ChannelUpdate_free(struct LDKChannelUpdate this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelUpdate_free", ()=>ChannelUpdate_free
);
// struct LDKSignature ChannelUpdate_get_signature(const struct LDKChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelUpdate_get_signature", ()=>ChannelUpdate_get_signature
);
// void ChannelUpdate_set_signature(struct LDKChannelUpdate *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */ parcelHelpers.export(exports, "ChannelUpdate_set_signature", ()=>ChannelUpdate_set_signature
);
// struct LDKUnsignedChannelUpdate ChannelUpdate_get_contents(const struct LDKChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelUpdate_get_contents", ()=>ChannelUpdate_get_contents
);
// void ChannelUpdate_set_contents(struct LDKChannelUpdate *NONNULL_PTR this_ptr, struct LDKUnsignedChannelUpdate val);
/* @internal */ parcelHelpers.export(exports, "ChannelUpdate_set_contents", ()=>ChannelUpdate_set_contents
);
// MUST_USE_RES struct LDKChannelUpdate ChannelUpdate_new(struct LDKSignature signature_arg, struct LDKUnsignedChannelUpdate contents_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelUpdate_new", ()=>ChannelUpdate_new
);
// uintptr_t ChannelUpdate_clone_ptr(LDKChannelUpdate *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ChannelUpdate_clone_ptr", ()=>ChannelUpdate_clone_ptr
);
// struct LDKChannelUpdate ChannelUpdate_clone(const struct LDKChannelUpdate *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChannelUpdate_clone", ()=>ChannelUpdate_clone
);
// void QueryChannelRange_free(struct LDKQueryChannelRange this_obj);
/* @internal */ parcelHelpers.export(exports, "QueryChannelRange_free", ()=>QueryChannelRange_free
);
// const uint8_t (*QueryChannelRange_get_chain_hash(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "QueryChannelRange_get_chain_hash", ()=>QueryChannelRange_get_chain_hash
);
// void QueryChannelRange_set_chain_hash(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "QueryChannelRange_set_chain_hash", ()=>QueryChannelRange_set_chain_hash
);
// uint32_t QueryChannelRange_get_first_blocknum(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "QueryChannelRange_get_first_blocknum", ()=>QueryChannelRange_get_first_blocknum
);
// void QueryChannelRange_set_first_blocknum(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "QueryChannelRange_set_first_blocknum", ()=>QueryChannelRange_set_first_blocknum
);
// uint32_t QueryChannelRange_get_number_of_blocks(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "QueryChannelRange_get_number_of_blocks", ()=>QueryChannelRange_get_number_of_blocks
);
// void QueryChannelRange_set_number_of_blocks(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "QueryChannelRange_set_number_of_blocks", ()=>QueryChannelRange_set_number_of_blocks
);
// MUST_USE_RES struct LDKQueryChannelRange QueryChannelRange_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_blocknum_arg, uint32_t number_of_blocks_arg);
/* @internal */ parcelHelpers.export(exports, "QueryChannelRange_new", ()=>QueryChannelRange_new
);
// uintptr_t QueryChannelRange_clone_ptr(LDKQueryChannelRange *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "QueryChannelRange_clone_ptr", ()=>QueryChannelRange_clone_ptr
);
// struct LDKQueryChannelRange QueryChannelRange_clone(const struct LDKQueryChannelRange *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "QueryChannelRange_clone", ()=>QueryChannelRange_clone
);
// void ReplyChannelRange_free(struct LDKReplyChannelRange this_obj);
/* @internal */ parcelHelpers.export(exports, "ReplyChannelRange_free", ()=>ReplyChannelRange_free
);
// const uint8_t (*ReplyChannelRange_get_chain_hash(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "ReplyChannelRange_get_chain_hash", ()=>ReplyChannelRange_get_chain_hash
);
// void ReplyChannelRange_set_chain_hash(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "ReplyChannelRange_set_chain_hash", ()=>ReplyChannelRange_set_chain_hash
);
// uint32_t ReplyChannelRange_get_first_blocknum(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ReplyChannelRange_get_first_blocknum", ()=>ReplyChannelRange_get_first_blocknum
);
// void ReplyChannelRange_set_first_blocknum(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "ReplyChannelRange_set_first_blocknum", ()=>ReplyChannelRange_set_first_blocknum
);
// uint32_t ReplyChannelRange_get_number_of_blocks(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ReplyChannelRange_get_number_of_blocks", ()=>ReplyChannelRange_get_number_of_blocks
);
// void ReplyChannelRange_set_number_of_blocks(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "ReplyChannelRange_set_number_of_blocks", ()=>ReplyChannelRange_set_number_of_blocks
);
// bool ReplyChannelRange_get_sync_complete(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ReplyChannelRange_get_sync_complete", ()=>ReplyChannelRange_get_sync_complete
);
// void ReplyChannelRange_set_sync_complete(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, bool val);
/* @internal */ parcelHelpers.export(exports, "ReplyChannelRange_set_sync_complete", ()=>ReplyChannelRange_set_sync_complete
);
// void ReplyChannelRange_set_short_channel_ids(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);
/* @internal */ parcelHelpers.export(exports, "ReplyChannelRange_set_short_channel_ids", ()=>ReplyChannelRange_set_short_channel_ids
);
// MUST_USE_RES struct LDKReplyChannelRange ReplyChannelRange_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_blocknum_arg, uint32_t number_of_blocks_arg, bool sync_complete_arg, struct LDKCVec_u64Z short_channel_ids_arg);
/* @internal */ parcelHelpers.export(exports, "ReplyChannelRange_new", ()=>ReplyChannelRange_new
);
// uintptr_t ReplyChannelRange_clone_ptr(LDKReplyChannelRange *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ReplyChannelRange_clone_ptr", ()=>ReplyChannelRange_clone_ptr
);
// struct LDKReplyChannelRange ReplyChannelRange_clone(const struct LDKReplyChannelRange *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ReplyChannelRange_clone", ()=>ReplyChannelRange_clone
);
// void QueryShortChannelIds_free(struct LDKQueryShortChannelIds this_obj);
/* @internal */ parcelHelpers.export(exports, "QueryShortChannelIds_free", ()=>QueryShortChannelIds_free
);
// const uint8_t (*QueryShortChannelIds_get_chain_hash(const struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "QueryShortChannelIds_get_chain_hash", ()=>QueryShortChannelIds_get_chain_hash
);
// void QueryShortChannelIds_set_chain_hash(struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "QueryShortChannelIds_set_chain_hash", ()=>QueryShortChannelIds_set_chain_hash
);
// void QueryShortChannelIds_set_short_channel_ids(struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);
/* @internal */ parcelHelpers.export(exports, "QueryShortChannelIds_set_short_channel_ids", ()=>QueryShortChannelIds_set_short_channel_ids
);
// MUST_USE_RES struct LDKQueryShortChannelIds QueryShortChannelIds_new(struct LDKThirtyTwoBytes chain_hash_arg, struct LDKCVec_u64Z short_channel_ids_arg);
/* @internal */ parcelHelpers.export(exports, "QueryShortChannelIds_new", ()=>QueryShortChannelIds_new
);
// uintptr_t QueryShortChannelIds_clone_ptr(LDKQueryShortChannelIds *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "QueryShortChannelIds_clone_ptr", ()=>QueryShortChannelIds_clone_ptr
);
// struct LDKQueryShortChannelIds QueryShortChannelIds_clone(const struct LDKQueryShortChannelIds *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "QueryShortChannelIds_clone", ()=>QueryShortChannelIds_clone
);
// void ReplyShortChannelIdsEnd_free(struct LDKReplyShortChannelIdsEnd this_obj);
/* @internal */ parcelHelpers.export(exports, "ReplyShortChannelIdsEnd_free", ()=>ReplyShortChannelIdsEnd_free
);
// const uint8_t (*ReplyShortChannelIdsEnd_get_chain_hash(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "ReplyShortChannelIdsEnd_get_chain_hash", ()=>ReplyShortChannelIdsEnd_get_chain_hash
);
// void ReplyShortChannelIdsEnd_set_chain_hash(struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "ReplyShortChannelIdsEnd_set_chain_hash", ()=>ReplyShortChannelIdsEnd_set_chain_hash
);
// bool ReplyShortChannelIdsEnd_get_full_information(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ReplyShortChannelIdsEnd_get_full_information", ()=>ReplyShortChannelIdsEnd_get_full_information
);
// void ReplyShortChannelIdsEnd_set_full_information(struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr, bool val);
/* @internal */ parcelHelpers.export(exports, "ReplyShortChannelIdsEnd_set_full_information", ()=>ReplyShortChannelIdsEnd_set_full_information
);
// MUST_USE_RES struct LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_new(struct LDKThirtyTwoBytes chain_hash_arg, bool full_information_arg);
/* @internal */ parcelHelpers.export(exports, "ReplyShortChannelIdsEnd_new", ()=>ReplyShortChannelIdsEnd_new
);
// uintptr_t ReplyShortChannelIdsEnd_clone_ptr(LDKReplyShortChannelIdsEnd *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ReplyShortChannelIdsEnd_clone_ptr", ()=>ReplyShortChannelIdsEnd_clone_ptr
);
// struct LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_clone(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ReplyShortChannelIdsEnd_clone", ()=>ReplyShortChannelIdsEnd_clone
);
// void GossipTimestampFilter_free(struct LDKGossipTimestampFilter this_obj);
/* @internal */ parcelHelpers.export(exports, "GossipTimestampFilter_free", ()=>GossipTimestampFilter_free
);
// const uint8_t (*GossipTimestampFilter_get_chain_hash(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "GossipTimestampFilter_get_chain_hash", ()=>GossipTimestampFilter_get_chain_hash
);
// void GossipTimestampFilter_set_chain_hash(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "GossipTimestampFilter_set_chain_hash", ()=>GossipTimestampFilter_set_chain_hash
);
// uint32_t GossipTimestampFilter_get_first_timestamp(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "GossipTimestampFilter_get_first_timestamp", ()=>GossipTimestampFilter_get_first_timestamp
);
// void GossipTimestampFilter_set_first_timestamp(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "GossipTimestampFilter_set_first_timestamp", ()=>GossipTimestampFilter_set_first_timestamp
);
// uint32_t GossipTimestampFilter_get_timestamp_range(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "GossipTimestampFilter_get_timestamp_range", ()=>GossipTimestampFilter_get_timestamp_range
);
// void GossipTimestampFilter_set_timestamp_range(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "GossipTimestampFilter_set_timestamp_range", ()=>GossipTimestampFilter_set_timestamp_range
);
// MUST_USE_RES struct LDKGossipTimestampFilter GossipTimestampFilter_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_timestamp_arg, uint32_t timestamp_range_arg);
/* @internal */ parcelHelpers.export(exports, "GossipTimestampFilter_new", ()=>GossipTimestampFilter_new
);
// uintptr_t GossipTimestampFilter_clone_ptr(LDKGossipTimestampFilter *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "GossipTimestampFilter_clone_ptr", ()=>GossipTimestampFilter_clone_ptr
);
// struct LDKGossipTimestampFilter GossipTimestampFilter_clone(const struct LDKGossipTimestampFilter *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "GossipTimestampFilter_clone", ()=>GossipTimestampFilter_clone
);
// void ErrorAction_free(struct LDKErrorAction this_ptr);
/* @internal */ parcelHelpers.export(exports, "ErrorAction_free", ()=>ErrorAction_free
);
// uintptr_t ErrorAction_clone_ptr(LDKErrorAction *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ErrorAction_clone_ptr", ()=>ErrorAction_clone_ptr
);
// struct LDKErrorAction ErrorAction_clone(const struct LDKErrorAction *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ErrorAction_clone", ()=>ErrorAction_clone
);
// struct LDKErrorAction ErrorAction_disconnect_peer(struct LDKErrorMessage msg);
/* @internal */ parcelHelpers.export(exports, "ErrorAction_disconnect_peer", ()=>ErrorAction_disconnect_peer
);
// struct LDKErrorAction ErrorAction_ignore_error(void);
/* @internal */ parcelHelpers.export(exports, "ErrorAction_ignore_error", ()=>ErrorAction_ignore_error
);
// struct LDKErrorAction ErrorAction_ignore_and_log(enum LDKLevel a);
/* @internal */ parcelHelpers.export(exports, "ErrorAction_ignore_and_log", ()=>ErrorAction_ignore_and_log
);
// struct LDKErrorAction ErrorAction_ignore_duplicate_gossip(void);
/* @internal */ parcelHelpers.export(exports, "ErrorAction_ignore_duplicate_gossip", ()=>ErrorAction_ignore_duplicate_gossip
);
// struct LDKErrorAction ErrorAction_send_error_message(struct LDKErrorMessage msg);
/* @internal */ parcelHelpers.export(exports, "ErrorAction_send_error_message", ()=>ErrorAction_send_error_message
);
// void LightningError_free(struct LDKLightningError this_obj);
/* @internal */ parcelHelpers.export(exports, "LightningError_free", ()=>LightningError_free
);
// struct LDKStr LightningError_get_err(const struct LDKLightningError *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "LightningError_get_err", ()=>LightningError_get_err
);
// void LightningError_set_err(struct LDKLightningError *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */ parcelHelpers.export(exports, "LightningError_set_err", ()=>LightningError_set_err
);
// struct LDKErrorAction LightningError_get_action(const struct LDKLightningError *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "LightningError_get_action", ()=>LightningError_get_action
);
// void LightningError_set_action(struct LDKLightningError *NONNULL_PTR this_ptr, struct LDKErrorAction val);
/* @internal */ parcelHelpers.export(exports, "LightningError_set_action", ()=>LightningError_set_action
);
// MUST_USE_RES struct LDKLightningError LightningError_new(struct LDKStr err_arg, struct LDKErrorAction action_arg);
/* @internal */ parcelHelpers.export(exports, "LightningError_new", ()=>LightningError_new
);
// uintptr_t LightningError_clone_ptr(LDKLightningError *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "LightningError_clone_ptr", ()=>LightningError_clone_ptr
);
// struct LDKLightningError LightningError_clone(const struct LDKLightningError *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "LightningError_clone", ()=>LightningError_clone
);
// void CommitmentUpdate_free(struct LDKCommitmentUpdate this_obj);
/* @internal */ parcelHelpers.export(exports, "CommitmentUpdate_free", ()=>CommitmentUpdate_free
);
// struct LDKCVec_UpdateAddHTLCZ CommitmentUpdate_get_update_add_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "CommitmentUpdate_get_update_add_htlcs", ()=>CommitmentUpdate_get_update_add_htlcs
);
// void CommitmentUpdate_set_update_add_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateAddHTLCZ val);
/* @internal */ parcelHelpers.export(exports, "CommitmentUpdate_set_update_add_htlcs", ()=>CommitmentUpdate_set_update_add_htlcs
);
// struct LDKCVec_UpdateFulfillHTLCZ CommitmentUpdate_get_update_fulfill_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "CommitmentUpdate_get_update_fulfill_htlcs", ()=>CommitmentUpdate_get_update_fulfill_htlcs
);
// void CommitmentUpdate_set_update_fulfill_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFulfillHTLCZ val);
/* @internal */ parcelHelpers.export(exports, "CommitmentUpdate_set_update_fulfill_htlcs", ()=>CommitmentUpdate_set_update_fulfill_htlcs
);
// struct LDKCVec_UpdateFailHTLCZ CommitmentUpdate_get_update_fail_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "CommitmentUpdate_get_update_fail_htlcs", ()=>CommitmentUpdate_get_update_fail_htlcs
);
// void CommitmentUpdate_set_update_fail_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFailHTLCZ val);
/* @internal */ parcelHelpers.export(exports, "CommitmentUpdate_set_update_fail_htlcs", ()=>CommitmentUpdate_set_update_fail_htlcs
);
// struct LDKCVec_UpdateFailMalformedHTLCZ CommitmentUpdate_get_update_fail_malformed_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "CommitmentUpdate_get_update_fail_malformed_htlcs", ()=>CommitmentUpdate_get_update_fail_malformed_htlcs
);
// void CommitmentUpdate_set_update_fail_malformed_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFailMalformedHTLCZ val);
/* @internal */ parcelHelpers.export(exports, "CommitmentUpdate_set_update_fail_malformed_htlcs", ()=>CommitmentUpdate_set_update_fail_malformed_htlcs
);
// struct LDKUpdateFee CommitmentUpdate_get_update_fee(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "CommitmentUpdate_get_update_fee", ()=>CommitmentUpdate_get_update_fee
);
// void CommitmentUpdate_set_update_fee(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKUpdateFee val);
/* @internal */ parcelHelpers.export(exports, "CommitmentUpdate_set_update_fee", ()=>CommitmentUpdate_set_update_fee
);
// struct LDKCommitmentSigned CommitmentUpdate_get_commitment_signed(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "CommitmentUpdate_get_commitment_signed", ()=>CommitmentUpdate_get_commitment_signed
);
// void CommitmentUpdate_set_commitment_signed(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCommitmentSigned val);
/* @internal */ parcelHelpers.export(exports, "CommitmentUpdate_set_commitment_signed", ()=>CommitmentUpdate_set_commitment_signed
);
// MUST_USE_RES struct LDKCommitmentUpdate CommitmentUpdate_new(struct LDKCVec_UpdateAddHTLCZ update_add_htlcs_arg, struct LDKCVec_UpdateFulfillHTLCZ update_fulfill_htlcs_arg, struct LDKCVec_UpdateFailHTLCZ update_fail_htlcs_arg, struct LDKCVec_UpdateFailMalformedHTLCZ update_fail_malformed_htlcs_arg, struct LDKUpdateFee update_fee_arg, struct LDKCommitmentSigned commitment_signed_arg);
/* @internal */ parcelHelpers.export(exports, "CommitmentUpdate_new", ()=>CommitmentUpdate_new
);
// uintptr_t CommitmentUpdate_clone_ptr(LDKCommitmentUpdate *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CommitmentUpdate_clone_ptr", ()=>CommitmentUpdate_clone_ptr
);
// struct LDKCommitmentUpdate CommitmentUpdate_clone(const struct LDKCommitmentUpdate *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CommitmentUpdate_clone", ()=>CommitmentUpdate_clone
);
// void ChannelMessageHandler_free(struct LDKChannelMessageHandler this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelMessageHandler_free", ()=>ChannelMessageHandler_free
);
// void RoutingMessageHandler_free(struct LDKRoutingMessageHandler this_ptr);
/* @internal */ parcelHelpers.export(exports, "RoutingMessageHandler_free", ()=>RoutingMessageHandler_free
);
// struct LDKCVec_u8Z AcceptChannel_write(const struct LDKAcceptChannel *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_write", ()=>AcceptChannel_write
);
// struct LDKCResult_AcceptChannelDecodeErrorZ AcceptChannel_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "AcceptChannel_read", ()=>AcceptChannel_read
);
// struct LDKCVec_u8Z AnnouncementSignatures_write(const struct LDKAnnouncementSignatures *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "AnnouncementSignatures_write", ()=>AnnouncementSignatures_write
);
// struct LDKCResult_AnnouncementSignaturesDecodeErrorZ AnnouncementSignatures_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "AnnouncementSignatures_read", ()=>AnnouncementSignatures_read
);
// struct LDKCVec_u8Z ChannelReestablish_write(const struct LDKChannelReestablish *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ChannelReestablish_write", ()=>ChannelReestablish_write
);
// struct LDKCResult_ChannelReestablishDecodeErrorZ ChannelReestablish_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ChannelReestablish_read", ()=>ChannelReestablish_read
);
// struct LDKCVec_u8Z ClosingSigned_write(const struct LDKClosingSigned *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ClosingSigned_write", ()=>ClosingSigned_write
);
// struct LDKCResult_ClosingSignedDecodeErrorZ ClosingSigned_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ClosingSigned_read", ()=>ClosingSigned_read
);
// struct LDKCVec_u8Z ClosingSignedFeeRange_write(const struct LDKClosingSignedFeeRange *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ClosingSignedFeeRange_write", ()=>ClosingSignedFeeRange_write
);
// struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ ClosingSignedFeeRange_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ClosingSignedFeeRange_read", ()=>ClosingSignedFeeRange_read
);
// struct LDKCVec_u8Z CommitmentSigned_write(const struct LDKCommitmentSigned *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "CommitmentSigned_write", ()=>CommitmentSigned_write
);
// struct LDKCResult_CommitmentSignedDecodeErrorZ CommitmentSigned_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "CommitmentSigned_read", ()=>CommitmentSigned_read
);
// struct LDKCVec_u8Z FundingCreated_write(const struct LDKFundingCreated *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "FundingCreated_write", ()=>FundingCreated_write
);
// struct LDKCResult_FundingCreatedDecodeErrorZ FundingCreated_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "FundingCreated_read", ()=>FundingCreated_read
);
// struct LDKCVec_u8Z FundingSigned_write(const struct LDKFundingSigned *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "FundingSigned_write", ()=>FundingSigned_write
);
// struct LDKCResult_FundingSignedDecodeErrorZ FundingSigned_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "FundingSigned_read", ()=>FundingSigned_read
);
// struct LDKCVec_u8Z FundingLocked_write(const struct LDKFundingLocked *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "FundingLocked_write", ()=>FundingLocked_write
);
// struct LDKCResult_FundingLockedDecodeErrorZ FundingLocked_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "FundingLocked_read", ()=>FundingLocked_read
);
// struct LDKCVec_u8Z Init_write(const struct LDKInit *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "Init_write", ()=>Init_write
);
// struct LDKCResult_InitDecodeErrorZ Init_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "Init_read", ()=>Init_read
);
// struct LDKCVec_u8Z OpenChannel_write(const struct LDKOpenChannel *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_write", ()=>OpenChannel_write
);
// struct LDKCResult_OpenChannelDecodeErrorZ OpenChannel_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "OpenChannel_read", ()=>OpenChannel_read
);
// struct LDKCVec_u8Z RevokeAndACK_write(const struct LDKRevokeAndACK *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "RevokeAndACK_write", ()=>RevokeAndACK_write
);
// struct LDKCResult_RevokeAndACKDecodeErrorZ RevokeAndACK_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "RevokeAndACK_read", ()=>RevokeAndACK_read
);
// struct LDKCVec_u8Z Shutdown_write(const struct LDKShutdown *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "Shutdown_write", ()=>Shutdown_write
);
// struct LDKCResult_ShutdownDecodeErrorZ Shutdown_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "Shutdown_read", ()=>Shutdown_read
);
// struct LDKCVec_u8Z UpdateFailHTLC_write(const struct LDKUpdateFailHTLC *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "UpdateFailHTLC_write", ()=>UpdateFailHTLC_write
);
// struct LDKCResult_UpdateFailHTLCDecodeErrorZ UpdateFailHTLC_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "UpdateFailHTLC_read", ()=>UpdateFailHTLC_read
);
// struct LDKCVec_u8Z UpdateFailMalformedHTLC_write(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "UpdateFailMalformedHTLC_write", ()=>UpdateFailMalformedHTLC_write
);
// struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ UpdateFailMalformedHTLC_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "UpdateFailMalformedHTLC_read", ()=>UpdateFailMalformedHTLC_read
);
// struct LDKCVec_u8Z UpdateFee_write(const struct LDKUpdateFee *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "UpdateFee_write", ()=>UpdateFee_write
);
// struct LDKCResult_UpdateFeeDecodeErrorZ UpdateFee_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "UpdateFee_read", ()=>UpdateFee_read
);
// struct LDKCVec_u8Z UpdateFulfillHTLC_write(const struct LDKUpdateFulfillHTLC *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "UpdateFulfillHTLC_write", ()=>UpdateFulfillHTLC_write
);
// struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ UpdateFulfillHTLC_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "UpdateFulfillHTLC_read", ()=>UpdateFulfillHTLC_read
);
// struct LDKCVec_u8Z UpdateAddHTLC_write(const struct LDKUpdateAddHTLC *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "UpdateAddHTLC_write", ()=>UpdateAddHTLC_write
);
// struct LDKCResult_UpdateAddHTLCDecodeErrorZ UpdateAddHTLC_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "UpdateAddHTLC_read", ()=>UpdateAddHTLC_read
);
// struct LDKCVec_u8Z Ping_write(const struct LDKPing *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "Ping_write", ()=>Ping_write
);
// struct LDKCResult_PingDecodeErrorZ Ping_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "Ping_read", ()=>Ping_read
);
// struct LDKCVec_u8Z Pong_write(const struct LDKPong *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "Pong_write", ()=>Pong_write
);
// struct LDKCResult_PongDecodeErrorZ Pong_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "Pong_read", ()=>Pong_read
);
// struct LDKCVec_u8Z UnsignedChannelAnnouncement_write(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_write", ()=>UnsignedChannelAnnouncement_write
);
// struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ UnsignedChannelAnnouncement_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement_read", ()=>UnsignedChannelAnnouncement_read
);
// struct LDKCVec_u8Z ChannelAnnouncement_write(const struct LDKChannelAnnouncement *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ChannelAnnouncement_write", ()=>ChannelAnnouncement_write
);
// struct LDKCResult_ChannelAnnouncementDecodeErrorZ ChannelAnnouncement_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ChannelAnnouncement_read", ()=>ChannelAnnouncement_read
);
// struct LDKCVec_u8Z UnsignedChannelUpdate_write(const struct LDKUnsignedChannelUpdate *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_write", ()=>UnsignedChannelUpdate_write
);
// struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ UnsignedChannelUpdate_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "UnsignedChannelUpdate_read", ()=>UnsignedChannelUpdate_read
);
// struct LDKCVec_u8Z ChannelUpdate_write(const struct LDKChannelUpdate *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ChannelUpdate_write", ()=>ChannelUpdate_write
);
// struct LDKCResult_ChannelUpdateDecodeErrorZ ChannelUpdate_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ChannelUpdate_read", ()=>ChannelUpdate_read
);
// struct LDKCVec_u8Z ErrorMessage_write(const struct LDKErrorMessage *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ErrorMessage_write", ()=>ErrorMessage_write
);
// struct LDKCResult_ErrorMessageDecodeErrorZ ErrorMessage_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ErrorMessage_read", ()=>ErrorMessage_read
);
// struct LDKCVec_u8Z UnsignedNodeAnnouncement_write(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement_write", ()=>UnsignedNodeAnnouncement_write
);
// struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ UnsignedNodeAnnouncement_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement_read", ()=>UnsignedNodeAnnouncement_read
);
// struct LDKCVec_u8Z NodeAnnouncement_write(const struct LDKNodeAnnouncement *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncement_write", ()=>NodeAnnouncement_write
);
// struct LDKCResult_NodeAnnouncementDecodeErrorZ NodeAnnouncement_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncement_read", ()=>NodeAnnouncement_read
);
// struct LDKCResult_QueryShortChannelIdsDecodeErrorZ QueryShortChannelIds_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "QueryShortChannelIds_read", ()=>QueryShortChannelIds_read
);
// struct LDKCVec_u8Z QueryShortChannelIds_write(const struct LDKQueryShortChannelIds *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "QueryShortChannelIds_write", ()=>QueryShortChannelIds_write
);
// struct LDKCVec_u8Z ReplyShortChannelIdsEnd_write(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ReplyShortChannelIdsEnd_write", ()=>ReplyShortChannelIdsEnd_write
);
// struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ ReplyShortChannelIdsEnd_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ReplyShortChannelIdsEnd_read", ()=>ReplyShortChannelIdsEnd_read
);
// MUST_USE_RES uint32_t QueryChannelRange_end_blocknum(const struct LDKQueryChannelRange *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "QueryChannelRange_end_blocknum", ()=>QueryChannelRange_end_blocknum
);
// struct LDKCVec_u8Z QueryChannelRange_write(const struct LDKQueryChannelRange *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "QueryChannelRange_write", ()=>QueryChannelRange_write
);
// struct LDKCResult_QueryChannelRangeDecodeErrorZ QueryChannelRange_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "QueryChannelRange_read", ()=>QueryChannelRange_read
);
// struct LDKCResult_ReplyChannelRangeDecodeErrorZ ReplyChannelRange_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ReplyChannelRange_read", ()=>ReplyChannelRange_read
);
// struct LDKCVec_u8Z ReplyChannelRange_write(const struct LDKReplyChannelRange *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ReplyChannelRange_write", ()=>ReplyChannelRange_write
);
// struct LDKCVec_u8Z GossipTimestampFilter_write(const struct LDKGossipTimestampFilter *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "GossipTimestampFilter_write", ()=>GossipTimestampFilter_write
);
// struct LDKCResult_GossipTimestampFilterDecodeErrorZ GossipTimestampFilter_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "GossipTimestampFilter_read", ()=>GossipTimestampFilter_read
);
// void CustomMessageHandler_free(struct LDKCustomMessageHandler this_ptr);
/* @internal */ parcelHelpers.export(exports, "CustomMessageHandler_free", ()=>CustomMessageHandler_free
);
// void IgnoringMessageHandler_free(struct LDKIgnoringMessageHandler this_obj);
/* @internal */ parcelHelpers.export(exports, "IgnoringMessageHandler_free", ()=>IgnoringMessageHandler_free
);
// MUST_USE_RES struct LDKIgnoringMessageHandler IgnoringMessageHandler_new(void);
/* @internal */ parcelHelpers.export(exports, "IgnoringMessageHandler_new", ()=>IgnoringMessageHandler_new
);
// struct LDKMessageSendEventsProvider IgnoringMessageHandler_as_MessageSendEventsProvider(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "IgnoringMessageHandler_as_MessageSendEventsProvider", ()=>IgnoringMessageHandler_as_MessageSendEventsProvider
);
// struct LDKRoutingMessageHandler IgnoringMessageHandler_as_RoutingMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "IgnoringMessageHandler_as_RoutingMessageHandler", ()=>IgnoringMessageHandler_as_RoutingMessageHandler
);
// struct LDKCustomMessageReader IgnoringMessageHandler_as_CustomMessageReader(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "IgnoringMessageHandler_as_CustomMessageReader", ()=>IgnoringMessageHandler_as_CustomMessageReader
);
// struct LDKCustomMessageHandler IgnoringMessageHandler_as_CustomMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "IgnoringMessageHandler_as_CustomMessageHandler", ()=>IgnoringMessageHandler_as_CustomMessageHandler
);
// void ErroringMessageHandler_free(struct LDKErroringMessageHandler this_obj);
/* @internal */ parcelHelpers.export(exports, "ErroringMessageHandler_free", ()=>ErroringMessageHandler_free
);
// MUST_USE_RES struct LDKErroringMessageHandler ErroringMessageHandler_new(void);
/* @internal */ parcelHelpers.export(exports, "ErroringMessageHandler_new", ()=>ErroringMessageHandler_new
);
// struct LDKMessageSendEventsProvider ErroringMessageHandler_as_MessageSendEventsProvider(const struct LDKErroringMessageHandler *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ErroringMessageHandler_as_MessageSendEventsProvider", ()=>ErroringMessageHandler_as_MessageSendEventsProvider
);
// struct LDKChannelMessageHandler ErroringMessageHandler_as_ChannelMessageHandler(const struct LDKErroringMessageHandler *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ErroringMessageHandler_as_ChannelMessageHandler", ()=>ErroringMessageHandler_as_ChannelMessageHandler
);
// void MessageHandler_free(struct LDKMessageHandler this_obj);
/* @internal */ parcelHelpers.export(exports, "MessageHandler_free", ()=>MessageHandler_free
);
// const struct LDKChannelMessageHandler *MessageHandler_get_chan_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "MessageHandler_get_chan_handler", ()=>MessageHandler_get_chan_handler
);
// void MessageHandler_set_chan_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKChannelMessageHandler val);
/* @internal */ parcelHelpers.export(exports, "MessageHandler_set_chan_handler", ()=>MessageHandler_set_chan_handler
);
// const struct LDKRoutingMessageHandler *MessageHandler_get_route_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "MessageHandler_get_route_handler", ()=>MessageHandler_get_route_handler
);
// void MessageHandler_set_route_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKRoutingMessageHandler val);
/* @internal */ parcelHelpers.export(exports, "MessageHandler_set_route_handler", ()=>MessageHandler_set_route_handler
);
// MUST_USE_RES struct LDKMessageHandler MessageHandler_new(struct LDKChannelMessageHandler chan_handler_arg, struct LDKRoutingMessageHandler route_handler_arg);
/* @internal */ parcelHelpers.export(exports, "MessageHandler_new", ()=>MessageHandler_new
);
// uintptr_t SocketDescriptor_clone_ptr(LDKSocketDescriptor *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "SocketDescriptor_clone_ptr", ()=>SocketDescriptor_clone_ptr
);
// struct LDKSocketDescriptor SocketDescriptor_clone(const struct LDKSocketDescriptor *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "SocketDescriptor_clone", ()=>SocketDescriptor_clone
);
// void SocketDescriptor_free(struct LDKSocketDescriptor this_ptr);
/* @internal */ parcelHelpers.export(exports, "SocketDescriptor_free", ()=>SocketDescriptor_free
);
// void PeerHandleError_free(struct LDKPeerHandleError this_obj);
/* @internal */ parcelHelpers.export(exports, "PeerHandleError_free", ()=>PeerHandleError_free
);
// bool PeerHandleError_get_no_connection_possible(const struct LDKPeerHandleError *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "PeerHandleError_get_no_connection_possible", ()=>PeerHandleError_get_no_connection_possible
);
// void PeerHandleError_set_no_connection_possible(struct LDKPeerHandleError *NONNULL_PTR this_ptr, bool val);
/* @internal */ parcelHelpers.export(exports, "PeerHandleError_set_no_connection_possible", ()=>PeerHandleError_set_no_connection_possible
);
// MUST_USE_RES struct LDKPeerHandleError PeerHandleError_new(bool no_connection_possible_arg);
/* @internal */ parcelHelpers.export(exports, "PeerHandleError_new", ()=>PeerHandleError_new
);
// uintptr_t PeerHandleError_clone_ptr(LDKPeerHandleError *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "PeerHandleError_clone_ptr", ()=>PeerHandleError_clone_ptr
);
// struct LDKPeerHandleError PeerHandleError_clone(const struct LDKPeerHandleError *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "PeerHandleError_clone", ()=>PeerHandleError_clone
);
// void PeerManager_free(struct LDKPeerManager this_obj);
/* @internal */ parcelHelpers.export(exports, "PeerManager_free", ()=>PeerManager_free
);
// MUST_USE_RES struct LDKPeerManager PeerManager_new(struct LDKMessageHandler message_handler, struct LDKSecretKey our_node_secret, const uint8_t (*ephemeral_random_data)[32], struct LDKLogger logger, struct LDKCustomMessageHandler custom_message_handler);
/* @internal */ parcelHelpers.export(exports, "PeerManager_new", ()=>PeerManager_new
);
// MUST_USE_RES struct LDKCVec_PublicKeyZ PeerManager_get_peer_node_ids(const struct LDKPeerManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "PeerManager_get_peer_node_ids", ()=>PeerManager_get_peer_node_ids
);
// MUST_USE_RES struct LDKCResult_CVec_u8ZPeerHandleErrorZ PeerManager_new_outbound_connection(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKSocketDescriptor descriptor);
/* @internal */ parcelHelpers.export(exports, "PeerManager_new_outbound_connection", ()=>PeerManager_new_outbound_connection
);
// MUST_USE_RES struct LDKCResult_NonePeerHandleErrorZ PeerManager_new_inbound_connection(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor descriptor);
/* @internal */ parcelHelpers.export(exports, "PeerManager_new_inbound_connection", ()=>PeerManager_new_inbound_connection
);
// MUST_USE_RES struct LDKCResult_NonePeerHandleErrorZ PeerManager_write_buffer_space_avail(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor *NONNULL_PTR descriptor);
/* @internal */ parcelHelpers.export(exports, "PeerManager_write_buffer_space_avail", ()=>PeerManager_write_buffer_space_avail
);
// MUST_USE_RES struct LDKCResult_boolPeerHandleErrorZ PeerManager_read_event(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor *NONNULL_PTR peer_descriptor, struct LDKu8slice data);
/* @internal */ parcelHelpers.export(exports, "PeerManager_read_event", ()=>PeerManager_read_event
);
// void PeerManager_process_events(const struct LDKPeerManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "PeerManager_process_events", ()=>PeerManager_process_events
);
// void PeerManager_socket_disconnected(const struct LDKPeerManager *NONNULL_PTR this_arg, const struct LDKSocketDescriptor *NONNULL_PTR descriptor);
/* @internal */ parcelHelpers.export(exports, "PeerManager_socket_disconnected", ()=>PeerManager_socket_disconnected
);
// void PeerManager_disconnect_by_node_id(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKPublicKey node_id, bool no_connection_possible);
/* @internal */ parcelHelpers.export(exports, "PeerManager_disconnect_by_node_id", ()=>PeerManager_disconnect_by_node_id
);
// void PeerManager_disconnect_all_peers(const struct LDKPeerManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "PeerManager_disconnect_all_peers", ()=>PeerManager_disconnect_all_peers
);
// void PeerManager_timer_tick_occurred(const struct LDKPeerManager *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "PeerManager_timer_tick_occurred", ()=>PeerManager_timer_tick_occurred
);
// uint64_t htlc_success_tx_weight(bool opt_anchors);
/* @internal */ parcelHelpers.export(exports, "htlc_success_tx_weight", ()=>htlc_success_tx_weight
);
// uint64_t htlc_timeout_tx_weight(bool opt_anchors);
/* @internal */ parcelHelpers.export(exports, "htlc_timeout_tx_weight", ()=>htlc_timeout_tx_weight
);
// struct LDKThirtyTwoBytes build_commitment_secret(const uint8_t (*commitment_seed)[32], uint64_t idx);
/* @internal */ parcelHelpers.export(exports, "build_commitment_secret", ()=>build_commitment_secret
);
// struct LDKTransaction build_closing_transaction(uint64_t to_holder_value_sat, uint64_t to_counterparty_value_sat, struct LDKCVec_u8Z to_holder_script, struct LDKCVec_u8Z to_counterparty_script, struct LDKOutPoint funding_outpoint);
/* @internal */ parcelHelpers.export(exports, "build_closing_transaction", ()=>build_closing_transaction
);
// struct LDKCResult_SecretKeyErrorZ derive_private_key(struct LDKPublicKey per_commitment_point, const uint8_t (*base_secret)[32]);
/* @internal */ parcelHelpers.export(exports, "derive_private_key", ()=>derive_private_key
);
// struct LDKCResult_PublicKeyErrorZ derive_public_key(struct LDKPublicKey per_commitment_point, struct LDKPublicKey base_point);
/* @internal */ parcelHelpers.export(exports, "derive_public_key", ()=>derive_public_key
);
// struct LDKCResult_SecretKeyErrorZ derive_private_revocation_key(const uint8_t (*per_commitment_secret)[32], const uint8_t (*countersignatory_revocation_base_secret)[32]);
/* @internal */ parcelHelpers.export(exports, "derive_private_revocation_key", ()=>derive_private_revocation_key
);
// struct LDKCResult_PublicKeyErrorZ derive_public_revocation_key(struct LDKPublicKey per_commitment_point, struct LDKPublicKey countersignatory_revocation_base_point);
/* @internal */ parcelHelpers.export(exports, "derive_public_revocation_key", ()=>derive_public_revocation_key
);
// void TxCreationKeys_free(struct LDKTxCreationKeys this_obj);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_free", ()=>TxCreationKeys_free
);
// struct LDKPublicKey TxCreationKeys_get_per_commitment_point(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_get_per_commitment_point", ()=>TxCreationKeys_get_per_commitment_point
);
// void TxCreationKeys_set_per_commitment_point(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_set_per_commitment_point", ()=>TxCreationKeys_set_per_commitment_point
);
// struct LDKPublicKey TxCreationKeys_get_revocation_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_get_revocation_key", ()=>TxCreationKeys_get_revocation_key
);
// void TxCreationKeys_set_revocation_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_set_revocation_key", ()=>TxCreationKeys_set_revocation_key
);
// struct LDKPublicKey TxCreationKeys_get_broadcaster_htlc_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_get_broadcaster_htlc_key", ()=>TxCreationKeys_get_broadcaster_htlc_key
);
// void TxCreationKeys_set_broadcaster_htlc_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_set_broadcaster_htlc_key", ()=>TxCreationKeys_set_broadcaster_htlc_key
);
// struct LDKPublicKey TxCreationKeys_get_countersignatory_htlc_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_get_countersignatory_htlc_key", ()=>TxCreationKeys_get_countersignatory_htlc_key
);
// void TxCreationKeys_set_countersignatory_htlc_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_set_countersignatory_htlc_key", ()=>TxCreationKeys_set_countersignatory_htlc_key
);
// struct LDKPublicKey TxCreationKeys_get_broadcaster_delayed_payment_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_get_broadcaster_delayed_payment_key", ()=>TxCreationKeys_get_broadcaster_delayed_payment_key
);
// void TxCreationKeys_set_broadcaster_delayed_payment_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_set_broadcaster_delayed_payment_key", ()=>TxCreationKeys_set_broadcaster_delayed_payment_key
);
// MUST_USE_RES struct LDKTxCreationKeys TxCreationKeys_new(struct LDKPublicKey per_commitment_point_arg, struct LDKPublicKey revocation_key_arg, struct LDKPublicKey broadcaster_htlc_key_arg, struct LDKPublicKey countersignatory_htlc_key_arg, struct LDKPublicKey broadcaster_delayed_payment_key_arg);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_new", ()=>TxCreationKeys_new
);
// uintptr_t TxCreationKeys_clone_ptr(LDKTxCreationKeys *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_clone_ptr", ()=>TxCreationKeys_clone_ptr
);
// struct LDKTxCreationKeys TxCreationKeys_clone(const struct LDKTxCreationKeys *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_clone", ()=>TxCreationKeys_clone
);
// struct LDKCVec_u8Z TxCreationKeys_write(const struct LDKTxCreationKeys *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_write", ()=>TxCreationKeys_write
);
// struct LDKCResult_TxCreationKeysDecodeErrorZ TxCreationKeys_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_read", ()=>TxCreationKeys_read
);
// void ChannelPublicKeys_free(struct LDKChannelPublicKeys this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelPublicKeys_free", ()=>ChannelPublicKeys_free
);
// struct LDKPublicKey ChannelPublicKeys_get_funding_pubkey(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelPublicKeys_get_funding_pubkey", ()=>ChannelPublicKeys_get_funding_pubkey
);
// void ChannelPublicKeys_set_funding_pubkey(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "ChannelPublicKeys_set_funding_pubkey", ()=>ChannelPublicKeys_set_funding_pubkey
);
// struct LDKPublicKey ChannelPublicKeys_get_revocation_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelPublicKeys_get_revocation_basepoint", ()=>ChannelPublicKeys_get_revocation_basepoint
);
// void ChannelPublicKeys_set_revocation_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "ChannelPublicKeys_set_revocation_basepoint", ()=>ChannelPublicKeys_set_revocation_basepoint
);
// struct LDKPublicKey ChannelPublicKeys_get_payment_point(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelPublicKeys_get_payment_point", ()=>ChannelPublicKeys_get_payment_point
);
// void ChannelPublicKeys_set_payment_point(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "ChannelPublicKeys_set_payment_point", ()=>ChannelPublicKeys_set_payment_point
);
// struct LDKPublicKey ChannelPublicKeys_get_delayed_payment_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelPublicKeys_get_delayed_payment_basepoint", ()=>ChannelPublicKeys_get_delayed_payment_basepoint
);
// void ChannelPublicKeys_set_delayed_payment_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "ChannelPublicKeys_set_delayed_payment_basepoint", ()=>ChannelPublicKeys_set_delayed_payment_basepoint
);
// struct LDKPublicKey ChannelPublicKeys_get_htlc_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelPublicKeys_get_htlc_basepoint", ()=>ChannelPublicKeys_get_htlc_basepoint
);
// void ChannelPublicKeys_set_htlc_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "ChannelPublicKeys_set_htlc_basepoint", ()=>ChannelPublicKeys_set_htlc_basepoint
);
// MUST_USE_RES struct LDKChannelPublicKeys ChannelPublicKeys_new(struct LDKPublicKey funding_pubkey_arg, struct LDKPublicKey revocation_basepoint_arg, struct LDKPublicKey payment_point_arg, struct LDKPublicKey delayed_payment_basepoint_arg, struct LDKPublicKey htlc_basepoint_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelPublicKeys_new", ()=>ChannelPublicKeys_new
);
// uintptr_t ChannelPublicKeys_clone_ptr(LDKChannelPublicKeys *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ChannelPublicKeys_clone_ptr", ()=>ChannelPublicKeys_clone_ptr
);
// struct LDKChannelPublicKeys ChannelPublicKeys_clone(const struct LDKChannelPublicKeys *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChannelPublicKeys_clone", ()=>ChannelPublicKeys_clone
);
// struct LDKCVec_u8Z ChannelPublicKeys_write(const struct LDKChannelPublicKeys *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ChannelPublicKeys_write", ()=>ChannelPublicKeys_write
);
// struct LDKCResult_ChannelPublicKeysDecodeErrorZ ChannelPublicKeys_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ChannelPublicKeys_read", ()=>ChannelPublicKeys_read
);
// MUST_USE_RES struct LDKCResult_TxCreationKeysErrorZ TxCreationKeys_derive_new(struct LDKPublicKey per_commitment_point, struct LDKPublicKey broadcaster_delayed_payment_base, struct LDKPublicKey broadcaster_htlc_base, struct LDKPublicKey countersignatory_revocation_base, struct LDKPublicKey countersignatory_htlc_base);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_derive_new", ()=>TxCreationKeys_derive_new
);
// MUST_USE_RES struct LDKCResult_TxCreationKeysErrorZ TxCreationKeys_from_channel_static_keys(struct LDKPublicKey per_commitment_point, const struct LDKChannelPublicKeys *NONNULL_PTR broadcaster_keys, const struct LDKChannelPublicKeys *NONNULL_PTR countersignatory_keys);
/* @internal */ parcelHelpers.export(exports, "TxCreationKeys_from_channel_static_keys", ()=>TxCreationKeys_from_channel_static_keys
);
// struct LDKCVec_u8Z get_revokeable_redeemscript(struct LDKPublicKey revocation_key, uint16_t contest_delay, struct LDKPublicKey broadcaster_delayed_payment_key);
/* @internal */ parcelHelpers.export(exports, "get_revokeable_redeemscript", ()=>get_revokeable_redeemscript
);
// void HTLCOutputInCommitment_free(struct LDKHTLCOutputInCommitment this_obj);
/* @internal */ parcelHelpers.export(exports, "HTLCOutputInCommitment_free", ()=>HTLCOutputInCommitment_free
);
// bool HTLCOutputInCommitment_get_offered(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "HTLCOutputInCommitment_get_offered", ()=>HTLCOutputInCommitment_get_offered
);
// void HTLCOutputInCommitment_set_offered(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, bool val);
/* @internal */ parcelHelpers.export(exports, "HTLCOutputInCommitment_set_offered", ()=>HTLCOutputInCommitment_set_offered
);
// uint64_t HTLCOutputInCommitment_get_amount_msat(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "HTLCOutputInCommitment_get_amount_msat", ()=>HTLCOutputInCommitment_get_amount_msat
);
// void HTLCOutputInCommitment_set_amount_msat(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "HTLCOutputInCommitment_set_amount_msat", ()=>HTLCOutputInCommitment_set_amount_msat
);
// uint32_t HTLCOutputInCommitment_get_cltv_expiry(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "HTLCOutputInCommitment_get_cltv_expiry", ()=>HTLCOutputInCommitment_get_cltv_expiry
);
// void HTLCOutputInCommitment_set_cltv_expiry(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "HTLCOutputInCommitment_set_cltv_expiry", ()=>HTLCOutputInCommitment_set_cltv_expiry
);
// const uint8_t (*HTLCOutputInCommitment_get_payment_hash(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "HTLCOutputInCommitment_get_payment_hash", ()=>HTLCOutputInCommitment_get_payment_hash
);
// void HTLCOutputInCommitment_set_payment_hash(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "HTLCOutputInCommitment_set_payment_hash", ()=>HTLCOutputInCommitment_set_payment_hash
);
// struct LDKCOption_u32Z HTLCOutputInCommitment_get_transaction_output_index(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "HTLCOutputInCommitment_get_transaction_output_index", ()=>HTLCOutputInCommitment_get_transaction_output_index
);
// void HTLCOutputInCommitment_set_transaction_output_index(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);
/* @internal */ parcelHelpers.export(exports, "HTLCOutputInCommitment_set_transaction_output_index", ()=>HTLCOutputInCommitment_set_transaction_output_index
);
// MUST_USE_RES struct LDKHTLCOutputInCommitment HTLCOutputInCommitment_new(bool offered_arg, uint64_t amount_msat_arg, uint32_t cltv_expiry_arg, struct LDKThirtyTwoBytes payment_hash_arg, struct LDKCOption_u32Z transaction_output_index_arg);
/* @internal */ parcelHelpers.export(exports, "HTLCOutputInCommitment_new", ()=>HTLCOutputInCommitment_new
);
// uintptr_t HTLCOutputInCommitment_clone_ptr(LDKHTLCOutputInCommitment *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "HTLCOutputInCommitment_clone_ptr", ()=>HTLCOutputInCommitment_clone_ptr
);
// struct LDKHTLCOutputInCommitment HTLCOutputInCommitment_clone(const struct LDKHTLCOutputInCommitment *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "HTLCOutputInCommitment_clone", ()=>HTLCOutputInCommitment_clone
);
// struct LDKCVec_u8Z HTLCOutputInCommitment_write(const struct LDKHTLCOutputInCommitment *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "HTLCOutputInCommitment_write", ()=>HTLCOutputInCommitment_write
);
// struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ HTLCOutputInCommitment_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "HTLCOutputInCommitment_read", ()=>HTLCOutputInCommitment_read
);
// struct LDKCVec_u8Z get_htlc_redeemscript(const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc, bool opt_anchors, const struct LDKTxCreationKeys *NONNULL_PTR keys);
/* @internal */ parcelHelpers.export(exports, "get_htlc_redeemscript", ()=>get_htlc_redeemscript
);
// struct LDKCVec_u8Z make_funding_redeemscript(struct LDKPublicKey broadcaster, struct LDKPublicKey countersignatory);
/* @internal */ parcelHelpers.export(exports, "make_funding_redeemscript", ()=>make_funding_redeemscript
);
// struct LDKTransaction build_htlc_transaction(const uint8_t (*commitment_txid)[32], uint32_t feerate_per_kw, uint16_t contest_delay, const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc, bool opt_anchors, struct LDKPublicKey broadcaster_delayed_payment_key, struct LDKPublicKey revocation_key);
/* @internal */ parcelHelpers.export(exports, "build_htlc_transaction", ()=>build_htlc_transaction
);
// struct LDKCVec_u8Z get_anchor_redeemscript(struct LDKPublicKey funding_pubkey);
/* @internal */ parcelHelpers.export(exports, "get_anchor_redeemscript", ()=>get_anchor_redeemscript
);
// void ChannelTransactionParameters_free(struct LDKChannelTransactionParameters this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_free", ()=>ChannelTransactionParameters_free
);
// struct LDKChannelPublicKeys ChannelTransactionParameters_get_holder_pubkeys(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_get_holder_pubkeys", ()=>ChannelTransactionParameters_get_holder_pubkeys
);
// void ChannelTransactionParameters_set_holder_pubkeys(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelPublicKeys val);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_set_holder_pubkeys", ()=>ChannelTransactionParameters_set_holder_pubkeys
);
// uint16_t ChannelTransactionParameters_get_holder_selected_contest_delay(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_get_holder_selected_contest_delay", ()=>ChannelTransactionParameters_get_holder_selected_contest_delay
);
// void ChannelTransactionParameters_set_holder_selected_contest_delay(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_set_holder_selected_contest_delay", ()=>ChannelTransactionParameters_set_holder_selected_contest_delay
);
// bool ChannelTransactionParameters_get_is_outbound_from_holder(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_get_is_outbound_from_holder", ()=>ChannelTransactionParameters_get_is_outbound_from_holder
);
// void ChannelTransactionParameters_set_is_outbound_from_holder(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, bool val);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_set_is_outbound_from_holder", ()=>ChannelTransactionParameters_set_is_outbound_from_holder
);
// struct LDKCounterpartyChannelTransactionParameters ChannelTransactionParameters_get_counterparty_parameters(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_get_counterparty_parameters", ()=>ChannelTransactionParameters_get_counterparty_parameters
);
// void ChannelTransactionParameters_set_counterparty_parameters(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKCounterpartyChannelTransactionParameters val);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_set_counterparty_parameters", ()=>ChannelTransactionParameters_set_counterparty_parameters
);
// struct LDKOutPoint ChannelTransactionParameters_get_funding_outpoint(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_get_funding_outpoint", ()=>ChannelTransactionParameters_get_funding_outpoint
);
// void ChannelTransactionParameters_set_funding_outpoint(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_set_funding_outpoint", ()=>ChannelTransactionParameters_set_funding_outpoint
);
// enum LDKCOption_NoneZ ChannelTransactionParameters_get_opt_anchors(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_get_opt_anchors", ()=>ChannelTransactionParameters_get_opt_anchors
);
// void ChannelTransactionParameters_set_opt_anchors(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, enum LDKCOption_NoneZ val);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_set_opt_anchors", ()=>ChannelTransactionParameters_set_opt_anchors
);
// MUST_USE_RES struct LDKChannelTransactionParameters ChannelTransactionParameters_new(struct LDKChannelPublicKeys holder_pubkeys_arg, uint16_t holder_selected_contest_delay_arg, bool is_outbound_from_holder_arg, struct LDKCounterpartyChannelTransactionParameters counterparty_parameters_arg, struct LDKOutPoint funding_outpoint_arg, enum LDKCOption_NoneZ opt_anchors_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_new", ()=>ChannelTransactionParameters_new
);
// uintptr_t ChannelTransactionParameters_clone_ptr(LDKChannelTransactionParameters *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_clone_ptr", ()=>ChannelTransactionParameters_clone_ptr
);
// struct LDKChannelTransactionParameters ChannelTransactionParameters_clone(const struct LDKChannelTransactionParameters *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_clone", ()=>ChannelTransactionParameters_clone
);
// void CounterpartyChannelTransactionParameters_free(struct LDKCounterpartyChannelTransactionParameters this_obj);
/* @internal */ parcelHelpers.export(exports, "CounterpartyChannelTransactionParameters_free", ()=>CounterpartyChannelTransactionParameters_free
);
// struct LDKChannelPublicKeys CounterpartyChannelTransactionParameters_get_pubkeys(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "CounterpartyChannelTransactionParameters_get_pubkeys", ()=>CounterpartyChannelTransactionParameters_get_pubkeys
);
// void CounterpartyChannelTransactionParameters_set_pubkeys(struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelPublicKeys val);
/* @internal */ parcelHelpers.export(exports, "CounterpartyChannelTransactionParameters_set_pubkeys", ()=>CounterpartyChannelTransactionParameters_set_pubkeys
);
// uint16_t CounterpartyChannelTransactionParameters_get_selected_contest_delay(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "CounterpartyChannelTransactionParameters_get_selected_contest_delay", ()=>CounterpartyChannelTransactionParameters_get_selected_contest_delay
);
// void CounterpartyChannelTransactionParameters_set_selected_contest_delay(struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "CounterpartyChannelTransactionParameters_set_selected_contest_delay", ()=>CounterpartyChannelTransactionParameters_set_selected_contest_delay
);
// MUST_USE_RES struct LDKCounterpartyChannelTransactionParameters CounterpartyChannelTransactionParameters_new(struct LDKChannelPublicKeys pubkeys_arg, uint16_t selected_contest_delay_arg);
/* @internal */ parcelHelpers.export(exports, "CounterpartyChannelTransactionParameters_new", ()=>CounterpartyChannelTransactionParameters_new
);
// uintptr_t CounterpartyChannelTransactionParameters_clone_ptr(LDKCounterpartyChannelTransactionParameters *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CounterpartyChannelTransactionParameters_clone_ptr", ()=>CounterpartyChannelTransactionParameters_clone_ptr
);
// struct LDKCounterpartyChannelTransactionParameters CounterpartyChannelTransactionParameters_clone(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CounterpartyChannelTransactionParameters_clone", ()=>CounterpartyChannelTransactionParameters_clone
);
// MUST_USE_RES bool ChannelTransactionParameters_is_populated(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_is_populated", ()=>ChannelTransactionParameters_is_populated
);
// MUST_USE_RES struct LDKDirectedChannelTransactionParameters ChannelTransactionParameters_as_holder_broadcastable(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_as_holder_broadcastable", ()=>ChannelTransactionParameters_as_holder_broadcastable
);
// MUST_USE_RES struct LDKDirectedChannelTransactionParameters ChannelTransactionParameters_as_counterparty_broadcastable(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_as_counterparty_broadcastable", ()=>ChannelTransactionParameters_as_counterparty_broadcastable
);
// struct LDKCVec_u8Z CounterpartyChannelTransactionParameters_write(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "CounterpartyChannelTransactionParameters_write", ()=>CounterpartyChannelTransactionParameters_write
);
// struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CounterpartyChannelTransactionParameters_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "CounterpartyChannelTransactionParameters_read", ()=>CounterpartyChannelTransactionParameters_read
);
// struct LDKCVec_u8Z ChannelTransactionParameters_write(const struct LDKChannelTransactionParameters *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_write", ()=>ChannelTransactionParameters_write
);
// struct LDKCResult_ChannelTransactionParametersDecodeErrorZ ChannelTransactionParameters_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ChannelTransactionParameters_read", ()=>ChannelTransactionParameters_read
);
// void DirectedChannelTransactionParameters_free(struct LDKDirectedChannelTransactionParameters this_obj);
/* @internal */ parcelHelpers.export(exports, "DirectedChannelTransactionParameters_free", ()=>DirectedChannelTransactionParameters_free
);
// MUST_USE_RES struct LDKChannelPublicKeys DirectedChannelTransactionParameters_broadcaster_pubkeys(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "DirectedChannelTransactionParameters_broadcaster_pubkeys", ()=>DirectedChannelTransactionParameters_broadcaster_pubkeys
);
// MUST_USE_RES struct LDKChannelPublicKeys DirectedChannelTransactionParameters_countersignatory_pubkeys(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "DirectedChannelTransactionParameters_countersignatory_pubkeys", ()=>DirectedChannelTransactionParameters_countersignatory_pubkeys
);
// MUST_USE_RES uint16_t DirectedChannelTransactionParameters_contest_delay(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "DirectedChannelTransactionParameters_contest_delay", ()=>DirectedChannelTransactionParameters_contest_delay
);
// MUST_USE_RES bool DirectedChannelTransactionParameters_is_outbound(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "DirectedChannelTransactionParameters_is_outbound", ()=>DirectedChannelTransactionParameters_is_outbound
);
// MUST_USE_RES struct LDKOutPoint DirectedChannelTransactionParameters_funding_outpoint(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "DirectedChannelTransactionParameters_funding_outpoint", ()=>DirectedChannelTransactionParameters_funding_outpoint
);
// MUST_USE_RES bool DirectedChannelTransactionParameters_opt_anchors(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "DirectedChannelTransactionParameters_opt_anchors", ()=>DirectedChannelTransactionParameters_opt_anchors
);
// void HolderCommitmentTransaction_free(struct LDKHolderCommitmentTransaction this_obj);
/* @internal */ parcelHelpers.export(exports, "HolderCommitmentTransaction_free", ()=>HolderCommitmentTransaction_free
);
// struct LDKSignature HolderCommitmentTransaction_get_counterparty_sig(const struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "HolderCommitmentTransaction_get_counterparty_sig", ()=>HolderCommitmentTransaction_get_counterparty_sig
);
// void HolderCommitmentTransaction_set_counterparty_sig(struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */ parcelHelpers.export(exports, "HolderCommitmentTransaction_set_counterparty_sig", ()=>HolderCommitmentTransaction_set_counterparty_sig
);
// void HolderCommitmentTransaction_set_counterparty_htlc_sigs(struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKCVec_SignatureZ val);
/* @internal */ parcelHelpers.export(exports, "HolderCommitmentTransaction_set_counterparty_htlc_sigs", ()=>HolderCommitmentTransaction_set_counterparty_htlc_sigs
);
// uintptr_t HolderCommitmentTransaction_clone_ptr(LDKHolderCommitmentTransaction *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "HolderCommitmentTransaction_clone_ptr", ()=>HolderCommitmentTransaction_clone_ptr
);
// struct LDKHolderCommitmentTransaction HolderCommitmentTransaction_clone(const struct LDKHolderCommitmentTransaction *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "HolderCommitmentTransaction_clone", ()=>HolderCommitmentTransaction_clone
);
// struct LDKCVec_u8Z HolderCommitmentTransaction_write(const struct LDKHolderCommitmentTransaction *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "HolderCommitmentTransaction_write", ()=>HolderCommitmentTransaction_write
);
// struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ HolderCommitmentTransaction_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "HolderCommitmentTransaction_read", ()=>HolderCommitmentTransaction_read
);
// MUST_USE_RES struct LDKHolderCommitmentTransaction HolderCommitmentTransaction_new(struct LDKCommitmentTransaction commitment_tx, struct LDKSignature counterparty_sig, struct LDKCVec_SignatureZ counterparty_htlc_sigs, struct LDKPublicKey holder_funding_key, struct LDKPublicKey counterparty_funding_key);
/* @internal */ parcelHelpers.export(exports, "HolderCommitmentTransaction_new", ()=>HolderCommitmentTransaction_new
);
// void BuiltCommitmentTransaction_free(struct LDKBuiltCommitmentTransaction this_obj);
/* @internal */ parcelHelpers.export(exports, "BuiltCommitmentTransaction_free", ()=>BuiltCommitmentTransaction_free
);
// struct LDKTransaction BuiltCommitmentTransaction_get_transaction(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "BuiltCommitmentTransaction_get_transaction", ()=>BuiltCommitmentTransaction_get_transaction
);
// void BuiltCommitmentTransaction_set_transaction(struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKTransaction val);
/* @internal */ parcelHelpers.export(exports, "BuiltCommitmentTransaction_set_transaction", ()=>BuiltCommitmentTransaction_set_transaction
);
// const uint8_t (*BuiltCommitmentTransaction_get_txid(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "BuiltCommitmentTransaction_get_txid", ()=>BuiltCommitmentTransaction_get_txid
);
// void BuiltCommitmentTransaction_set_txid(struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "BuiltCommitmentTransaction_set_txid", ()=>BuiltCommitmentTransaction_set_txid
);
// MUST_USE_RES struct LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_new(struct LDKTransaction transaction_arg, struct LDKThirtyTwoBytes txid_arg);
/* @internal */ parcelHelpers.export(exports, "BuiltCommitmentTransaction_new", ()=>BuiltCommitmentTransaction_new
);
// uintptr_t BuiltCommitmentTransaction_clone_ptr(LDKBuiltCommitmentTransaction *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "BuiltCommitmentTransaction_clone_ptr", ()=>BuiltCommitmentTransaction_clone_ptr
);
// struct LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_clone(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "BuiltCommitmentTransaction_clone", ()=>BuiltCommitmentTransaction_clone
);
// struct LDKCVec_u8Z BuiltCommitmentTransaction_write(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "BuiltCommitmentTransaction_write", ()=>BuiltCommitmentTransaction_write
);
// struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ BuiltCommitmentTransaction_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "BuiltCommitmentTransaction_read", ()=>BuiltCommitmentTransaction_read
);
// MUST_USE_RES struct LDKThirtyTwoBytes BuiltCommitmentTransaction_get_sighash_all(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);
/* @internal */ parcelHelpers.export(exports, "BuiltCommitmentTransaction_get_sighash_all", ()=>BuiltCommitmentTransaction_get_sighash_all
);
// MUST_USE_RES struct LDKSignature BuiltCommitmentTransaction_sign(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*funding_key)[32], struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);
/* @internal */ parcelHelpers.export(exports, "BuiltCommitmentTransaction_sign", ()=>BuiltCommitmentTransaction_sign
);
// void ClosingTransaction_free(struct LDKClosingTransaction this_obj);
/* @internal */ parcelHelpers.export(exports, "ClosingTransaction_free", ()=>ClosingTransaction_free
);
// uintptr_t ClosingTransaction_clone_ptr(LDKClosingTransaction *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ClosingTransaction_clone_ptr", ()=>ClosingTransaction_clone_ptr
);
// struct LDKClosingTransaction ClosingTransaction_clone(const struct LDKClosingTransaction *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ClosingTransaction_clone", ()=>ClosingTransaction_clone
);
// uint64_t ClosingTransaction_hash(const struct LDKClosingTransaction *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "ClosingTransaction_hash", ()=>ClosingTransaction_hash
);
// MUST_USE_RES struct LDKClosingTransaction ClosingTransaction_new(uint64_t to_holder_value_sat, uint64_t to_counterparty_value_sat, struct LDKCVec_u8Z to_holder_script, struct LDKCVec_u8Z to_counterparty_script, struct LDKOutPoint funding_outpoint);
/* @internal */ parcelHelpers.export(exports, "ClosingTransaction_new", ()=>ClosingTransaction_new
);
// MUST_USE_RES struct LDKTrustedClosingTransaction ClosingTransaction_trust(const struct LDKClosingTransaction *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ClosingTransaction_trust", ()=>ClosingTransaction_trust
);
// MUST_USE_RES struct LDKCResult_TrustedClosingTransactionNoneZ ClosingTransaction_verify(const struct LDKClosingTransaction *NONNULL_PTR this_arg, struct LDKOutPoint funding_outpoint);
/* @internal */ parcelHelpers.export(exports, "ClosingTransaction_verify", ()=>ClosingTransaction_verify
);
// MUST_USE_RES uint64_t ClosingTransaction_to_holder_value_sat(const struct LDKClosingTransaction *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ClosingTransaction_to_holder_value_sat", ()=>ClosingTransaction_to_holder_value_sat
);
// MUST_USE_RES uint64_t ClosingTransaction_to_counterparty_value_sat(const struct LDKClosingTransaction *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ClosingTransaction_to_counterparty_value_sat", ()=>ClosingTransaction_to_counterparty_value_sat
);
// MUST_USE_RES struct LDKu8slice ClosingTransaction_to_holder_script(const struct LDKClosingTransaction *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ClosingTransaction_to_holder_script", ()=>ClosingTransaction_to_holder_script
);
// MUST_USE_RES struct LDKu8slice ClosingTransaction_to_counterparty_script(const struct LDKClosingTransaction *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ClosingTransaction_to_counterparty_script", ()=>ClosingTransaction_to_counterparty_script
);
// void TrustedClosingTransaction_free(struct LDKTrustedClosingTransaction this_obj);
/* @internal */ parcelHelpers.export(exports, "TrustedClosingTransaction_free", ()=>TrustedClosingTransaction_free
);
// MUST_USE_RES struct LDKTransaction TrustedClosingTransaction_built_transaction(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "TrustedClosingTransaction_built_transaction", ()=>TrustedClosingTransaction_built_transaction
);
// MUST_USE_RES struct LDKThirtyTwoBytes TrustedClosingTransaction_get_sighash_all(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg, struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);
/* @internal */ parcelHelpers.export(exports, "TrustedClosingTransaction_get_sighash_all", ()=>TrustedClosingTransaction_get_sighash_all
);
// MUST_USE_RES struct LDKSignature TrustedClosingTransaction_sign(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg, const uint8_t (*funding_key)[32], struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);
/* @internal */ parcelHelpers.export(exports, "TrustedClosingTransaction_sign", ()=>TrustedClosingTransaction_sign
);
// void CommitmentTransaction_free(struct LDKCommitmentTransaction this_obj);
/* @internal */ parcelHelpers.export(exports, "CommitmentTransaction_free", ()=>CommitmentTransaction_free
);
// uintptr_t CommitmentTransaction_clone_ptr(LDKCommitmentTransaction *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "CommitmentTransaction_clone_ptr", ()=>CommitmentTransaction_clone_ptr
);
// struct LDKCommitmentTransaction CommitmentTransaction_clone(const struct LDKCommitmentTransaction *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "CommitmentTransaction_clone", ()=>CommitmentTransaction_clone
);
// struct LDKCVec_u8Z CommitmentTransaction_write(const struct LDKCommitmentTransaction *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "CommitmentTransaction_write", ()=>CommitmentTransaction_write
);
// struct LDKCResult_CommitmentTransactionDecodeErrorZ CommitmentTransaction_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "CommitmentTransaction_read", ()=>CommitmentTransaction_read
);
// MUST_USE_RES uint64_t CommitmentTransaction_commitment_number(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "CommitmentTransaction_commitment_number", ()=>CommitmentTransaction_commitment_number
);
// MUST_USE_RES uint64_t CommitmentTransaction_to_broadcaster_value_sat(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "CommitmentTransaction_to_broadcaster_value_sat", ()=>CommitmentTransaction_to_broadcaster_value_sat
);
// MUST_USE_RES uint64_t CommitmentTransaction_to_countersignatory_value_sat(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "CommitmentTransaction_to_countersignatory_value_sat", ()=>CommitmentTransaction_to_countersignatory_value_sat
);
// MUST_USE_RES uint32_t CommitmentTransaction_feerate_per_kw(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "CommitmentTransaction_feerate_per_kw", ()=>CommitmentTransaction_feerate_per_kw
);
// MUST_USE_RES struct LDKTrustedCommitmentTransaction CommitmentTransaction_trust(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "CommitmentTransaction_trust", ()=>CommitmentTransaction_trust
);
// MUST_USE_RES struct LDKCResult_TrustedCommitmentTransactionNoneZ CommitmentTransaction_verify(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg, const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR channel_parameters, const struct LDKChannelPublicKeys *NONNULL_PTR broadcaster_keys, const struct LDKChannelPublicKeys *NONNULL_PTR countersignatory_keys);
/* @internal */ parcelHelpers.export(exports, "CommitmentTransaction_verify", ()=>CommitmentTransaction_verify
);
// void TrustedCommitmentTransaction_free(struct LDKTrustedCommitmentTransaction this_obj);
/* @internal */ parcelHelpers.export(exports, "TrustedCommitmentTransaction_free", ()=>TrustedCommitmentTransaction_free
);
// MUST_USE_RES struct LDKThirtyTwoBytes TrustedCommitmentTransaction_txid(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "TrustedCommitmentTransaction_txid", ()=>TrustedCommitmentTransaction_txid
);
// MUST_USE_RES struct LDKBuiltCommitmentTransaction TrustedCommitmentTransaction_built_transaction(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "TrustedCommitmentTransaction_built_transaction", ()=>TrustedCommitmentTransaction_built_transaction
);
// MUST_USE_RES struct LDKTxCreationKeys TrustedCommitmentTransaction_keys(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "TrustedCommitmentTransaction_keys", ()=>TrustedCommitmentTransaction_keys
);
// MUST_USE_RES bool TrustedCommitmentTransaction_opt_anchors(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "TrustedCommitmentTransaction_opt_anchors", ()=>TrustedCommitmentTransaction_opt_anchors
);
// MUST_USE_RES struct LDKCResult_CVec_SignatureZNoneZ TrustedCommitmentTransaction_get_htlc_sigs(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*htlc_base_key)[32], const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR channel_parameters);
/* @internal */ parcelHelpers.export(exports, "TrustedCommitmentTransaction_get_htlc_sigs", ()=>TrustedCommitmentTransaction_get_htlc_sigs
);
// uint64_t get_commitment_transaction_number_obscure_factor(struct LDKPublicKey broadcaster_payment_basepoint, struct LDKPublicKey countersignatory_payment_basepoint, bool outbound_from_broadcaster);
/* @internal */ parcelHelpers.export(exports, "get_commitment_transaction_number_obscure_factor", ()=>get_commitment_transaction_number_obscure_factor
);
// bool InitFeatures_eq(const struct LDKInitFeatures *NONNULL_PTR a, const struct LDKInitFeatures *NONNULL_PTR b);
/* @internal */ parcelHelpers.export(exports, "InitFeatures_eq", ()=>InitFeatures_eq
);
// bool NodeFeatures_eq(const struct LDKNodeFeatures *NONNULL_PTR a, const struct LDKNodeFeatures *NONNULL_PTR b);
/* @internal */ parcelHelpers.export(exports, "NodeFeatures_eq", ()=>NodeFeatures_eq
);
// bool ChannelFeatures_eq(const struct LDKChannelFeatures *NONNULL_PTR a, const struct LDKChannelFeatures *NONNULL_PTR b);
/* @internal */ parcelHelpers.export(exports, "ChannelFeatures_eq", ()=>ChannelFeatures_eq
);
// bool InvoiceFeatures_eq(const struct LDKInvoiceFeatures *NONNULL_PTR a, const struct LDKInvoiceFeatures *NONNULL_PTR b);
/* @internal */ parcelHelpers.export(exports, "InvoiceFeatures_eq", ()=>InvoiceFeatures_eq
);
// bool ChannelTypeFeatures_eq(const struct LDKChannelTypeFeatures *NONNULL_PTR a, const struct LDKChannelTypeFeatures *NONNULL_PTR b);
/* @internal */ parcelHelpers.export(exports, "ChannelTypeFeatures_eq", ()=>ChannelTypeFeatures_eq
);
// uintptr_t InitFeatures_clone_ptr(LDKInitFeatures *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "InitFeatures_clone_ptr", ()=>InitFeatures_clone_ptr
);
// struct LDKInitFeatures InitFeatures_clone(const struct LDKInitFeatures *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "InitFeatures_clone", ()=>InitFeatures_clone
);
// uintptr_t NodeFeatures_clone_ptr(LDKNodeFeatures *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "NodeFeatures_clone_ptr", ()=>NodeFeatures_clone_ptr
);
// struct LDKNodeFeatures NodeFeatures_clone(const struct LDKNodeFeatures *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "NodeFeatures_clone", ()=>NodeFeatures_clone
);
// uintptr_t ChannelFeatures_clone_ptr(LDKChannelFeatures *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ChannelFeatures_clone_ptr", ()=>ChannelFeatures_clone_ptr
);
// struct LDKChannelFeatures ChannelFeatures_clone(const struct LDKChannelFeatures *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChannelFeatures_clone", ()=>ChannelFeatures_clone
);
// uintptr_t InvoiceFeatures_clone_ptr(LDKInvoiceFeatures *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "InvoiceFeatures_clone_ptr", ()=>InvoiceFeatures_clone_ptr
);
// struct LDKInvoiceFeatures InvoiceFeatures_clone(const struct LDKInvoiceFeatures *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "InvoiceFeatures_clone", ()=>InvoiceFeatures_clone
);
// uintptr_t ChannelTypeFeatures_clone_ptr(LDKChannelTypeFeatures *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ChannelTypeFeatures_clone_ptr", ()=>ChannelTypeFeatures_clone_ptr
);
// struct LDKChannelTypeFeatures ChannelTypeFeatures_clone(const struct LDKChannelTypeFeatures *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChannelTypeFeatures_clone", ()=>ChannelTypeFeatures_clone
);
// void InitFeatures_free(struct LDKInitFeatures this_obj);
/* @internal */ parcelHelpers.export(exports, "InitFeatures_free", ()=>InitFeatures_free
);
// void NodeFeatures_free(struct LDKNodeFeatures this_obj);
/* @internal */ parcelHelpers.export(exports, "NodeFeatures_free", ()=>NodeFeatures_free
);
// void ChannelFeatures_free(struct LDKChannelFeatures this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelFeatures_free", ()=>ChannelFeatures_free
);
// void InvoiceFeatures_free(struct LDKInvoiceFeatures this_obj);
/* @internal */ parcelHelpers.export(exports, "InvoiceFeatures_free", ()=>InvoiceFeatures_free
);
// void ChannelTypeFeatures_free(struct LDKChannelTypeFeatures this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelTypeFeatures_free", ()=>ChannelTypeFeatures_free
);
// MUST_USE_RES struct LDKInitFeatures InitFeatures_empty(void);
/* @internal */ parcelHelpers.export(exports, "InitFeatures_empty", ()=>InitFeatures_empty
);
// MUST_USE_RES struct LDKInitFeatures InitFeatures_known(void);
/* @internal */ parcelHelpers.export(exports, "InitFeatures_known", ()=>InitFeatures_known
);
// MUST_USE_RES bool InitFeatures_requires_unknown_bits(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "InitFeatures_requires_unknown_bits", ()=>InitFeatures_requires_unknown_bits
);
// MUST_USE_RES struct LDKNodeFeatures NodeFeatures_empty(void);
/* @internal */ parcelHelpers.export(exports, "NodeFeatures_empty", ()=>NodeFeatures_empty
);
// MUST_USE_RES struct LDKNodeFeatures NodeFeatures_known(void);
/* @internal */ parcelHelpers.export(exports, "NodeFeatures_known", ()=>NodeFeatures_known
);
// MUST_USE_RES bool NodeFeatures_requires_unknown_bits(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "NodeFeatures_requires_unknown_bits", ()=>NodeFeatures_requires_unknown_bits
);
// MUST_USE_RES struct LDKChannelFeatures ChannelFeatures_empty(void);
/* @internal */ parcelHelpers.export(exports, "ChannelFeatures_empty", ()=>ChannelFeatures_empty
);
// MUST_USE_RES struct LDKChannelFeatures ChannelFeatures_known(void);
/* @internal */ parcelHelpers.export(exports, "ChannelFeatures_known", ()=>ChannelFeatures_known
);
// MUST_USE_RES bool ChannelFeatures_requires_unknown_bits(const struct LDKChannelFeatures *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelFeatures_requires_unknown_bits", ()=>ChannelFeatures_requires_unknown_bits
);
// MUST_USE_RES struct LDKInvoiceFeatures InvoiceFeatures_empty(void);
/* @internal */ parcelHelpers.export(exports, "InvoiceFeatures_empty", ()=>InvoiceFeatures_empty
);
// MUST_USE_RES struct LDKInvoiceFeatures InvoiceFeatures_known(void);
/* @internal */ parcelHelpers.export(exports, "InvoiceFeatures_known", ()=>InvoiceFeatures_known
);
// MUST_USE_RES bool InvoiceFeatures_requires_unknown_bits(const struct LDKInvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "InvoiceFeatures_requires_unknown_bits", ()=>InvoiceFeatures_requires_unknown_bits
);
// MUST_USE_RES struct LDKChannelTypeFeatures ChannelTypeFeatures_empty(void);
/* @internal */ parcelHelpers.export(exports, "ChannelTypeFeatures_empty", ()=>ChannelTypeFeatures_empty
);
// MUST_USE_RES struct LDKChannelTypeFeatures ChannelTypeFeatures_known(void);
/* @internal */ parcelHelpers.export(exports, "ChannelTypeFeatures_known", ()=>ChannelTypeFeatures_known
);
// MUST_USE_RES bool ChannelTypeFeatures_requires_unknown_bits(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ChannelTypeFeatures_requires_unknown_bits", ()=>ChannelTypeFeatures_requires_unknown_bits
);
// struct LDKCVec_u8Z InitFeatures_write(const struct LDKInitFeatures *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "InitFeatures_write", ()=>InitFeatures_write
);
// struct LDKCResult_InitFeaturesDecodeErrorZ InitFeatures_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "InitFeatures_read", ()=>InitFeatures_read
);
// struct LDKCVec_u8Z ChannelFeatures_write(const struct LDKChannelFeatures *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ChannelFeatures_write", ()=>ChannelFeatures_write
);
// struct LDKCResult_ChannelFeaturesDecodeErrorZ ChannelFeatures_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ChannelFeatures_read", ()=>ChannelFeatures_read
);
// struct LDKCVec_u8Z NodeFeatures_write(const struct LDKNodeFeatures *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "NodeFeatures_write", ()=>NodeFeatures_write
);
// struct LDKCResult_NodeFeaturesDecodeErrorZ NodeFeatures_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "NodeFeatures_read", ()=>NodeFeatures_read
);
// struct LDKCVec_u8Z InvoiceFeatures_write(const struct LDKInvoiceFeatures *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "InvoiceFeatures_write", ()=>InvoiceFeatures_write
);
// struct LDKCResult_InvoiceFeaturesDecodeErrorZ InvoiceFeatures_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "InvoiceFeatures_read", ()=>InvoiceFeatures_read
);
// struct LDKCVec_u8Z ChannelTypeFeatures_write(const struct LDKChannelTypeFeatures *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ChannelTypeFeatures_write", ()=>ChannelTypeFeatures_write
);
// struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ ChannelTypeFeatures_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ChannelTypeFeatures_read", ()=>ChannelTypeFeatures_read
);
// void ShutdownScript_free(struct LDKShutdownScript this_obj);
/* @internal */ parcelHelpers.export(exports, "ShutdownScript_free", ()=>ShutdownScript_free
);
// uintptr_t ShutdownScript_clone_ptr(LDKShutdownScript *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ShutdownScript_clone_ptr", ()=>ShutdownScript_clone_ptr
);
// struct LDKShutdownScript ShutdownScript_clone(const struct LDKShutdownScript *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ShutdownScript_clone", ()=>ShutdownScript_clone
);
// void InvalidShutdownScript_free(struct LDKInvalidShutdownScript this_obj);
/* @internal */ parcelHelpers.export(exports, "InvalidShutdownScript_free", ()=>InvalidShutdownScript_free
);
// struct LDKu8slice InvalidShutdownScript_get_script(const struct LDKInvalidShutdownScript *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "InvalidShutdownScript_get_script", ()=>InvalidShutdownScript_get_script
);
// void InvalidShutdownScript_set_script(struct LDKInvalidShutdownScript *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);
/* @internal */ parcelHelpers.export(exports, "InvalidShutdownScript_set_script", ()=>InvalidShutdownScript_set_script
);
// MUST_USE_RES struct LDKInvalidShutdownScript InvalidShutdownScript_new(struct LDKCVec_u8Z script_arg);
/* @internal */ parcelHelpers.export(exports, "InvalidShutdownScript_new", ()=>InvalidShutdownScript_new
);
// uintptr_t InvalidShutdownScript_clone_ptr(LDKInvalidShutdownScript *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "InvalidShutdownScript_clone_ptr", ()=>InvalidShutdownScript_clone_ptr
);
// struct LDKInvalidShutdownScript InvalidShutdownScript_clone(const struct LDKInvalidShutdownScript *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "InvalidShutdownScript_clone", ()=>InvalidShutdownScript_clone
);
// struct LDKCVec_u8Z ShutdownScript_write(const struct LDKShutdownScript *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ShutdownScript_write", ()=>ShutdownScript_write
);
// struct LDKCResult_ShutdownScriptDecodeErrorZ ShutdownScript_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ShutdownScript_read", ()=>ShutdownScript_read
);
// MUST_USE_RES struct LDKShutdownScript ShutdownScript_new_p2wpkh(const uint8_t (*pubkey_hash)[20]);
/* @internal */ parcelHelpers.export(exports, "ShutdownScript_new_p2wpkh", ()=>ShutdownScript_new_p2wpkh
);
// MUST_USE_RES struct LDKShutdownScript ShutdownScript_new_p2wsh(const uint8_t (*script_hash)[32]);
/* @internal */ parcelHelpers.export(exports, "ShutdownScript_new_p2wsh", ()=>ShutdownScript_new_p2wsh
);
// MUST_USE_RES struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ ShutdownScript_new_witness_program(uint8_t version, struct LDKu8slice program);
/* @internal */ parcelHelpers.export(exports, "ShutdownScript_new_witness_program", ()=>ShutdownScript_new_witness_program
);
// MUST_USE_RES struct LDKCVec_u8Z ShutdownScript_into_inner(struct LDKShutdownScript this_arg);
/* @internal */ parcelHelpers.export(exports, "ShutdownScript_into_inner", ()=>ShutdownScript_into_inner
);
// MUST_USE_RES struct LDKPublicKey ShutdownScript_as_legacy_pubkey(const struct LDKShutdownScript *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "ShutdownScript_as_legacy_pubkey", ()=>ShutdownScript_as_legacy_pubkey
);
// MUST_USE_RES bool ShutdownScript_is_compatible(const struct LDKShutdownScript *NONNULL_PTR this_arg, const struct LDKInitFeatures *NONNULL_PTR features);
/* @internal */ parcelHelpers.export(exports, "ShutdownScript_is_compatible", ()=>ShutdownScript_is_compatible
);
// void CustomMessageReader_free(struct LDKCustomMessageReader this_ptr);
/* @internal */ parcelHelpers.export(exports, "CustomMessageReader_free", ()=>CustomMessageReader_free
);
// uintptr_t Type_clone_ptr(LDKType *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "Type_clone_ptr", ()=>Type_clone_ptr
);
// struct LDKType Type_clone(const struct LDKType *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "Type_clone", ()=>Type_clone
);
// void Type_free(struct LDKType this_ptr);
/* @internal */ parcelHelpers.export(exports, "Type_free", ()=>Type_free
);
// void NodeId_free(struct LDKNodeId this_obj);
/* @internal */ parcelHelpers.export(exports, "NodeId_free", ()=>NodeId_free
);
// uintptr_t NodeId_clone_ptr(LDKNodeId *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "NodeId_clone_ptr", ()=>NodeId_clone_ptr
);
// struct LDKNodeId NodeId_clone(const struct LDKNodeId *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "NodeId_clone", ()=>NodeId_clone
);
// MUST_USE_RES struct LDKNodeId NodeId_from_pubkey(struct LDKPublicKey pubkey);
/* @internal */ parcelHelpers.export(exports, "NodeId_from_pubkey", ()=>NodeId_from_pubkey
);
// MUST_USE_RES struct LDKu8slice NodeId_as_slice(const struct LDKNodeId *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "NodeId_as_slice", ()=>NodeId_as_slice
);
// uint64_t NodeId_hash(const struct LDKNodeId *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "NodeId_hash", ()=>NodeId_hash
);
// struct LDKCVec_u8Z NodeId_write(const struct LDKNodeId *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "NodeId_write", ()=>NodeId_write
);
// struct LDKCResult_NodeIdDecodeErrorZ NodeId_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "NodeId_read", ()=>NodeId_read
);
// void NetworkGraph_free(struct LDKNetworkGraph this_obj);
/* @internal */ parcelHelpers.export(exports, "NetworkGraph_free", ()=>NetworkGraph_free
);
// uintptr_t NetworkGraph_clone_ptr(LDKNetworkGraph *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "NetworkGraph_clone_ptr", ()=>NetworkGraph_clone_ptr
);
// struct LDKNetworkGraph NetworkGraph_clone(const struct LDKNetworkGraph *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "NetworkGraph_clone", ()=>NetworkGraph_clone
);
// void ReadOnlyNetworkGraph_free(struct LDKReadOnlyNetworkGraph this_obj);
/* @internal */ parcelHelpers.export(exports, "ReadOnlyNetworkGraph_free", ()=>ReadOnlyNetworkGraph_free
);
// void NetworkUpdate_free(struct LDKNetworkUpdate this_ptr);
/* @internal */ parcelHelpers.export(exports, "NetworkUpdate_free", ()=>NetworkUpdate_free
);
// uintptr_t NetworkUpdate_clone_ptr(LDKNetworkUpdate *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "NetworkUpdate_clone_ptr", ()=>NetworkUpdate_clone_ptr
);
// struct LDKNetworkUpdate NetworkUpdate_clone(const struct LDKNetworkUpdate *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "NetworkUpdate_clone", ()=>NetworkUpdate_clone
);
// struct LDKNetworkUpdate NetworkUpdate_channel_update_message(struct LDKChannelUpdate msg);
/* @internal */ parcelHelpers.export(exports, "NetworkUpdate_channel_update_message", ()=>NetworkUpdate_channel_update_message
);
// struct LDKNetworkUpdate NetworkUpdate_channel_closed(uint64_t short_channel_id, bool is_permanent);
/* @internal */ parcelHelpers.export(exports, "NetworkUpdate_channel_closed", ()=>NetworkUpdate_channel_closed
);
// struct LDKNetworkUpdate NetworkUpdate_node_failure(struct LDKPublicKey node_id, bool is_permanent);
/* @internal */ parcelHelpers.export(exports, "NetworkUpdate_node_failure", ()=>NetworkUpdate_node_failure
);
// struct LDKCVec_u8Z NetworkUpdate_write(const struct LDKNetworkUpdate *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "NetworkUpdate_write", ()=>NetworkUpdate_write
);
// struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ NetworkUpdate_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "NetworkUpdate_read", ()=>NetworkUpdate_read
);
// struct LDKEventHandler NetGraphMsgHandler_as_EventHandler(const struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "NetGraphMsgHandler_as_EventHandler", ()=>NetGraphMsgHandler_as_EventHandler
);
// void NetGraphMsgHandler_free(struct LDKNetGraphMsgHandler this_obj);
/* @internal */ parcelHelpers.export(exports, "NetGraphMsgHandler_free", ()=>NetGraphMsgHandler_free
);
// MUST_USE_RES struct LDKNetGraphMsgHandler NetGraphMsgHandler_new(const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKCOption_AccessZ chain_access, struct LDKLogger logger);
/* @internal */ parcelHelpers.export(exports, "NetGraphMsgHandler_new", ()=>NetGraphMsgHandler_new
);
// void NetGraphMsgHandler_add_chain_access(struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg, struct LDKCOption_AccessZ chain_access);
/* @internal */ parcelHelpers.export(exports, "NetGraphMsgHandler_add_chain_access", ()=>NetGraphMsgHandler_add_chain_access
);
// struct LDKRoutingMessageHandler NetGraphMsgHandler_as_RoutingMessageHandler(const struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "NetGraphMsgHandler_as_RoutingMessageHandler", ()=>NetGraphMsgHandler_as_RoutingMessageHandler
);
// struct LDKMessageSendEventsProvider NetGraphMsgHandler_as_MessageSendEventsProvider(const struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "NetGraphMsgHandler_as_MessageSendEventsProvider", ()=>NetGraphMsgHandler_as_MessageSendEventsProvider
);
// void DirectionalChannelInfo_free(struct LDKDirectionalChannelInfo this_obj);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_free", ()=>DirectionalChannelInfo_free
);
// uint32_t DirectionalChannelInfo_get_last_update(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_get_last_update", ()=>DirectionalChannelInfo_get_last_update
);
// void DirectionalChannelInfo_set_last_update(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_set_last_update", ()=>DirectionalChannelInfo_set_last_update
);
// bool DirectionalChannelInfo_get_enabled(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_get_enabled", ()=>DirectionalChannelInfo_get_enabled
);
// void DirectionalChannelInfo_set_enabled(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, bool val);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_set_enabled", ()=>DirectionalChannelInfo_set_enabled
);
// uint16_t DirectionalChannelInfo_get_cltv_expiry_delta(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_get_cltv_expiry_delta", ()=>DirectionalChannelInfo_get_cltv_expiry_delta
);
// void DirectionalChannelInfo_set_cltv_expiry_delta(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_set_cltv_expiry_delta", ()=>DirectionalChannelInfo_set_cltv_expiry_delta
);
// uint64_t DirectionalChannelInfo_get_htlc_minimum_msat(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_get_htlc_minimum_msat", ()=>DirectionalChannelInfo_get_htlc_minimum_msat
);
// void DirectionalChannelInfo_set_htlc_minimum_msat(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_set_htlc_minimum_msat", ()=>DirectionalChannelInfo_set_htlc_minimum_msat
);
// struct LDKCOption_u64Z DirectionalChannelInfo_get_htlc_maximum_msat(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_get_htlc_maximum_msat", ()=>DirectionalChannelInfo_get_htlc_maximum_msat
);
// void DirectionalChannelInfo_set_htlc_maximum_msat(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_set_htlc_maximum_msat", ()=>DirectionalChannelInfo_set_htlc_maximum_msat
);
// struct LDKRoutingFees DirectionalChannelInfo_get_fees(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_get_fees", ()=>DirectionalChannelInfo_get_fees
);
// void DirectionalChannelInfo_set_fees(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, struct LDKRoutingFees val);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_set_fees", ()=>DirectionalChannelInfo_set_fees
);
// struct LDKChannelUpdate DirectionalChannelInfo_get_last_update_message(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_get_last_update_message", ()=>DirectionalChannelInfo_get_last_update_message
);
// void DirectionalChannelInfo_set_last_update_message(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdate val);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_set_last_update_message", ()=>DirectionalChannelInfo_set_last_update_message
);
// MUST_USE_RES struct LDKDirectionalChannelInfo DirectionalChannelInfo_new(uint32_t last_update_arg, bool enabled_arg, uint16_t cltv_expiry_delta_arg, uint64_t htlc_minimum_msat_arg, struct LDKCOption_u64Z htlc_maximum_msat_arg, struct LDKRoutingFees fees_arg, struct LDKChannelUpdate last_update_message_arg);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_new", ()=>DirectionalChannelInfo_new
);
// uintptr_t DirectionalChannelInfo_clone_ptr(LDKDirectionalChannelInfo *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_clone_ptr", ()=>DirectionalChannelInfo_clone_ptr
);
// struct LDKDirectionalChannelInfo DirectionalChannelInfo_clone(const struct LDKDirectionalChannelInfo *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_clone", ()=>DirectionalChannelInfo_clone
);
// struct LDKCVec_u8Z DirectionalChannelInfo_write(const struct LDKDirectionalChannelInfo *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_write", ()=>DirectionalChannelInfo_write
);
// struct LDKCResult_DirectionalChannelInfoDecodeErrorZ DirectionalChannelInfo_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "DirectionalChannelInfo_read", ()=>DirectionalChannelInfo_read
);
// void ChannelInfo_free(struct LDKChannelInfo this_obj);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_free", ()=>ChannelInfo_free
);
// struct LDKChannelFeatures ChannelInfo_get_features(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_get_features", ()=>ChannelInfo_get_features
);
// void ChannelInfo_set_features(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_set_features", ()=>ChannelInfo_set_features
);
// struct LDKNodeId ChannelInfo_get_node_one(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_get_node_one", ()=>ChannelInfo_get_node_one
);
// void ChannelInfo_set_node_one(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKNodeId val);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_set_node_one", ()=>ChannelInfo_set_node_one
);
// struct LDKDirectionalChannelInfo ChannelInfo_get_one_to_two(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_get_one_to_two", ()=>ChannelInfo_get_one_to_two
);
// void ChannelInfo_set_one_to_two(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKDirectionalChannelInfo val);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_set_one_to_two", ()=>ChannelInfo_set_one_to_two
);
// struct LDKNodeId ChannelInfo_get_node_two(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_get_node_two", ()=>ChannelInfo_get_node_two
);
// void ChannelInfo_set_node_two(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKNodeId val);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_set_node_two", ()=>ChannelInfo_set_node_two
);
// struct LDKDirectionalChannelInfo ChannelInfo_get_two_to_one(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_get_two_to_one", ()=>ChannelInfo_get_two_to_one
);
// void ChannelInfo_set_two_to_one(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKDirectionalChannelInfo val);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_set_two_to_one", ()=>ChannelInfo_set_two_to_one
);
// struct LDKCOption_u64Z ChannelInfo_get_capacity_sats(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_get_capacity_sats", ()=>ChannelInfo_get_capacity_sats
);
// void ChannelInfo_set_capacity_sats(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_set_capacity_sats", ()=>ChannelInfo_set_capacity_sats
);
// struct LDKChannelAnnouncement ChannelInfo_get_announcement_message(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_get_announcement_message", ()=>ChannelInfo_get_announcement_message
);
// void ChannelInfo_set_announcement_message(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelAnnouncement val);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_set_announcement_message", ()=>ChannelInfo_set_announcement_message
);
// uintptr_t ChannelInfo_clone_ptr(LDKChannelInfo *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_clone_ptr", ()=>ChannelInfo_clone_ptr
);
// struct LDKChannelInfo ChannelInfo_clone(const struct LDKChannelInfo *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_clone", ()=>ChannelInfo_clone
);
// struct LDKCVec_u8Z ChannelInfo_write(const struct LDKChannelInfo *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_write", ()=>ChannelInfo_write
);
// struct LDKCResult_ChannelInfoDecodeErrorZ ChannelInfo_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ChannelInfo_read", ()=>ChannelInfo_read
);
// void RoutingFees_free(struct LDKRoutingFees this_obj);
/* @internal */ parcelHelpers.export(exports, "RoutingFees_free", ()=>RoutingFees_free
);
// uint32_t RoutingFees_get_base_msat(const struct LDKRoutingFees *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RoutingFees_get_base_msat", ()=>RoutingFees_get_base_msat
);
// void RoutingFees_set_base_msat(struct LDKRoutingFees *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "RoutingFees_set_base_msat", ()=>RoutingFees_set_base_msat
);
// uint32_t RoutingFees_get_proportional_millionths(const struct LDKRoutingFees *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RoutingFees_get_proportional_millionths", ()=>RoutingFees_get_proportional_millionths
);
// void RoutingFees_set_proportional_millionths(struct LDKRoutingFees *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "RoutingFees_set_proportional_millionths", ()=>RoutingFees_set_proportional_millionths
);
// MUST_USE_RES struct LDKRoutingFees RoutingFees_new(uint32_t base_msat_arg, uint32_t proportional_millionths_arg);
/* @internal */ parcelHelpers.export(exports, "RoutingFees_new", ()=>RoutingFees_new
);
// bool RoutingFees_eq(const struct LDKRoutingFees *NONNULL_PTR a, const struct LDKRoutingFees *NONNULL_PTR b);
/* @internal */ parcelHelpers.export(exports, "RoutingFees_eq", ()=>RoutingFees_eq
);
// uintptr_t RoutingFees_clone_ptr(LDKRoutingFees *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "RoutingFees_clone_ptr", ()=>RoutingFees_clone_ptr
);
// struct LDKRoutingFees RoutingFees_clone(const struct LDKRoutingFees *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "RoutingFees_clone", ()=>RoutingFees_clone
);
// uint64_t RoutingFees_hash(const struct LDKRoutingFees *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "RoutingFees_hash", ()=>RoutingFees_hash
);
// struct LDKCVec_u8Z RoutingFees_write(const struct LDKRoutingFees *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "RoutingFees_write", ()=>RoutingFees_write
);
// struct LDKCResult_RoutingFeesDecodeErrorZ RoutingFees_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "RoutingFees_read", ()=>RoutingFees_read
);
// void NodeAnnouncementInfo_free(struct LDKNodeAnnouncementInfo this_obj);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_free", ()=>NodeAnnouncementInfo_free
);
// struct LDKNodeFeatures NodeAnnouncementInfo_get_features(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_get_features", ()=>NodeAnnouncementInfo_get_features
);
// void NodeAnnouncementInfo_set_features(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_set_features", ()=>NodeAnnouncementInfo_set_features
);
// uint32_t NodeAnnouncementInfo_get_last_update(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_get_last_update", ()=>NodeAnnouncementInfo_get_last_update
);
// void NodeAnnouncementInfo_set_last_update(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_set_last_update", ()=>NodeAnnouncementInfo_set_last_update
);
// const uint8_t (*NodeAnnouncementInfo_get_rgb(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr))[3];
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_get_rgb", ()=>NodeAnnouncementInfo_get_rgb
);
// void NodeAnnouncementInfo_set_rgb(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKThreeBytes val);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_set_rgb", ()=>NodeAnnouncementInfo_set_rgb
);
// const uint8_t (*NodeAnnouncementInfo_get_alias(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr))[32];
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_get_alias", ()=>NodeAnnouncementInfo_get_alias
);
// void NodeAnnouncementInfo_set_alias(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_set_alias", ()=>NodeAnnouncementInfo_set_alias
);
// void NodeAnnouncementInfo_set_addresses(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKCVec_NetAddressZ val);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_set_addresses", ()=>NodeAnnouncementInfo_set_addresses
);
// struct LDKNodeAnnouncement NodeAnnouncementInfo_get_announcement_message(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_get_announcement_message", ()=>NodeAnnouncementInfo_get_announcement_message
);
// void NodeAnnouncementInfo_set_announcement_message(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeAnnouncement val);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_set_announcement_message", ()=>NodeAnnouncementInfo_set_announcement_message
);
// MUST_USE_RES struct LDKNodeAnnouncementInfo NodeAnnouncementInfo_new(struct LDKNodeFeatures features_arg, uint32_t last_update_arg, struct LDKThreeBytes rgb_arg, struct LDKThirtyTwoBytes alias_arg, struct LDKCVec_NetAddressZ addresses_arg, struct LDKNodeAnnouncement announcement_message_arg);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_new", ()=>NodeAnnouncementInfo_new
);
// uintptr_t NodeAnnouncementInfo_clone_ptr(LDKNodeAnnouncementInfo *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_clone_ptr", ()=>NodeAnnouncementInfo_clone_ptr
);
// struct LDKNodeAnnouncementInfo NodeAnnouncementInfo_clone(const struct LDKNodeAnnouncementInfo *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_clone", ()=>NodeAnnouncementInfo_clone
);
// struct LDKCVec_u8Z NodeAnnouncementInfo_write(const struct LDKNodeAnnouncementInfo *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_write", ()=>NodeAnnouncementInfo_write
);
// struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ NodeAnnouncementInfo_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "NodeAnnouncementInfo_read", ()=>NodeAnnouncementInfo_read
);
// void NodeInfo_free(struct LDKNodeInfo this_obj);
/* @internal */ parcelHelpers.export(exports, "NodeInfo_free", ()=>NodeInfo_free
);
// void NodeInfo_set_channels(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);
/* @internal */ parcelHelpers.export(exports, "NodeInfo_set_channels", ()=>NodeInfo_set_channels
);
// struct LDKRoutingFees NodeInfo_get_lowest_inbound_channel_fees(const struct LDKNodeInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "NodeInfo_get_lowest_inbound_channel_fees", ()=>NodeInfo_get_lowest_inbound_channel_fees
);
// void NodeInfo_set_lowest_inbound_channel_fees(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKRoutingFees val);
/* @internal */ parcelHelpers.export(exports, "NodeInfo_set_lowest_inbound_channel_fees", ()=>NodeInfo_set_lowest_inbound_channel_fees
);
// struct LDKNodeAnnouncementInfo NodeInfo_get_announcement_info(const struct LDKNodeInfo *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "NodeInfo_get_announcement_info", ()=>NodeInfo_get_announcement_info
);
// void NodeInfo_set_announcement_info(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKNodeAnnouncementInfo val);
/* @internal */ parcelHelpers.export(exports, "NodeInfo_set_announcement_info", ()=>NodeInfo_set_announcement_info
);
// MUST_USE_RES struct LDKNodeInfo NodeInfo_new(struct LDKCVec_u64Z channels_arg, struct LDKRoutingFees lowest_inbound_channel_fees_arg, struct LDKNodeAnnouncementInfo announcement_info_arg);
/* @internal */ parcelHelpers.export(exports, "NodeInfo_new", ()=>NodeInfo_new
);
// uintptr_t NodeInfo_clone_ptr(LDKNodeInfo *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "NodeInfo_clone_ptr", ()=>NodeInfo_clone_ptr
);
// struct LDKNodeInfo NodeInfo_clone(const struct LDKNodeInfo *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "NodeInfo_clone", ()=>NodeInfo_clone
);
// struct LDKCVec_u8Z NodeInfo_write(const struct LDKNodeInfo *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "NodeInfo_write", ()=>NodeInfo_write
);
// struct LDKCResult_NodeInfoDecodeErrorZ NodeInfo_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "NodeInfo_read", ()=>NodeInfo_read
);
// struct LDKCVec_u8Z NetworkGraph_write(const struct LDKNetworkGraph *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "NetworkGraph_write", ()=>NetworkGraph_write
);
// struct LDKCResult_NetworkGraphDecodeErrorZ NetworkGraph_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "NetworkGraph_read", ()=>NetworkGraph_read
);
// MUST_USE_RES struct LDKNetworkGraph NetworkGraph_new(struct LDKThirtyTwoBytes genesis_hash);
/* @internal */ parcelHelpers.export(exports, "NetworkGraph_new", ()=>NetworkGraph_new
);
// MUST_USE_RES struct LDKReadOnlyNetworkGraph NetworkGraph_read_only(const struct LDKNetworkGraph *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "NetworkGraph_read_only", ()=>NetworkGraph_read_only
);
// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKNodeAnnouncement *NONNULL_PTR msg);
/* @internal */ parcelHelpers.export(exports, "NetworkGraph_update_node_from_announcement", ()=>NetworkGraph_update_node_from_announcement
);
// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_unsigned_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR msg);
/* @internal */ parcelHelpers.export(exports, "NetworkGraph_update_node_from_unsigned_announcement", ()=>NetworkGraph_update_node_from_unsigned_announcement
);
// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg, struct LDKCOption_AccessZ chain_access);
/* @internal */ parcelHelpers.export(exports, "NetworkGraph_update_channel_from_announcement", ()=>NetworkGraph_update_channel_from_announcement
);
// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_unsigned_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR msg, struct LDKCOption_AccessZ chain_access);
/* @internal */ parcelHelpers.export(exports, "NetworkGraph_update_channel_from_unsigned_announcement", ()=>NetworkGraph_update_channel_from_unsigned_announcement
);
// void NetworkGraph_close_channel_from_update(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t short_channel_id, bool is_permanent);
/* @internal */ parcelHelpers.export(exports, "NetworkGraph_close_channel_from_update", ()=>NetworkGraph_close_channel_from_update
);
// void NetworkGraph_fail_node(const struct LDKNetworkGraph *NONNULL_PTR this_arg, struct LDKPublicKey _node_id, bool is_permanent);
/* @internal */ parcelHelpers.export(exports, "NetworkGraph_fail_node", ()=>NetworkGraph_fail_node
);
// void NetworkGraph_remove_stale_channels_with_time(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t current_time_unix);
/* @internal */ parcelHelpers.export(exports, "NetworkGraph_remove_stale_channels_with_time", ()=>NetworkGraph_remove_stale_channels_with_time
);
// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelUpdate *NONNULL_PTR msg);
/* @internal */ parcelHelpers.export(exports, "NetworkGraph_update_channel", ()=>NetworkGraph_update_channel
);
// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_unsigned(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedChannelUpdate *NONNULL_PTR msg);
/* @internal */ parcelHelpers.export(exports, "NetworkGraph_update_channel_unsigned", ()=>NetworkGraph_update_channel_unsigned
);
// MUST_USE_RES struct LDKCOption_CVec_NetAddressZZ ReadOnlyNetworkGraph_get_addresses(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg, struct LDKPublicKey pubkey);
/* @internal */ parcelHelpers.export(exports, "ReadOnlyNetworkGraph_get_addresses", ()=>ReadOnlyNetworkGraph_get_addresses
);
// void RouteHop_free(struct LDKRouteHop this_obj);
/* @internal */ parcelHelpers.export(exports, "RouteHop_free", ()=>RouteHop_free
);
// struct LDKPublicKey RouteHop_get_pubkey(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RouteHop_get_pubkey", ()=>RouteHop_get_pubkey
);
// void RouteHop_set_pubkey(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "RouteHop_set_pubkey", ()=>RouteHop_set_pubkey
);
// struct LDKNodeFeatures RouteHop_get_node_features(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RouteHop_get_node_features", ()=>RouteHop_get_node_features
);
// void RouteHop_set_node_features(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);
/* @internal */ parcelHelpers.export(exports, "RouteHop_set_node_features", ()=>RouteHop_set_node_features
);
// uint64_t RouteHop_get_short_channel_id(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RouteHop_get_short_channel_id", ()=>RouteHop_get_short_channel_id
);
// void RouteHop_set_short_channel_id(struct LDKRouteHop *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "RouteHop_set_short_channel_id", ()=>RouteHop_set_short_channel_id
);
// struct LDKChannelFeatures RouteHop_get_channel_features(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RouteHop_get_channel_features", ()=>RouteHop_get_channel_features
);
// void RouteHop_set_channel_features(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);
/* @internal */ parcelHelpers.export(exports, "RouteHop_set_channel_features", ()=>RouteHop_set_channel_features
);
// uint64_t RouteHop_get_fee_msat(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RouteHop_get_fee_msat", ()=>RouteHop_get_fee_msat
);
// void RouteHop_set_fee_msat(struct LDKRouteHop *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "RouteHop_set_fee_msat", ()=>RouteHop_set_fee_msat
);
// uint32_t RouteHop_get_cltv_expiry_delta(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RouteHop_get_cltv_expiry_delta", ()=>RouteHop_get_cltv_expiry_delta
);
// void RouteHop_set_cltv_expiry_delta(struct LDKRouteHop *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "RouteHop_set_cltv_expiry_delta", ()=>RouteHop_set_cltv_expiry_delta
);
// MUST_USE_RES struct LDKRouteHop RouteHop_new(struct LDKPublicKey pubkey_arg, struct LDKNodeFeatures node_features_arg, uint64_t short_channel_id_arg, struct LDKChannelFeatures channel_features_arg, uint64_t fee_msat_arg, uint32_t cltv_expiry_delta_arg);
/* @internal */ parcelHelpers.export(exports, "RouteHop_new", ()=>RouteHop_new
);
// uintptr_t RouteHop_clone_ptr(LDKRouteHop *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "RouteHop_clone_ptr", ()=>RouteHop_clone_ptr
);
// struct LDKRouteHop RouteHop_clone(const struct LDKRouteHop *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "RouteHop_clone", ()=>RouteHop_clone
);
// uint64_t RouteHop_hash(const struct LDKRouteHop *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "RouteHop_hash", ()=>RouteHop_hash
);
// bool RouteHop_eq(const struct LDKRouteHop *NONNULL_PTR a, const struct LDKRouteHop *NONNULL_PTR b);
/* @internal */ parcelHelpers.export(exports, "RouteHop_eq", ()=>RouteHop_eq
);
// struct LDKCVec_u8Z RouteHop_write(const struct LDKRouteHop *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "RouteHop_write", ()=>RouteHop_write
);
// struct LDKCResult_RouteHopDecodeErrorZ RouteHop_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "RouteHop_read", ()=>RouteHop_read
);
// void Route_free(struct LDKRoute this_obj);
/* @internal */ parcelHelpers.export(exports, "Route_free", ()=>Route_free
);
// struct LDKCVec_CVec_RouteHopZZ Route_get_paths(const struct LDKRoute *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "Route_get_paths", ()=>Route_get_paths
);
// void Route_set_paths(struct LDKRoute *NONNULL_PTR this_ptr, struct LDKCVec_CVec_RouteHopZZ val);
/* @internal */ parcelHelpers.export(exports, "Route_set_paths", ()=>Route_set_paths
);
// struct LDKPayee Route_get_payee(const struct LDKRoute *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "Route_get_payee", ()=>Route_get_payee
);
// void Route_set_payee(struct LDKRoute *NONNULL_PTR this_ptr, struct LDKPayee val);
/* @internal */ parcelHelpers.export(exports, "Route_set_payee", ()=>Route_set_payee
);
// MUST_USE_RES struct LDKRoute Route_new(struct LDKCVec_CVec_RouteHopZZ paths_arg, struct LDKPayee payee_arg);
/* @internal */ parcelHelpers.export(exports, "Route_new", ()=>Route_new
);
// uintptr_t Route_clone_ptr(LDKRoute *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "Route_clone_ptr", ()=>Route_clone_ptr
);
// struct LDKRoute Route_clone(const struct LDKRoute *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "Route_clone", ()=>Route_clone
);
// uint64_t Route_hash(const struct LDKRoute *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "Route_hash", ()=>Route_hash
);
// bool Route_eq(const struct LDKRoute *NONNULL_PTR a, const struct LDKRoute *NONNULL_PTR b);
/* @internal */ parcelHelpers.export(exports, "Route_eq", ()=>Route_eq
);
// MUST_USE_RES uint64_t Route_get_total_fees(const struct LDKRoute *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "Route_get_total_fees", ()=>Route_get_total_fees
);
// MUST_USE_RES uint64_t Route_get_total_amount(const struct LDKRoute *NONNULL_PTR this_arg);
/* @internal */ parcelHelpers.export(exports, "Route_get_total_amount", ()=>Route_get_total_amount
);
// struct LDKCVec_u8Z Route_write(const struct LDKRoute *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "Route_write", ()=>Route_write
);
// struct LDKCResult_RouteDecodeErrorZ Route_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "Route_read", ()=>Route_read
);
// void RouteParameters_free(struct LDKRouteParameters this_obj);
/* @internal */ parcelHelpers.export(exports, "RouteParameters_free", ()=>RouteParameters_free
);
// struct LDKPayee RouteParameters_get_payee(const struct LDKRouteParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RouteParameters_get_payee", ()=>RouteParameters_get_payee
);
// void RouteParameters_set_payee(struct LDKRouteParameters *NONNULL_PTR this_ptr, struct LDKPayee val);
/* @internal */ parcelHelpers.export(exports, "RouteParameters_set_payee", ()=>RouteParameters_set_payee
);
// uint64_t RouteParameters_get_final_value_msat(const struct LDKRouteParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RouteParameters_get_final_value_msat", ()=>RouteParameters_get_final_value_msat
);
// void RouteParameters_set_final_value_msat(struct LDKRouteParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "RouteParameters_set_final_value_msat", ()=>RouteParameters_set_final_value_msat
);
// uint32_t RouteParameters_get_final_cltv_expiry_delta(const struct LDKRouteParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RouteParameters_get_final_cltv_expiry_delta", ()=>RouteParameters_get_final_cltv_expiry_delta
);
// void RouteParameters_set_final_cltv_expiry_delta(struct LDKRouteParameters *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */ parcelHelpers.export(exports, "RouteParameters_set_final_cltv_expiry_delta", ()=>RouteParameters_set_final_cltv_expiry_delta
);
// MUST_USE_RES struct LDKRouteParameters RouteParameters_new(struct LDKPayee payee_arg, uint64_t final_value_msat_arg, uint32_t final_cltv_expiry_delta_arg);
/* @internal */ parcelHelpers.export(exports, "RouteParameters_new", ()=>RouteParameters_new
);
// uintptr_t RouteParameters_clone_ptr(LDKRouteParameters *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "RouteParameters_clone_ptr", ()=>RouteParameters_clone_ptr
);
// struct LDKRouteParameters RouteParameters_clone(const struct LDKRouteParameters *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "RouteParameters_clone", ()=>RouteParameters_clone
);
// struct LDKCVec_u8Z RouteParameters_write(const struct LDKRouteParameters *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "RouteParameters_write", ()=>RouteParameters_write
);
// struct LDKCResult_RouteParametersDecodeErrorZ RouteParameters_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "RouteParameters_read", ()=>RouteParameters_read
);
// void Payee_free(struct LDKPayee this_obj);
/* @internal */ parcelHelpers.export(exports, "Payee_free", ()=>Payee_free
);
// struct LDKPublicKey Payee_get_pubkey(const struct LDKPayee *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "Payee_get_pubkey", ()=>Payee_get_pubkey
);
// void Payee_set_pubkey(struct LDKPayee *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "Payee_set_pubkey", ()=>Payee_set_pubkey
);
// struct LDKInvoiceFeatures Payee_get_features(const struct LDKPayee *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "Payee_get_features", ()=>Payee_get_features
);
// void Payee_set_features(struct LDKPayee *NONNULL_PTR this_ptr, struct LDKInvoiceFeatures val);
/* @internal */ parcelHelpers.export(exports, "Payee_set_features", ()=>Payee_set_features
);
// struct LDKCVec_RouteHintZ Payee_get_route_hints(const struct LDKPayee *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "Payee_get_route_hints", ()=>Payee_get_route_hints
);
// void Payee_set_route_hints(struct LDKPayee *NONNULL_PTR this_ptr, struct LDKCVec_RouteHintZ val);
/* @internal */ parcelHelpers.export(exports, "Payee_set_route_hints", ()=>Payee_set_route_hints
);
// struct LDKCOption_u64Z Payee_get_expiry_time(const struct LDKPayee *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "Payee_get_expiry_time", ()=>Payee_get_expiry_time
);
// void Payee_set_expiry_time(struct LDKPayee *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */ parcelHelpers.export(exports, "Payee_set_expiry_time", ()=>Payee_set_expiry_time
);
// MUST_USE_RES struct LDKPayee Payee_new(struct LDKPublicKey pubkey_arg, struct LDKInvoiceFeatures features_arg, struct LDKCVec_RouteHintZ route_hints_arg, struct LDKCOption_u64Z expiry_time_arg);
/* @internal */ parcelHelpers.export(exports, "Payee_new", ()=>Payee_new
);
// uintptr_t Payee_clone_ptr(LDKPayee *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "Payee_clone_ptr", ()=>Payee_clone_ptr
);
// struct LDKPayee Payee_clone(const struct LDKPayee *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "Payee_clone", ()=>Payee_clone
);
// uint64_t Payee_hash(const struct LDKPayee *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "Payee_hash", ()=>Payee_hash
);
// bool Payee_eq(const struct LDKPayee *NONNULL_PTR a, const struct LDKPayee *NONNULL_PTR b);
/* @internal */ parcelHelpers.export(exports, "Payee_eq", ()=>Payee_eq
);
// struct LDKCVec_u8Z Payee_write(const struct LDKPayee *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "Payee_write", ()=>Payee_write
);
// struct LDKCResult_PayeeDecodeErrorZ Payee_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "Payee_read", ()=>Payee_read
);
// MUST_USE_RES struct LDKPayee Payee_from_node_id(struct LDKPublicKey pubkey);
/* @internal */ parcelHelpers.export(exports, "Payee_from_node_id", ()=>Payee_from_node_id
);
// MUST_USE_RES struct LDKPayee Payee_for_keysend(struct LDKPublicKey pubkey);
/* @internal */ parcelHelpers.export(exports, "Payee_for_keysend", ()=>Payee_for_keysend
);
// void RouteHint_free(struct LDKRouteHint this_obj);
/* @internal */ parcelHelpers.export(exports, "RouteHint_free", ()=>RouteHint_free
);
// struct LDKCVec_RouteHintHopZ RouteHint_get_a(const struct LDKRouteHint *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RouteHint_get_a", ()=>RouteHint_get_a
);
// void RouteHint_set_a(struct LDKRouteHint *NONNULL_PTR this_ptr, struct LDKCVec_RouteHintHopZ val);
/* @internal */ parcelHelpers.export(exports, "RouteHint_set_a", ()=>RouteHint_set_a
);
// MUST_USE_RES struct LDKRouteHint RouteHint_new(struct LDKCVec_RouteHintHopZ a_arg);
/* @internal */ parcelHelpers.export(exports, "RouteHint_new", ()=>RouteHint_new
);
// uintptr_t RouteHint_clone_ptr(LDKRouteHint *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "RouteHint_clone_ptr", ()=>RouteHint_clone_ptr
);
// struct LDKRouteHint RouteHint_clone(const struct LDKRouteHint *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "RouteHint_clone", ()=>RouteHint_clone
);
// uint64_t RouteHint_hash(const struct LDKRouteHint *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "RouteHint_hash", ()=>RouteHint_hash
);
// bool RouteHint_eq(const struct LDKRouteHint *NONNULL_PTR a, const struct LDKRouteHint *NONNULL_PTR b);
/* @internal */ parcelHelpers.export(exports, "RouteHint_eq", ()=>RouteHint_eq
);
// struct LDKCVec_u8Z RouteHint_write(const struct LDKRouteHint *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "RouteHint_write", ()=>RouteHint_write
);
// struct LDKCResult_RouteHintDecodeErrorZ RouteHint_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "RouteHint_read", ()=>RouteHint_read
);
// void RouteHintHop_free(struct LDKRouteHintHop this_obj);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_free", ()=>RouteHintHop_free
);
// struct LDKPublicKey RouteHintHop_get_src_node_id(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_get_src_node_id", ()=>RouteHintHop_get_src_node_id
);
// void RouteHintHop_set_src_node_id(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_set_src_node_id", ()=>RouteHintHop_set_src_node_id
);
// uint64_t RouteHintHop_get_short_channel_id(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_get_short_channel_id", ()=>RouteHintHop_get_short_channel_id
);
// void RouteHintHop_set_short_channel_id(struct LDKRouteHintHop *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_set_short_channel_id", ()=>RouteHintHop_set_short_channel_id
);
// struct LDKRoutingFees RouteHintHop_get_fees(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_get_fees", ()=>RouteHintHop_get_fees
);
// void RouteHintHop_set_fees(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKRoutingFees val);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_set_fees", ()=>RouteHintHop_set_fees
);
// uint16_t RouteHintHop_get_cltv_expiry_delta(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_get_cltv_expiry_delta", ()=>RouteHintHop_get_cltv_expiry_delta
);
// void RouteHintHop_set_cltv_expiry_delta(struct LDKRouteHintHop *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_set_cltv_expiry_delta", ()=>RouteHintHop_set_cltv_expiry_delta
);
// struct LDKCOption_u64Z RouteHintHop_get_htlc_minimum_msat(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_get_htlc_minimum_msat", ()=>RouteHintHop_get_htlc_minimum_msat
);
// void RouteHintHop_set_htlc_minimum_msat(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_set_htlc_minimum_msat", ()=>RouteHintHop_set_htlc_minimum_msat
);
// struct LDKCOption_u64Z RouteHintHop_get_htlc_maximum_msat(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_get_htlc_maximum_msat", ()=>RouteHintHop_get_htlc_maximum_msat
);
// void RouteHintHop_set_htlc_maximum_msat(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_set_htlc_maximum_msat", ()=>RouteHintHop_set_htlc_maximum_msat
);
// MUST_USE_RES struct LDKRouteHintHop RouteHintHop_new(struct LDKPublicKey src_node_id_arg, uint64_t short_channel_id_arg, struct LDKRoutingFees fees_arg, uint16_t cltv_expiry_delta_arg, struct LDKCOption_u64Z htlc_minimum_msat_arg, struct LDKCOption_u64Z htlc_maximum_msat_arg);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_new", ()=>RouteHintHop_new
);
// uintptr_t RouteHintHop_clone_ptr(LDKRouteHintHop *NONNULL_PTR arg);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_clone_ptr", ()=>RouteHintHop_clone_ptr
);
// struct LDKRouteHintHop RouteHintHop_clone(const struct LDKRouteHintHop *NONNULL_PTR orig);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_clone", ()=>RouteHintHop_clone
);
// uint64_t RouteHintHop_hash(const struct LDKRouteHintHop *NONNULL_PTR o);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_hash", ()=>RouteHintHop_hash
);
// bool RouteHintHop_eq(const struct LDKRouteHintHop *NONNULL_PTR a, const struct LDKRouteHintHop *NONNULL_PTR b);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_eq", ()=>RouteHintHop_eq
);
// struct LDKCVec_u8Z RouteHintHop_write(const struct LDKRouteHintHop *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_write", ()=>RouteHintHop_write
);
// struct LDKCResult_RouteHintHopDecodeErrorZ RouteHintHop_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "RouteHintHop_read", ()=>RouteHintHop_read
);
// struct LDKCResult_RouteLightningErrorZ find_route(struct LDKPublicKey our_node_pubkey, const struct LDKRouteParameters *NONNULL_PTR params, const struct LDKNetworkGraph *NONNULL_PTR network, struct LDKCVec_ChannelDetailsZ *first_hops, struct LDKLogger logger, const struct LDKScore *NONNULL_PTR scorer);
/* @internal */ parcelHelpers.export(exports, "find_route", ()=>find_route
);
// void Score_free(struct LDKScore this_ptr);
/* @internal */ parcelHelpers.export(exports, "Score_free", ()=>Score_free
);
// void LockableScore_free(struct LDKLockableScore this_ptr);
/* @internal */ parcelHelpers.export(exports, "LockableScore_free", ()=>LockableScore_free
);
// void MultiThreadedLockableScore_free(struct LDKMultiThreadedLockableScore this_obj);
/* @internal */ parcelHelpers.export(exports, "MultiThreadedLockableScore_free", ()=>MultiThreadedLockableScore_free
);
// MUST_USE_RES struct LDKMultiThreadedLockableScore MultiThreadedLockableScore_new(struct LDKScore score);
/* @internal */ parcelHelpers.export(exports, "MultiThreadedLockableScore_new", ()=>MultiThreadedLockableScore_new
);
// void ScoringParameters_free(struct LDKScoringParameters this_obj);
/* @internal */ parcelHelpers.export(exports, "ScoringParameters_free", ()=>ScoringParameters_free
);
// uint64_t ScoringParameters_get_base_penalty_msat(const struct LDKScoringParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ScoringParameters_get_base_penalty_msat", ()=>ScoringParameters_get_base_penalty_msat
);
// void ScoringParameters_set_base_penalty_msat(struct LDKScoringParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ScoringParameters_set_base_penalty_msat", ()=>ScoringParameters_set_base_penalty_msat
);
// uint64_t ScoringParameters_get_failure_penalty_msat(const struct LDKScoringParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ScoringParameters_get_failure_penalty_msat", ()=>ScoringParameters_get_failure_penalty_msat
);
// void ScoringParameters_set_failure_penalty_msat(struct LDKScoringParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ScoringParameters_set_failure_penalty_msat", ()=>ScoringParameters_set_failure_penalty_msat
);
// uint16_t ScoringParameters_get_overuse_penalty_start_1024th(const struct LDKScoringParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ScoringParameters_get_overuse_penalty_start_1024th", ()=>ScoringParameters_get_overuse_penalty_start_1024th
);
// void ScoringParameters_set_overuse_penalty_start_1024th(struct LDKScoringParameters *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */ parcelHelpers.export(exports, "ScoringParameters_set_overuse_penalty_start_1024th", ()=>ScoringParameters_set_overuse_penalty_start_1024th
);
// uint64_t ScoringParameters_get_overuse_penalty_msat_per_1024th(const struct LDKScoringParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ScoringParameters_get_overuse_penalty_msat_per_1024th", ()=>ScoringParameters_get_overuse_penalty_msat_per_1024th
);
// void ScoringParameters_set_overuse_penalty_msat_per_1024th(struct LDKScoringParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ScoringParameters_set_overuse_penalty_msat_per_1024th", ()=>ScoringParameters_set_overuse_penalty_msat_per_1024th
);
// uint64_t ScoringParameters_get_failure_penalty_half_life(const struct LDKScoringParameters *NONNULL_PTR this_ptr);
/* @internal */ parcelHelpers.export(exports, "ScoringParameters_get_failure_penalty_half_life", ()=>ScoringParameters_get_failure_penalty_half_life
);
// void ScoringParameters_set_failure_penalty_half_life(struct LDKScoringParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */ parcelHelpers.export(exports, "ScoringParameters_set_failure_penalty_half_life", ()=>ScoringParameters_set_failure_penalty_half_life
);
// MUST_USE_RES struct LDKScoringParameters ScoringParameters_new(uint64_t base_penalty_msat_arg, uint64_t failure_penalty_msat_arg, uint16_t overuse_penalty_start_1024th_arg, uint64_t overuse_penalty_msat_per_1024th_arg, uint64_t failure_penalty_half_life_arg);
/* @internal */ parcelHelpers.export(exports, "ScoringParameters_new", ()=>ScoringParameters_new
);
// struct LDKCVec_u8Z ScoringParameters_write(const struct LDKScoringParameters *NONNULL_PTR obj);
/* @internal */ parcelHelpers.export(exports, "ScoringParameters_write", ()=>ScoringParameters_write
);
// struct LDKCResult_ScoringParametersDecodeErrorZ ScoringParameters_read(struct LDKu8slice ser);
/* @internal */ parcelHelpers.export(exports, "ScoringParameters_read", ()=>ScoringParameters_read
);
// MUST_USE_RES struct LDKScoringParameters ScoringParameters_default(void);
/* @internal */ parcelHelpers.export(exports, "ScoringParameters_default", ()=>ScoringParameters_default
);
var _versionMjs = require("./version.mjs");
const imports = {
};
imports.env = {
};
var js_objs = [];
var js_invoke;
var getRandomValues;
imports.wasi_snapshot_preview1 = {
    "fd_write": (fd, iovec_array_ptr, iovec_array_len)=>{
        // This should generally only be used to print panic messages
        console.log("FD_WRITE to " + fd + " in " + iovec_array_len + " chunks.");
        const ptr_len_view = new Uint32Array(wasm.memory.buffer, iovec_array_ptr, iovec_array_len * 2);
        for(var i = 0; i < iovec_array_len; i++){
            const bytes_view = new Uint8Array(wasm.memory.buffer, ptr_len_view[i * 2], ptr_len_view[i * 2 + 1]);
            console.log(String.fromCharCode(...bytes_view));
        }
        return 0;
    },
    "fd_close": (_fd)=>{
        // This is not generally called, but may be referenced in debug builds
        console.log("wasi_snapshot_preview1:fd_close");
        return 58; // Not Supported
    },
    "fd_seek": (_fd, _offset, _whence, _new_offset)=>{
        // This is not generally called, but may be referenced in debug builds
        console.log("wasi_snapshot_preview1:fd_seek");
        return 58; // Not Supported
    },
    "random_get": (buf_ptr, buf_len)=>{
        const buf = new Uint8Array(wasm.memory.buffer, buf_ptr, buf_len);
        getRandomValues(buf);
        return 0;
    },
    "environ_sizes_get": (environ_var_count_ptr, environ_len_ptr)=>{
        // This is called before fd_write to format + print panic messages
        console.log("wasi_snapshot_preview1:environ_sizes_get");
        const out_count_view = new Uint32Array(wasm.memory.buffer, environ_var_count_ptr, 1);
        out_count_view[0] = 0;
        const out_len_view = new Uint32Array(wasm.memory.buffer, environ_len_ptr, 1);
        out_len_view[0] = 0;
        return 0;
    },
    "environ_get": (environ_ptr, environ_buf_ptr)=>{
        // This is called before fd_write to format + print panic messages
        console.log("wasi_snapshot_preview1:environ_get");
        return 58; // Note supported - we said there were 0 environment entries!
    },
    "proc_exit": ()=>{
        console.log("wasi_snapshot_preview1:proc_exit");
    }
};
var wasm = null;
let isWasmInitialized = false;
async function finishInitializeWasm(wasmInstance) {
    if (typeof crypto === "undefined") {
        var crypto_import = (await require("ef76b51c9c3ce6c8")).webcrypto;
        getRandomValues = crypto_import.getRandomValues.bind(crypto_import);
    } else getRandomValues = crypto.getRandomValues.bind(crypto);
    wasm = wasmInstance.exports;
    if (!wasm.test_bigint_pass_deadbeef0badf00d(BigInt("0xdeadbeef0badf00d"))) throw new Error("Currently need BigInt-as-u64 support, try ----experimental-wasm-bigint");
    if (decodeString(wasm.TS_get_lib_version_string()) !== _versionMjs.get_ldk_java_bindings_version()) throw new Error("Compiled LDK library and LDK class failes do not match");
    // Fetching the LDK versions from C also checks that the header and binaries match
    const c_bindings_ver = wasm.TS_get_ldk_c_bindings_version();
    const ldk_ver = wasm.TS_get_ldk_version();
    if (c_bindings_ver == 0) throw new Error("LDK version did not match the header we built against");
    if (ldk_ver == 0) throw new Error("LDK C bindings version did not match the header we built against");
    const c_bindings_version = decodeString(c_bindings_ver);
    const ldk_version = decodeString(ldk_ver);
    console.log("Loaded LDK-Java Bindings with LDK " + ldk_version + " and LDK-C-Bindings " + c_bindings_version);
    isWasmInitialized = true;
}
async function initializeWasmFromUint8Array(wasmBinary) {
    imports.env["js_invoke_function"] = js_invoke;
    const { instance: wasmInstance  } = await WebAssembly.instantiate(wasmBinary, imports);
    await finishInitializeWasm(wasmInstance);
}
async function initializeWasmFetch(uri) {
    const stream = fetch(uri);
    imports.env["js_invoke_function"] = js_invoke;
    const { instance: wasmInstance  } = await WebAssembly.instantiateStreaming(stream, imports);
    await finishInitializeWasm(wasmInstance);
}
// WASM CODEC
const nextMultipleOfFour = (value)=>{
    return Math.ceil(value / 4) * 4;
};
function encodeUint8Array(inputArray) {
    const cArrayPointer = wasm.TS_malloc(inputArray.length + 4);
    const arrayLengthView = new Uint32Array(wasm.memory.buffer, cArrayPointer, 1);
    arrayLengthView[0] = inputArray.length;
    const arrayMemoryView = new Uint8Array(wasm.memory.buffer, cArrayPointer + 4, inputArray.length);
    arrayMemoryView.set(inputArray);
    return cArrayPointer;
}
function encodeUint32Array(inputArray) {
    const cArrayPointer = wasm.TS_malloc((inputArray.length + 1) * 4);
    const arrayMemoryView = new Uint32Array(wasm.memory.buffer, cArrayPointer, inputArray.length);
    arrayMemoryView.set(inputArray, 1);
    arrayMemoryView[0] = inputArray.length;
    return cArrayPointer;
}
function encodeUint64Array(inputArray) {
    const cArrayPointer = wasm.TS_malloc(inputArray.length * 8 + 1);
    const arrayLengthView = new Uint32Array(wasm.memory.buffer, cArrayPointer, 1);
    arrayLengthView[0] = inputArray.length;
    const arrayMemoryView = new BigUint64Array(wasm.memory.buffer, cArrayPointer + 4, inputArray.length);
    arrayMemoryView.set(inputArray);
    return cArrayPointer;
}
function check_arr_len(arr, len) {
    if (arr.length != len) throw new Error("Expected array of length " + len + "got " + arr.length);
    return arr;
}
function getArrayLength(arrayPointer) {
    const arraySizeViewer = new Uint32Array(wasm.memory.buffer, arrayPointer, 1);
    return arraySizeViewer[0];
}
function decodeUint8Array(arrayPointer, free = true) {
    const arraySize = getArrayLength(arrayPointer);
    const actualArrayViewer = new Uint8Array(wasm.memory.buffer, arrayPointer + 4, arraySize);
    // Clone the contents, TODO: In the future we should wrap the Viewer in a class that
    // will free the underlying memory when it becomes unreachable instead of copying here.
    // Note that doing so may have edge-case interactions with memory resizing (invalidating the buffer).
    const actualArray = actualArrayViewer.slice(0, arraySize);
    if (free) wasm.TS_free(arrayPointer);
    return actualArray;
}
const decodeUint32Array = (arrayPointer, free = true)=>{
    const arraySize = getArrayLength(arrayPointer);
    const actualArrayViewer = new Uint32Array(wasm.memory.buffer, arrayPointer + 4, arraySize // uint32 count
    );
    // Clone the contents, TODO: In the future we should wrap the Viewer in a class that
    // will free the underlying memory when it becomes unreachable instead of copying here.
    const actualArray = actualArrayViewer.slice(0, arraySize);
    if (free) wasm.TS_free(arrayPointer);
    return actualArray;
};
function freeWasmMemory(pointer) {
    wasm.TS_free(pointer);
}
function getU32ArrayElem(arrayPointer, idx) {
    const actualArrayViewer = new Uint32Array(wasm.memory.buffer, arrayPointer + 4, idx + 1);
    return actualArrayViewer[idx];
}
function encodeString(str) {
    const charArray = new TextEncoder().encode(str);
    return encodeUint8Array(charArray);
}
function decodeString(stringPointer, free = true) {
    const arraySize = getArrayLength(stringPointer);
    const memoryView = new Uint8Array(wasm.memory.buffer, stringPointer + 4, arraySize);
    const result = new TextDecoder("utf-8").decode(memoryView);
    if (free) wasm.TS_free(stringPointer);
    return result;
}
function getRemainingAllocationCount() {
    return 0;
}
function debugPrintRemainingAllocs() {
}
var AccessError;
(function(AccessError1) {
    /**
     * The requested chain is unknown.
     */ AccessError1[AccessError1["LDKAccessError_UnknownChain"] = 0] = "LDKAccessError_UnknownChain";
    /**
     * The requested transaction doesn't exist or hasn't confirmed.
     */ AccessError1[AccessError1["LDKAccessError_UnknownTx"] = 1] = "LDKAccessError_UnknownTx";
})(AccessError || (AccessError = {
}));
var COption_NoneZ;
(function(COption_NoneZ1) {
    /**
     * When we're in this state, this COption_NoneZ contains a
     */ COption_NoneZ1[COption_NoneZ1["LDKCOption_NoneZ_Some"] = 0] = "LDKCOption_NoneZ_Some";
    /**
     * When we're in this state, this COption_NoneZ contains nothing
     */ COption_NoneZ1[COption_NoneZ1["LDKCOption_NoneZ_None"] = 1] = "LDKCOption_NoneZ_None";
})(COption_NoneZ || (COption_NoneZ = {
}));
var ChannelMonitorUpdateErr;
(function(ChannelMonitorUpdateErr1) {
    /**
     * Used to indicate a temporary failure (eg connection to a watchtower or remote backup of
    our state failed, but is expected to succeed at some point in the future).
    
    Such a failure will \"freeze\" a channel, preventing us from revoking old states or
    submitting new commitment transactions to the counterparty. Once the update(s) that failed
    have been successfully applied, a [`MonitorEvent::UpdateCompleted`] event should be returned
    via [`Watch::release_pending_monitor_events`] which will then restore the channel to an
    operational state.
    
    Note that a given ChannelManager will *never* re-generate a given ChannelMonitorUpdate. If
    you return a TemporaryFailure you must ensure that it is written to disk safely before
    writing out the latest ChannelManager state.
    
    Even when a channel has been \"frozen\" updates to the ChannelMonitor can continue to occur
    (eg if an inbound HTLC which we forwarded was claimed upstream resulting in us attempting
    to claim it on this channel) and those updates must be applied wherever they can be. At
    least one such updated ChannelMonitor must be persisted otherwise PermanentFailure should
    be returned to get things on-chain ASAP using only the in-memory copy. Obviously updates to
    the channel which would invalidate previous ChannelMonitors are not made when a channel has
    been \"frozen\".
    
    Note that even if updates made after TemporaryFailure succeed you must still provide a
    [`MonitorEvent::UpdateCompleted`] to ensure you have the latest monitor and re-enable
    normal channel operation. Note that this is normally generated through a call to
    [`ChainMonitor::channel_monitor_updated`].
    
    Note that the update being processed here will not be replayed for you when you return a
    [`MonitorEvent::UpdateCompleted`] event via [`Watch::release_pending_monitor_events`], so
    you must store the update itself on your own local disk prior to returning a
    TemporaryFailure. You may, of course, employ a journaling approach, storing only the
    ChannelMonitorUpdate on disk without updating the monitor itself, replaying the journal at
    reload-time.
    
    For deployments where a copy of ChannelMonitors and other local state are backed up in a
    remote location (with local copies persisted immediately), it is anticipated that all
    updates will return TemporaryFailure until the remote copies could be updated.
    
    [`ChainMonitor::channel_monitor_updated`]: chainmonitor::ChainMonitor::channel_monitor_updated
     */ ChannelMonitorUpdateErr1[ChannelMonitorUpdateErr1["LDKChannelMonitorUpdateErr_TemporaryFailure"] = 0] = "LDKChannelMonitorUpdateErr_TemporaryFailure";
    /**
     * Used to indicate no further channel monitor updates will be allowed (eg we've moved on to a
    different watchtower and cannot update with all watchtowers that were previously informed
    of this channel).
    
    At reception of this error, ChannelManager will force-close the channel and return at
    least a final ChannelMonitorUpdate::ChannelForceClosed which must be delivered to at
    least one ChannelMonitor copy. Revocation secret MUST NOT be released and offchain channel
    update must be rejected.
    
    This failure may also signal a failure to update the local persisted copy of one of
    the channel monitor instance.
    
    Note that even when you fail a holder commitment transaction update, you must store the
    update to ensure you can claim from it in case of a duplicate copy of this ChannelMonitor
    broadcasts it (e.g distributed channel-monitor deployment)
    
    In case of distributed watchtowers deployment, the new version must be written to disk, as
    state may have been stored but rejected due to a block forcing a commitment broadcast. This
    storage is used to claim outputs of rejected state confirmed onchain by another watchtower,
    lagging behind on block processing.
     */ ChannelMonitorUpdateErr1[ChannelMonitorUpdateErr1["LDKChannelMonitorUpdateErr_PermanentFailure"] = 1] = "LDKChannelMonitorUpdateErr_PermanentFailure";
})(ChannelMonitorUpdateErr || (ChannelMonitorUpdateErr = {
}));
var ConfirmationTarget;
(function(ConfirmationTarget1) {
    /**
     * We are happy with this transaction confirming slowly when feerate drops some.
     */ ConfirmationTarget1[ConfirmationTarget1["LDKConfirmationTarget_Background"] = 0] = "LDKConfirmationTarget_Background";
    /**
     * We'd like this transaction to confirm without major delay, but 12-18 blocks is fine.
     */ ConfirmationTarget1[ConfirmationTarget1["LDKConfirmationTarget_Normal"] = 1] = "LDKConfirmationTarget_Normal";
    /**
     * We'd like this transaction to confirm in the next few blocks.
     */ ConfirmationTarget1[ConfirmationTarget1["LDKConfirmationTarget_HighPriority"] = 2] = "LDKConfirmationTarget_HighPriority";
})(ConfirmationTarget || (ConfirmationTarget = {
}));
var Level;
(function(Level1) {
    /**
     * Designates extremely verbose information, including gossip-induced messages
     */ Level1[Level1["LDKLevel_Gossip"] = 0] = "LDKLevel_Gossip";
    /**
     * Designates very low priority, often extremely verbose, information
     */ Level1[Level1["LDKLevel_Trace"] = 1] = "LDKLevel_Trace";
    /**
     * Designates lower priority information
     */ Level1[Level1["LDKLevel_Debug"] = 2] = "LDKLevel_Debug";
    /**
     * Designates useful information
     */ Level1[Level1["LDKLevel_Info"] = 3] = "LDKLevel_Info";
    /**
     * Designates hazardous situations
     */ Level1[Level1["LDKLevel_Warn"] = 4] = "LDKLevel_Warn";
    /**
     * Designates very serious errors
     */ Level1[Level1["LDKLevel_Error"] = 5] = "LDKLevel_Error";
})(Level || (Level = {
}));
var Network;
(function(Network1) {
    /**
     * The main Bitcoin blockchain.
     */ Network1[Network1["LDKNetwork_Bitcoin"] = 0] = "LDKNetwork_Bitcoin";
    /**
     * The testnet3 blockchain.
     */ Network1[Network1["LDKNetwork_Testnet"] = 1] = "LDKNetwork_Testnet";
    /**
     * A local test blockchain.
     */ Network1[Network1["LDKNetwork_Regtest"] = 2] = "LDKNetwork_Regtest";
    /**
     * A blockchain on which blocks are signed instead of mined.
     */ Network1[Network1["LDKNetwork_Signet"] = 3] = "LDKNetwork_Signet";
})(Network || (Network = {
}));
var Secp256k1Error;
(function(Secp256k1Error1) {
    /**
     * Signature failed verification
     */ Secp256k1Error1[Secp256k1Error1["LDKSecp256k1Error_IncorrectSignature"] = 0] = "LDKSecp256k1Error_IncorrectSignature";
    /**
     * Badly sized message ("messages" are actually fixed-sized digests; see the MESSAGE_SIZE constant)
     */ Secp256k1Error1[Secp256k1Error1["LDKSecp256k1Error_InvalidMessage"] = 1] = "LDKSecp256k1Error_InvalidMessage";
    /**
     * Bad public key
     */ Secp256k1Error1[Secp256k1Error1["LDKSecp256k1Error_InvalidPublicKey"] = 2] = "LDKSecp256k1Error_InvalidPublicKey";
    /**
     * Bad signature
     */ Secp256k1Error1[Secp256k1Error1["LDKSecp256k1Error_InvalidSignature"] = 3] = "LDKSecp256k1Error_InvalidSignature";
    /**
     * Bad secret key
     */ Secp256k1Error1[Secp256k1Error1["LDKSecp256k1Error_InvalidSecretKey"] = 4] = "LDKSecp256k1Error_InvalidSecretKey";
    /**
     * Bad recovery id
     */ Secp256k1Error1[Secp256k1Error1["LDKSecp256k1Error_InvalidRecoveryId"] = 5] = "LDKSecp256k1Error_InvalidRecoveryId";
    /**
     * Invalid tweak for add_assign or mul_assign
     */ Secp256k1Error1[Secp256k1Error1["LDKSecp256k1Error_InvalidTweak"] = 6] = "LDKSecp256k1Error_InvalidTweak";
    /**
     * tweak_add_check failed on an xonly public key
     */ Secp256k1Error1[Secp256k1Error1["LDKSecp256k1Error_TweakCheckFailed"] = 7] = "LDKSecp256k1Error_TweakCheckFailed";
    /**
     * Didn't pass enough memory to context creation with preallocated memory
     */ Secp256k1Error1[Secp256k1Error1["LDKSecp256k1Error_NotEnoughMemory"] = 8] = "LDKSecp256k1Error_NotEnoughMemory";
})(Secp256k1Error || (Secp256k1Error = {
}));
function TxOut_get_script_pubkey(thing) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxOut_get_script_pubkey(thing);
    return nativeResponseValue;
}
function TxOut_get_value(thing) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxOut_get_value(thing);
    return nativeResponseValue;
}
function CResult_ChannelConfigDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ChannelConfigDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_OutPointDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_OutPointDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_SecretKeyErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SecretKeyErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_SecretKeyErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SecretKeyErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_PublicKeyErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_PublicKeyErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_TxCreationKeysDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_TxCreationKeysDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_ChannelPublicKeysDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ChannelPublicKeysDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_TxCreationKeysErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxCreationKeysErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_TxCreationKeysErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxCreationKeysErrorZ_get_err(owner);
    return nativeResponseValue;
}
class LDKCOption_u32Z {
    constructor(){
    }
}
function LDKCOption_u32Z_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_u32Z_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKCOption_u32Z_Some_get_some(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_u32Z_Some_get_some(ptr);
    return nativeResponseValue;
}
function CResult_HTLCOutputInCommitmentDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_HTLCOutputInCommitmentDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_ChannelTransactionParametersDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ChannelTransactionParametersDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_HolderCommitmentTransactionDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_HolderCommitmentTransactionDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_BuiltCommitmentTransactionDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_BuiltCommitmentTransactionDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_TrustedClosingTransactionNoneZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_TrustedClosingTransactionNoneZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_get_err(owner);
// debug statements here
}
function CResult_CommitmentTransactionDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_CommitmentTransactionDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_TrustedCommitmentTransactionNoneZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_TrustedCommitmentTransactionNoneZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_get_err(owner);
// debug statements here
}
function CResult_CVec_SignatureZNoneZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_CVec_SignatureZNoneZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_get_err(owner);
// debug statements here
}
function CResult_ShutdownScriptDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ShutdownScriptDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_ShutdownScriptInvalidShutdownScriptZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ShutdownScriptInvalidShutdownScriptZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_get_err(owner);
    return nativeResponseValue;
}
function LDKType_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKType_new(i);
}
function Type_type_id(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Type_type_id(this_arg);
    return nativeResponseValue;
}
function Type_debug_str(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Type_debug_str(this_arg);
    return nativeResponseValue;
}
function Type_write(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Type_write(this_arg);
    return nativeResponseValue;
}
class LDKCOption_TypeZ {
    constructor(){
    }
}
function LDKCOption_TypeZ_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_TypeZ_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKCOption_TypeZ_Some_get_some(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_TypeZ_Some_get_some(ptr);
    return nativeResponseValue;
}
function CResult_COption_TypeZDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_COption_TypeZDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_StringErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_StringErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_StringErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_StringErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_ChannelMonitorUpdateDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ChannelMonitorUpdateDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
class LDKMonitorEvent {
    constructor(){
    }
}
function LDKMonitorEvent_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMonitorEvent_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKMonitorEvent_HTLCEvent_get_htlc_event(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMonitorEvent_HTLCEvent_get_htlc_event(ptr);
    return nativeResponseValue;
}
function LDKMonitorEvent_CommitmentTxConfirmed_get_commitment_tx_confirmed(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMonitorEvent_CommitmentTxConfirmed_get_commitment_tx_confirmed(ptr);
    return nativeResponseValue;
}
function LDKMonitorEvent_UpdateCompleted_get_funding_txo(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMonitorEvent_UpdateCompleted_get_funding_txo(ptr);
    return nativeResponseValue;
}
function LDKMonitorEvent_UpdateCompleted_get_monitor_update_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMonitorEvent_UpdateCompleted_get_monitor_update_id(ptr);
    return nativeResponseValue;
}
function LDKMonitorEvent_UpdateFailed_get_update_failed(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMonitorEvent_UpdateFailed_get_update_failed(ptr);
    return nativeResponseValue;
}
class LDKCOption_MonitorEventZ {
    constructor(){
    }
}
function LDKCOption_MonitorEventZ_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_MonitorEventZ_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKCOption_MonitorEventZ_Some_get_some(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_MonitorEventZ_Some_get_some(ptr);
    return nativeResponseValue;
}
function CResult_COption_MonitorEventZDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_COption_MonitorEventZDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_HTLCUpdateDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_HTLCUpdateDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_NoneNoneZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_get_ok(owner);
// debug statements here
}
function CResult_NoneNoneZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_get_err(owner);
// debug statements here
}
function C2Tuple_OutPointScriptZ_get_a(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_OutPointScriptZ_get_a(owner);
    return nativeResponseValue;
}
function C2Tuple_OutPointScriptZ_get_b(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_OutPointScriptZ_get_b(owner);
    return nativeResponseValue;
}
function C2Tuple_u32ScriptZ_get_a(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_u32ScriptZ_get_a(owner);
    return nativeResponseValue;
}
function C2Tuple_u32ScriptZ_get_b(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_u32ScriptZ_get_b(owner);
    return nativeResponseValue;
}
function C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_a(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_a(owner);
    return nativeResponseValue;
}
function C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_b(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_b(owner);
    return nativeResponseValue;
}
class LDKPaymentPurpose {
    constructor(){
    }
}
function LDKPaymentPurpose_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKPaymentPurpose_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKPaymentPurpose_InvoicePayment_get_payment_preimage(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKPaymentPurpose_InvoicePayment_get_payment_preimage(ptr);
    return nativeResponseValue;
}
function LDKPaymentPurpose_InvoicePayment_get_payment_secret(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKPaymentPurpose_InvoicePayment_get_payment_secret(ptr);
    return nativeResponseValue;
}
function LDKPaymentPurpose_SpontaneousPayment_get_spontaneous_payment(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKPaymentPurpose_SpontaneousPayment_get_spontaneous_payment(ptr);
    return nativeResponseValue;
}
class LDKCOption_u64Z {
    constructor(){
    }
}
function LDKCOption_u64Z_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_u64Z_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKCOption_u64Z_Some_get_some(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_u64Z_Some_get_some(ptr);
    return nativeResponseValue;
}
class LDKNetworkUpdate {
    constructor(){
    }
}
function LDKNetworkUpdate_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKNetworkUpdate_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKNetworkUpdate_ChannelUpdateMessage_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKNetworkUpdate_ChannelUpdateMessage_get_msg(ptr);
    return nativeResponseValue;
}
function LDKNetworkUpdate_ChannelClosed_get_short_channel_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKNetworkUpdate_ChannelClosed_get_short_channel_id(ptr);
    return nativeResponseValue;
}
function LDKNetworkUpdate_ChannelClosed_get_is_permanent(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKNetworkUpdate_ChannelClosed_get_is_permanent(ptr);
    return nativeResponseValue;
}
function LDKNetworkUpdate_NodeFailure_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKNetworkUpdate_NodeFailure_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKNetworkUpdate_NodeFailure_get_is_permanent(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKNetworkUpdate_NodeFailure_get_is_permanent(ptr);
    return nativeResponseValue;
}
class LDKCOption_NetworkUpdateZ {
    constructor(){
    }
}
function LDKCOption_NetworkUpdateZ_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_NetworkUpdateZ_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKCOption_NetworkUpdateZ_Some_get_some(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_NetworkUpdateZ_Some_get_some(ptr);
    return nativeResponseValue;
}
class LDKSpendableOutputDescriptor {
    constructor(){
    }
}
function LDKSpendableOutputDescriptor_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKSpendableOutputDescriptor_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKSpendableOutputDescriptor_StaticOutput_get_outpoint(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKSpendableOutputDescriptor_StaticOutput_get_outpoint(ptr);
    return nativeResponseValue;
}
function LDKSpendableOutputDescriptor_StaticOutput_get_output(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKSpendableOutputDescriptor_StaticOutput_get_output(ptr);
    return nativeResponseValue;
}
function LDKSpendableOutputDescriptor_DelayedPaymentOutput_get_delayed_payment_output(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKSpendableOutputDescriptor_DelayedPaymentOutput_get_delayed_payment_output(ptr);
    return nativeResponseValue;
}
function LDKSpendableOutputDescriptor_StaticPaymentOutput_get_static_payment_output(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKSpendableOutputDescriptor_StaticPaymentOutput_get_static_payment_output(ptr);
    return nativeResponseValue;
}
class LDKClosureReason {
    constructor(){
    }
}
function LDKClosureReason_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKClosureReason_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKClosureReason_CounterpartyForceClosed_get_peer_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKClosureReason_CounterpartyForceClosed_get_peer_msg(ptr);
    return nativeResponseValue;
}
function LDKClosureReason_ProcessingError_get_err(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKClosureReason_ProcessingError_get_err(ptr);
    return nativeResponseValue;
}
class LDKEvent {
    constructor(){
    }
}
function LDKEvent_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKEvent_FundingGenerationReady_get_temporary_channel_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_FundingGenerationReady_get_temporary_channel_id(ptr);
    return nativeResponseValue;
}
function LDKEvent_FundingGenerationReady_get_channel_value_satoshis(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_FundingGenerationReady_get_channel_value_satoshis(ptr);
    return nativeResponseValue;
}
function LDKEvent_FundingGenerationReady_get_output_script(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_FundingGenerationReady_get_output_script(ptr);
    return nativeResponseValue;
}
function LDKEvent_FundingGenerationReady_get_user_channel_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_FundingGenerationReady_get_user_channel_id(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentReceived_get_payment_hash(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentReceived_get_payment_hash(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentReceived_get_amt(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentReceived_get_amt(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentReceived_get_purpose(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentReceived_get_purpose(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentSent_get_payment_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentSent_get_payment_id(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentSent_get_payment_preimage(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentSent_get_payment_preimage(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentSent_get_payment_hash(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentSent_get_payment_hash(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentSent_get_fee_paid_msat(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentSent_get_fee_paid_msat(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentPathFailed_get_payment_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_payment_id(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentPathFailed_get_payment_hash(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_payment_hash(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentPathFailed_get_rejected_by_dest(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_rejected_by_dest(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentPathFailed_get_network_update(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_network_update(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentPathFailed_get_all_paths_failed(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_all_paths_failed(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentPathFailed_get_path(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_path(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentPathFailed_get_short_channel_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_short_channel_id(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentPathFailed_get_retry(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_retry(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentFailed_get_payment_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentFailed_get_payment_id(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentFailed_get_payment_hash(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentFailed_get_payment_hash(ptr);
    return nativeResponseValue;
}
function LDKEvent_PendingHTLCsForwardable_get_time_forwardable(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PendingHTLCsForwardable_get_time_forwardable(ptr);
    return nativeResponseValue;
}
function LDKEvent_SpendableOutputs_get_outputs(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_SpendableOutputs_get_outputs(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentForwarded_get_fee_earned_msat(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentForwarded_get_fee_earned_msat(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentForwarded_get_claim_from_onchain_tx(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentForwarded_get_claim_from_onchain_tx(ptr);
    return nativeResponseValue;
}
function LDKEvent_ChannelClosed_get_channel_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_ChannelClosed_get_channel_id(ptr);
    return nativeResponseValue;
}
function LDKEvent_ChannelClosed_get_user_channel_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_ChannelClosed_get_user_channel_id(ptr);
    return nativeResponseValue;
}
function LDKEvent_ChannelClosed_get_reason(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_ChannelClosed_get_reason(ptr);
    return nativeResponseValue;
}
function LDKEvent_DiscardFunding_get_channel_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_DiscardFunding_get_channel_id(ptr);
    return nativeResponseValue;
}
function LDKEvent_DiscardFunding_get_transaction(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_DiscardFunding_get_transaction(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentPathSuccessful_get_payment_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathSuccessful_get_payment_id(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentPathSuccessful_get_payment_hash(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathSuccessful_get_payment_hash(ptr);
    return nativeResponseValue;
}
function LDKEvent_PaymentPathSuccessful_get_path(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathSuccessful_get_path(ptr);
    return nativeResponseValue;
}
function C2Tuple_usizeTransactionZ_get_a(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_get_a(owner);
    return nativeResponseValue;
}
function C2Tuple_usizeTransactionZ_get_b(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_get_b(owner);
    return nativeResponseValue;
}
function C2Tuple_u32TxOutZ_get_a(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_get_a(owner);
    return nativeResponseValue;
}
function C2Tuple_u32TxOutZ_get_b(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_get_b(owner);
    return nativeResponseValue;
}
function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_a(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_a(owner);
    return nativeResponseValue;
}
function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_b(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_b(owner);
    return nativeResponseValue;
}
class LDKBalance {
    constructor(){
    }
}
function LDKBalance_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKBalance_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKBalance_ClaimableOnChannelClose_get_claimable_amount_satoshis(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKBalance_ClaimableOnChannelClose_get_claimable_amount_satoshis(ptr);
    return nativeResponseValue;
}
function LDKBalance_ClaimableAwaitingConfirmations_get_claimable_amount_satoshis(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKBalance_ClaimableAwaitingConfirmations_get_claimable_amount_satoshis(ptr);
    return nativeResponseValue;
}
function LDKBalance_ClaimableAwaitingConfirmations_get_confirmation_height(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKBalance_ClaimableAwaitingConfirmations_get_confirmation_height(ptr);
    return nativeResponseValue;
}
function LDKBalance_ContentiousClaimable_get_claimable_amount_satoshis(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKBalance_ContentiousClaimable_get_claimable_amount_satoshis(ptr);
    return nativeResponseValue;
}
function LDKBalance_ContentiousClaimable_get_timeout_height(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKBalance_ContentiousClaimable_get_timeout_height(ptr);
    return nativeResponseValue;
}
function LDKBalance_MaybeClaimableHTLCAwaitingTimeout_get_claimable_amount_satoshis(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKBalance_MaybeClaimableHTLCAwaitingTimeout_get_claimable_amount_satoshis(ptr);
    return nativeResponseValue;
}
function LDKBalance_MaybeClaimableHTLCAwaitingTimeout_get_claimable_height(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKBalance_MaybeClaimableHTLCAwaitingTimeout_get_claimable_height(ptr);
    return nativeResponseValue;
}
function C2Tuple_SignatureCVec_SignatureZZ_get_a(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_get_a(owner);
    return nativeResponseValue;
}
function C2Tuple_SignatureCVec_SignatureZZ_get_b(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_get_b(owner);
    return nativeResponseValue;
}
function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_err(owner);
// debug statements here
}
function CResult_SignatureNoneZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_SignatureNoneZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_get_err(owner);
// debug statements here
}
function LDKBaseSign_new(impl, pubkeys) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKBaseSign_new(i);
}
function BaseSign_get_per_commitment_point(this_arg, idx) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BaseSign_get_per_commitment_point(this_arg, idx);
    return nativeResponseValue;
}
function BaseSign_release_commitment_secret(this_arg, idx) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BaseSign_release_commitment_secret(this_arg, idx);
    return nativeResponseValue;
}
function BaseSign_validate_holder_commitment(this_arg, holder_tx) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BaseSign_validate_holder_commitment(this_arg, holder_tx);
    return nativeResponseValue;
}
function BaseSign_channel_keys_id(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BaseSign_channel_keys_id(this_arg);
    return nativeResponseValue;
}
function BaseSign_sign_counterparty_commitment(this_arg, commitment_tx) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BaseSign_sign_counterparty_commitment(this_arg, commitment_tx);
    return nativeResponseValue;
}
function BaseSign_validate_counterparty_revocation(this_arg, idx, secret) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BaseSign_validate_counterparty_revocation(this_arg, idx, secret);
    return nativeResponseValue;
}
function BaseSign_sign_holder_commitment_and_htlcs(this_arg, commitment_tx) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BaseSign_sign_holder_commitment_and_htlcs(this_arg, commitment_tx);
    return nativeResponseValue;
}
function BaseSign_sign_justice_revoked_output(this_arg, justice_tx, input, amount, per_commitment_key) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BaseSign_sign_justice_revoked_output(this_arg, justice_tx, input, amount, per_commitment_key);
    return nativeResponseValue;
}
function BaseSign_sign_justice_revoked_htlc(this_arg, justice_tx, input, amount, per_commitment_key, htlc) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BaseSign_sign_justice_revoked_htlc(this_arg, justice_tx, input, amount, per_commitment_key, htlc);
    return nativeResponseValue;
}
function BaseSign_sign_counterparty_htlc_transaction(this_arg, htlc_tx, input, amount, per_commitment_point, htlc) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BaseSign_sign_counterparty_htlc_transaction(this_arg, htlc_tx, input, amount, per_commitment_point, htlc);
    return nativeResponseValue;
}
function BaseSign_sign_closing_transaction(this_arg, closing_tx) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BaseSign_sign_closing_transaction(this_arg, closing_tx);
    return nativeResponseValue;
}
function BaseSign_sign_channel_announcement(this_arg, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BaseSign_sign_channel_announcement(this_arg, msg);
    return nativeResponseValue;
}
function BaseSign_ready_channel(this_arg, channel_parameters) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BaseSign_ready_channel(this_arg, channel_parameters);
// debug statements here
}
function BaseSign_get_pubkeys(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BaseSign_get_pubkeys(this_arg);
    return nativeResponseValue;
}
function LDKSign_new(impl, BaseSign, pubkeys) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKSign_new(i);
}
function Sign_write(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Sign_write(this_arg);
    return nativeResponseValue;
}
function C2Tuple_BlockHashChannelMonitorZ_get_a(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_get_a(owner);
    return nativeResponseValue;
}
function C2Tuple_BlockHashChannelMonitorZ_get_b(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_get_b(owner);
    return nativeResponseValue;
}
function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_RouteHopDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_RouteHopDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_RouteDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_RouteDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_RouteParametersDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_RouteParametersDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_PayeeDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PayeeDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_PayeeDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PayeeDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_RouteHintDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_RouteHintDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_RouteHintHopDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_RouteHintHopDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_RouteLightningErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_RouteLightningErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_NoneLightningErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_get_ok(owner);
// debug statements here
}
function CResult_NoneLightningErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_get_err(owner);
    return nativeResponseValue;
}
function C2Tuple_PublicKeyTypeZ_get_a(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_get_a(owner);
    return nativeResponseValue;
}
function C2Tuple_PublicKeyTypeZ_get_b(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_get_b(owner);
    return nativeResponseValue;
}
class LDKErrorAction {
    constructor(){
    }
}
function LDKErrorAction_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKErrorAction_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKErrorAction_DisconnectPeer_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKErrorAction_DisconnectPeer_get_msg(ptr);
    return nativeResponseValue;
}
function LDKErrorAction_IgnoreAndLog_get_ignore_and_log(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKErrorAction_IgnoreAndLog_get_ignore_and_log(ptr);
    return nativeResponseValue;
}
function LDKErrorAction_SendErrorMessage_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKErrorAction_SendErrorMessage_get_msg(ptr);
    return nativeResponseValue;
}
class LDKMessageSendEvent {
    constructor(){
    }
}
function LDKMessageSendEvent_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendAcceptChannel_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendAcceptChannel_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendAcceptChannel_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendAcceptChannel_get_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendOpenChannel_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendOpenChannel_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendOpenChannel_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendOpenChannel_get_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendFundingCreated_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendFundingCreated_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendFundingCreated_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendFundingCreated_get_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendFundingSigned_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendFundingSigned_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendFundingSigned_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendFundingSigned_get_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendFundingLocked_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendFundingLocked_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendFundingLocked_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendFundingLocked_get_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendAnnouncementSignatures_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendAnnouncementSignatures_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendAnnouncementSignatures_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendAnnouncementSignatures_get_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_UpdateHTLCs_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_UpdateHTLCs_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_UpdateHTLCs_get_updates(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_UpdateHTLCs_get_updates(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendRevokeAndACK_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendRevokeAndACK_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendRevokeAndACK_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendRevokeAndACK_get_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendClosingSigned_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendClosingSigned_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendClosingSigned_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendClosingSigned_get_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendShutdown_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendShutdown_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendShutdown_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendShutdown_get_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendChannelReestablish_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelReestablish_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendChannelReestablish_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelReestablish_get_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_BroadcastChannelAnnouncement_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_BroadcastChannelAnnouncement_get_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_BroadcastChannelAnnouncement_get_update_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_BroadcastChannelAnnouncement_get_update_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_BroadcastNodeAnnouncement_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_BroadcastNodeAnnouncement_get_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_BroadcastChannelUpdate_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_BroadcastChannelUpdate_get_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendChannelUpdate_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelUpdate_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendChannelUpdate_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelUpdate_get_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_HandleError_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_HandleError_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_HandleError_get_action(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_HandleError_get_action(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendChannelRangeQuery_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelRangeQuery_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendChannelRangeQuery_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelRangeQuery_get_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendShortIdsQuery_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendShortIdsQuery_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendShortIdsQuery_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendShortIdsQuery_get_msg(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendReplyChannelRange_get_node_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendReplyChannelRange_get_node_id(ptr);
    return nativeResponseValue;
}
function LDKMessageSendEvent_SendReplyChannelRange_get_msg(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendReplyChannelRange_get_msg(ptr);
    return nativeResponseValue;
}
function CResult_boolLightningErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_boolLightningErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_get_err(owner);
    return nativeResponseValue;
}
function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_a(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_a(owner);
    return nativeResponseValue;
}
function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_b(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_b(owner);
    return nativeResponseValue;
}
function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_c(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_c(owner);
    return nativeResponseValue;
}
function CResult_CVec_u8ZPeerHandleErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_CVec_u8ZPeerHandleErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_NonePeerHandleErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_get_ok(owner);
// debug statements here
}
function CResult_NonePeerHandleErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_boolPeerHandleErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_boolPeerHandleErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_TxOutAccessErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxOutAccessErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_TxOutAccessErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxOutAccessErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_NoneChannelMonitorUpdateErrZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneChannelMonitorUpdateErrZ_get_ok(owner);
// debug statements here
}
function CResult_NoneChannelMonitorUpdateErrZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneChannelMonitorUpdateErrZ_get_err(owner);
    return nativeResponseValue;
}
class LDKCOption_C2Tuple_usizeTransactionZZ {
    constructor(){
    }
}
function LDKCOption_C2Tuple_usizeTransactionZZ_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_C2Tuple_usizeTransactionZZ_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKCOption_C2Tuple_usizeTransactionZZ_Some_get_some(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_C2Tuple_usizeTransactionZZ_Some_get_some(ptr);
    return nativeResponseValue;
}
class LDKCOption_ClosureReasonZ {
    constructor(){
    }
}
function LDKCOption_ClosureReasonZ_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_ClosureReasonZ_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKCOption_ClosureReasonZ_Some_get_some(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_ClosureReasonZ_Some_get_some(ptr);
    return nativeResponseValue;
}
function CResult_COption_ClosureReasonZDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_COption_ClosureReasonZDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
class LDKCOption_EventZ {
    constructor(){
    }
}
function LDKCOption_EventZ_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_EventZ_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKCOption_EventZ_Some_get_some(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_EventZ_Some_get_some(ptr);
    return nativeResponseValue;
}
function CResult_COption_EventZDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_COption_EventZDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_NodeIdDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_NodeIdDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_COption_NetworkUpdateZDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_COption_NetworkUpdateZDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function LDKAccess_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKAccess_new(i);
}
function Access_get_utxo(this_arg, genesis_hash, short_channel_id) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Access_get_utxo(this_arg, genesis_hash, short_channel_id);
    return nativeResponseValue;
}
class LDKCOption_AccessZ {
    constructor(){
    }
}
function LDKCOption_AccessZ_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_AccessZ_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKCOption_AccessZ_Some_get_some(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_AccessZ_Some_get_some(ptr);
    return nativeResponseValue;
}
function CResult_DirectionalChannelInfoDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_DirectionalChannelInfoDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_DirectionalChannelInfoDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_DirectionalChannelInfoDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_ChannelInfoDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ChannelInfoDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_RoutingFeesDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_RoutingFeesDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
class LDKNetAddress {
    constructor(){
    }
}
function LDKNetAddress_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKNetAddress_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKNetAddress_IPv4_get_addr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKNetAddress_IPv4_get_addr(ptr);
    return nativeResponseValue;
}
function LDKNetAddress_IPv4_get_port(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKNetAddress_IPv4_get_port(ptr);
    return nativeResponseValue;
}
function LDKNetAddress_IPv6_get_addr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKNetAddress_IPv6_get_addr(ptr);
    return nativeResponseValue;
}
function LDKNetAddress_IPv6_get_port(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKNetAddress_IPv6_get_port(ptr);
    return nativeResponseValue;
}
function LDKNetAddress_OnionV2_get_onion_v2(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKNetAddress_OnionV2_get_onion_v2(ptr);
    return nativeResponseValue;
}
function LDKNetAddress_OnionV3_get_ed25519_pubkey(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKNetAddress_OnionV3_get_ed25519_pubkey(ptr);
    return nativeResponseValue;
}
function LDKNetAddress_OnionV3_get_checksum(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKNetAddress_OnionV3_get_checksum(ptr);
    return nativeResponseValue;
}
function LDKNetAddress_OnionV3_get_version(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKNetAddress_OnionV3_get_version(ptr);
    return nativeResponseValue;
}
function LDKNetAddress_OnionV3_get_port(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKNetAddress_OnionV3_get_port(ptr);
    return nativeResponseValue;
}
function CResult_NodeAnnouncementInfoDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_NodeAnnouncementInfoDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_NodeInfoDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_NodeInfoDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_NetworkGraphDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_NetworkGraphDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
class LDKCOption_CVec_NetAddressZZ {
    constructor(){
    }
}
function LDKCOption_CVec_NetAddressZZ_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_CVec_NetAddressZZ_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKCOption_CVec_NetAddressZZ_Some_get_some(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_CVec_NetAddressZZ_Some_get_some(ptr);
    return nativeResponseValue;
}
function CResult_ScoringParametersDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ScoringParametersDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ScoringParametersDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ScoringParametersDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_InitFeaturesDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_InitFeaturesDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_ChannelFeaturesDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ChannelFeaturesDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_NodeFeaturesDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_NodeFeaturesDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_InvoiceFeaturesDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InvoiceFeaturesDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_InvoiceFeaturesDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InvoiceFeaturesDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_ChannelTypeFeaturesDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ChannelTypeFeaturesDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_NetAddressDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_NetAddressDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_AcceptChannelDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_AcceptChannelDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_AnnouncementSignaturesDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_AnnouncementSignaturesDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_ChannelReestablishDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ChannelReestablishDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_ClosingSignedDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ClosingSignedDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_ClosingSignedFeeRangeDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ClosingSignedFeeRangeDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_CommitmentSignedDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_CommitmentSignedDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_FundingCreatedDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_FundingCreatedDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_FundingSignedDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_FundingSignedDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_FundingLockedDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingLockedDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_FundingLockedDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingLockedDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_InitDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_InitDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_OpenChannelDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_OpenChannelDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_RevokeAndACKDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_RevokeAndACKDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_ShutdownDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ShutdownDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_UpdateFailHTLCDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_UpdateFailHTLCDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_UpdateFeeDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_UpdateFeeDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_UpdateFulfillHTLCDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_UpdateFulfillHTLCDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_UpdateAddHTLCDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_UpdateAddHTLCDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_PingDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_PingDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_PongDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_PongDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_ChannelAnnouncementDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ChannelAnnouncementDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_UnsignedChannelUpdateDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_UnsignedChannelUpdateDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_ChannelUpdateDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ChannelUpdateDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_ErrorMessageDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ErrorMessageDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_NodeAnnouncementDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_NodeAnnouncementDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_QueryShortChannelIdsDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_QueryShortChannelIdsDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_QueryChannelRangeDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_QueryChannelRangeDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_ReplyChannelRangeDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_ReplyChannelRangeDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_GossipTimestampFilterDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_GossipTimestampFilterDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_SpendableOutputDescriptorDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_SpendableOutputDescriptorDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_SignDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SignDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_SignDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SignDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_RecoverableSignatureNoneZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_RecoverableSignatureNoneZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_get_err(owner);
// debug statements here
}
function CResult_CVec_CVec_u8ZZNoneZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_CVec_CVec_u8ZZNoneZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_get_err(owner);
// debug statements here
}
function CResult_InMemorySignerDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_InMemorySignerDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_TransactionNoneZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_TransactionNoneZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_get_err(owner);
// debug statements here
}
function LDKFilter_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKFilter_new(i);
}
function Filter_register_tx(this_arg, txid, script_pubkey) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Filter_register_tx(this_arg, txid, script_pubkey);
// debug statements here
}
function Filter_register_output(this_arg, output) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Filter_register_output(this_arg, output);
    return nativeResponseValue;
}
class LDKCOption_FilterZ {
    constructor(){
    }
}
function LDKCOption_FilterZ_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_FilterZ_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKCOption_FilterZ_Some_get_some(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_FilterZ_Some_get_some(ptr);
    return nativeResponseValue;
}
function CResult_LockedChannelMonitorNoneZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_LockedChannelMonitorNoneZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_get_err(owner);
// debug statements here
}
class LDKAPIError {
    constructor(){
    }
}
function LDKAPIError_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKAPIError_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKAPIError_APIMisuseError_get_err(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKAPIError_APIMisuseError_get_err(ptr);
    return nativeResponseValue;
}
function LDKAPIError_FeeRateTooHigh_get_err(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKAPIError_FeeRateTooHigh_get_err(ptr);
    return nativeResponseValue;
}
function LDKAPIError_FeeRateTooHigh_get_feerate(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKAPIError_FeeRateTooHigh_get_feerate(ptr);
    return nativeResponseValue;
}
function LDKAPIError_RouteError_get_err(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKAPIError_RouteError_get_err(ptr);
    return nativeResponseValue;
}
function LDKAPIError_ChannelUnavailable_get_err(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKAPIError_ChannelUnavailable_get_err(ptr);
    return nativeResponseValue;
}
function LDKAPIError_IncompatibleShutdownScript_get_script(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKAPIError_IncompatibleShutdownScript_get_script(ptr);
    return nativeResponseValue;
}
function CResult_NoneAPIErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_get_ok(owner);
// debug statements here
}
function CResult_NoneAPIErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_get_err(owner);
    return nativeResponseValue;
}
class LDKCOption_u16Z {
    constructor(){
    }
}
function LDKCOption_u16Z_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_u16Z_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKCOption_u16Z_Some_get_some(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKCOption_u16Z_Some_get_some(ptr);
    return nativeResponseValue;
}
function CResult__u832APIErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult__u832APIErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_get_err(owner);
    return nativeResponseValue;
}
class LDKPaymentSendFailure {
    constructor(){
    }
}
function LDKPaymentSendFailure_ty_from_ptr(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_ty_from_ptr(ptr);
    return nativeResponseValue;
}
function LDKPaymentSendFailure_ParameterError_get_parameter_error(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_ParameterError_get_parameter_error(ptr);
    return nativeResponseValue;
}
function LDKPaymentSendFailure_PathParameterError_get_path_parameter_error(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_PathParameterError_get_path_parameter_error(ptr);
    return nativeResponseValue;
}
function LDKPaymentSendFailure_AllFailedRetrySafe_get_all_failed_retry_safe(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_AllFailedRetrySafe_get_all_failed_retry_safe(ptr);
    return nativeResponseValue;
}
function LDKPaymentSendFailure_PartialFailure_get_results(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_PartialFailure_get_results(ptr);
    return nativeResponseValue;
}
function LDKPaymentSendFailure_PartialFailure_get_failed_paths_retry(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_PartialFailure_get_failed_paths_retry(ptr);
    return nativeResponseValue;
}
function LDKPaymentSendFailure_PartialFailure_get_payment_id(ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_PartialFailure_get_payment_id(ptr);
    return nativeResponseValue;
}
function CResult_PaymentIdPaymentSendFailureZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentSendFailureZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_PaymentIdPaymentSendFailureZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentSendFailureZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_NonePaymentSendFailureZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_get_ok(owner);
// debug statements here
}
function CResult_NonePaymentSendFailureZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_get_err(owner);
    return nativeResponseValue;
}
function C2Tuple_PaymentHashPaymentIdZ_get_a(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_get_a(owner);
    return nativeResponseValue;
}
function C2Tuple_PaymentHashPaymentIdZ_get_b(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_get_b(owner);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_err(owner);
    return nativeResponseValue;
}
function C2Tuple_PaymentHashPaymentSecretZ_get_a(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_get_a(owner);
    return nativeResponseValue;
}
function C2Tuple_PaymentHashPaymentSecretZ_get_b(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_get_b(owner);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_err(owner);
// debug statements here
}
function CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_PaymentSecretNoneZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_PaymentSecretNoneZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_get_err(owner);
// debug statements here
}
function CResult_PaymentSecretAPIErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentSecretAPIErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_PaymentSecretAPIErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentSecretAPIErrorZ_get_err(owner);
    return nativeResponseValue;
}
function CResult_PaymentPreimageAPIErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_PaymentPreimageAPIErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_get_err(owner);
    return nativeResponseValue;
}
function LDKWatch_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKWatch_new(i);
}
function Watch_watch_channel(this_arg, funding_txo, monitor) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Watch_watch_channel(this_arg, funding_txo, monitor);
    return nativeResponseValue;
}
function Watch_update_channel(this_arg, funding_txo, update) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Watch_update_channel(this_arg, funding_txo, update);
    return nativeResponseValue;
}
function Watch_release_pending_monitor_events(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Watch_release_pending_monitor_events(this_arg);
    return nativeResponseValue;
}
function LDKBroadcasterInterface_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKBroadcasterInterface_new(i);
}
function BroadcasterInterface_broadcast_transaction(this_arg, tx) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BroadcasterInterface_broadcast_transaction(this_arg, tx);
// debug statements here
}
function LDKKeysInterface_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKKeysInterface_new(i);
}
function KeysInterface_get_node_secret(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_KeysInterface_get_node_secret(this_arg);
    return nativeResponseValue;
}
function KeysInterface_get_destination_script(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_KeysInterface_get_destination_script(this_arg);
    return nativeResponseValue;
}
function KeysInterface_get_shutdown_scriptpubkey(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_KeysInterface_get_shutdown_scriptpubkey(this_arg);
    return nativeResponseValue;
}
function KeysInterface_get_channel_signer(this_arg, inbound, channel_value_satoshis) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_KeysInterface_get_channel_signer(this_arg, inbound, channel_value_satoshis);
    return nativeResponseValue;
}
function KeysInterface_get_secure_random_bytes(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_KeysInterface_get_secure_random_bytes(this_arg);
    return nativeResponseValue;
}
function KeysInterface_read_chan_signer(this_arg, reader) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_KeysInterface_read_chan_signer(this_arg, reader);
    return nativeResponseValue;
}
function KeysInterface_sign_invoice(this_arg, invoice_preimage) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_KeysInterface_sign_invoice(this_arg, invoice_preimage);
    return nativeResponseValue;
}
function KeysInterface_get_inbound_payment_key_material(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_KeysInterface_get_inbound_payment_key_material(this_arg);
    return nativeResponseValue;
}
function LDKFeeEstimator_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKFeeEstimator_new(i);
}
function FeeEstimator_get_est_sat_per_1000_weight(this_arg, confirmation_target) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FeeEstimator_get_est_sat_per_1000_weight(this_arg, confirmation_target);
    return nativeResponseValue;
}
function LDKLogger_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKLogger_new(i);
}
function C2Tuple_BlockHashChannelManagerZ_get_a(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelManagerZ_get_a(owner);
    return nativeResponseValue;
}
function C2Tuple_BlockHashChannelManagerZ_get_b(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelManagerZ_get_b(owner);
    return nativeResponseValue;
}
function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_ok(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_ok(owner);
    return nativeResponseValue;
}
function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_err(owner) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_err(owner);
    return nativeResponseValue;
}
function LDKMessageSendEventsProvider_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKMessageSendEventsProvider_new(i);
}
function MessageSendEventsProvider_get_and_clear_pending_msg_events(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEventsProvider_get_and_clear_pending_msg_events(this_arg);
    return nativeResponseValue;
}
function LDKEventHandler_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKEventHandler_new(i);
}
function EventHandler_handle_event(this_arg, event) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_EventHandler_handle_event(this_arg, event);
// debug statements here
}
function LDKEventsProvider_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKEventsProvider_new(i);
}
function EventsProvider_process_pending_events(this_arg, handler) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_EventsProvider_process_pending_events(this_arg, handler);
// debug statements here
}
function LDKListen_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKListen_new(i);
}
function Listen_block_connected(this_arg, block, height) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Listen_block_connected(this_arg, block, height);
// debug statements here
}
function Listen_block_disconnected(this_arg, header, height) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Listen_block_disconnected(this_arg, header, height);
// debug statements here
}
function LDKConfirm_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKConfirm_new(i);
}
function Confirm_transactions_confirmed(this_arg, header, txdata, height) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Confirm_transactions_confirmed(this_arg, header, txdata, height);
// debug statements here
}
function Confirm_transaction_unconfirmed(this_arg, txid) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Confirm_transaction_unconfirmed(this_arg, txid);
// debug statements here
}
function Confirm_best_block_updated(this_arg, header, height) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Confirm_best_block_updated(this_arg, header, height);
// debug statements here
}
function Confirm_get_relevant_txids(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Confirm_get_relevant_txids(this_arg);
    return nativeResponseValue;
}
function LDKPersist_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKPersist_new(i);
}
function Persist_persist_new_channel(this_arg, channel_id, data, update_id) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Persist_persist_new_channel(this_arg, channel_id, data, update_id);
    return nativeResponseValue;
}
function Persist_update_persisted_channel(this_arg, channel_id, update, data, update_id) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Persist_update_persisted_channel(this_arg, channel_id, update, data, update_id);
    return nativeResponseValue;
}
function LDKChannelMessageHandler_new(impl, MessageSendEventsProvider) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKChannelMessageHandler_new(i);
}
function ChannelMessageHandler_handle_open_channel(this_arg, their_node_id, their_features, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_open_channel(this_arg, their_node_id, their_features, msg);
// debug statements here
}
function ChannelMessageHandler_handle_accept_channel(this_arg, their_node_id, their_features, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_accept_channel(this_arg, their_node_id, their_features, msg);
// debug statements here
}
function ChannelMessageHandler_handle_funding_created(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_funding_created(this_arg, their_node_id, msg);
// debug statements here
}
function ChannelMessageHandler_handle_funding_signed(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_funding_signed(this_arg, their_node_id, msg);
// debug statements here
}
function ChannelMessageHandler_handle_funding_locked(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_funding_locked(this_arg, their_node_id, msg);
// debug statements here
}
function ChannelMessageHandler_handle_shutdown(this_arg, their_node_id, their_features, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_shutdown(this_arg, their_node_id, their_features, msg);
// debug statements here
}
function ChannelMessageHandler_handle_closing_signed(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_closing_signed(this_arg, their_node_id, msg);
// debug statements here
}
function ChannelMessageHandler_handle_update_add_htlc(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_update_add_htlc(this_arg, their_node_id, msg);
// debug statements here
}
function ChannelMessageHandler_handle_update_fulfill_htlc(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_update_fulfill_htlc(this_arg, their_node_id, msg);
// debug statements here
}
function ChannelMessageHandler_handle_update_fail_htlc(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_update_fail_htlc(this_arg, their_node_id, msg);
// debug statements here
}
function ChannelMessageHandler_handle_update_fail_malformed_htlc(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_update_fail_malformed_htlc(this_arg, their_node_id, msg);
// debug statements here
}
function ChannelMessageHandler_handle_commitment_signed(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_commitment_signed(this_arg, their_node_id, msg);
// debug statements here
}
function ChannelMessageHandler_handle_revoke_and_ack(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_revoke_and_ack(this_arg, their_node_id, msg);
// debug statements here
}
function ChannelMessageHandler_handle_update_fee(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_update_fee(this_arg, their_node_id, msg);
// debug statements here
}
function ChannelMessageHandler_handle_announcement_signatures(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_announcement_signatures(this_arg, their_node_id, msg);
// debug statements here
}
function ChannelMessageHandler_peer_disconnected(this_arg, their_node_id, no_connection_possible) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_peer_disconnected(this_arg, their_node_id, no_connection_possible);
// debug statements here
}
function ChannelMessageHandler_peer_connected(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_peer_connected(this_arg, their_node_id, msg);
// debug statements here
}
function ChannelMessageHandler_handle_channel_reestablish(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_channel_reestablish(this_arg, their_node_id, msg);
// debug statements here
}
function ChannelMessageHandler_handle_channel_update(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_channel_update(this_arg, their_node_id, msg);
// debug statements here
}
function ChannelMessageHandler_handle_error(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_error(this_arg, their_node_id, msg);
// debug statements here
}
function LDKRoutingMessageHandler_new(impl, MessageSendEventsProvider) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKRoutingMessageHandler_new(i);
}
function RoutingMessageHandler_handle_node_announcement(this_arg, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_node_announcement(this_arg, msg);
    return nativeResponseValue;
}
function RoutingMessageHandler_handle_channel_announcement(this_arg, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_channel_announcement(this_arg, msg);
    return nativeResponseValue;
}
function RoutingMessageHandler_handle_channel_update(this_arg, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_channel_update(this_arg, msg);
    return nativeResponseValue;
}
function RoutingMessageHandler_get_next_channel_announcements(this_arg, starting_point, batch_amount) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingMessageHandler_get_next_channel_announcements(this_arg, starting_point, batch_amount);
    return nativeResponseValue;
}
function RoutingMessageHandler_get_next_node_announcements(this_arg, starting_point, batch_amount) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingMessageHandler_get_next_node_announcements(this_arg, starting_point, batch_amount);
    return nativeResponseValue;
}
function RoutingMessageHandler_sync_routing_table(this_arg, their_node_id, init) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingMessageHandler_sync_routing_table(this_arg, their_node_id, init);
// debug statements here
}
function RoutingMessageHandler_handle_reply_channel_range(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_reply_channel_range(this_arg, their_node_id, msg);
    return nativeResponseValue;
}
function RoutingMessageHandler_handle_reply_short_channel_ids_end(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_reply_short_channel_ids_end(this_arg, their_node_id, msg);
    return nativeResponseValue;
}
function RoutingMessageHandler_handle_query_channel_range(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_query_channel_range(this_arg, their_node_id, msg);
    return nativeResponseValue;
}
function RoutingMessageHandler_handle_query_short_channel_ids(this_arg, their_node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_query_short_channel_ids(this_arg, their_node_id, msg);
    return nativeResponseValue;
}
function LDKCustomMessageReader_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKCustomMessageReader_new(i);
}
function CustomMessageReader_read(this_arg, message_type, buffer) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CustomMessageReader_read(this_arg, message_type, buffer);
    return nativeResponseValue;
}
function LDKCustomMessageHandler_new(impl, CustomMessageReader) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKCustomMessageHandler_new(i);
}
function CustomMessageHandler_handle_custom_message(this_arg, msg, sender_node_id) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CustomMessageHandler_handle_custom_message(this_arg, msg, sender_node_id);
    return nativeResponseValue;
}
function CustomMessageHandler_get_and_clear_pending_msg(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CustomMessageHandler_get_and_clear_pending_msg(this_arg);
    return nativeResponseValue;
}
function LDKSocketDescriptor_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKSocketDescriptor_new(i);
}
function SocketDescriptor_send_data(this_arg, data, resume_read) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_SocketDescriptor_send_data(this_arg, data, resume_read);
    return nativeResponseValue;
}
function SocketDescriptor_disconnect_socket(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_SocketDescriptor_disconnect_socket(this_arg);
// debug statements here
}
function SocketDescriptor_hash(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_SocketDescriptor_hash(this_arg);
    return nativeResponseValue;
}
function LDKScore_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKScore_new(i);
}
function Score_channel_penalty_msat(this_arg, short_channel_id, send_amt_msat, channel_capacity_msat, source, target) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Score_channel_penalty_msat(this_arg, short_channel_id, send_amt_msat, channel_capacity_msat, source, target);
    return nativeResponseValue;
}
function Score_payment_path_failed(this_arg, path, short_channel_id) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Score_payment_path_failed(this_arg, path, short_channel_id);
// debug statements here
}
function Score_payment_path_successful(this_arg, path) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Score_payment_path_successful(this_arg, path);
// debug statements here
}
function Score_write(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Score_write(this_arg);
    return nativeResponseValue;
}
function LDKLockableScore_new(impl) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    var new_obj_idx = js_objs.length;
    for(var i = 0; i < js_objs.length; i++)if (js_objs[i] == null || js_objs[i] == undefined) {
        new_obj_idx = i;
        break;
    }
    js_objs[i] = new WeakRef(impl);
    return wasm.TS_LDKLockableScore_new(i);
}
function LockableScore_lock(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LockableScore_lock(this_arg);
    return nativeResponseValue;
}
function _ldk_get_compiled_version() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS__ldk_get_compiled_version();
    return nativeResponseValue;
}
function _ldk_c_bindings_get_compiled_version() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS__ldk_c_bindings_get_compiled_version();
    return nativeResponseValue;
}
function Transaction_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Transaction_free(_res);
// debug statements here
}
function TxOut_new(script_pubkey, value) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxOut_new(script_pubkey, value);
    return nativeResponseValue;
}
function TxOut_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxOut_free(_res);
// debug statements here
}
function TxOut_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxOut_clone_ptr(arg);
    return nativeResponseValue;
}
function TxOut_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxOut_clone(orig);
    return nativeResponseValue;
}
function Str_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Str_free(_res);
// debug statements here
}
function CResult_ChannelConfigDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelConfigDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ChannelConfigDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelConfigDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ChannelConfigDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_ChannelConfigDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_OutPointDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_OutPointDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_OutPointDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_OutPointDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_OutPointDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_OutPointDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_SecretKeyErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SecretKeyErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_SecretKeyErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SecretKeyErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_SecretKeyErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SecretKeyErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_SecretKeyErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SecretKeyErrorZ_free(_res);
// debug statements here
}
function CResult_PublicKeyErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_PublicKeyErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_PublicKeyErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_PublicKeyErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_free(_res);
// debug statements here
}
function CResult_PublicKeyErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_PublicKeyErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_TxCreationKeysDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_TxCreationKeysDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_TxCreationKeysDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_TxCreationKeysDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_TxCreationKeysDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_TxCreationKeysDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_ChannelPublicKeysDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelPublicKeysDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ChannelPublicKeysDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelPublicKeysDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ChannelPublicKeysDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_ChannelPublicKeysDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_TxCreationKeysErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxCreationKeysErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_TxCreationKeysErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxCreationKeysErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_TxCreationKeysErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxCreationKeysErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_TxCreationKeysErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxCreationKeysErrorZ_free(_res);
// debug statements here
}
function CResult_TxCreationKeysErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxCreationKeysErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_TxCreationKeysErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxCreationKeysErrorZ_clone(orig);
    return nativeResponseValue;
}
function COption_u32Z_some(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_u32Z_some(o);
    return nativeResponseValue;
}
function COption_u32Z_none() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_u32Z_none();
    return nativeResponseValue;
}
function COption_u32Z_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_u32Z_free(_res);
// debug statements here
}
function COption_u32Z_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_u32Z_clone_ptr(arg);
    return nativeResponseValue;
}
function COption_u32Z_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_u32Z_clone(orig);
    return nativeResponseValue;
}
function CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_HTLCOutputInCommitmentDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_HTLCOutputInCommitmentDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_HTLCOutputInCommitmentDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function COption_NoneZ_some() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_NoneZ_some();
    return nativeResponseValue;
}
function COption_NoneZ_none() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_NoneZ_none();
    return nativeResponseValue;
}
function COption_NoneZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_NoneZ_free(_res);
// debug statements here
}
function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_ChannelTransactionParametersDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelTransactionParametersDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelTransactionParametersDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ChannelTransactionParametersDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_ChannelTransactionParametersDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CVec_SignatureZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_SignatureZ_free(_res);
// debug statements here
}
function CResult_HolderCommitmentTransactionDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_HolderCommitmentTransactionDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_HolderCommitmentTransactionDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_HolderCommitmentTransactionDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_HolderCommitmentTransactionDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_BuiltCommitmentTransactionDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_BuiltCommitmentTransactionDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_BuiltCommitmentTransactionDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_TrustedClosingTransactionNoneZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_ok(o);
    return nativeResponseValue;
}
function CResult_TrustedClosingTransactionNoneZ_err() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_err();
    return nativeResponseValue;
}
function CResult_TrustedClosingTransactionNoneZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_TrustedClosingTransactionNoneZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_free(_res);
// debug statements here
}
function CResult_CommitmentTransactionDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_CommitmentTransactionDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_CommitmentTransactionDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_CommitmentTransactionDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_CommitmentTransactionDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_CommitmentTransactionDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_TrustedCommitmentTransactionNoneZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_ok(o);
    return nativeResponseValue;
}
function CResult_TrustedCommitmentTransactionNoneZ_err() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_err();
    return nativeResponseValue;
}
function CResult_TrustedCommitmentTransactionNoneZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_TrustedCommitmentTransactionNoneZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_free(_res);
// debug statements here
}
function CResult_CVec_SignatureZNoneZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_ok(o);
    return nativeResponseValue;
}
function CResult_CVec_SignatureZNoneZ_err() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_err();
    return nativeResponseValue;
}
function CResult_CVec_SignatureZNoneZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_CVec_SignatureZNoneZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_free(_res);
// debug statements here
}
function CResult_CVec_SignatureZNoneZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_CVec_SignatureZNoneZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_clone(orig);
    return nativeResponseValue;
}
function CResult_ShutdownScriptDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ShutdownScriptDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ShutdownScriptDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ShutdownScriptDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ShutdownScriptDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_ShutdownScriptDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_ShutdownScriptInvalidShutdownScriptZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_ok(o);
    return nativeResponseValue;
}
function CResult_ShutdownScriptInvalidShutdownScriptZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_err(e);
    return nativeResponseValue;
}
function CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ShutdownScriptInvalidShutdownScriptZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_free(_res);
// debug statements here
}
function CResult_ShutdownScriptInvalidShutdownScriptZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_ShutdownScriptInvalidShutdownScriptZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_clone(orig);
    return nativeResponseValue;
}
function COption_TypeZ_some(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_TypeZ_some(o);
    return nativeResponseValue;
}
function COption_TypeZ_none() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_TypeZ_none();
    return nativeResponseValue;
}
function COption_TypeZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_TypeZ_free(_res);
// debug statements here
}
function COption_TypeZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_TypeZ_clone_ptr(arg);
    return nativeResponseValue;
}
function COption_TypeZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_TypeZ_clone(orig);
    return nativeResponseValue;
}
function CResult_COption_TypeZDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_COption_TypeZDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_COption_TypeZDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_COption_TypeZDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_COption_TypeZDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_COption_TypeZDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_StringErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_StringErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_StringErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_StringErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_StringErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_StringErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_StringErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_StringErrorZ_free(_res);
// debug statements here
}
function CResult_ChannelMonitorUpdateDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelMonitorUpdateDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelMonitorUpdateDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ChannelMonitorUpdateDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_ChannelMonitorUpdateDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function COption_MonitorEventZ_some(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_MonitorEventZ_some(o);
    return nativeResponseValue;
}
function COption_MonitorEventZ_none() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_MonitorEventZ_none();
    return nativeResponseValue;
}
function COption_MonitorEventZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_MonitorEventZ_free(_res);
// debug statements here
}
function COption_MonitorEventZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_MonitorEventZ_clone_ptr(arg);
    return nativeResponseValue;
}
function COption_MonitorEventZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_MonitorEventZ_clone(orig);
    return nativeResponseValue;
}
function CResult_COption_MonitorEventZDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_COption_MonitorEventZDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_COption_MonitorEventZDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_COption_MonitorEventZDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_COption_MonitorEventZDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_COption_MonitorEventZDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_HTLCUpdateDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_HTLCUpdateDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_HTLCUpdateDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_HTLCUpdateDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_HTLCUpdateDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_HTLCUpdateDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_NoneNoneZ_ok() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_ok();
    return nativeResponseValue;
}
function CResult_NoneNoneZ_err() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_err();
    return nativeResponseValue;
}
function CResult_NoneNoneZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_NoneNoneZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_free(_res);
// debug statements here
}
function CResult_NoneNoneZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_NoneNoneZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_clone(orig);
    return nativeResponseValue;
}
function C2Tuple_OutPointScriptZ_new(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_OutPointScriptZ_new(a, b);
    return nativeResponseValue;
}
function C2Tuple_OutPointScriptZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_OutPointScriptZ_free(_res);
// debug statements here
}
function C2Tuple_u32ScriptZ_new(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_u32ScriptZ_new(a, b);
    return nativeResponseValue;
}
function C2Tuple_u32ScriptZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_u32ScriptZ_free(_res);
// debug statements here
}
function CVec_C2Tuple_u32ScriptZZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_C2Tuple_u32ScriptZZ_free(_res);
// debug statements here
}
function C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(a, b);
    return nativeResponseValue;
}
function C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free(_res);
// debug statements here
}
function CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free(_res);
// debug statements here
}
function CVec_MonitorEventZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_MonitorEventZ_free(_res);
// debug statements here
}
function CVec_EventZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_EventZ_free(_res);
// debug statements here
}
function CVec_TransactionZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_TransactionZ_free(_res);
// debug statements here
}
function C2Tuple_usizeTransactionZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_clone_ptr(arg);
    return nativeResponseValue;
}
function C2Tuple_usizeTransactionZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_clone(orig);
    return nativeResponseValue;
}
function C2Tuple_usizeTransactionZ_new(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_new(a, b);
    return nativeResponseValue;
}
function C2Tuple_usizeTransactionZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_free(_res);
// debug statements here
}
function CVec_C2Tuple_usizeTransactionZZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_C2Tuple_usizeTransactionZZ_free(_res);
// debug statements here
}
function C2Tuple_u32TxOutZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_clone_ptr(arg);
    return nativeResponseValue;
}
function C2Tuple_u32TxOutZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_clone(orig);
    return nativeResponseValue;
}
function C2Tuple_u32TxOutZ_new(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_new(a, b);
    return nativeResponseValue;
}
function C2Tuple_u32TxOutZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_free(_res);
// debug statements here
}
function CVec_C2Tuple_u32TxOutZZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_C2Tuple_u32TxOutZZ_free(_res);
// debug statements here
}
function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone_ptr(arg);
    return nativeResponseValue;
}
function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(orig);
    return nativeResponseValue;
}
function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(a, b);
    return nativeResponseValue;
}
function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free(_res);
// debug statements here
}
function CVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ_free(_res);
// debug statements here
}
function CVec_TxidZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_TxidZ_free(_res);
// debug statements here
}
function CVec_BalanceZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_BalanceZ_free(_res);
// debug statements here
}
function C2Tuple_BlockHashChannelMonitorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function C2Tuple_BlockHashChannelMonitorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_clone(orig);
    return nativeResponseValue;
}
function C2Tuple_BlockHashChannelMonitorZ_new(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_new(a, b);
    return nativeResponseValue;
}
function C2Tuple_BlockHashChannelMonitorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_free(_res);
// debug statements here
}
function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_RouteHopDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_RouteHopDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_RouteHopDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_RouteHopDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_RouteHopDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_RouteHopDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CVec_RouteHopZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_RouteHopZ_free(_res);
// debug statements here
}
function CVec_CVec_RouteHopZZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_CVec_RouteHopZZ_free(_res);
// debug statements here
}
function CResult_RouteDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_RouteDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_RouteDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_RouteDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_RouteDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_RouteDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_RouteParametersDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_RouteParametersDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_RouteParametersDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_RouteParametersDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_RouteParametersDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_RouteParametersDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CVec_RouteHintZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_RouteHintZ_free(_res);
// debug statements here
}
function COption_u64Z_some(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_u64Z_some(o);
    return nativeResponseValue;
}
function COption_u64Z_none() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_u64Z_none();
    return nativeResponseValue;
}
function COption_u64Z_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_u64Z_free(_res);
// debug statements here
}
function COption_u64Z_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_u64Z_clone_ptr(arg);
    return nativeResponseValue;
}
function COption_u64Z_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_u64Z_clone(orig);
    return nativeResponseValue;
}
function CResult_PayeeDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PayeeDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_PayeeDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PayeeDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_PayeeDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PayeeDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_PayeeDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PayeeDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_PayeeDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PayeeDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_PayeeDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PayeeDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CVec_RouteHintHopZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_RouteHintHopZ_free(_res);
// debug statements here
}
function CResult_RouteHintDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_RouteHintDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_RouteHintDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_RouteHintDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_RouteHintDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_RouteHintDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_RouteHintHopDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_RouteHintHopDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_RouteHintHopDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_RouteHintHopDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_RouteHintHopDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_RouteHintHopDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CVec_ChannelDetailsZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_ChannelDetailsZ_free(_res);
// debug statements here
}
function CResult_RouteLightningErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_RouteLightningErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_RouteLightningErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_RouteLightningErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_free(_res);
// debug statements here
}
function CResult_RouteLightningErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_RouteLightningErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_NoneLightningErrorZ_ok() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_ok();
    return nativeResponseValue;
}
function CResult_NoneLightningErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_NoneLightningErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_NoneLightningErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_free(_res);
// debug statements here
}
function CResult_NoneLightningErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_NoneLightningErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_clone(orig);
    return nativeResponseValue;
}
function C2Tuple_PublicKeyTypeZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_clone_ptr(arg);
    return nativeResponseValue;
}
function C2Tuple_PublicKeyTypeZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_clone(orig);
    return nativeResponseValue;
}
function C2Tuple_PublicKeyTypeZ_new(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_new(a, b);
    return nativeResponseValue;
}
function C2Tuple_PublicKeyTypeZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_free(_res);
// debug statements here
}
function CVec_C2Tuple_PublicKeyTypeZZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_C2Tuple_PublicKeyTypeZZ_free(_res);
// debug statements here
}
function CVec_MessageSendEventZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_MessageSendEventZ_free(_res);
// debug statements here
}
function CResult_boolLightningErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_boolLightningErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_boolLightningErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_boolLightningErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_free(_res);
// debug statements here
}
function CResult_boolLightningErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_boolLightningErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_clone(orig);
    return nativeResponseValue;
}
function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone_ptr(arg);
    return nativeResponseValue;
}
function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(orig);
    return nativeResponseValue;
}
function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(a, b, c) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(a, b, c);
    return nativeResponseValue;
}
function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(_res);
// debug statements here
}
function CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(_res);
// debug statements here
}
function CVec_NodeAnnouncementZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_NodeAnnouncementZ_free(_res);
// debug statements here
}
function CVec_PublicKeyZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_PublicKeyZ_free(_res);
// debug statements here
}
function CVec_u8Z_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_u8Z_free(_res);
// debug statements here
}
function CResult_CVec_u8ZPeerHandleErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_CVec_u8ZPeerHandleErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_CVec_u8ZPeerHandleErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_CVec_u8ZPeerHandleErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_free(_res);
// debug statements here
}
function CResult_CVec_u8ZPeerHandleErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_CVec_u8ZPeerHandleErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_NonePeerHandleErrorZ_ok() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_ok();
    return nativeResponseValue;
}
function CResult_NonePeerHandleErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_NonePeerHandleErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_NonePeerHandleErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_free(_res);
// debug statements here
}
function CResult_NonePeerHandleErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_NonePeerHandleErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_boolPeerHandleErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_boolPeerHandleErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_boolPeerHandleErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_boolPeerHandleErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_free(_res);
// debug statements here
}
function CResult_boolPeerHandleErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_boolPeerHandleErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_TxOutAccessErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxOutAccessErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_TxOutAccessErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxOutAccessErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_TxOutAccessErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxOutAccessErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_TxOutAccessErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxOutAccessErrorZ_free(_res);
// debug statements here
}
function CResult_TxOutAccessErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxOutAccessErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_TxOutAccessErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TxOutAccessErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_NoneChannelMonitorUpdateErrZ_ok() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneChannelMonitorUpdateErrZ_ok();
    return nativeResponseValue;
}
function CResult_NoneChannelMonitorUpdateErrZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneChannelMonitorUpdateErrZ_err(e);
    return nativeResponseValue;
}
function CResult_NoneChannelMonitorUpdateErrZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneChannelMonitorUpdateErrZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_NoneChannelMonitorUpdateErrZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneChannelMonitorUpdateErrZ_free(_res);
// debug statements here
}
function CResult_NoneChannelMonitorUpdateErrZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneChannelMonitorUpdateErrZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_NoneChannelMonitorUpdateErrZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneChannelMonitorUpdateErrZ_clone(orig);
    return nativeResponseValue;
}
function COption_C2Tuple_usizeTransactionZZ_some(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_C2Tuple_usizeTransactionZZ_some(o);
    return nativeResponseValue;
}
function COption_C2Tuple_usizeTransactionZZ_none() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_C2Tuple_usizeTransactionZZ_none();
    return nativeResponseValue;
}
function COption_C2Tuple_usizeTransactionZZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_C2Tuple_usizeTransactionZZ_free(_res);
// debug statements here
}
function COption_C2Tuple_usizeTransactionZZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_C2Tuple_usizeTransactionZZ_clone_ptr(arg);
    return nativeResponseValue;
}
function COption_C2Tuple_usizeTransactionZZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_C2Tuple_usizeTransactionZZ_clone(orig);
    return nativeResponseValue;
}
function COption_ClosureReasonZ_some(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_ClosureReasonZ_some(o);
    return nativeResponseValue;
}
function COption_ClosureReasonZ_none() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_ClosureReasonZ_none();
    return nativeResponseValue;
}
function COption_ClosureReasonZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_ClosureReasonZ_free(_res);
// debug statements here
}
function COption_ClosureReasonZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_ClosureReasonZ_clone_ptr(arg);
    return nativeResponseValue;
}
function COption_ClosureReasonZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_ClosureReasonZ_clone(orig);
    return nativeResponseValue;
}
function CResult_COption_ClosureReasonZDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_COption_ClosureReasonZDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_COption_ClosureReasonZDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_COption_ClosureReasonZDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_COption_ClosureReasonZDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function COption_NetworkUpdateZ_some(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_NetworkUpdateZ_some(o);
    return nativeResponseValue;
}
function COption_NetworkUpdateZ_none() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_NetworkUpdateZ_none();
    return nativeResponseValue;
}
function COption_NetworkUpdateZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_NetworkUpdateZ_free(_res);
// debug statements here
}
function COption_NetworkUpdateZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_NetworkUpdateZ_clone_ptr(arg);
    return nativeResponseValue;
}
function COption_NetworkUpdateZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_NetworkUpdateZ_clone(orig);
    return nativeResponseValue;
}
function CVec_SpendableOutputDescriptorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_SpendableOutputDescriptorZ_free(_res);
// debug statements here
}
function COption_EventZ_some(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_EventZ_some(o);
    return nativeResponseValue;
}
function COption_EventZ_none() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_EventZ_none();
    return nativeResponseValue;
}
function COption_EventZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_EventZ_free(_res);
// debug statements here
}
function COption_EventZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_EventZ_clone_ptr(arg);
    return nativeResponseValue;
}
function COption_EventZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_EventZ_clone(orig);
    return nativeResponseValue;
}
function CResult_COption_EventZDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_COption_EventZDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_COption_EventZDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_COption_EventZDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_COption_EventZDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_COption_EventZDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_NodeIdDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_NodeIdDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_NodeIdDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_NodeIdDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_NodeIdDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_NodeIdDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_COption_NetworkUpdateZDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_COption_NetworkUpdateZDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_COption_NetworkUpdateZDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_COption_NetworkUpdateZDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_COption_NetworkUpdateZDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function COption_AccessZ_some(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_AccessZ_some(o);
    return nativeResponseValue;
}
function COption_AccessZ_none() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_AccessZ_none();
    return nativeResponseValue;
}
function COption_AccessZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_AccessZ_free(_res);
// debug statements here
}
function CResult_DirectionalChannelInfoDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_DirectionalChannelInfoDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_DirectionalChannelInfoDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_DirectionalChannelInfoDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_DirectionalChannelInfoDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_DirectionalChannelInfoDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_DirectionalChannelInfoDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_DirectionalChannelInfoDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_DirectionalChannelInfoDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_DirectionalChannelInfoDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_DirectionalChannelInfoDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_DirectionalChannelInfoDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_ChannelInfoDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelInfoDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ChannelInfoDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelInfoDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ChannelInfoDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_ChannelInfoDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_RoutingFeesDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_RoutingFeesDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_RoutingFeesDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_RoutingFeesDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_RoutingFeesDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_RoutingFeesDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CVec_NetAddressZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_NetAddressZ_free(_res);
// debug statements here
}
function CResult_NodeAnnouncementInfoDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_NodeAnnouncementInfoDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_NodeAnnouncementInfoDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_NodeAnnouncementInfoDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_NodeAnnouncementInfoDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CVec_u64Z_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_u64Z_free(_res);
// debug statements here
}
function CResult_NodeInfoDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_NodeInfoDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_NodeInfoDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_NodeInfoDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_NodeInfoDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_NodeInfoDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_NetworkGraphDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_NetworkGraphDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_NetworkGraphDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_NetworkGraphDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_NetworkGraphDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_NetworkGraphDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function COption_CVec_NetAddressZZ_some(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_CVec_NetAddressZZ_some(o);
    return nativeResponseValue;
}
function COption_CVec_NetAddressZZ_none() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_CVec_NetAddressZZ_none();
    return nativeResponseValue;
}
function COption_CVec_NetAddressZZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_CVec_NetAddressZZ_free(_res);
// debug statements here
}
function COption_CVec_NetAddressZZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_CVec_NetAddressZZ_clone_ptr(arg);
    return nativeResponseValue;
}
function COption_CVec_NetAddressZZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_CVec_NetAddressZZ_clone(orig);
    return nativeResponseValue;
}
function CResult_ScoringParametersDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ScoringParametersDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ScoringParametersDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ScoringParametersDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ScoringParametersDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ScoringParametersDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ScoringParametersDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ScoringParametersDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_InitFeaturesDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_InitFeaturesDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_InitFeaturesDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_InitFeaturesDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ChannelFeaturesDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelFeaturesDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ChannelFeaturesDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelFeaturesDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_NodeFeaturesDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_NodeFeaturesDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_NodeFeaturesDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_NodeFeaturesDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_InvoiceFeaturesDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InvoiceFeaturesDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_InvoiceFeaturesDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InvoiceFeaturesDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_InvoiceFeaturesDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InvoiceFeaturesDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_InvoiceFeaturesDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InvoiceFeaturesDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ChannelTypeFeaturesDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelTypeFeaturesDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelTypeFeaturesDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_NetAddressDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_NetAddressDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_NetAddressDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_NetAddressDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_NetAddressDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_NetAddressDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CVec_UpdateAddHTLCZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_UpdateAddHTLCZ_free(_res);
// debug statements here
}
function CVec_UpdateFulfillHTLCZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_UpdateFulfillHTLCZ_free(_res);
// debug statements here
}
function CVec_UpdateFailHTLCZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_UpdateFailHTLCZ_free(_res);
// debug statements here
}
function CVec_UpdateFailMalformedHTLCZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_UpdateFailMalformedHTLCZ_free(_res);
// debug statements here
}
function CResult_AcceptChannelDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_AcceptChannelDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_AcceptChannelDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_AcceptChannelDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_AcceptChannelDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_AcceptChannelDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_AnnouncementSignaturesDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_AnnouncementSignaturesDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_AnnouncementSignaturesDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_AnnouncementSignaturesDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_AnnouncementSignaturesDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_ChannelReestablishDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelReestablishDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ChannelReestablishDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelReestablishDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ChannelReestablishDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_ChannelReestablishDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_ClosingSignedDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ClosingSignedDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ClosingSignedDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ClosingSignedDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ClosingSignedDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_ClosingSignedDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ClosingSignedFeeRangeDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ClosingSignedFeeRangeDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ClosingSignedFeeRangeDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_CommitmentSignedDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_CommitmentSignedDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_CommitmentSignedDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_CommitmentSignedDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_CommitmentSignedDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_CommitmentSignedDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_FundingCreatedDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_FundingCreatedDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_FundingCreatedDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_FundingCreatedDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_FundingCreatedDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_FundingCreatedDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_FundingSignedDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_FundingSignedDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_FundingSignedDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_FundingSignedDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_FundingSignedDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_FundingSignedDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_FundingLockedDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingLockedDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_FundingLockedDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingLockedDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_FundingLockedDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingLockedDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_FundingLockedDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingLockedDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_FundingLockedDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingLockedDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_FundingLockedDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_FundingLockedDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_InitDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_InitDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_InitDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_InitDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_InitDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_InitDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_OpenChannelDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_OpenChannelDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_OpenChannelDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_OpenChannelDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_OpenChannelDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_OpenChannelDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_RevokeAndACKDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_RevokeAndACKDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_RevokeAndACKDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_RevokeAndACKDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_RevokeAndACKDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_RevokeAndACKDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_ShutdownDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ShutdownDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ShutdownDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ShutdownDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ShutdownDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_ShutdownDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_UpdateFailHTLCDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_UpdateFailHTLCDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_UpdateFailHTLCDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_UpdateFailHTLCDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_UpdateFailHTLCDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_UpdateFailHTLCDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_UpdateFeeDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_UpdateFeeDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_UpdateFeeDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_UpdateFeeDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_UpdateFeeDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_UpdateFeeDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_UpdateFulfillHTLCDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_UpdateFulfillHTLCDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_UpdateFulfillHTLCDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_UpdateFulfillHTLCDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_UpdateFulfillHTLCDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_UpdateAddHTLCDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_UpdateAddHTLCDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_UpdateAddHTLCDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_UpdateAddHTLCDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_UpdateAddHTLCDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_UpdateAddHTLCDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_PingDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_PingDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_PingDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_PingDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_PingDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_PingDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_PongDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_PongDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_PongDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_PongDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_PongDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_PongDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_ChannelAnnouncementDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelAnnouncementDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ChannelAnnouncementDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelAnnouncementDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ChannelAnnouncementDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_ChannelAnnouncementDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_UnsignedChannelUpdateDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_UnsignedChannelUpdateDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_UnsignedChannelUpdateDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_UnsignedChannelUpdateDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_UnsignedChannelUpdateDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_ChannelUpdateDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelUpdateDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ChannelUpdateDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ChannelUpdateDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ChannelUpdateDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_ChannelUpdateDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_ErrorMessageDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ErrorMessageDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ErrorMessageDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ErrorMessageDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ErrorMessageDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_ErrorMessageDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_NodeAnnouncementDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_NodeAnnouncementDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_NodeAnnouncementDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_NodeAnnouncementDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_NodeAnnouncementDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_NodeAnnouncementDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_QueryShortChannelIdsDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_QueryShortChannelIdsDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_QueryShortChannelIdsDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_QueryShortChannelIdsDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_QueryShortChannelIdsDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_QueryChannelRangeDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_QueryChannelRangeDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_QueryChannelRangeDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_QueryChannelRangeDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_QueryChannelRangeDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_QueryChannelRangeDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_ReplyChannelRangeDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_ReplyChannelRangeDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_ReplyChannelRangeDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_ReplyChannelRangeDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_ReplyChannelRangeDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_ReplyChannelRangeDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_GossipTimestampFilterDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_GossipTimestampFilterDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_GossipTimestampFilterDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_GossipTimestampFilterDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_GossipTimestampFilterDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_GossipTimestampFilterDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_SpendableOutputDescriptorDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_SpendableOutputDescriptorDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_SpendableOutputDescriptorDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_SpendableOutputDescriptorDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_SpendableOutputDescriptorDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function C2Tuple_SignatureCVec_SignatureZZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_clone_ptr(arg);
    return nativeResponseValue;
}
function C2Tuple_SignatureCVec_SignatureZZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_clone(orig);
    return nativeResponseValue;
}
function C2Tuple_SignatureCVec_SignatureZZ_new(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_new(a, b);
    return nativeResponseValue;
}
function C2Tuple_SignatureCVec_SignatureZZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_free(_res);
// debug statements here
}
function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(o);
    return nativeResponseValue;
}
function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err();
    return nativeResponseValue;
}
function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free(_res);
// debug statements here
}
function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(orig);
    return nativeResponseValue;
}
function CResult_SignatureNoneZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_ok(o);
    return nativeResponseValue;
}
function CResult_SignatureNoneZ_err() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_err();
    return nativeResponseValue;
}
function CResult_SignatureNoneZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_SignatureNoneZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_free(_res);
// debug statements here
}
function CResult_SignatureNoneZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_SignatureNoneZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_clone(orig);
    return nativeResponseValue;
}
function CResult_SignDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SignDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_SignDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SignDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_SignDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SignDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_SignDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SignDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_SignDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SignDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_SignDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_SignDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_RecoverableSignatureNoneZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_ok(o);
    return nativeResponseValue;
}
function CResult_RecoverableSignatureNoneZ_err() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_err();
    return nativeResponseValue;
}
function CResult_RecoverableSignatureNoneZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_RecoverableSignatureNoneZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_free(_res);
// debug statements here
}
function CResult_RecoverableSignatureNoneZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_RecoverableSignatureNoneZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_clone(orig);
    return nativeResponseValue;
}
function CVec_CVec_u8ZZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_CVec_u8ZZ_free(_res);
// debug statements here
}
function CResult_CVec_CVec_u8ZZNoneZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_ok(o);
    return nativeResponseValue;
}
function CResult_CVec_CVec_u8ZZNoneZ_err() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_err();
    return nativeResponseValue;
}
function CResult_CVec_CVec_u8ZZNoneZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_CVec_CVec_u8ZZNoneZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_free(_res);
// debug statements here
}
function CResult_CVec_CVec_u8ZZNoneZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_CVec_CVec_u8ZZNoneZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_clone(orig);
    return nativeResponseValue;
}
function CResult_InMemorySignerDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_InMemorySignerDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_InMemorySignerDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_InMemorySignerDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_free(_res);
// debug statements here
}
function CResult_InMemorySignerDecodeErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_InMemorySignerDecodeErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_clone(orig);
    return nativeResponseValue;
}
function CVec_TxOutZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_TxOutZ_free(_res);
// debug statements here
}
function CResult_TransactionNoneZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_ok(o);
    return nativeResponseValue;
}
function CResult_TransactionNoneZ_err() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_err();
    return nativeResponseValue;
}
function CResult_TransactionNoneZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_TransactionNoneZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_free(_res);
// debug statements here
}
function CResult_TransactionNoneZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_TransactionNoneZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_clone(orig);
    return nativeResponseValue;
}
function COption_FilterZ_some(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_FilterZ_some(o);
    return nativeResponseValue;
}
function COption_FilterZ_none() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_FilterZ_none();
    return nativeResponseValue;
}
function COption_FilterZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_FilterZ_free(_res);
// debug statements here
}
function CResult_LockedChannelMonitorNoneZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_ok(o);
    return nativeResponseValue;
}
function CResult_LockedChannelMonitorNoneZ_err() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_err();
    return nativeResponseValue;
}
function CResult_LockedChannelMonitorNoneZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_LockedChannelMonitorNoneZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_free(_res);
// debug statements here
}
function CVec_OutPointZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_OutPointZ_free(_res);
// debug statements here
}
function CResult_NoneAPIErrorZ_ok() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_ok();
    return nativeResponseValue;
}
function CResult_NoneAPIErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_NoneAPIErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_NoneAPIErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_free(_res);
// debug statements here
}
function CResult_NoneAPIErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_NoneAPIErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_clone(orig);
    return nativeResponseValue;
}
function COption_u16Z_some(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_u16Z_some(o);
    return nativeResponseValue;
}
function COption_u16Z_none() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_u16Z_none();
    return nativeResponseValue;
}
function COption_u16Z_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_u16Z_free(_res);
// debug statements here
}
function COption_u16Z_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_u16Z_clone_ptr(arg);
    return nativeResponseValue;
}
function COption_u16Z_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_COption_u16Z_clone(orig);
    return nativeResponseValue;
}
function CVec_CResult_NoneAPIErrorZZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_CResult_NoneAPIErrorZZ_free(_res);
// debug statements here
}
function CVec_APIErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_APIErrorZ_free(_res);
// debug statements here
}
function CResult__u832APIErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult__u832APIErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_err(e);
    return nativeResponseValue;
}
function CResult__u832APIErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult__u832APIErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_free(_res);
// debug statements here
}
function CResult__u832APIErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult__u832APIErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_PaymentIdPaymentSendFailureZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentSendFailureZ_ok(o);
    return nativeResponseValue;
}
function CResult_PaymentIdPaymentSendFailureZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentSendFailureZ_err(e);
    return nativeResponseValue;
}
function CResult_PaymentIdPaymentSendFailureZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentSendFailureZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_PaymentIdPaymentSendFailureZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentSendFailureZ_free(_res);
// debug statements here
}
function CResult_PaymentIdPaymentSendFailureZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentSendFailureZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_PaymentIdPaymentSendFailureZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentSendFailureZ_clone(orig);
    return nativeResponseValue;
}
function CResult_NonePaymentSendFailureZ_ok() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_ok();
    return nativeResponseValue;
}
function CResult_NonePaymentSendFailureZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_err(e);
    return nativeResponseValue;
}
function CResult_NonePaymentSendFailureZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_NonePaymentSendFailureZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_free(_res);
// debug statements here
}
function CResult_NonePaymentSendFailureZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_NonePaymentSendFailureZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_clone(orig);
    return nativeResponseValue;
}
function C2Tuple_PaymentHashPaymentIdZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_clone_ptr(arg);
    return nativeResponseValue;
}
function C2Tuple_PaymentHashPaymentIdZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_clone(orig);
    return nativeResponseValue;
}
function C2Tuple_PaymentHashPaymentIdZ_new(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_new(a, b);
    return nativeResponseValue;
}
function C2Tuple_PaymentHashPaymentIdZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_free(_res);
// debug statements here
}
function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok(o);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err(e);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free(_res);
// debug statements here
}
function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone(orig);
    return nativeResponseValue;
}
function C2Tuple_PaymentHashPaymentSecretZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_clone_ptr(arg);
    return nativeResponseValue;
}
function C2Tuple_PaymentHashPaymentSecretZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_clone(orig);
    return nativeResponseValue;
}
function C2Tuple_PaymentHashPaymentSecretZ_new(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_new(a, b);
    return nativeResponseValue;
}
function C2Tuple_PaymentHashPaymentSecretZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_free(_res);
// debug statements here
}
function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok(o);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err();
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free(_res);
// debug statements here
}
function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone(orig);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_free(_res);
// debug statements here
}
function CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_PaymentSecretNoneZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_ok(o);
    return nativeResponseValue;
}
function CResult_PaymentSecretNoneZ_err() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_err();
    return nativeResponseValue;
}
function CResult_PaymentSecretNoneZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_PaymentSecretNoneZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_free(_res);
// debug statements here
}
function CResult_PaymentSecretNoneZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_PaymentSecretNoneZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_clone(orig);
    return nativeResponseValue;
}
function CResult_PaymentSecretAPIErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentSecretAPIErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_PaymentSecretAPIErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentSecretAPIErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_PaymentSecretAPIErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentSecretAPIErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_PaymentSecretAPIErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentSecretAPIErrorZ_free(_res);
// debug statements here
}
function CResult_PaymentSecretAPIErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentSecretAPIErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_PaymentSecretAPIErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentSecretAPIErrorZ_clone(orig);
    return nativeResponseValue;
}
function CResult_PaymentPreimageAPIErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_PaymentPreimageAPIErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_PaymentPreimageAPIErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_PaymentPreimageAPIErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_free(_res);
// debug statements here
}
function CResult_PaymentPreimageAPIErrorZ_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_clone_ptr(arg);
    return nativeResponseValue;
}
function CResult_PaymentPreimageAPIErrorZ_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_clone(orig);
    return nativeResponseValue;
}
function CVec_ChannelMonitorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CVec_ChannelMonitorZ_free(_res);
// debug statements here
}
function C2Tuple_BlockHashChannelManagerZ_new(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelManagerZ_new(a, b);
    return nativeResponseValue;
}
function C2Tuple_BlockHashChannelManagerZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelManagerZ_free(_res);
// debug statements here
}
function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(o);
    return nativeResponseValue;
}
function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(e) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(e);
    return nativeResponseValue;
}
function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok(o);
    return nativeResponseValue;
}
function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free(_res) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free(_res);
// debug statements here
}
function PaymentPurpose_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PaymentPurpose_free(this_ptr);
// debug statements here
}
function PaymentPurpose_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PaymentPurpose_clone_ptr(arg);
    return nativeResponseValue;
}
function PaymentPurpose_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PaymentPurpose_clone(orig);
    return nativeResponseValue;
}
function PaymentPurpose_invoice_payment(payment_preimage, payment_secret) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PaymentPurpose_invoice_payment(payment_preimage, payment_secret);
    return nativeResponseValue;
}
function PaymentPurpose_spontaneous_payment(a) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PaymentPurpose_spontaneous_payment(a);
    return nativeResponseValue;
}
function ClosureReason_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosureReason_free(this_ptr);
// debug statements here
}
function ClosureReason_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosureReason_clone_ptr(arg);
    return nativeResponseValue;
}
function ClosureReason_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosureReason_clone(orig);
    return nativeResponseValue;
}
function ClosureReason_counterparty_force_closed(peer_msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosureReason_counterparty_force_closed(peer_msg);
    return nativeResponseValue;
}
function ClosureReason_holder_force_closed() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosureReason_holder_force_closed();
    return nativeResponseValue;
}
function ClosureReason_cooperative_closure() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosureReason_cooperative_closure();
    return nativeResponseValue;
}
function ClosureReason_commitment_tx_confirmed() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosureReason_commitment_tx_confirmed();
    return nativeResponseValue;
}
function ClosureReason_funding_timed_out() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosureReason_funding_timed_out();
    return nativeResponseValue;
}
function ClosureReason_processing_error(err) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosureReason_processing_error(err);
    return nativeResponseValue;
}
function ClosureReason_disconnected_peer() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosureReason_disconnected_peer();
    return nativeResponseValue;
}
function ClosureReason_outdated_channel_manager() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosureReason_outdated_channel_manager();
    return nativeResponseValue;
}
function ClosureReason_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosureReason_write(obj);
    return nativeResponseValue;
}
function ClosureReason_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosureReason_read(ser);
    return nativeResponseValue;
}
function Event_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Event_free(this_ptr);
// debug statements here
}
function Event_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Event_clone_ptr(arg);
    return nativeResponseValue;
}
function Event_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Event_clone(orig);
    return nativeResponseValue;
}
function Event_funding_generation_ready(temporary_channel_id, channel_value_satoshis, output_script, user_channel_id) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Event_funding_generation_ready(temporary_channel_id, channel_value_satoshis, output_script, user_channel_id);
    return nativeResponseValue;
}
function Event_payment_received(payment_hash, amt, purpose) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Event_payment_received(payment_hash, amt, purpose);
    return nativeResponseValue;
}
function Event_payment_sent(payment_id, payment_preimage, payment_hash, fee_paid_msat) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Event_payment_sent(payment_id, payment_preimage, payment_hash, fee_paid_msat);
    return nativeResponseValue;
}
function Event_payment_path_failed(payment_id, payment_hash, rejected_by_dest, network_update, all_paths_failed, path, short_channel_id, retry) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Event_payment_path_failed(payment_id, payment_hash, rejected_by_dest, network_update, all_paths_failed, path, short_channel_id, retry);
    return nativeResponseValue;
}
function Event_payment_failed(payment_id, payment_hash) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Event_payment_failed(payment_id, payment_hash);
    return nativeResponseValue;
}
function Event_pending_htlcs_forwardable(time_forwardable) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Event_pending_htlcs_forwardable(time_forwardable);
    return nativeResponseValue;
}
function Event_spendable_outputs(outputs) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Event_spendable_outputs(outputs);
    return nativeResponseValue;
}
function Event_payment_forwarded(fee_earned_msat, claim_from_onchain_tx) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Event_payment_forwarded(fee_earned_msat, claim_from_onchain_tx);
    return nativeResponseValue;
}
function Event_channel_closed(channel_id, user_channel_id, reason) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Event_channel_closed(channel_id, user_channel_id, reason);
    return nativeResponseValue;
}
function Event_discard_funding(channel_id, transaction) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Event_discard_funding(channel_id, transaction);
    return nativeResponseValue;
}
function Event_payment_path_successful(payment_id, payment_hash, path) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Event_payment_path_successful(payment_id, payment_hash, path);
    return nativeResponseValue;
}
function Event_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Event_write(obj);
    return nativeResponseValue;
}
function Event_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Event_read(ser);
    return nativeResponseValue;
}
function MessageSendEvent_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_free(this_ptr);
// debug statements here
}
function MessageSendEvent_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_clone_ptr(arg);
    return nativeResponseValue;
}
function MessageSendEvent_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_clone(orig);
    return nativeResponseValue;
}
function MessageSendEvent_send_accept_channel(node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_send_accept_channel(node_id, msg);
    return nativeResponseValue;
}
function MessageSendEvent_send_open_channel(node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_send_open_channel(node_id, msg);
    return nativeResponseValue;
}
function MessageSendEvent_send_funding_created(node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_send_funding_created(node_id, msg);
    return nativeResponseValue;
}
function MessageSendEvent_send_funding_signed(node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_send_funding_signed(node_id, msg);
    return nativeResponseValue;
}
function MessageSendEvent_send_funding_locked(node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_send_funding_locked(node_id, msg);
    return nativeResponseValue;
}
function MessageSendEvent_send_announcement_signatures(node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_send_announcement_signatures(node_id, msg);
    return nativeResponseValue;
}
function MessageSendEvent_update_htlcs(node_id, updates) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_update_htlcs(node_id, updates);
    return nativeResponseValue;
}
function MessageSendEvent_send_revoke_and_ack(node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_send_revoke_and_ack(node_id, msg);
    return nativeResponseValue;
}
function MessageSendEvent_send_closing_signed(node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_send_closing_signed(node_id, msg);
    return nativeResponseValue;
}
function MessageSendEvent_send_shutdown(node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_send_shutdown(node_id, msg);
    return nativeResponseValue;
}
function MessageSendEvent_send_channel_reestablish(node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_send_channel_reestablish(node_id, msg);
    return nativeResponseValue;
}
function MessageSendEvent_broadcast_channel_announcement(msg, update_msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_broadcast_channel_announcement(msg, update_msg);
    return nativeResponseValue;
}
function MessageSendEvent_broadcast_node_announcement(msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_broadcast_node_announcement(msg);
    return nativeResponseValue;
}
function MessageSendEvent_broadcast_channel_update(msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_broadcast_channel_update(msg);
    return nativeResponseValue;
}
function MessageSendEvent_send_channel_update(node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_send_channel_update(node_id, msg);
    return nativeResponseValue;
}
function MessageSendEvent_handle_error(node_id, action) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_handle_error(node_id, action);
    return nativeResponseValue;
}
function MessageSendEvent_send_channel_range_query(node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_send_channel_range_query(node_id, msg);
    return nativeResponseValue;
}
function MessageSendEvent_send_short_ids_query(node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_send_short_ids_query(node_id, msg);
    return nativeResponseValue;
}
function MessageSendEvent_send_reply_channel_range(node_id, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEvent_send_reply_channel_range(node_id, msg);
    return nativeResponseValue;
}
function MessageSendEventsProvider_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageSendEventsProvider_free(this_ptr);
// debug statements here
}
function EventsProvider_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_EventsProvider_free(this_ptr);
// debug statements here
}
function EventHandler_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_EventHandler_free(this_ptr);
// debug statements here
}
function APIError_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_APIError_free(this_ptr);
// debug statements here
}
function APIError_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_APIError_clone_ptr(arg);
    return nativeResponseValue;
}
function APIError_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_APIError_clone(orig);
    return nativeResponseValue;
}
function APIError_apimisuse_error(err) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_APIError_apimisuse_error(err);
    return nativeResponseValue;
}
function APIError_fee_rate_too_high(err, feerate) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_APIError_fee_rate_too_high(err, feerate);
    return nativeResponseValue;
}
function APIError_route_error(err) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_APIError_route_error(err);
    return nativeResponseValue;
}
function APIError_channel_unavailable(err) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_APIError_channel_unavailable(err);
    return nativeResponseValue;
}
function APIError_monitor_update_failed() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_APIError_monitor_update_failed();
    return nativeResponseValue;
}
function APIError_incompatible_shutdown_script(script) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_APIError_incompatible_shutdown_script(script);
    return nativeResponseValue;
}
function sign(msg, sk) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_sign(msg, sk);
    return nativeResponseValue;
}
function recover_pk(msg, sig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_recover_pk(msg, sig);
    return nativeResponseValue;
}
function verify(msg, sig, pk) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_verify(msg, sig, pk);
    return nativeResponseValue;
}
function Level_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Level_clone(orig);
    return nativeResponseValue;
}
function Level_gossip() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Level_gossip();
    return nativeResponseValue;
}
function Level_trace() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Level_trace();
    return nativeResponseValue;
}
function Level_debug() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Level_debug();
    return nativeResponseValue;
}
function Level_info() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Level_info();
    return nativeResponseValue;
}
function Level_warn() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Level_warn();
    return nativeResponseValue;
}
function Level_error() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Level_error();
    return nativeResponseValue;
}
function Level_eq(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Level_eq(a, b);
    return nativeResponseValue;
}
function Level_hash(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Level_hash(o);
    return nativeResponseValue;
}
function Level_max() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Level_max();
    return nativeResponseValue;
}
function Record_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Record_free(this_obj);
// debug statements here
}
function Record_get_level(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Record_get_level(this_ptr);
    return nativeResponseValue;
}
function Record_set_level(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Record_set_level(this_ptr, val);
// debug statements here
}
function Record_get_args(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Record_get_args(this_ptr);
    return nativeResponseValue;
}
function Record_set_args(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Record_set_args(this_ptr, val);
// debug statements here
}
function Record_get_module_path(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Record_get_module_path(this_ptr);
    return nativeResponseValue;
}
function Record_set_module_path(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Record_set_module_path(this_ptr, val);
// debug statements here
}
function Record_get_file(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Record_get_file(this_ptr);
    return nativeResponseValue;
}
function Record_set_file(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Record_set_file(this_ptr, val);
// debug statements here
}
function Record_get_line(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Record_get_line(this_ptr);
    return nativeResponseValue;
}
function Record_set_line(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Record_set_line(this_ptr, val);
// debug statements here
}
function Record_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Record_clone_ptr(arg);
    return nativeResponseValue;
}
function Record_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Record_clone(orig);
    return nativeResponseValue;
}
function Logger_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Logger_free(this_ptr);
// debug statements here
}
function ChannelHandshakeConfig_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_free(this_obj);
// debug statements here
}
function ChannelHandshakeConfig_get_minimum_depth(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_minimum_depth(this_ptr);
    return nativeResponseValue;
}
function ChannelHandshakeConfig_set_minimum_depth(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_minimum_depth(this_ptr, val);
// debug statements here
}
function ChannelHandshakeConfig_get_our_to_self_delay(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_our_to_self_delay(this_ptr);
    return nativeResponseValue;
}
function ChannelHandshakeConfig_set_our_to_self_delay(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_our_to_self_delay(this_ptr, val);
// debug statements here
}
function ChannelHandshakeConfig_get_our_htlc_minimum_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_our_htlc_minimum_msat(this_ptr);
    return nativeResponseValue;
}
function ChannelHandshakeConfig_set_our_htlc_minimum_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_our_htlc_minimum_msat(this_ptr, val);
// debug statements here
}
function ChannelHandshakeConfig_new(minimum_depth_arg, our_to_self_delay_arg, our_htlc_minimum_msat_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_new(minimum_depth_arg, our_to_self_delay_arg, our_htlc_minimum_msat_arg);
    return nativeResponseValue;
}
function ChannelHandshakeConfig_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_clone_ptr(arg);
    return nativeResponseValue;
}
function ChannelHandshakeConfig_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_clone(orig);
    return nativeResponseValue;
}
function ChannelHandshakeConfig_default() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_default();
    return nativeResponseValue;
}
function ChannelHandshakeLimits_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_free(this_obj);
// debug statements here
}
function ChannelHandshakeLimits_get_min_funding_satoshis(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_min_funding_satoshis(this_ptr);
    return nativeResponseValue;
}
function ChannelHandshakeLimits_set_min_funding_satoshis(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_min_funding_satoshis(this_ptr, val);
// debug statements here
}
function ChannelHandshakeLimits_get_max_htlc_minimum_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_max_htlc_minimum_msat(this_ptr);
    return nativeResponseValue;
}
function ChannelHandshakeLimits_set_max_htlc_minimum_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_max_htlc_minimum_msat(this_ptr, val);
// debug statements here
}
function ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(this_ptr);
    return nativeResponseValue;
}
function ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(this_ptr, val);
// debug statements here
}
function ChannelHandshakeLimits_get_max_channel_reserve_satoshis(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_max_channel_reserve_satoshis(this_ptr);
    return nativeResponseValue;
}
function ChannelHandshakeLimits_set_max_channel_reserve_satoshis(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_max_channel_reserve_satoshis(this_ptr, val);
// debug statements here
}
function ChannelHandshakeLimits_get_min_max_accepted_htlcs(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_min_max_accepted_htlcs(this_ptr);
    return nativeResponseValue;
}
function ChannelHandshakeLimits_set_min_max_accepted_htlcs(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_min_max_accepted_htlcs(this_ptr, val);
// debug statements here
}
function ChannelHandshakeLimits_get_max_minimum_depth(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_max_minimum_depth(this_ptr);
    return nativeResponseValue;
}
function ChannelHandshakeLimits_set_max_minimum_depth(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_max_minimum_depth(this_ptr, val);
// debug statements here
}
function ChannelHandshakeLimits_get_force_announced_channel_preference(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_force_announced_channel_preference(this_ptr);
    return nativeResponseValue;
}
function ChannelHandshakeLimits_set_force_announced_channel_preference(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_force_announced_channel_preference(this_ptr, val);
// debug statements here
}
function ChannelHandshakeLimits_get_their_to_self_delay(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_their_to_self_delay(this_ptr);
    return nativeResponseValue;
}
function ChannelHandshakeLimits_set_their_to_self_delay(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_their_to_self_delay(this_ptr, val);
// debug statements here
}
function ChannelHandshakeLimits_new(min_funding_satoshis_arg, max_htlc_minimum_msat_arg, min_max_htlc_value_in_flight_msat_arg, max_channel_reserve_satoshis_arg, min_max_accepted_htlcs_arg, max_minimum_depth_arg, force_announced_channel_preference_arg, their_to_self_delay_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_new(min_funding_satoshis_arg, max_htlc_minimum_msat_arg, min_max_htlc_value_in_flight_msat_arg, max_channel_reserve_satoshis_arg, min_max_accepted_htlcs_arg, max_minimum_depth_arg, force_announced_channel_preference_arg, their_to_self_delay_arg);
    return nativeResponseValue;
}
function ChannelHandshakeLimits_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_clone_ptr(arg);
    return nativeResponseValue;
}
function ChannelHandshakeLimits_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_clone(orig);
    return nativeResponseValue;
}
function ChannelHandshakeLimits_default() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_default();
    return nativeResponseValue;
}
function ChannelConfig_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_free(this_obj);
// debug statements here
}
function ChannelConfig_get_forwarding_fee_proportional_millionths(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_get_forwarding_fee_proportional_millionths(this_ptr);
    return nativeResponseValue;
}
function ChannelConfig_set_forwarding_fee_proportional_millionths(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_set_forwarding_fee_proportional_millionths(this_ptr, val);
// debug statements here
}
function ChannelConfig_get_forwarding_fee_base_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_get_forwarding_fee_base_msat(this_ptr);
    return nativeResponseValue;
}
function ChannelConfig_set_forwarding_fee_base_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_set_forwarding_fee_base_msat(this_ptr, val);
// debug statements here
}
function ChannelConfig_get_cltv_expiry_delta(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_get_cltv_expiry_delta(this_ptr);
    return nativeResponseValue;
}
function ChannelConfig_set_cltv_expiry_delta(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_set_cltv_expiry_delta(this_ptr, val);
// debug statements here
}
function ChannelConfig_get_announced_channel(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_get_announced_channel(this_ptr);
    return nativeResponseValue;
}
function ChannelConfig_set_announced_channel(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_set_announced_channel(this_ptr, val);
// debug statements here
}
function ChannelConfig_get_commit_upfront_shutdown_pubkey(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_get_commit_upfront_shutdown_pubkey(this_ptr);
    return nativeResponseValue;
}
function ChannelConfig_set_commit_upfront_shutdown_pubkey(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_set_commit_upfront_shutdown_pubkey(this_ptr, val);
// debug statements here
}
function ChannelConfig_get_max_dust_htlc_exposure_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_get_max_dust_htlc_exposure_msat(this_ptr);
    return nativeResponseValue;
}
function ChannelConfig_set_max_dust_htlc_exposure_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_set_max_dust_htlc_exposure_msat(this_ptr, val);
// debug statements here
}
function ChannelConfig_get_force_close_avoidance_max_fee_satoshis(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_get_force_close_avoidance_max_fee_satoshis(this_ptr);
    return nativeResponseValue;
}
function ChannelConfig_set_force_close_avoidance_max_fee_satoshis(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_set_force_close_avoidance_max_fee_satoshis(this_ptr, val);
// debug statements here
}
function ChannelConfig_new(forwarding_fee_proportional_millionths_arg, forwarding_fee_base_msat_arg, cltv_expiry_delta_arg, announced_channel_arg, commit_upfront_shutdown_pubkey_arg, max_dust_htlc_exposure_msat_arg, force_close_avoidance_max_fee_satoshis_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_new(forwarding_fee_proportional_millionths_arg, forwarding_fee_base_msat_arg, cltv_expiry_delta_arg, announced_channel_arg, commit_upfront_shutdown_pubkey_arg, max_dust_htlc_exposure_msat_arg, force_close_avoidance_max_fee_satoshis_arg);
    return nativeResponseValue;
}
function ChannelConfig_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_clone_ptr(arg);
    return nativeResponseValue;
}
function ChannelConfig_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_clone(orig);
    return nativeResponseValue;
}
function ChannelConfig_default() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_default();
    return nativeResponseValue;
}
function ChannelConfig_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_write(obj);
    return nativeResponseValue;
}
function ChannelConfig_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelConfig_read(ser);
    return nativeResponseValue;
}
function UserConfig_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UserConfig_free(this_obj);
// debug statements here
}
function UserConfig_get_own_channel_config(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UserConfig_get_own_channel_config(this_ptr);
    return nativeResponseValue;
}
function UserConfig_set_own_channel_config(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UserConfig_set_own_channel_config(this_ptr, val);
// debug statements here
}
function UserConfig_get_peer_channel_config_limits(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UserConfig_get_peer_channel_config_limits(this_ptr);
    return nativeResponseValue;
}
function UserConfig_set_peer_channel_config_limits(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UserConfig_set_peer_channel_config_limits(this_ptr, val);
// debug statements here
}
function UserConfig_get_channel_options(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UserConfig_get_channel_options(this_ptr);
    return nativeResponseValue;
}
function UserConfig_set_channel_options(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UserConfig_set_channel_options(this_ptr, val);
// debug statements here
}
function UserConfig_get_accept_forwards_to_priv_channels(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UserConfig_get_accept_forwards_to_priv_channels(this_ptr);
    return nativeResponseValue;
}
function UserConfig_set_accept_forwards_to_priv_channels(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UserConfig_set_accept_forwards_to_priv_channels(this_ptr, val);
// debug statements here
}
function UserConfig_get_accept_inbound_channels(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UserConfig_get_accept_inbound_channels(this_ptr);
    return nativeResponseValue;
}
function UserConfig_set_accept_inbound_channels(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UserConfig_set_accept_inbound_channels(this_ptr, val);
// debug statements here
}
function UserConfig_new(own_channel_config_arg, peer_channel_config_limits_arg, channel_options_arg, accept_forwards_to_priv_channels_arg, accept_inbound_channels_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UserConfig_new(own_channel_config_arg, peer_channel_config_limits_arg, channel_options_arg, accept_forwards_to_priv_channels_arg, accept_inbound_channels_arg);
    return nativeResponseValue;
}
function UserConfig_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UserConfig_clone_ptr(arg);
    return nativeResponseValue;
}
function UserConfig_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UserConfig_clone(orig);
    return nativeResponseValue;
}
function UserConfig_default() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UserConfig_default();
    return nativeResponseValue;
}
function BestBlock_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BestBlock_free(this_obj);
// debug statements here
}
function BestBlock_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BestBlock_clone_ptr(arg);
    return nativeResponseValue;
}
function BestBlock_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BestBlock_clone(orig);
    return nativeResponseValue;
}
function BestBlock_from_genesis(network) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BestBlock_from_genesis(network);
    return nativeResponseValue;
}
function BestBlock_new(block_hash, height) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BestBlock_new(block_hash, height);
    return nativeResponseValue;
}
function BestBlock_block_hash(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BestBlock_block_hash(this_arg);
    return nativeResponseValue;
}
function BestBlock_height(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BestBlock_height(this_arg);
    return nativeResponseValue;
}
function AccessError_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AccessError_clone(orig);
    return nativeResponseValue;
}
function AccessError_unknown_chain() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AccessError_unknown_chain();
    return nativeResponseValue;
}
function AccessError_unknown_tx() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AccessError_unknown_tx();
    return nativeResponseValue;
}
function Access_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Access_free(this_ptr);
// debug statements here
}
function Listen_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Listen_free(this_ptr);
// debug statements here
}
function Confirm_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Confirm_free(this_ptr);
// debug statements here
}
function ChannelMonitorUpdateErr_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitorUpdateErr_clone(orig);
    return nativeResponseValue;
}
function ChannelMonitorUpdateErr_temporary_failure() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitorUpdateErr_temporary_failure();
    return nativeResponseValue;
}
function ChannelMonitorUpdateErr_permanent_failure() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitorUpdateErr_permanent_failure();
    return nativeResponseValue;
}
function Watch_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Watch_free(this_ptr);
// debug statements here
}
function Filter_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Filter_free(this_ptr);
// debug statements here
}
function WatchedOutput_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_WatchedOutput_free(this_obj);
// debug statements here
}
function WatchedOutput_get_block_hash(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_WatchedOutput_get_block_hash(this_ptr);
    return nativeResponseValue;
}
function WatchedOutput_set_block_hash(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_WatchedOutput_set_block_hash(this_ptr, val);
// debug statements here
}
function WatchedOutput_get_outpoint(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_WatchedOutput_get_outpoint(this_ptr);
    return nativeResponseValue;
}
function WatchedOutput_set_outpoint(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_WatchedOutput_set_outpoint(this_ptr, val);
// debug statements here
}
function WatchedOutput_get_script_pubkey(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_WatchedOutput_get_script_pubkey(this_ptr);
    return nativeResponseValue;
}
function WatchedOutput_set_script_pubkey(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_WatchedOutput_set_script_pubkey(this_ptr, val);
// debug statements here
}
function WatchedOutput_new(block_hash_arg, outpoint_arg, script_pubkey_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_WatchedOutput_new(block_hash_arg, outpoint_arg, script_pubkey_arg);
    return nativeResponseValue;
}
function WatchedOutput_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_WatchedOutput_clone_ptr(arg);
    return nativeResponseValue;
}
function WatchedOutput_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_WatchedOutput_clone(orig);
    return nativeResponseValue;
}
function WatchedOutput_hash(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_WatchedOutput_hash(o);
    return nativeResponseValue;
}
function BroadcasterInterface_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BroadcasterInterface_free(this_ptr);
// debug statements here
}
function ConfirmationTarget_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ConfirmationTarget_clone(orig);
    return nativeResponseValue;
}
function ConfirmationTarget_background() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ConfirmationTarget_background();
    return nativeResponseValue;
}
function ConfirmationTarget_normal() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ConfirmationTarget_normal();
    return nativeResponseValue;
}
function ConfirmationTarget_high_priority() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ConfirmationTarget_high_priority();
    return nativeResponseValue;
}
function ConfirmationTarget_eq(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ConfirmationTarget_eq(a, b);
    return nativeResponseValue;
}
function FeeEstimator_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FeeEstimator_free(this_ptr);
// debug statements here
}
function MonitorUpdateId_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MonitorUpdateId_free(this_obj);
// debug statements here
}
function MonitorUpdateId_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MonitorUpdateId_clone_ptr(arg);
    return nativeResponseValue;
}
function MonitorUpdateId_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MonitorUpdateId_clone(orig);
    return nativeResponseValue;
}
function MonitorUpdateId_hash(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MonitorUpdateId_hash(o);
    return nativeResponseValue;
}
function MonitorUpdateId_eq(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MonitorUpdateId_eq(a, b);
    return nativeResponseValue;
}
function Persist_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Persist_free(this_ptr);
// debug statements here
}
function LockedChannelMonitor_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LockedChannelMonitor_free(this_obj);
// debug statements here
}
function ChainMonitor_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainMonitor_free(this_obj);
// debug statements here
}
function ChainMonitor_new(chain_source, broadcaster, logger, feeest, persister) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainMonitor_new(chain_source, broadcaster, logger, feeest, persister);
    return nativeResponseValue;
}
function ChainMonitor_get_claimable_balances(this_arg, ignored_channels) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainMonitor_get_claimable_balances(this_arg, ignored_channels);
    return nativeResponseValue;
}
function ChainMonitor_get_monitor(this_arg, funding_txo) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainMonitor_get_monitor(this_arg, funding_txo);
    return nativeResponseValue;
}
function ChainMonitor_list_monitors(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainMonitor_list_monitors(this_arg);
    return nativeResponseValue;
}
function ChainMonitor_channel_monitor_updated(this_arg, funding_txo, completed_update_id) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainMonitor_channel_monitor_updated(this_arg, funding_txo, completed_update_id);
    return nativeResponseValue;
}
function ChainMonitor_as_Listen(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainMonitor_as_Listen(this_arg);
    return nativeResponseValue;
}
function ChainMonitor_as_Confirm(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainMonitor_as_Confirm(this_arg);
    return nativeResponseValue;
}
function ChainMonitor_as_Watch(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainMonitor_as_Watch(this_arg);
    return nativeResponseValue;
}
function ChainMonitor_as_EventsProvider(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainMonitor_as_EventsProvider(this_arg);
    return nativeResponseValue;
}
function ChannelMonitorUpdate_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_free(this_obj);
// debug statements here
}
function ChannelMonitorUpdate_get_update_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_get_update_id(this_ptr);
    return nativeResponseValue;
}
function ChannelMonitorUpdate_set_update_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_set_update_id(this_ptr, val);
// debug statements here
}
function ChannelMonitorUpdate_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_clone_ptr(arg);
    return nativeResponseValue;
}
function ChannelMonitorUpdate_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_clone(orig);
    return nativeResponseValue;
}
function ChannelMonitorUpdate_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_write(obj);
    return nativeResponseValue;
}
function ChannelMonitorUpdate_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_read(ser);
    return nativeResponseValue;
}
function MonitorEvent_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MonitorEvent_free(this_ptr);
// debug statements here
}
function MonitorEvent_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MonitorEvent_clone_ptr(arg);
    return nativeResponseValue;
}
function MonitorEvent_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MonitorEvent_clone(orig);
    return nativeResponseValue;
}
function MonitorEvent_htlcevent(a) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MonitorEvent_htlcevent(a);
    return nativeResponseValue;
}
function MonitorEvent_commitment_tx_confirmed(a) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MonitorEvent_commitment_tx_confirmed(a);
    return nativeResponseValue;
}
function MonitorEvent_update_completed(funding_txo, monitor_update_id) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MonitorEvent_update_completed(funding_txo, monitor_update_id);
    return nativeResponseValue;
}
function MonitorEvent_update_failed(a) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MonitorEvent_update_failed(a);
    return nativeResponseValue;
}
function MonitorEvent_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MonitorEvent_write(obj);
    return nativeResponseValue;
}
function MonitorEvent_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MonitorEvent_read(ser);
    return nativeResponseValue;
}
function HTLCUpdate_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCUpdate_free(this_obj);
// debug statements here
}
function HTLCUpdate_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCUpdate_clone_ptr(arg);
    return nativeResponseValue;
}
function HTLCUpdate_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCUpdate_clone(orig);
    return nativeResponseValue;
}
function HTLCUpdate_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCUpdate_write(obj);
    return nativeResponseValue;
}
function HTLCUpdate_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCUpdate_read(ser);
    return nativeResponseValue;
}
function Balance_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Balance_free(this_ptr);
// debug statements here
}
function Balance_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Balance_clone_ptr(arg);
    return nativeResponseValue;
}
function Balance_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Balance_clone(orig);
    return nativeResponseValue;
}
function Balance_claimable_on_channel_close(claimable_amount_satoshis) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Balance_claimable_on_channel_close(claimable_amount_satoshis);
    return nativeResponseValue;
}
function Balance_claimable_awaiting_confirmations(claimable_amount_satoshis, confirmation_height) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Balance_claimable_awaiting_confirmations(claimable_amount_satoshis, confirmation_height);
    return nativeResponseValue;
}
function Balance_contentious_claimable(claimable_amount_satoshis, timeout_height) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Balance_contentious_claimable(claimable_amount_satoshis, timeout_height);
    return nativeResponseValue;
}
function Balance_maybe_claimable_htlcawaiting_timeout(claimable_amount_satoshis, claimable_height) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Balance_maybe_claimable_htlcawaiting_timeout(claimable_amount_satoshis, claimable_height);
    return nativeResponseValue;
}
function Balance_eq(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Balance_eq(a, b);
    return nativeResponseValue;
}
function ChannelMonitor_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_free(this_obj);
// debug statements here
}
function ChannelMonitor_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_clone_ptr(arg);
    return nativeResponseValue;
}
function ChannelMonitor_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_clone(orig);
    return nativeResponseValue;
}
function ChannelMonitor_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_write(obj);
    return nativeResponseValue;
}
function ChannelMonitor_update_monitor(this_arg, updates, broadcaster, fee_estimator, logger) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_update_monitor(this_arg, updates, broadcaster, fee_estimator, logger);
    return nativeResponseValue;
}
function ChannelMonitor_get_latest_update_id(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_get_latest_update_id(this_arg);
    return nativeResponseValue;
}
function ChannelMonitor_get_funding_txo(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_get_funding_txo(this_arg);
    return nativeResponseValue;
}
function ChannelMonitor_get_outputs_to_watch(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_get_outputs_to_watch(this_arg);
    return nativeResponseValue;
}
function ChannelMonitor_load_outputs_to_watch(this_arg, filter) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_load_outputs_to_watch(this_arg, filter);
// debug statements here
}
function ChannelMonitor_get_and_clear_pending_monitor_events(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_get_and_clear_pending_monitor_events(this_arg);
    return nativeResponseValue;
}
function ChannelMonitor_get_and_clear_pending_events(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_get_and_clear_pending_events(this_arg);
    return nativeResponseValue;
}
function ChannelMonitor_get_latest_holder_commitment_txn(this_arg, logger) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_get_latest_holder_commitment_txn(this_arg, logger);
    return nativeResponseValue;
}
function ChannelMonitor_block_connected(this_arg, header, txdata, height, broadcaster, fee_estimator, logger) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_block_connected(this_arg, header, txdata, height, broadcaster, fee_estimator, logger);
    return nativeResponseValue;
}
function ChannelMonitor_block_disconnected(this_arg, header, height, broadcaster, fee_estimator, logger) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_block_disconnected(this_arg, header, height, broadcaster, fee_estimator, logger);
// debug statements here
}
function ChannelMonitor_transactions_confirmed(this_arg, header, txdata, height, broadcaster, fee_estimator, logger) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_transactions_confirmed(this_arg, header, txdata, height, broadcaster, fee_estimator, logger);
    return nativeResponseValue;
}
function ChannelMonitor_transaction_unconfirmed(this_arg, txid, broadcaster, fee_estimator, logger) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_transaction_unconfirmed(this_arg, txid, broadcaster, fee_estimator, logger);
// debug statements here
}
function ChannelMonitor_best_block_updated(this_arg, header, height, broadcaster, fee_estimator, logger) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_best_block_updated(this_arg, header, height, broadcaster, fee_estimator, logger);
    return nativeResponseValue;
}
function ChannelMonitor_get_relevant_txids(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_get_relevant_txids(this_arg);
    return nativeResponseValue;
}
function ChannelMonitor_current_best_block(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_current_best_block(this_arg);
    return nativeResponseValue;
}
function ChannelMonitor_get_claimable_balances(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMonitor_get_claimable_balances(this_arg);
    return nativeResponseValue;
}
function C2Tuple_BlockHashChannelMonitorZ_read(ser, arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_read(ser, arg);
    return nativeResponseValue;
}
function OutPoint_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OutPoint_free(this_obj);
// debug statements here
}
function OutPoint_get_txid(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OutPoint_get_txid(this_ptr);
    return nativeResponseValue;
}
function OutPoint_set_txid(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OutPoint_set_txid(this_ptr, val);
// debug statements here
}
function OutPoint_get_index(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OutPoint_get_index(this_ptr);
    return nativeResponseValue;
}
function OutPoint_set_index(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OutPoint_set_index(this_ptr, val);
// debug statements here
}
function OutPoint_new(txid_arg, index_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OutPoint_new(txid_arg, index_arg);
    return nativeResponseValue;
}
function OutPoint_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OutPoint_clone_ptr(arg);
    return nativeResponseValue;
}
function OutPoint_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OutPoint_clone(orig);
    return nativeResponseValue;
}
function OutPoint_eq(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OutPoint_eq(a, b);
    return nativeResponseValue;
}
function OutPoint_hash(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OutPoint_hash(o);
    return nativeResponseValue;
}
function OutPoint_to_channel_id(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OutPoint_to_channel_id(this_arg);
    return nativeResponseValue;
}
function OutPoint_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OutPoint_write(obj);
    return nativeResponseValue;
}
function OutPoint_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OutPoint_read(ser);
    return nativeResponseValue;
}
function DelayedPaymentOutputDescriptor_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_free(this_obj);
// debug statements here
}
function DelayedPaymentOutputDescriptor_get_outpoint(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_outpoint(this_ptr);
    return nativeResponseValue;
}
function DelayedPaymentOutputDescriptor_set_outpoint(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_outpoint(this_ptr, val);
// debug statements here
}
function DelayedPaymentOutputDescriptor_get_per_commitment_point(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_per_commitment_point(this_ptr);
    return nativeResponseValue;
}
function DelayedPaymentOutputDescriptor_set_per_commitment_point(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_per_commitment_point(this_ptr, val);
// debug statements here
}
function DelayedPaymentOutputDescriptor_get_to_self_delay(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_to_self_delay(this_ptr);
    return nativeResponseValue;
}
function DelayedPaymentOutputDescriptor_set_to_self_delay(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_to_self_delay(this_ptr, val);
// debug statements here
}
function DelayedPaymentOutputDescriptor_set_output(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_output(this_ptr, val);
// debug statements here
}
function DelayedPaymentOutputDescriptor_get_revocation_pubkey(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_revocation_pubkey(this_ptr);
    return nativeResponseValue;
}
function DelayedPaymentOutputDescriptor_set_revocation_pubkey(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_revocation_pubkey(this_ptr, val);
// debug statements here
}
function DelayedPaymentOutputDescriptor_get_channel_keys_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_channel_keys_id(this_ptr);
    return nativeResponseValue;
}
function DelayedPaymentOutputDescriptor_set_channel_keys_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_channel_keys_id(this_ptr, val);
// debug statements here
}
function DelayedPaymentOutputDescriptor_get_channel_value_satoshis(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_channel_value_satoshis(this_ptr);
    return nativeResponseValue;
}
function DelayedPaymentOutputDescriptor_set_channel_value_satoshis(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_channel_value_satoshis(this_ptr, val);
// debug statements here
}
function DelayedPaymentOutputDescriptor_new(outpoint_arg, per_commitment_point_arg, to_self_delay_arg, output_arg, revocation_pubkey_arg, channel_keys_id_arg, channel_value_satoshis_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_new(outpoint_arg, per_commitment_point_arg, to_self_delay_arg, output_arg, revocation_pubkey_arg, channel_keys_id_arg, channel_value_satoshis_arg);
    return nativeResponseValue;
}
function DelayedPaymentOutputDescriptor_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_clone_ptr(arg);
    return nativeResponseValue;
}
function DelayedPaymentOutputDescriptor_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_clone(orig);
    return nativeResponseValue;
}
function DelayedPaymentOutputDescriptor_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_write(obj);
    return nativeResponseValue;
}
function DelayedPaymentOutputDescriptor_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_read(ser);
    return nativeResponseValue;
}
function StaticPaymentOutputDescriptor_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_free(this_obj);
// debug statements here
}
function StaticPaymentOutputDescriptor_get_outpoint(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_get_outpoint(this_ptr);
    return nativeResponseValue;
}
function StaticPaymentOutputDescriptor_set_outpoint(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_set_outpoint(this_ptr, val);
// debug statements here
}
function StaticPaymentOutputDescriptor_set_output(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_set_output(this_ptr, val);
// debug statements here
}
function StaticPaymentOutputDescriptor_get_channel_keys_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_get_channel_keys_id(this_ptr);
    return nativeResponseValue;
}
function StaticPaymentOutputDescriptor_set_channel_keys_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_set_channel_keys_id(this_ptr, val);
// debug statements here
}
function StaticPaymentOutputDescriptor_get_channel_value_satoshis(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_get_channel_value_satoshis(this_ptr);
    return nativeResponseValue;
}
function StaticPaymentOutputDescriptor_set_channel_value_satoshis(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_set_channel_value_satoshis(this_ptr, val);
// debug statements here
}
function StaticPaymentOutputDescriptor_new(outpoint_arg, output_arg, channel_keys_id_arg, channel_value_satoshis_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_new(outpoint_arg, output_arg, channel_keys_id_arg, channel_value_satoshis_arg);
    return nativeResponseValue;
}
function StaticPaymentOutputDescriptor_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_clone_ptr(arg);
    return nativeResponseValue;
}
function StaticPaymentOutputDescriptor_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_clone(orig);
    return nativeResponseValue;
}
function StaticPaymentOutputDescriptor_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_write(obj);
    return nativeResponseValue;
}
function StaticPaymentOutputDescriptor_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_read(ser);
    return nativeResponseValue;
}
function SpendableOutputDescriptor_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_free(this_ptr);
// debug statements here
}
function SpendableOutputDescriptor_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_clone_ptr(arg);
    return nativeResponseValue;
}
function SpendableOutputDescriptor_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_clone(orig);
    return nativeResponseValue;
}
function SpendableOutputDescriptor_static_output(outpoint, output) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_static_output(outpoint, output);
    return nativeResponseValue;
}
function SpendableOutputDescriptor_delayed_payment_output(a) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_delayed_payment_output(a);
    return nativeResponseValue;
}
function SpendableOutputDescriptor_static_payment_output(a) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_static_payment_output(a);
    return nativeResponseValue;
}
function SpendableOutputDescriptor_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_write(obj);
    return nativeResponseValue;
}
function SpendableOutputDescriptor_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_read(ser);
    return nativeResponseValue;
}
function BaseSign_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BaseSign_free(this_ptr);
// debug statements here
}
function Sign_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Sign_clone_ptr(arg);
    return nativeResponseValue;
}
function Sign_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Sign_clone(orig);
    return nativeResponseValue;
}
function Sign_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Sign_free(this_ptr);
// debug statements here
}
function KeysInterface_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_KeysInterface_free(this_ptr);
// debug statements here
}
function InMemorySigner_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_free(this_obj);
// debug statements here
}
function InMemorySigner_get_funding_key(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_get_funding_key(this_ptr);
    return nativeResponseValue;
}
function InMemorySigner_set_funding_key(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_set_funding_key(this_ptr, val);
// debug statements here
}
function InMemorySigner_get_revocation_base_key(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_get_revocation_base_key(this_ptr);
    return nativeResponseValue;
}
function InMemorySigner_set_revocation_base_key(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_set_revocation_base_key(this_ptr, val);
// debug statements here
}
function InMemorySigner_get_payment_key(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_get_payment_key(this_ptr);
    return nativeResponseValue;
}
function InMemorySigner_set_payment_key(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_set_payment_key(this_ptr, val);
// debug statements here
}
function InMemorySigner_get_delayed_payment_base_key(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_get_delayed_payment_base_key(this_ptr);
    return nativeResponseValue;
}
function InMemorySigner_set_delayed_payment_base_key(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_set_delayed_payment_base_key(this_ptr, val);
// debug statements here
}
function InMemorySigner_get_htlc_base_key(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_get_htlc_base_key(this_ptr);
    return nativeResponseValue;
}
function InMemorySigner_set_htlc_base_key(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_set_htlc_base_key(this_ptr, val);
// debug statements here
}
function InMemorySigner_get_commitment_seed(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_get_commitment_seed(this_ptr);
    return nativeResponseValue;
}
function InMemorySigner_set_commitment_seed(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_set_commitment_seed(this_ptr, val);
// debug statements here
}
function InMemorySigner_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_clone_ptr(arg);
    return nativeResponseValue;
}
function InMemorySigner_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_clone(orig);
    return nativeResponseValue;
}
function InMemorySigner_new(funding_key, revocation_base_key, payment_key, delayed_payment_base_key, htlc_base_key, commitment_seed, channel_value_satoshis, channel_keys_id) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_new(funding_key, revocation_base_key, payment_key, delayed_payment_base_key, htlc_base_key, commitment_seed, channel_value_satoshis, channel_keys_id);
    return nativeResponseValue;
}
function InMemorySigner_counterparty_pubkeys(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_counterparty_pubkeys(this_arg);
    return nativeResponseValue;
}
function InMemorySigner_counterparty_selected_contest_delay(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_counterparty_selected_contest_delay(this_arg);
    return nativeResponseValue;
}
function InMemorySigner_holder_selected_contest_delay(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_holder_selected_contest_delay(this_arg);
    return nativeResponseValue;
}
function InMemorySigner_is_outbound(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_is_outbound(this_arg);
    return nativeResponseValue;
}
function InMemorySigner_funding_outpoint(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_funding_outpoint(this_arg);
    return nativeResponseValue;
}
function InMemorySigner_get_channel_parameters(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_get_channel_parameters(this_arg);
    return nativeResponseValue;
}
function InMemorySigner_opt_anchors(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_opt_anchors(this_arg);
    return nativeResponseValue;
}
function InMemorySigner_sign_counterparty_payment_input(this_arg, spend_tx, input_idx, descriptor) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_sign_counterparty_payment_input(this_arg, spend_tx, input_idx, descriptor);
    return nativeResponseValue;
}
function InMemorySigner_sign_dynamic_p2wsh_input(this_arg, spend_tx, input_idx, descriptor) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_sign_dynamic_p2wsh_input(this_arg, spend_tx, input_idx, descriptor);
    return nativeResponseValue;
}
function InMemorySigner_as_BaseSign(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_as_BaseSign(this_arg);
    return nativeResponseValue;
}
function InMemorySigner_as_Sign(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_as_Sign(this_arg);
    return nativeResponseValue;
}
function InMemorySigner_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_write(obj);
    return nativeResponseValue;
}
function InMemorySigner_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InMemorySigner_read(ser);
    return nativeResponseValue;
}
function KeysManager_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_KeysManager_free(this_obj);
// debug statements here
}
function KeysManager_new(seed, starting_time_secs, starting_time_nanos) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_KeysManager_new(seed, starting_time_secs, starting_time_nanos);
    return nativeResponseValue;
}
function KeysManager_derive_channel_keys(this_arg, channel_value_satoshis, params) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_KeysManager_derive_channel_keys(this_arg, channel_value_satoshis, params);
    return nativeResponseValue;
}
function KeysManager_spend_spendable_outputs(this_arg, descriptors, outputs, change_destination_script, feerate_sat_per_1000_weight) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_KeysManager_spend_spendable_outputs(this_arg, descriptors, outputs, change_destination_script, feerate_sat_per_1000_weight);
    return nativeResponseValue;
}
function KeysManager_as_KeysInterface(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_KeysManager_as_KeysInterface(this_arg);
    return nativeResponseValue;
}
function ChannelManager_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_free(this_obj);
// debug statements here
}
function ChainParameters_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainParameters_free(this_obj);
// debug statements here
}
function ChainParameters_get_network(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainParameters_get_network(this_ptr);
    return nativeResponseValue;
}
function ChainParameters_set_network(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainParameters_set_network(this_ptr, val);
// debug statements here
}
function ChainParameters_get_best_block(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainParameters_get_best_block(this_ptr);
    return nativeResponseValue;
}
function ChainParameters_set_best_block(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainParameters_set_best_block(this_ptr, val);
// debug statements here
}
function ChainParameters_new(network_arg, best_block_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainParameters_new(network_arg, best_block_arg);
    return nativeResponseValue;
}
function ChainParameters_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainParameters_clone_ptr(arg);
    return nativeResponseValue;
}
function ChainParameters_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChainParameters_clone(orig);
    return nativeResponseValue;
}
function CounterpartyForwardingInfo_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_free(this_obj);
// debug statements here
}
function CounterpartyForwardingInfo_get_fee_base_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_get_fee_base_msat(this_ptr);
    return nativeResponseValue;
}
function CounterpartyForwardingInfo_set_fee_base_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_set_fee_base_msat(this_ptr, val);
// debug statements here
}
function CounterpartyForwardingInfo_get_fee_proportional_millionths(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_get_fee_proportional_millionths(this_ptr);
    return nativeResponseValue;
}
function CounterpartyForwardingInfo_set_fee_proportional_millionths(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_set_fee_proportional_millionths(this_ptr, val);
// debug statements here
}
function CounterpartyForwardingInfo_get_cltv_expiry_delta(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_get_cltv_expiry_delta(this_ptr);
    return nativeResponseValue;
}
function CounterpartyForwardingInfo_set_cltv_expiry_delta(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_set_cltv_expiry_delta(this_ptr, val);
// debug statements here
}
function CounterpartyForwardingInfo_new(fee_base_msat_arg, fee_proportional_millionths_arg, cltv_expiry_delta_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_new(fee_base_msat_arg, fee_proportional_millionths_arg, cltv_expiry_delta_arg);
    return nativeResponseValue;
}
function CounterpartyForwardingInfo_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_clone_ptr(arg);
    return nativeResponseValue;
}
function CounterpartyForwardingInfo_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_clone(orig);
    return nativeResponseValue;
}
function ChannelCounterparty_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelCounterparty_free(this_obj);
// debug statements here
}
function ChannelCounterparty_get_node_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelCounterparty_get_node_id(this_ptr);
    return nativeResponseValue;
}
function ChannelCounterparty_set_node_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelCounterparty_set_node_id(this_ptr, val);
// debug statements here
}
function ChannelCounterparty_get_features(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelCounterparty_get_features(this_ptr);
    return nativeResponseValue;
}
function ChannelCounterparty_set_features(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelCounterparty_set_features(this_ptr, val);
// debug statements here
}
function ChannelCounterparty_get_unspendable_punishment_reserve(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelCounterparty_get_unspendable_punishment_reserve(this_ptr);
    return nativeResponseValue;
}
function ChannelCounterparty_set_unspendable_punishment_reserve(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelCounterparty_set_unspendable_punishment_reserve(this_ptr, val);
// debug statements here
}
function ChannelCounterparty_get_forwarding_info(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelCounterparty_get_forwarding_info(this_ptr);
    return nativeResponseValue;
}
function ChannelCounterparty_set_forwarding_info(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelCounterparty_set_forwarding_info(this_ptr, val);
// debug statements here
}
function ChannelCounterparty_new(node_id_arg, features_arg, unspendable_punishment_reserve_arg, forwarding_info_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelCounterparty_new(node_id_arg, features_arg, unspendable_punishment_reserve_arg, forwarding_info_arg);
    return nativeResponseValue;
}
function ChannelCounterparty_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelCounterparty_clone_ptr(arg);
    return nativeResponseValue;
}
function ChannelCounterparty_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelCounterparty_clone(orig);
    return nativeResponseValue;
}
function ChannelDetails_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_free(this_obj);
// debug statements here
}
function ChannelDetails_get_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_get_channel_id(this_ptr);
    return nativeResponseValue;
}
function ChannelDetails_set_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_set_channel_id(this_ptr, val);
// debug statements here
}
function ChannelDetails_get_counterparty(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_get_counterparty(this_ptr);
    return nativeResponseValue;
}
function ChannelDetails_set_counterparty(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_set_counterparty(this_ptr, val);
// debug statements here
}
function ChannelDetails_get_funding_txo(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_get_funding_txo(this_ptr);
    return nativeResponseValue;
}
function ChannelDetails_set_funding_txo(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_set_funding_txo(this_ptr, val);
// debug statements here
}
function ChannelDetails_get_short_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_get_short_channel_id(this_ptr);
    return nativeResponseValue;
}
function ChannelDetails_set_short_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_set_short_channel_id(this_ptr, val);
// debug statements here
}
function ChannelDetails_get_channel_value_satoshis(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_get_channel_value_satoshis(this_ptr);
    return nativeResponseValue;
}
function ChannelDetails_set_channel_value_satoshis(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_set_channel_value_satoshis(this_ptr, val);
// debug statements here
}
function ChannelDetails_get_unspendable_punishment_reserve(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_get_unspendable_punishment_reserve(this_ptr);
    return nativeResponseValue;
}
function ChannelDetails_set_unspendable_punishment_reserve(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_set_unspendable_punishment_reserve(this_ptr, val);
// debug statements here
}
function ChannelDetails_get_user_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_get_user_channel_id(this_ptr);
    return nativeResponseValue;
}
function ChannelDetails_set_user_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_set_user_channel_id(this_ptr, val);
// debug statements here
}
function ChannelDetails_get_balance_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_get_balance_msat(this_ptr);
    return nativeResponseValue;
}
function ChannelDetails_set_balance_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_set_balance_msat(this_ptr, val);
// debug statements here
}
function ChannelDetails_get_outbound_capacity_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_get_outbound_capacity_msat(this_ptr);
    return nativeResponseValue;
}
function ChannelDetails_set_outbound_capacity_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_set_outbound_capacity_msat(this_ptr, val);
// debug statements here
}
function ChannelDetails_get_inbound_capacity_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_get_inbound_capacity_msat(this_ptr);
    return nativeResponseValue;
}
function ChannelDetails_set_inbound_capacity_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_set_inbound_capacity_msat(this_ptr, val);
// debug statements here
}
function ChannelDetails_get_confirmations_required(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_get_confirmations_required(this_ptr);
    return nativeResponseValue;
}
function ChannelDetails_set_confirmations_required(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_set_confirmations_required(this_ptr, val);
// debug statements here
}
function ChannelDetails_get_force_close_spend_delay(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_get_force_close_spend_delay(this_ptr);
    return nativeResponseValue;
}
function ChannelDetails_set_force_close_spend_delay(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_set_force_close_spend_delay(this_ptr, val);
// debug statements here
}
function ChannelDetails_get_is_outbound(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_get_is_outbound(this_ptr);
    return nativeResponseValue;
}
function ChannelDetails_set_is_outbound(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_set_is_outbound(this_ptr, val);
// debug statements here
}
function ChannelDetails_get_is_funding_locked(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_get_is_funding_locked(this_ptr);
    return nativeResponseValue;
}
function ChannelDetails_set_is_funding_locked(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_set_is_funding_locked(this_ptr, val);
// debug statements here
}
function ChannelDetails_get_is_usable(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_get_is_usable(this_ptr);
    return nativeResponseValue;
}
function ChannelDetails_set_is_usable(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_set_is_usable(this_ptr, val);
// debug statements here
}
function ChannelDetails_get_is_public(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_get_is_public(this_ptr);
    return nativeResponseValue;
}
function ChannelDetails_set_is_public(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_set_is_public(this_ptr, val);
// debug statements here
}
function ChannelDetails_new(channel_id_arg, counterparty_arg, funding_txo_arg, short_channel_id_arg, channel_value_satoshis_arg, unspendable_punishment_reserve_arg, user_channel_id_arg, balance_msat_arg, outbound_capacity_msat_arg, inbound_capacity_msat_arg, confirmations_required_arg, force_close_spend_delay_arg, is_outbound_arg, is_funding_locked_arg, is_usable_arg, is_public_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_new(channel_id_arg, counterparty_arg, funding_txo_arg, short_channel_id_arg, channel_value_satoshis_arg, unspendable_punishment_reserve_arg, user_channel_id_arg, balance_msat_arg, outbound_capacity_msat_arg, inbound_capacity_msat_arg, confirmations_required_arg, force_close_spend_delay_arg, is_outbound_arg, is_funding_locked_arg, is_usable_arg, is_public_arg);
    return nativeResponseValue;
}
function ChannelDetails_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_clone_ptr(arg);
    return nativeResponseValue;
}
function ChannelDetails_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelDetails_clone(orig);
    return nativeResponseValue;
}
function PaymentSendFailure_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PaymentSendFailure_free(this_ptr);
// debug statements here
}
function PaymentSendFailure_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PaymentSendFailure_clone_ptr(arg);
    return nativeResponseValue;
}
function PaymentSendFailure_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PaymentSendFailure_clone(orig);
    return nativeResponseValue;
}
function PaymentSendFailure_parameter_error(a) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PaymentSendFailure_parameter_error(a);
    return nativeResponseValue;
}
function PaymentSendFailure_path_parameter_error(a) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PaymentSendFailure_path_parameter_error(a);
    return nativeResponseValue;
}
function PaymentSendFailure_all_failed_retry_safe(a) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PaymentSendFailure_all_failed_retry_safe(a);
    return nativeResponseValue;
}
function PaymentSendFailure_partial_failure(results, failed_paths_retry, payment_id) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PaymentSendFailure_partial_failure(results, failed_paths_retry, payment_id);
    return nativeResponseValue;
}
function ChannelManager_new(fee_est, chain_monitor, tx_broadcaster, logger, keys_manager, config, params) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_new(fee_est, chain_monitor, tx_broadcaster, logger, keys_manager, config, params);
    return nativeResponseValue;
}
function ChannelManager_get_current_default_configuration(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_get_current_default_configuration(this_arg);
    return nativeResponseValue;
}
function ChannelManager_create_channel(this_arg, their_network_key, channel_value_satoshis, push_msat, user_channel_id, override_config) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_create_channel(this_arg, their_network_key, channel_value_satoshis, push_msat, user_channel_id, override_config);
    return nativeResponseValue;
}
function ChannelManager_list_channels(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_list_channels(this_arg);
    return nativeResponseValue;
}
function ChannelManager_list_usable_channels(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_list_usable_channels(this_arg);
    return nativeResponseValue;
}
function ChannelManager_close_channel(this_arg, channel_id) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_close_channel(this_arg, channel_id);
    return nativeResponseValue;
}
function ChannelManager_close_channel_with_target_feerate(this_arg, channel_id, target_feerate_sats_per_1000_weight) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_close_channel_with_target_feerate(this_arg, channel_id, target_feerate_sats_per_1000_weight);
    return nativeResponseValue;
}
function ChannelManager_force_close_channel(this_arg, channel_id) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_force_close_channel(this_arg, channel_id);
    return nativeResponseValue;
}
function ChannelManager_force_close_all_channels(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_force_close_all_channels(this_arg);
// debug statements here
}
function ChannelManager_send_payment(this_arg, route, payment_hash, payment_secret) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_send_payment(this_arg, route, payment_hash, payment_secret);
    return nativeResponseValue;
}
function ChannelManager_retry_payment(this_arg, route, payment_id) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_retry_payment(this_arg, route, payment_id);
    return nativeResponseValue;
}
function ChannelManager_abandon_payment(this_arg, payment_id) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_abandon_payment(this_arg, payment_id);
// debug statements here
}
function ChannelManager_send_spontaneous_payment(this_arg, route, payment_preimage) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_send_spontaneous_payment(this_arg, route, payment_preimage);
    return nativeResponseValue;
}
function ChannelManager_funding_transaction_generated(this_arg, temporary_channel_id, funding_transaction) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_funding_transaction_generated(this_arg, temporary_channel_id, funding_transaction);
    return nativeResponseValue;
}
function ChannelManager_broadcast_node_announcement(this_arg, rgb, alias, addresses) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_broadcast_node_announcement(this_arg, rgb, alias, addresses);
// debug statements here
}
function ChannelManager_process_pending_htlc_forwards(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_process_pending_htlc_forwards(this_arg);
// debug statements here
}
function ChannelManager_timer_tick_occurred(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_timer_tick_occurred(this_arg);
// debug statements here
}
function ChannelManager_fail_htlc_backwards(this_arg, payment_hash) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_fail_htlc_backwards(this_arg, payment_hash);
    return nativeResponseValue;
}
function ChannelManager_claim_funds(this_arg, payment_preimage) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_claim_funds(this_arg, payment_preimage);
    return nativeResponseValue;
}
function ChannelManager_get_our_node_id(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_get_our_node_id(this_arg);
    return nativeResponseValue;
}
function ChannelManager_create_inbound_payment(this_arg, min_value_msat, invoice_expiry_delta_secs) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_create_inbound_payment(this_arg, min_value_msat, invoice_expiry_delta_secs);
    return nativeResponseValue;
}
function ChannelManager_create_inbound_payment_legacy(this_arg, min_value_msat, invoice_expiry_delta_secs) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_create_inbound_payment_legacy(this_arg, min_value_msat, invoice_expiry_delta_secs);
    return nativeResponseValue;
}
function ChannelManager_create_inbound_payment_for_hash(this_arg, payment_hash, min_value_msat, invoice_expiry_delta_secs) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_create_inbound_payment_for_hash(this_arg, payment_hash, min_value_msat, invoice_expiry_delta_secs);
    return nativeResponseValue;
}
function ChannelManager_create_inbound_payment_for_hash_legacy(this_arg, payment_hash, min_value_msat, invoice_expiry_delta_secs) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_create_inbound_payment_for_hash_legacy(this_arg, payment_hash, min_value_msat, invoice_expiry_delta_secs);
    return nativeResponseValue;
}
function ChannelManager_get_payment_preimage(this_arg, payment_hash, payment_secret) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_get_payment_preimage(this_arg, payment_hash, payment_secret);
    return nativeResponseValue;
}
function ChannelManager_as_MessageSendEventsProvider(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_as_MessageSendEventsProvider(this_arg);
    return nativeResponseValue;
}
function ChannelManager_as_EventsProvider(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_as_EventsProvider(this_arg);
    return nativeResponseValue;
}
function ChannelManager_as_Listen(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_as_Listen(this_arg);
    return nativeResponseValue;
}
function ChannelManager_as_Confirm(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_as_Confirm(this_arg);
    return nativeResponseValue;
}
function ChannelManager_await_persistable_update(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_await_persistable_update(this_arg);
// debug statements here
}
function ChannelManager_current_best_block(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_current_best_block(this_arg);
    return nativeResponseValue;
}
function ChannelManager_as_ChannelMessageHandler(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_as_ChannelMessageHandler(this_arg);
    return nativeResponseValue;
}
function ChannelManager_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManager_write(obj);
    return nativeResponseValue;
}
function ChannelManagerReadArgs_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_free(this_obj);
// debug statements here
}
function ChannelManagerReadArgs_get_keys_manager(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_keys_manager(this_ptr);
    return nativeResponseValue;
}
function ChannelManagerReadArgs_set_keys_manager(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_keys_manager(this_ptr, val);
// debug statements here
}
function ChannelManagerReadArgs_get_fee_estimator(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_fee_estimator(this_ptr);
    return nativeResponseValue;
}
function ChannelManagerReadArgs_set_fee_estimator(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_fee_estimator(this_ptr, val);
// debug statements here
}
function ChannelManagerReadArgs_get_chain_monitor(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_chain_monitor(this_ptr);
    return nativeResponseValue;
}
function ChannelManagerReadArgs_set_chain_monitor(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_chain_monitor(this_ptr, val);
// debug statements here
}
function ChannelManagerReadArgs_get_tx_broadcaster(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_tx_broadcaster(this_ptr);
    return nativeResponseValue;
}
function ChannelManagerReadArgs_set_tx_broadcaster(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_tx_broadcaster(this_ptr, val);
// debug statements here
}
function ChannelManagerReadArgs_get_logger(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_logger(this_ptr);
    return nativeResponseValue;
}
function ChannelManagerReadArgs_set_logger(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_logger(this_ptr, val);
// debug statements here
}
function ChannelManagerReadArgs_get_default_config(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_default_config(this_ptr);
    return nativeResponseValue;
}
function ChannelManagerReadArgs_set_default_config(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_default_config(this_ptr, val);
// debug statements here
}
function ChannelManagerReadArgs_new(keys_manager, fee_estimator, chain_monitor, tx_broadcaster, logger, default_config, channel_monitors) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_new(keys_manager, fee_estimator, chain_monitor, tx_broadcaster, logger, default_config, channel_monitors);
    return nativeResponseValue;
}
function C2Tuple_BlockHashChannelManagerZ_read(ser, arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelManagerZ_read(ser, arg);
    return nativeResponseValue;
}
function DecodeError_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DecodeError_free(this_obj);
// debug statements here
}
function DecodeError_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DecodeError_clone_ptr(arg);
    return nativeResponseValue;
}
function DecodeError_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DecodeError_clone(orig);
    return nativeResponseValue;
}
function Init_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Init_free(this_obj);
// debug statements here
}
function Init_get_features(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Init_get_features(this_ptr);
    return nativeResponseValue;
}
function Init_set_features(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Init_set_features(this_ptr, val);
// debug statements here
}
function Init_new(features_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Init_new(features_arg);
    return nativeResponseValue;
}
function Init_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Init_clone_ptr(arg);
    return nativeResponseValue;
}
function Init_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Init_clone(orig);
    return nativeResponseValue;
}
function ErrorMessage_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorMessage_free(this_obj);
// debug statements here
}
function ErrorMessage_get_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorMessage_get_channel_id(this_ptr);
    return nativeResponseValue;
}
function ErrorMessage_set_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorMessage_set_channel_id(this_ptr, val);
// debug statements here
}
function ErrorMessage_get_data(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorMessage_get_data(this_ptr);
    return nativeResponseValue;
}
function ErrorMessage_set_data(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorMessage_set_data(this_ptr, val);
// debug statements here
}
function ErrorMessage_new(channel_id_arg, data_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorMessage_new(channel_id_arg, data_arg);
    return nativeResponseValue;
}
function ErrorMessage_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorMessage_clone_ptr(arg);
    return nativeResponseValue;
}
function ErrorMessage_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorMessage_clone(orig);
    return nativeResponseValue;
}
function Ping_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Ping_free(this_obj);
// debug statements here
}
function Ping_get_ponglen(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Ping_get_ponglen(this_ptr);
    return nativeResponseValue;
}
function Ping_set_ponglen(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Ping_set_ponglen(this_ptr, val);
// debug statements here
}
function Ping_get_byteslen(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Ping_get_byteslen(this_ptr);
    return nativeResponseValue;
}
function Ping_set_byteslen(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Ping_set_byteslen(this_ptr, val);
// debug statements here
}
function Ping_new(ponglen_arg, byteslen_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Ping_new(ponglen_arg, byteslen_arg);
    return nativeResponseValue;
}
function Ping_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Ping_clone_ptr(arg);
    return nativeResponseValue;
}
function Ping_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Ping_clone(orig);
    return nativeResponseValue;
}
function Pong_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Pong_free(this_obj);
// debug statements here
}
function Pong_get_byteslen(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Pong_get_byteslen(this_ptr);
    return nativeResponseValue;
}
function Pong_set_byteslen(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Pong_set_byteslen(this_ptr, val);
// debug statements here
}
function Pong_new(byteslen_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Pong_new(byteslen_arg);
    return nativeResponseValue;
}
function Pong_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Pong_clone_ptr(arg);
    return nativeResponseValue;
}
function Pong_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Pong_clone(orig);
    return nativeResponseValue;
}
function OpenChannel_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_free(this_obj);
// debug statements here
}
function OpenChannel_get_chain_hash(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_chain_hash(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_chain_hash(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_chain_hash(this_ptr, val);
// debug statements here
}
function OpenChannel_get_temporary_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_temporary_channel_id(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_temporary_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_temporary_channel_id(this_ptr, val);
// debug statements here
}
function OpenChannel_get_funding_satoshis(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_funding_satoshis(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_funding_satoshis(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_funding_satoshis(this_ptr, val);
// debug statements here
}
function OpenChannel_get_push_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_push_msat(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_push_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_push_msat(this_ptr, val);
// debug statements here
}
function OpenChannel_get_dust_limit_satoshis(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_dust_limit_satoshis(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_dust_limit_satoshis(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_dust_limit_satoshis(this_ptr, val);
// debug statements here
}
function OpenChannel_get_max_htlc_value_in_flight_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_max_htlc_value_in_flight_msat(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_max_htlc_value_in_flight_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_max_htlc_value_in_flight_msat(this_ptr, val);
// debug statements here
}
function OpenChannel_get_channel_reserve_satoshis(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_channel_reserve_satoshis(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_channel_reserve_satoshis(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_channel_reserve_satoshis(this_ptr, val);
// debug statements here
}
function OpenChannel_get_htlc_minimum_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_htlc_minimum_msat(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_htlc_minimum_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_htlc_minimum_msat(this_ptr, val);
// debug statements here
}
function OpenChannel_get_feerate_per_kw(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_feerate_per_kw(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_feerate_per_kw(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_feerate_per_kw(this_ptr, val);
// debug statements here
}
function OpenChannel_get_to_self_delay(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_to_self_delay(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_to_self_delay(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_to_self_delay(this_ptr, val);
// debug statements here
}
function OpenChannel_get_max_accepted_htlcs(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_max_accepted_htlcs(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_max_accepted_htlcs(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_max_accepted_htlcs(this_ptr, val);
// debug statements here
}
function OpenChannel_get_funding_pubkey(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_funding_pubkey(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_funding_pubkey(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_funding_pubkey(this_ptr, val);
// debug statements here
}
function OpenChannel_get_revocation_basepoint(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_revocation_basepoint(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_revocation_basepoint(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_revocation_basepoint(this_ptr, val);
// debug statements here
}
function OpenChannel_get_payment_point(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_payment_point(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_payment_point(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_payment_point(this_ptr, val);
// debug statements here
}
function OpenChannel_get_delayed_payment_basepoint(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_delayed_payment_basepoint(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_delayed_payment_basepoint(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_delayed_payment_basepoint(this_ptr, val);
// debug statements here
}
function OpenChannel_get_htlc_basepoint(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_htlc_basepoint(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_htlc_basepoint(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_htlc_basepoint(this_ptr, val);
// debug statements here
}
function OpenChannel_get_first_per_commitment_point(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_first_per_commitment_point(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_first_per_commitment_point(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_first_per_commitment_point(this_ptr, val);
// debug statements here
}
function OpenChannel_get_channel_flags(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_channel_flags(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_channel_flags(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_channel_flags(this_ptr, val);
// debug statements here
}
function OpenChannel_get_channel_type(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_get_channel_type(this_ptr);
    return nativeResponseValue;
}
function OpenChannel_set_channel_type(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_set_channel_type(this_ptr, val);
// debug statements here
}
function OpenChannel_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_clone_ptr(arg);
    return nativeResponseValue;
}
function OpenChannel_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_clone(orig);
    return nativeResponseValue;
}
function AcceptChannel_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_free(this_obj);
// debug statements here
}
function AcceptChannel_get_temporary_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_get_temporary_channel_id(this_ptr);
    return nativeResponseValue;
}
function AcceptChannel_set_temporary_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_set_temporary_channel_id(this_ptr, val);
// debug statements here
}
function AcceptChannel_get_dust_limit_satoshis(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_get_dust_limit_satoshis(this_ptr);
    return nativeResponseValue;
}
function AcceptChannel_set_dust_limit_satoshis(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_set_dust_limit_satoshis(this_ptr, val);
// debug statements here
}
function AcceptChannel_get_max_htlc_value_in_flight_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_get_max_htlc_value_in_flight_msat(this_ptr);
    return nativeResponseValue;
}
function AcceptChannel_set_max_htlc_value_in_flight_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_set_max_htlc_value_in_flight_msat(this_ptr, val);
// debug statements here
}
function AcceptChannel_get_channel_reserve_satoshis(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_get_channel_reserve_satoshis(this_ptr);
    return nativeResponseValue;
}
function AcceptChannel_set_channel_reserve_satoshis(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_set_channel_reserve_satoshis(this_ptr, val);
// debug statements here
}
function AcceptChannel_get_htlc_minimum_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_get_htlc_minimum_msat(this_ptr);
    return nativeResponseValue;
}
function AcceptChannel_set_htlc_minimum_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_set_htlc_minimum_msat(this_ptr, val);
// debug statements here
}
function AcceptChannel_get_minimum_depth(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_get_minimum_depth(this_ptr);
    return nativeResponseValue;
}
function AcceptChannel_set_minimum_depth(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_set_minimum_depth(this_ptr, val);
// debug statements here
}
function AcceptChannel_get_to_self_delay(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_get_to_self_delay(this_ptr);
    return nativeResponseValue;
}
function AcceptChannel_set_to_self_delay(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_set_to_self_delay(this_ptr, val);
// debug statements here
}
function AcceptChannel_get_max_accepted_htlcs(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_get_max_accepted_htlcs(this_ptr);
    return nativeResponseValue;
}
function AcceptChannel_set_max_accepted_htlcs(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_set_max_accepted_htlcs(this_ptr, val);
// debug statements here
}
function AcceptChannel_get_funding_pubkey(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_get_funding_pubkey(this_ptr);
    return nativeResponseValue;
}
function AcceptChannel_set_funding_pubkey(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_set_funding_pubkey(this_ptr, val);
// debug statements here
}
function AcceptChannel_get_revocation_basepoint(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_get_revocation_basepoint(this_ptr);
    return nativeResponseValue;
}
function AcceptChannel_set_revocation_basepoint(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_set_revocation_basepoint(this_ptr, val);
// debug statements here
}
function AcceptChannel_get_payment_point(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_get_payment_point(this_ptr);
    return nativeResponseValue;
}
function AcceptChannel_set_payment_point(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_set_payment_point(this_ptr, val);
// debug statements here
}
function AcceptChannel_get_delayed_payment_basepoint(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_get_delayed_payment_basepoint(this_ptr);
    return nativeResponseValue;
}
function AcceptChannel_set_delayed_payment_basepoint(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_set_delayed_payment_basepoint(this_ptr, val);
// debug statements here
}
function AcceptChannel_get_htlc_basepoint(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_get_htlc_basepoint(this_ptr);
    return nativeResponseValue;
}
function AcceptChannel_set_htlc_basepoint(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_set_htlc_basepoint(this_ptr, val);
// debug statements here
}
function AcceptChannel_get_first_per_commitment_point(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_get_first_per_commitment_point(this_ptr);
    return nativeResponseValue;
}
function AcceptChannel_set_first_per_commitment_point(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_set_first_per_commitment_point(this_ptr, val);
// debug statements here
}
function AcceptChannel_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_clone_ptr(arg);
    return nativeResponseValue;
}
function AcceptChannel_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_clone(orig);
    return nativeResponseValue;
}
function FundingCreated_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingCreated_free(this_obj);
// debug statements here
}
function FundingCreated_get_temporary_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingCreated_get_temporary_channel_id(this_ptr);
    return nativeResponseValue;
}
function FundingCreated_set_temporary_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingCreated_set_temporary_channel_id(this_ptr, val);
// debug statements here
}
function FundingCreated_get_funding_txid(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingCreated_get_funding_txid(this_ptr);
    return nativeResponseValue;
}
function FundingCreated_set_funding_txid(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingCreated_set_funding_txid(this_ptr, val);
// debug statements here
}
function FundingCreated_get_funding_output_index(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingCreated_get_funding_output_index(this_ptr);
    return nativeResponseValue;
}
function FundingCreated_set_funding_output_index(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingCreated_set_funding_output_index(this_ptr, val);
// debug statements here
}
function FundingCreated_get_signature(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingCreated_get_signature(this_ptr);
    return nativeResponseValue;
}
function FundingCreated_set_signature(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingCreated_set_signature(this_ptr, val);
// debug statements here
}
function FundingCreated_new(temporary_channel_id_arg, funding_txid_arg, funding_output_index_arg, signature_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingCreated_new(temporary_channel_id_arg, funding_txid_arg, funding_output_index_arg, signature_arg);
    return nativeResponseValue;
}
function FundingCreated_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingCreated_clone_ptr(arg);
    return nativeResponseValue;
}
function FundingCreated_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingCreated_clone(orig);
    return nativeResponseValue;
}
function FundingSigned_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingSigned_free(this_obj);
// debug statements here
}
function FundingSigned_get_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingSigned_get_channel_id(this_ptr);
    return nativeResponseValue;
}
function FundingSigned_set_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingSigned_set_channel_id(this_ptr, val);
// debug statements here
}
function FundingSigned_get_signature(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingSigned_get_signature(this_ptr);
    return nativeResponseValue;
}
function FundingSigned_set_signature(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingSigned_set_signature(this_ptr, val);
// debug statements here
}
function FundingSigned_new(channel_id_arg, signature_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingSigned_new(channel_id_arg, signature_arg);
    return nativeResponseValue;
}
function FundingSigned_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingSigned_clone_ptr(arg);
    return nativeResponseValue;
}
function FundingSigned_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingSigned_clone(orig);
    return nativeResponseValue;
}
function FundingLocked_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingLocked_free(this_obj);
// debug statements here
}
function FundingLocked_get_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingLocked_get_channel_id(this_ptr);
    return nativeResponseValue;
}
function FundingLocked_set_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingLocked_set_channel_id(this_ptr, val);
// debug statements here
}
function FundingLocked_get_next_per_commitment_point(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingLocked_get_next_per_commitment_point(this_ptr);
    return nativeResponseValue;
}
function FundingLocked_set_next_per_commitment_point(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingLocked_set_next_per_commitment_point(this_ptr, val);
// debug statements here
}
function FundingLocked_new(channel_id_arg, next_per_commitment_point_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingLocked_new(channel_id_arg, next_per_commitment_point_arg);
    return nativeResponseValue;
}
function FundingLocked_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingLocked_clone_ptr(arg);
    return nativeResponseValue;
}
function FundingLocked_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingLocked_clone(orig);
    return nativeResponseValue;
}
function Shutdown_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Shutdown_free(this_obj);
// debug statements here
}
function Shutdown_get_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Shutdown_get_channel_id(this_ptr);
    return nativeResponseValue;
}
function Shutdown_set_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Shutdown_set_channel_id(this_ptr, val);
// debug statements here
}
function Shutdown_get_scriptpubkey(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Shutdown_get_scriptpubkey(this_ptr);
    return nativeResponseValue;
}
function Shutdown_set_scriptpubkey(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Shutdown_set_scriptpubkey(this_ptr, val);
// debug statements here
}
function Shutdown_new(channel_id_arg, scriptpubkey_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Shutdown_new(channel_id_arg, scriptpubkey_arg);
    return nativeResponseValue;
}
function Shutdown_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Shutdown_clone_ptr(arg);
    return nativeResponseValue;
}
function Shutdown_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Shutdown_clone(orig);
    return nativeResponseValue;
}
function ClosingSignedFeeRange_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_free(this_obj);
// debug statements here
}
function ClosingSignedFeeRange_get_min_fee_satoshis(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_get_min_fee_satoshis(this_ptr);
    return nativeResponseValue;
}
function ClosingSignedFeeRange_set_min_fee_satoshis(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_set_min_fee_satoshis(this_ptr, val);
// debug statements here
}
function ClosingSignedFeeRange_get_max_fee_satoshis(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_get_max_fee_satoshis(this_ptr);
    return nativeResponseValue;
}
function ClosingSignedFeeRange_set_max_fee_satoshis(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_set_max_fee_satoshis(this_ptr, val);
// debug statements here
}
function ClosingSignedFeeRange_new(min_fee_satoshis_arg, max_fee_satoshis_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_new(min_fee_satoshis_arg, max_fee_satoshis_arg);
    return nativeResponseValue;
}
function ClosingSignedFeeRange_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_clone_ptr(arg);
    return nativeResponseValue;
}
function ClosingSignedFeeRange_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_clone(orig);
    return nativeResponseValue;
}
function ClosingSigned_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSigned_free(this_obj);
// debug statements here
}
function ClosingSigned_get_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSigned_get_channel_id(this_ptr);
    return nativeResponseValue;
}
function ClosingSigned_set_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSigned_set_channel_id(this_ptr, val);
// debug statements here
}
function ClosingSigned_get_fee_satoshis(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSigned_get_fee_satoshis(this_ptr);
    return nativeResponseValue;
}
function ClosingSigned_set_fee_satoshis(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSigned_set_fee_satoshis(this_ptr, val);
// debug statements here
}
function ClosingSigned_get_signature(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSigned_get_signature(this_ptr);
    return nativeResponseValue;
}
function ClosingSigned_set_signature(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSigned_set_signature(this_ptr, val);
// debug statements here
}
function ClosingSigned_get_fee_range(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSigned_get_fee_range(this_ptr);
    return nativeResponseValue;
}
function ClosingSigned_set_fee_range(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSigned_set_fee_range(this_ptr, val);
// debug statements here
}
function ClosingSigned_new(channel_id_arg, fee_satoshis_arg, signature_arg, fee_range_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSigned_new(channel_id_arg, fee_satoshis_arg, signature_arg, fee_range_arg);
    return nativeResponseValue;
}
function ClosingSigned_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSigned_clone_ptr(arg);
    return nativeResponseValue;
}
function ClosingSigned_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSigned_clone(orig);
    return nativeResponseValue;
}
function UpdateAddHTLC_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateAddHTLC_free(this_obj);
// debug statements here
}
function UpdateAddHTLC_get_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateAddHTLC_get_channel_id(this_ptr);
    return nativeResponseValue;
}
function UpdateAddHTLC_set_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateAddHTLC_set_channel_id(this_ptr, val);
// debug statements here
}
function UpdateAddHTLC_get_htlc_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateAddHTLC_get_htlc_id(this_ptr);
    return nativeResponseValue;
}
function UpdateAddHTLC_set_htlc_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateAddHTLC_set_htlc_id(this_ptr, val);
// debug statements here
}
function UpdateAddHTLC_get_amount_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateAddHTLC_get_amount_msat(this_ptr);
    return nativeResponseValue;
}
function UpdateAddHTLC_set_amount_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateAddHTLC_set_amount_msat(this_ptr, val);
// debug statements here
}
function UpdateAddHTLC_get_payment_hash(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateAddHTLC_get_payment_hash(this_ptr);
    return nativeResponseValue;
}
function UpdateAddHTLC_set_payment_hash(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateAddHTLC_set_payment_hash(this_ptr, val);
// debug statements here
}
function UpdateAddHTLC_get_cltv_expiry(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateAddHTLC_get_cltv_expiry(this_ptr);
    return nativeResponseValue;
}
function UpdateAddHTLC_set_cltv_expiry(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateAddHTLC_set_cltv_expiry(this_ptr, val);
// debug statements here
}
function UpdateAddHTLC_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateAddHTLC_clone_ptr(arg);
    return nativeResponseValue;
}
function UpdateAddHTLC_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateAddHTLC_clone(orig);
    return nativeResponseValue;
}
function UpdateFulfillHTLC_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_free(this_obj);
// debug statements here
}
function UpdateFulfillHTLC_get_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_get_channel_id(this_ptr);
    return nativeResponseValue;
}
function UpdateFulfillHTLC_set_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_set_channel_id(this_ptr, val);
// debug statements here
}
function UpdateFulfillHTLC_get_htlc_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_get_htlc_id(this_ptr);
    return nativeResponseValue;
}
function UpdateFulfillHTLC_set_htlc_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_set_htlc_id(this_ptr, val);
// debug statements here
}
function UpdateFulfillHTLC_get_payment_preimage(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_get_payment_preimage(this_ptr);
    return nativeResponseValue;
}
function UpdateFulfillHTLC_set_payment_preimage(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_set_payment_preimage(this_ptr, val);
// debug statements here
}
function UpdateFulfillHTLC_new(channel_id_arg, htlc_id_arg, payment_preimage_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_new(channel_id_arg, htlc_id_arg, payment_preimage_arg);
    return nativeResponseValue;
}
function UpdateFulfillHTLC_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_clone_ptr(arg);
    return nativeResponseValue;
}
function UpdateFulfillHTLC_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_clone(orig);
    return nativeResponseValue;
}
function UpdateFailHTLC_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailHTLC_free(this_obj);
// debug statements here
}
function UpdateFailHTLC_get_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailHTLC_get_channel_id(this_ptr);
    return nativeResponseValue;
}
function UpdateFailHTLC_set_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailHTLC_set_channel_id(this_ptr, val);
// debug statements here
}
function UpdateFailHTLC_get_htlc_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailHTLC_get_htlc_id(this_ptr);
    return nativeResponseValue;
}
function UpdateFailHTLC_set_htlc_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailHTLC_set_htlc_id(this_ptr, val);
// debug statements here
}
function UpdateFailHTLC_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailHTLC_clone_ptr(arg);
    return nativeResponseValue;
}
function UpdateFailHTLC_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailHTLC_clone(orig);
    return nativeResponseValue;
}
function UpdateFailMalformedHTLC_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_free(this_obj);
// debug statements here
}
function UpdateFailMalformedHTLC_get_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_get_channel_id(this_ptr);
    return nativeResponseValue;
}
function UpdateFailMalformedHTLC_set_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_set_channel_id(this_ptr, val);
// debug statements here
}
function UpdateFailMalformedHTLC_get_htlc_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_get_htlc_id(this_ptr);
    return nativeResponseValue;
}
function UpdateFailMalformedHTLC_set_htlc_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_set_htlc_id(this_ptr, val);
// debug statements here
}
function UpdateFailMalformedHTLC_get_failure_code(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_get_failure_code(this_ptr);
    return nativeResponseValue;
}
function UpdateFailMalformedHTLC_set_failure_code(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_set_failure_code(this_ptr, val);
// debug statements here
}
function UpdateFailMalformedHTLC_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_clone_ptr(arg);
    return nativeResponseValue;
}
function UpdateFailMalformedHTLC_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_clone(orig);
    return nativeResponseValue;
}
function CommitmentSigned_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentSigned_free(this_obj);
// debug statements here
}
function CommitmentSigned_get_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentSigned_get_channel_id(this_ptr);
    return nativeResponseValue;
}
function CommitmentSigned_set_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentSigned_set_channel_id(this_ptr, val);
// debug statements here
}
function CommitmentSigned_get_signature(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentSigned_get_signature(this_ptr);
    return nativeResponseValue;
}
function CommitmentSigned_set_signature(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentSigned_set_signature(this_ptr, val);
// debug statements here
}
function CommitmentSigned_set_htlc_signatures(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentSigned_set_htlc_signatures(this_ptr, val);
// debug statements here
}
function CommitmentSigned_new(channel_id_arg, signature_arg, htlc_signatures_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentSigned_new(channel_id_arg, signature_arg, htlc_signatures_arg);
    return nativeResponseValue;
}
function CommitmentSigned_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentSigned_clone_ptr(arg);
    return nativeResponseValue;
}
function CommitmentSigned_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentSigned_clone(orig);
    return nativeResponseValue;
}
function RevokeAndACK_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RevokeAndACK_free(this_obj);
// debug statements here
}
function RevokeAndACK_get_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RevokeAndACK_get_channel_id(this_ptr);
    return nativeResponseValue;
}
function RevokeAndACK_set_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RevokeAndACK_set_channel_id(this_ptr, val);
// debug statements here
}
function RevokeAndACK_get_per_commitment_secret(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RevokeAndACK_get_per_commitment_secret(this_ptr);
    return nativeResponseValue;
}
function RevokeAndACK_set_per_commitment_secret(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RevokeAndACK_set_per_commitment_secret(this_ptr, val);
// debug statements here
}
function RevokeAndACK_get_next_per_commitment_point(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RevokeAndACK_get_next_per_commitment_point(this_ptr);
    return nativeResponseValue;
}
function RevokeAndACK_set_next_per_commitment_point(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RevokeAndACK_set_next_per_commitment_point(this_ptr, val);
// debug statements here
}
function RevokeAndACK_new(channel_id_arg, per_commitment_secret_arg, next_per_commitment_point_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RevokeAndACK_new(channel_id_arg, per_commitment_secret_arg, next_per_commitment_point_arg);
    return nativeResponseValue;
}
function RevokeAndACK_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RevokeAndACK_clone_ptr(arg);
    return nativeResponseValue;
}
function RevokeAndACK_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RevokeAndACK_clone(orig);
    return nativeResponseValue;
}
function UpdateFee_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFee_free(this_obj);
// debug statements here
}
function UpdateFee_get_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFee_get_channel_id(this_ptr);
    return nativeResponseValue;
}
function UpdateFee_set_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFee_set_channel_id(this_ptr, val);
// debug statements here
}
function UpdateFee_get_feerate_per_kw(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFee_get_feerate_per_kw(this_ptr);
    return nativeResponseValue;
}
function UpdateFee_set_feerate_per_kw(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFee_set_feerate_per_kw(this_ptr, val);
// debug statements here
}
function UpdateFee_new(channel_id_arg, feerate_per_kw_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFee_new(channel_id_arg, feerate_per_kw_arg);
    return nativeResponseValue;
}
function UpdateFee_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFee_clone_ptr(arg);
    return nativeResponseValue;
}
function UpdateFee_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFee_clone(orig);
    return nativeResponseValue;
}
function DataLossProtect_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DataLossProtect_free(this_obj);
// debug statements here
}
function DataLossProtect_get_your_last_per_commitment_secret(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DataLossProtect_get_your_last_per_commitment_secret(this_ptr);
    return nativeResponseValue;
}
function DataLossProtect_set_your_last_per_commitment_secret(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DataLossProtect_set_your_last_per_commitment_secret(this_ptr, val);
// debug statements here
}
function DataLossProtect_get_my_current_per_commitment_point(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DataLossProtect_get_my_current_per_commitment_point(this_ptr);
    return nativeResponseValue;
}
function DataLossProtect_set_my_current_per_commitment_point(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DataLossProtect_set_my_current_per_commitment_point(this_ptr, val);
// debug statements here
}
function DataLossProtect_new(your_last_per_commitment_secret_arg, my_current_per_commitment_point_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DataLossProtect_new(your_last_per_commitment_secret_arg, my_current_per_commitment_point_arg);
    return nativeResponseValue;
}
function DataLossProtect_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DataLossProtect_clone_ptr(arg);
    return nativeResponseValue;
}
function DataLossProtect_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DataLossProtect_clone(orig);
    return nativeResponseValue;
}
function ChannelReestablish_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelReestablish_free(this_obj);
// debug statements here
}
function ChannelReestablish_get_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelReestablish_get_channel_id(this_ptr);
    return nativeResponseValue;
}
function ChannelReestablish_set_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelReestablish_set_channel_id(this_ptr, val);
// debug statements here
}
function ChannelReestablish_get_next_local_commitment_number(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelReestablish_get_next_local_commitment_number(this_ptr);
    return nativeResponseValue;
}
function ChannelReestablish_set_next_local_commitment_number(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelReestablish_set_next_local_commitment_number(this_ptr, val);
// debug statements here
}
function ChannelReestablish_get_next_remote_commitment_number(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelReestablish_get_next_remote_commitment_number(this_ptr);
    return nativeResponseValue;
}
function ChannelReestablish_set_next_remote_commitment_number(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelReestablish_set_next_remote_commitment_number(this_ptr, val);
// debug statements here
}
function ChannelReestablish_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelReestablish_clone_ptr(arg);
    return nativeResponseValue;
}
function ChannelReestablish_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelReestablish_clone(orig);
    return nativeResponseValue;
}
function AnnouncementSignatures_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AnnouncementSignatures_free(this_obj);
// debug statements here
}
function AnnouncementSignatures_get_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AnnouncementSignatures_get_channel_id(this_ptr);
    return nativeResponseValue;
}
function AnnouncementSignatures_set_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AnnouncementSignatures_set_channel_id(this_ptr, val);
// debug statements here
}
function AnnouncementSignatures_get_short_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AnnouncementSignatures_get_short_channel_id(this_ptr);
    return nativeResponseValue;
}
function AnnouncementSignatures_set_short_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AnnouncementSignatures_set_short_channel_id(this_ptr, val);
// debug statements here
}
function AnnouncementSignatures_get_node_signature(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AnnouncementSignatures_get_node_signature(this_ptr);
    return nativeResponseValue;
}
function AnnouncementSignatures_set_node_signature(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AnnouncementSignatures_set_node_signature(this_ptr, val);
// debug statements here
}
function AnnouncementSignatures_get_bitcoin_signature(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AnnouncementSignatures_get_bitcoin_signature(this_ptr);
    return nativeResponseValue;
}
function AnnouncementSignatures_set_bitcoin_signature(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AnnouncementSignatures_set_bitcoin_signature(this_ptr, val);
// debug statements here
}
function AnnouncementSignatures_new(channel_id_arg, short_channel_id_arg, node_signature_arg, bitcoin_signature_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AnnouncementSignatures_new(channel_id_arg, short_channel_id_arg, node_signature_arg, bitcoin_signature_arg);
    return nativeResponseValue;
}
function AnnouncementSignatures_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AnnouncementSignatures_clone_ptr(arg);
    return nativeResponseValue;
}
function AnnouncementSignatures_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AnnouncementSignatures_clone(orig);
    return nativeResponseValue;
}
function NetAddress_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetAddress_free(this_ptr);
// debug statements here
}
function NetAddress_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetAddress_clone_ptr(arg);
    return nativeResponseValue;
}
function NetAddress_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetAddress_clone(orig);
    return nativeResponseValue;
}
function NetAddress_ipv4(addr, port) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetAddress_ipv4(addr, port);
    return nativeResponseValue;
}
function NetAddress_ipv6(addr, port) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetAddress_ipv6(addr, port);
    return nativeResponseValue;
}
function NetAddress_onion_v2(a) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetAddress_onion_v2(a);
    return nativeResponseValue;
}
function NetAddress_onion_v3(ed25519_pubkey, checksum, version, port) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetAddress_onion_v3(ed25519_pubkey, checksum, version, port);
    return nativeResponseValue;
}
function NetAddress_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetAddress_write(obj);
    return nativeResponseValue;
}
function NetAddress_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetAddress_read(ser);
    return nativeResponseValue;
}
function UnsignedNodeAnnouncement_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_free(this_obj);
// debug statements here
}
function UnsignedNodeAnnouncement_get_features(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_get_features(this_ptr);
    return nativeResponseValue;
}
function UnsignedNodeAnnouncement_set_features(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_features(this_ptr, val);
// debug statements here
}
function UnsignedNodeAnnouncement_get_timestamp(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_get_timestamp(this_ptr);
    return nativeResponseValue;
}
function UnsignedNodeAnnouncement_set_timestamp(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_timestamp(this_ptr, val);
// debug statements here
}
function UnsignedNodeAnnouncement_get_node_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_get_node_id(this_ptr);
    return nativeResponseValue;
}
function UnsignedNodeAnnouncement_set_node_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_node_id(this_ptr, val);
// debug statements here
}
function UnsignedNodeAnnouncement_get_rgb(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_get_rgb(this_ptr);
    return nativeResponseValue;
}
function UnsignedNodeAnnouncement_set_rgb(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_rgb(this_ptr, val);
// debug statements here
}
function UnsignedNodeAnnouncement_get_alias(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_get_alias(this_ptr);
    return nativeResponseValue;
}
function UnsignedNodeAnnouncement_set_alias(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_alias(this_ptr, val);
// debug statements here
}
function UnsignedNodeAnnouncement_set_addresses(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_addresses(this_ptr, val);
// debug statements here
}
function UnsignedNodeAnnouncement_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_clone_ptr(arg);
    return nativeResponseValue;
}
function UnsignedNodeAnnouncement_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_clone(orig);
    return nativeResponseValue;
}
function NodeAnnouncement_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncement_free(this_obj);
// debug statements here
}
function NodeAnnouncement_get_signature(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncement_get_signature(this_ptr);
    return nativeResponseValue;
}
function NodeAnnouncement_set_signature(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncement_set_signature(this_ptr, val);
// debug statements here
}
function NodeAnnouncement_get_contents(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncement_get_contents(this_ptr);
    return nativeResponseValue;
}
function NodeAnnouncement_set_contents(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncement_set_contents(this_ptr, val);
// debug statements here
}
function NodeAnnouncement_new(signature_arg, contents_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncement_new(signature_arg, contents_arg);
    return nativeResponseValue;
}
function NodeAnnouncement_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncement_clone_ptr(arg);
    return nativeResponseValue;
}
function NodeAnnouncement_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncement_clone(orig);
    return nativeResponseValue;
}
function UnsignedChannelAnnouncement_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_free(this_obj);
// debug statements here
}
function UnsignedChannelAnnouncement_get_features(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_features(this_ptr);
    return nativeResponseValue;
}
function UnsignedChannelAnnouncement_set_features(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_features(this_ptr, val);
// debug statements here
}
function UnsignedChannelAnnouncement_get_chain_hash(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_chain_hash(this_ptr);
    return nativeResponseValue;
}
function UnsignedChannelAnnouncement_set_chain_hash(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_chain_hash(this_ptr, val);
// debug statements here
}
function UnsignedChannelAnnouncement_get_short_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_short_channel_id(this_ptr);
    return nativeResponseValue;
}
function UnsignedChannelAnnouncement_set_short_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_short_channel_id(this_ptr, val);
// debug statements here
}
function UnsignedChannelAnnouncement_get_node_id_1(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_node_id_1(this_ptr);
    return nativeResponseValue;
}
function UnsignedChannelAnnouncement_set_node_id_1(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_node_id_1(this_ptr, val);
// debug statements here
}
function UnsignedChannelAnnouncement_get_node_id_2(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_node_id_2(this_ptr);
    return nativeResponseValue;
}
function UnsignedChannelAnnouncement_set_node_id_2(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_node_id_2(this_ptr, val);
// debug statements here
}
function UnsignedChannelAnnouncement_get_bitcoin_key_1(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_bitcoin_key_1(this_ptr);
    return nativeResponseValue;
}
function UnsignedChannelAnnouncement_set_bitcoin_key_1(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_bitcoin_key_1(this_ptr, val);
// debug statements here
}
function UnsignedChannelAnnouncement_get_bitcoin_key_2(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_bitcoin_key_2(this_ptr);
    return nativeResponseValue;
}
function UnsignedChannelAnnouncement_set_bitcoin_key_2(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_bitcoin_key_2(this_ptr, val);
// debug statements here
}
function UnsignedChannelAnnouncement_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_clone_ptr(arg);
    return nativeResponseValue;
}
function UnsignedChannelAnnouncement_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_clone(orig);
    return nativeResponseValue;
}
function ChannelAnnouncement_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelAnnouncement_free(this_obj);
// debug statements here
}
function ChannelAnnouncement_get_node_signature_1(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelAnnouncement_get_node_signature_1(this_ptr);
    return nativeResponseValue;
}
function ChannelAnnouncement_set_node_signature_1(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelAnnouncement_set_node_signature_1(this_ptr, val);
// debug statements here
}
function ChannelAnnouncement_get_node_signature_2(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelAnnouncement_get_node_signature_2(this_ptr);
    return nativeResponseValue;
}
function ChannelAnnouncement_set_node_signature_2(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelAnnouncement_set_node_signature_2(this_ptr, val);
// debug statements here
}
function ChannelAnnouncement_get_bitcoin_signature_1(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelAnnouncement_get_bitcoin_signature_1(this_ptr);
    return nativeResponseValue;
}
function ChannelAnnouncement_set_bitcoin_signature_1(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelAnnouncement_set_bitcoin_signature_1(this_ptr, val);
// debug statements here
}
function ChannelAnnouncement_get_bitcoin_signature_2(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelAnnouncement_get_bitcoin_signature_2(this_ptr);
    return nativeResponseValue;
}
function ChannelAnnouncement_set_bitcoin_signature_2(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelAnnouncement_set_bitcoin_signature_2(this_ptr, val);
// debug statements here
}
function ChannelAnnouncement_get_contents(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelAnnouncement_get_contents(this_ptr);
    return nativeResponseValue;
}
function ChannelAnnouncement_set_contents(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelAnnouncement_set_contents(this_ptr, val);
// debug statements here
}
function ChannelAnnouncement_new(node_signature_1_arg, node_signature_2_arg, bitcoin_signature_1_arg, bitcoin_signature_2_arg, contents_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelAnnouncement_new(node_signature_1_arg, node_signature_2_arg, bitcoin_signature_1_arg, bitcoin_signature_2_arg, contents_arg);
    return nativeResponseValue;
}
function ChannelAnnouncement_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelAnnouncement_clone_ptr(arg);
    return nativeResponseValue;
}
function ChannelAnnouncement_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelAnnouncement_clone(orig);
    return nativeResponseValue;
}
function UnsignedChannelUpdate_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_free(this_obj);
// debug statements here
}
function UnsignedChannelUpdate_get_chain_hash(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_chain_hash(this_ptr);
    return nativeResponseValue;
}
function UnsignedChannelUpdate_set_chain_hash(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_chain_hash(this_ptr, val);
// debug statements here
}
function UnsignedChannelUpdate_get_short_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_short_channel_id(this_ptr);
    return nativeResponseValue;
}
function UnsignedChannelUpdate_set_short_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_short_channel_id(this_ptr, val);
// debug statements here
}
function UnsignedChannelUpdate_get_timestamp(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_timestamp(this_ptr);
    return nativeResponseValue;
}
function UnsignedChannelUpdate_set_timestamp(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_timestamp(this_ptr, val);
// debug statements here
}
function UnsignedChannelUpdate_get_flags(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_flags(this_ptr);
    return nativeResponseValue;
}
function UnsignedChannelUpdate_set_flags(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_flags(this_ptr, val);
// debug statements here
}
function UnsignedChannelUpdate_get_cltv_expiry_delta(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_cltv_expiry_delta(this_ptr);
    return nativeResponseValue;
}
function UnsignedChannelUpdate_set_cltv_expiry_delta(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_cltv_expiry_delta(this_ptr, val);
// debug statements here
}
function UnsignedChannelUpdate_get_htlc_minimum_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_htlc_minimum_msat(this_ptr);
    return nativeResponseValue;
}
function UnsignedChannelUpdate_set_htlc_minimum_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_htlc_minimum_msat(this_ptr, val);
// debug statements here
}
function UnsignedChannelUpdate_get_fee_base_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_fee_base_msat(this_ptr);
    return nativeResponseValue;
}
function UnsignedChannelUpdate_set_fee_base_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_fee_base_msat(this_ptr, val);
// debug statements here
}
function UnsignedChannelUpdate_get_fee_proportional_millionths(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_fee_proportional_millionths(this_ptr);
    return nativeResponseValue;
}
function UnsignedChannelUpdate_set_fee_proportional_millionths(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_fee_proportional_millionths(this_ptr, val);
// debug statements here
}
function UnsignedChannelUpdate_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_clone_ptr(arg);
    return nativeResponseValue;
}
function UnsignedChannelUpdate_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_clone(orig);
    return nativeResponseValue;
}
function ChannelUpdate_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelUpdate_free(this_obj);
// debug statements here
}
function ChannelUpdate_get_signature(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelUpdate_get_signature(this_ptr);
    return nativeResponseValue;
}
function ChannelUpdate_set_signature(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelUpdate_set_signature(this_ptr, val);
// debug statements here
}
function ChannelUpdate_get_contents(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelUpdate_get_contents(this_ptr);
    return nativeResponseValue;
}
function ChannelUpdate_set_contents(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelUpdate_set_contents(this_ptr, val);
// debug statements here
}
function ChannelUpdate_new(signature_arg, contents_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelUpdate_new(signature_arg, contents_arg);
    return nativeResponseValue;
}
function ChannelUpdate_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelUpdate_clone_ptr(arg);
    return nativeResponseValue;
}
function ChannelUpdate_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelUpdate_clone(orig);
    return nativeResponseValue;
}
function QueryChannelRange_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryChannelRange_free(this_obj);
// debug statements here
}
function QueryChannelRange_get_chain_hash(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryChannelRange_get_chain_hash(this_ptr);
    return nativeResponseValue;
}
function QueryChannelRange_set_chain_hash(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryChannelRange_set_chain_hash(this_ptr, val);
// debug statements here
}
function QueryChannelRange_get_first_blocknum(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryChannelRange_get_first_blocknum(this_ptr);
    return nativeResponseValue;
}
function QueryChannelRange_set_first_blocknum(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryChannelRange_set_first_blocknum(this_ptr, val);
// debug statements here
}
function QueryChannelRange_get_number_of_blocks(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryChannelRange_get_number_of_blocks(this_ptr);
    return nativeResponseValue;
}
function QueryChannelRange_set_number_of_blocks(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryChannelRange_set_number_of_blocks(this_ptr, val);
// debug statements here
}
function QueryChannelRange_new(chain_hash_arg, first_blocknum_arg, number_of_blocks_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryChannelRange_new(chain_hash_arg, first_blocknum_arg, number_of_blocks_arg);
    return nativeResponseValue;
}
function QueryChannelRange_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryChannelRange_clone_ptr(arg);
    return nativeResponseValue;
}
function QueryChannelRange_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryChannelRange_clone(orig);
    return nativeResponseValue;
}
function ReplyChannelRange_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyChannelRange_free(this_obj);
// debug statements here
}
function ReplyChannelRange_get_chain_hash(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyChannelRange_get_chain_hash(this_ptr);
    return nativeResponseValue;
}
function ReplyChannelRange_set_chain_hash(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyChannelRange_set_chain_hash(this_ptr, val);
// debug statements here
}
function ReplyChannelRange_get_first_blocknum(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyChannelRange_get_first_blocknum(this_ptr);
    return nativeResponseValue;
}
function ReplyChannelRange_set_first_blocknum(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyChannelRange_set_first_blocknum(this_ptr, val);
// debug statements here
}
function ReplyChannelRange_get_number_of_blocks(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyChannelRange_get_number_of_blocks(this_ptr);
    return nativeResponseValue;
}
function ReplyChannelRange_set_number_of_blocks(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyChannelRange_set_number_of_blocks(this_ptr, val);
// debug statements here
}
function ReplyChannelRange_get_sync_complete(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyChannelRange_get_sync_complete(this_ptr);
    return nativeResponseValue;
}
function ReplyChannelRange_set_sync_complete(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyChannelRange_set_sync_complete(this_ptr, val);
// debug statements here
}
function ReplyChannelRange_set_short_channel_ids(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyChannelRange_set_short_channel_ids(this_ptr, val);
// debug statements here
}
function ReplyChannelRange_new(chain_hash_arg, first_blocknum_arg, number_of_blocks_arg, sync_complete_arg, short_channel_ids_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyChannelRange_new(chain_hash_arg, first_blocknum_arg, number_of_blocks_arg, sync_complete_arg, short_channel_ids_arg);
    return nativeResponseValue;
}
function ReplyChannelRange_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyChannelRange_clone_ptr(arg);
    return nativeResponseValue;
}
function ReplyChannelRange_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyChannelRange_clone(orig);
    return nativeResponseValue;
}
function QueryShortChannelIds_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryShortChannelIds_free(this_obj);
// debug statements here
}
function QueryShortChannelIds_get_chain_hash(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryShortChannelIds_get_chain_hash(this_ptr);
    return nativeResponseValue;
}
function QueryShortChannelIds_set_chain_hash(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryShortChannelIds_set_chain_hash(this_ptr, val);
// debug statements here
}
function QueryShortChannelIds_set_short_channel_ids(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryShortChannelIds_set_short_channel_ids(this_ptr, val);
// debug statements here
}
function QueryShortChannelIds_new(chain_hash_arg, short_channel_ids_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryShortChannelIds_new(chain_hash_arg, short_channel_ids_arg);
    return nativeResponseValue;
}
function QueryShortChannelIds_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryShortChannelIds_clone_ptr(arg);
    return nativeResponseValue;
}
function QueryShortChannelIds_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryShortChannelIds_clone(orig);
    return nativeResponseValue;
}
function ReplyShortChannelIdsEnd_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_free(this_obj);
// debug statements here
}
function ReplyShortChannelIdsEnd_get_chain_hash(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_get_chain_hash(this_ptr);
    return nativeResponseValue;
}
function ReplyShortChannelIdsEnd_set_chain_hash(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_set_chain_hash(this_ptr, val);
// debug statements here
}
function ReplyShortChannelIdsEnd_get_full_information(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_get_full_information(this_ptr);
    return nativeResponseValue;
}
function ReplyShortChannelIdsEnd_set_full_information(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_set_full_information(this_ptr, val);
// debug statements here
}
function ReplyShortChannelIdsEnd_new(chain_hash_arg, full_information_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_new(chain_hash_arg, full_information_arg);
    return nativeResponseValue;
}
function ReplyShortChannelIdsEnd_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_clone_ptr(arg);
    return nativeResponseValue;
}
function ReplyShortChannelIdsEnd_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_clone(orig);
    return nativeResponseValue;
}
function GossipTimestampFilter_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_GossipTimestampFilter_free(this_obj);
// debug statements here
}
function GossipTimestampFilter_get_chain_hash(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_GossipTimestampFilter_get_chain_hash(this_ptr);
    return nativeResponseValue;
}
function GossipTimestampFilter_set_chain_hash(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_GossipTimestampFilter_set_chain_hash(this_ptr, val);
// debug statements here
}
function GossipTimestampFilter_get_first_timestamp(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_GossipTimestampFilter_get_first_timestamp(this_ptr);
    return nativeResponseValue;
}
function GossipTimestampFilter_set_first_timestamp(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_GossipTimestampFilter_set_first_timestamp(this_ptr, val);
// debug statements here
}
function GossipTimestampFilter_get_timestamp_range(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_GossipTimestampFilter_get_timestamp_range(this_ptr);
    return nativeResponseValue;
}
function GossipTimestampFilter_set_timestamp_range(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_GossipTimestampFilter_set_timestamp_range(this_ptr, val);
// debug statements here
}
function GossipTimestampFilter_new(chain_hash_arg, first_timestamp_arg, timestamp_range_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_GossipTimestampFilter_new(chain_hash_arg, first_timestamp_arg, timestamp_range_arg);
    return nativeResponseValue;
}
function GossipTimestampFilter_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_GossipTimestampFilter_clone_ptr(arg);
    return nativeResponseValue;
}
function GossipTimestampFilter_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_GossipTimestampFilter_clone(orig);
    return nativeResponseValue;
}
function ErrorAction_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorAction_free(this_ptr);
// debug statements here
}
function ErrorAction_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorAction_clone_ptr(arg);
    return nativeResponseValue;
}
function ErrorAction_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorAction_clone(orig);
    return nativeResponseValue;
}
function ErrorAction_disconnect_peer(msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorAction_disconnect_peer(msg);
    return nativeResponseValue;
}
function ErrorAction_ignore_error() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorAction_ignore_error();
    return nativeResponseValue;
}
function ErrorAction_ignore_and_log(a) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorAction_ignore_and_log(a);
    return nativeResponseValue;
}
function ErrorAction_ignore_duplicate_gossip() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorAction_ignore_duplicate_gossip();
    return nativeResponseValue;
}
function ErrorAction_send_error_message(msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorAction_send_error_message(msg);
    return nativeResponseValue;
}
function LightningError_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LightningError_free(this_obj);
// debug statements here
}
function LightningError_get_err(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LightningError_get_err(this_ptr);
    return nativeResponseValue;
}
function LightningError_set_err(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LightningError_set_err(this_ptr, val);
// debug statements here
}
function LightningError_get_action(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LightningError_get_action(this_ptr);
    return nativeResponseValue;
}
function LightningError_set_action(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LightningError_set_action(this_ptr, val);
// debug statements here
}
function LightningError_new(err_arg, action_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LightningError_new(err_arg, action_arg);
    return nativeResponseValue;
}
function LightningError_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LightningError_clone_ptr(arg);
    return nativeResponseValue;
}
function LightningError_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LightningError_clone(orig);
    return nativeResponseValue;
}
function CommitmentUpdate_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentUpdate_free(this_obj);
// debug statements here
}
function CommitmentUpdate_get_update_add_htlcs(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentUpdate_get_update_add_htlcs(this_ptr);
    return nativeResponseValue;
}
function CommitmentUpdate_set_update_add_htlcs(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentUpdate_set_update_add_htlcs(this_ptr, val);
// debug statements here
}
function CommitmentUpdate_get_update_fulfill_htlcs(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentUpdate_get_update_fulfill_htlcs(this_ptr);
    return nativeResponseValue;
}
function CommitmentUpdate_set_update_fulfill_htlcs(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentUpdate_set_update_fulfill_htlcs(this_ptr, val);
// debug statements here
}
function CommitmentUpdate_get_update_fail_htlcs(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentUpdate_get_update_fail_htlcs(this_ptr);
    return nativeResponseValue;
}
function CommitmentUpdate_set_update_fail_htlcs(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentUpdate_set_update_fail_htlcs(this_ptr, val);
// debug statements here
}
function CommitmentUpdate_get_update_fail_malformed_htlcs(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentUpdate_get_update_fail_malformed_htlcs(this_ptr);
    return nativeResponseValue;
}
function CommitmentUpdate_set_update_fail_malformed_htlcs(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentUpdate_set_update_fail_malformed_htlcs(this_ptr, val);
// debug statements here
}
function CommitmentUpdate_get_update_fee(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentUpdate_get_update_fee(this_ptr);
    return nativeResponseValue;
}
function CommitmentUpdate_set_update_fee(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentUpdate_set_update_fee(this_ptr, val);
// debug statements here
}
function CommitmentUpdate_get_commitment_signed(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentUpdate_get_commitment_signed(this_ptr);
    return nativeResponseValue;
}
function CommitmentUpdate_set_commitment_signed(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentUpdate_set_commitment_signed(this_ptr, val);
// debug statements here
}
function CommitmentUpdate_new(update_add_htlcs_arg, update_fulfill_htlcs_arg, update_fail_htlcs_arg, update_fail_malformed_htlcs_arg, update_fee_arg, commitment_signed_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentUpdate_new(update_add_htlcs_arg, update_fulfill_htlcs_arg, update_fail_htlcs_arg, update_fail_malformed_htlcs_arg, update_fee_arg, commitment_signed_arg);
    return nativeResponseValue;
}
function CommitmentUpdate_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentUpdate_clone_ptr(arg);
    return nativeResponseValue;
}
function CommitmentUpdate_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentUpdate_clone(orig);
    return nativeResponseValue;
}
function ChannelMessageHandler_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelMessageHandler_free(this_ptr);
// debug statements here
}
function RoutingMessageHandler_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingMessageHandler_free(this_ptr);
// debug statements here
}
function AcceptChannel_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_write(obj);
    return nativeResponseValue;
}
function AcceptChannel_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AcceptChannel_read(ser);
    return nativeResponseValue;
}
function AnnouncementSignatures_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AnnouncementSignatures_write(obj);
    return nativeResponseValue;
}
function AnnouncementSignatures_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_AnnouncementSignatures_read(ser);
    return nativeResponseValue;
}
function ChannelReestablish_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelReestablish_write(obj);
    return nativeResponseValue;
}
function ChannelReestablish_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelReestablish_read(ser);
    return nativeResponseValue;
}
function ClosingSigned_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSigned_write(obj);
    return nativeResponseValue;
}
function ClosingSigned_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSigned_read(ser);
    return nativeResponseValue;
}
function ClosingSignedFeeRange_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_write(obj);
    return nativeResponseValue;
}
function ClosingSignedFeeRange_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_read(ser);
    return nativeResponseValue;
}
function CommitmentSigned_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentSigned_write(obj);
    return nativeResponseValue;
}
function CommitmentSigned_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentSigned_read(ser);
    return nativeResponseValue;
}
function FundingCreated_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingCreated_write(obj);
    return nativeResponseValue;
}
function FundingCreated_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingCreated_read(ser);
    return nativeResponseValue;
}
function FundingSigned_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingSigned_write(obj);
    return nativeResponseValue;
}
function FundingSigned_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingSigned_read(ser);
    return nativeResponseValue;
}
function FundingLocked_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingLocked_write(obj);
    return nativeResponseValue;
}
function FundingLocked_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_FundingLocked_read(ser);
    return nativeResponseValue;
}
function Init_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Init_write(obj);
    return nativeResponseValue;
}
function Init_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Init_read(ser);
    return nativeResponseValue;
}
function OpenChannel_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_write(obj);
    return nativeResponseValue;
}
function OpenChannel_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_OpenChannel_read(ser);
    return nativeResponseValue;
}
function RevokeAndACK_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RevokeAndACK_write(obj);
    return nativeResponseValue;
}
function RevokeAndACK_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RevokeAndACK_read(ser);
    return nativeResponseValue;
}
function Shutdown_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Shutdown_write(obj);
    return nativeResponseValue;
}
function Shutdown_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Shutdown_read(ser);
    return nativeResponseValue;
}
function UpdateFailHTLC_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailHTLC_write(obj);
    return nativeResponseValue;
}
function UpdateFailHTLC_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailHTLC_read(ser);
    return nativeResponseValue;
}
function UpdateFailMalformedHTLC_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_write(obj);
    return nativeResponseValue;
}
function UpdateFailMalformedHTLC_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_read(ser);
    return nativeResponseValue;
}
function UpdateFee_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFee_write(obj);
    return nativeResponseValue;
}
function UpdateFee_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFee_read(ser);
    return nativeResponseValue;
}
function UpdateFulfillHTLC_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_write(obj);
    return nativeResponseValue;
}
function UpdateFulfillHTLC_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_read(ser);
    return nativeResponseValue;
}
function UpdateAddHTLC_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateAddHTLC_write(obj);
    return nativeResponseValue;
}
function UpdateAddHTLC_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UpdateAddHTLC_read(ser);
    return nativeResponseValue;
}
function Ping_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Ping_write(obj);
    return nativeResponseValue;
}
function Ping_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Ping_read(ser);
    return nativeResponseValue;
}
function Pong_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Pong_write(obj);
    return nativeResponseValue;
}
function Pong_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Pong_read(ser);
    return nativeResponseValue;
}
function UnsignedChannelAnnouncement_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_write(obj);
    return nativeResponseValue;
}
function UnsignedChannelAnnouncement_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_read(ser);
    return nativeResponseValue;
}
function ChannelAnnouncement_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelAnnouncement_write(obj);
    return nativeResponseValue;
}
function ChannelAnnouncement_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelAnnouncement_read(ser);
    return nativeResponseValue;
}
function UnsignedChannelUpdate_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_write(obj);
    return nativeResponseValue;
}
function UnsignedChannelUpdate_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_read(ser);
    return nativeResponseValue;
}
function ChannelUpdate_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelUpdate_write(obj);
    return nativeResponseValue;
}
function ChannelUpdate_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelUpdate_read(ser);
    return nativeResponseValue;
}
function ErrorMessage_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorMessage_write(obj);
    return nativeResponseValue;
}
function ErrorMessage_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErrorMessage_read(ser);
    return nativeResponseValue;
}
function UnsignedNodeAnnouncement_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_write(obj);
    return nativeResponseValue;
}
function UnsignedNodeAnnouncement_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_read(ser);
    return nativeResponseValue;
}
function NodeAnnouncement_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncement_write(obj);
    return nativeResponseValue;
}
function NodeAnnouncement_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncement_read(ser);
    return nativeResponseValue;
}
function QueryShortChannelIds_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryShortChannelIds_read(ser);
    return nativeResponseValue;
}
function QueryShortChannelIds_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryShortChannelIds_write(obj);
    return nativeResponseValue;
}
function ReplyShortChannelIdsEnd_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_write(obj);
    return nativeResponseValue;
}
function ReplyShortChannelIdsEnd_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_read(ser);
    return nativeResponseValue;
}
function QueryChannelRange_end_blocknum(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryChannelRange_end_blocknum(this_arg);
    return nativeResponseValue;
}
function QueryChannelRange_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryChannelRange_write(obj);
    return nativeResponseValue;
}
function QueryChannelRange_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_QueryChannelRange_read(ser);
    return nativeResponseValue;
}
function ReplyChannelRange_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyChannelRange_read(ser);
    return nativeResponseValue;
}
function ReplyChannelRange_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReplyChannelRange_write(obj);
    return nativeResponseValue;
}
function GossipTimestampFilter_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_GossipTimestampFilter_write(obj);
    return nativeResponseValue;
}
function GossipTimestampFilter_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_GossipTimestampFilter_read(ser);
    return nativeResponseValue;
}
function CustomMessageHandler_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CustomMessageHandler_free(this_ptr);
// debug statements here
}
function IgnoringMessageHandler_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_IgnoringMessageHandler_free(this_obj);
// debug statements here
}
function IgnoringMessageHandler_new() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_IgnoringMessageHandler_new();
    return nativeResponseValue;
}
function IgnoringMessageHandler_as_MessageSendEventsProvider(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_IgnoringMessageHandler_as_MessageSendEventsProvider(this_arg);
    return nativeResponseValue;
}
function IgnoringMessageHandler_as_RoutingMessageHandler(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_IgnoringMessageHandler_as_RoutingMessageHandler(this_arg);
    return nativeResponseValue;
}
function IgnoringMessageHandler_as_CustomMessageReader(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_IgnoringMessageHandler_as_CustomMessageReader(this_arg);
    return nativeResponseValue;
}
function IgnoringMessageHandler_as_CustomMessageHandler(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_IgnoringMessageHandler_as_CustomMessageHandler(this_arg);
    return nativeResponseValue;
}
function ErroringMessageHandler_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErroringMessageHandler_free(this_obj);
// debug statements here
}
function ErroringMessageHandler_new() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErroringMessageHandler_new();
    return nativeResponseValue;
}
function ErroringMessageHandler_as_MessageSendEventsProvider(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErroringMessageHandler_as_MessageSendEventsProvider(this_arg);
    return nativeResponseValue;
}
function ErroringMessageHandler_as_ChannelMessageHandler(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ErroringMessageHandler_as_ChannelMessageHandler(this_arg);
    return nativeResponseValue;
}
function MessageHandler_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageHandler_free(this_obj);
// debug statements here
}
function MessageHandler_get_chan_handler(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageHandler_get_chan_handler(this_ptr);
    return nativeResponseValue;
}
function MessageHandler_set_chan_handler(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageHandler_set_chan_handler(this_ptr, val);
// debug statements here
}
function MessageHandler_get_route_handler(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageHandler_get_route_handler(this_ptr);
    return nativeResponseValue;
}
function MessageHandler_set_route_handler(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageHandler_set_route_handler(this_ptr, val);
// debug statements here
}
function MessageHandler_new(chan_handler_arg, route_handler_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MessageHandler_new(chan_handler_arg, route_handler_arg);
    return nativeResponseValue;
}
function SocketDescriptor_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_SocketDescriptor_clone_ptr(arg);
    return nativeResponseValue;
}
function SocketDescriptor_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_SocketDescriptor_clone(orig);
    return nativeResponseValue;
}
function SocketDescriptor_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_SocketDescriptor_free(this_ptr);
// debug statements here
}
function PeerHandleError_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerHandleError_free(this_obj);
// debug statements here
}
function PeerHandleError_get_no_connection_possible(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerHandleError_get_no_connection_possible(this_ptr);
    return nativeResponseValue;
}
function PeerHandleError_set_no_connection_possible(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerHandleError_set_no_connection_possible(this_ptr, val);
// debug statements here
}
function PeerHandleError_new(no_connection_possible_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerHandleError_new(no_connection_possible_arg);
    return nativeResponseValue;
}
function PeerHandleError_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerHandleError_clone_ptr(arg);
    return nativeResponseValue;
}
function PeerHandleError_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerHandleError_clone(orig);
    return nativeResponseValue;
}
function PeerManager_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerManager_free(this_obj);
// debug statements here
}
function PeerManager_new(message_handler, our_node_secret, ephemeral_random_data, logger, custom_message_handler) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerManager_new(message_handler, our_node_secret, ephemeral_random_data, logger, custom_message_handler);
    return nativeResponseValue;
}
function PeerManager_get_peer_node_ids(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerManager_get_peer_node_ids(this_arg);
    return nativeResponseValue;
}
function PeerManager_new_outbound_connection(this_arg, their_node_id, descriptor) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerManager_new_outbound_connection(this_arg, their_node_id, descriptor);
    return nativeResponseValue;
}
function PeerManager_new_inbound_connection(this_arg, descriptor) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerManager_new_inbound_connection(this_arg, descriptor);
    return nativeResponseValue;
}
function PeerManager_write_buffer_space_avail(this_arg, descriptor) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerManager_write_buffer_space_avail(this_arg, descriptor);
    return nativeResponseValue;
}
function PeerManager_read_event(this_arg, peer_descriptor, data) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerManager_read_event(this_arg, peer_descriptor, data);
    return nativeResponseValue;
}
function PeerManager_process_events(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerManager_process_events(this_arg);
// debug statements here
}
function PeerManager_socket_disconnected(this_arg, descriptor) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerManager_socket_disconnected(this_arg, descriptor);
// debug statements here
}
function PeerManager_disconnect_by_node_id(this_arg, node_id, no_connection_possible) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerManager_disconnect_by_node_id(this_arg, node_id, no_connection_possible);
// debug statements here
}
function PeerManager_disconnect_all_peers(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerManager_disconnect_all_peers(this_arg);
// debug statements here
}
function PeerManager_timer_tick_occurred(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_PeerManager_timer_tick_occurred(this_arg);
// debug statements here
}
function htlc_success_tx_weight(opt_anchors) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_htlc_success_tx_weight(opt_anchors);
    return nativeResponseValue;
}
function htlc_timeout_tx_weight(opt_anchors) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_htlc_timeout_tx_weight(opt_anchors);
    return nativeResponseValue;
}
function build_commitment_secret(commitment_seed, idx) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_build_commitment_secret(commitment_seed, idx);
    return nativeResponseValue;
}
function build_closing_transaction(to_holder_value_sat, to_counterparty_value_sat, to_holder_script, to_counterparty_script, funding_outpoint) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_build_closing_transaction(to_holder_value_sat, to_counterparty_value_sat, to_holder_script, to_counterparty_script, funding_outpoint);
    return nativeResponseValue;
}
function derive_private_key(per_commitment_point, base_secret) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_derive_private_key(per_commitment_point, base_secret);
    return nativeResponseValue;
}
function derive_public_key(per_commitment_point, base_point) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_derive_public_key(per_commitment_point, base_point);
    return nativeResponseValue;
}
function derive_private_revocation_key(per_commitment_secret, countersignatory_revocation_base_secret) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_derive_private_revocation_key(per_commitment_secret, countersignatory_revocation_base_secret);
    return nativeResponseValue;
}
function derive_public_revocation_key(per_commitment_point, countersignatory_revocation_base_point) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_derive_public_revocation_key(per_commitment_point, countersignatory_revocation_base_point);
    return nativeResponseValue;
}
function TxCreationKeys_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_free(this_obj);
// debug statements here
}
function TxCreationKeys_get_per_commitment_point(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_get_per_commitment_point(this_ptr);
    return nativeResponseValue;
}
function TxCreationKeys_set_per_commitment_point(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_set_per_commitment_point(this_ptr, val);
// debug statements here
}
function TxCreationKeys_get_revocation_key(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_get_revocation_key(this_ptr);
    return nativeResponseValue;
}
function TxCreationKeys_set_revocation_key(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_set_revocation_key(this_ptr, val);
// debug statements here
}
function TxCreationKeys_get_broadcaster_htlc_key(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_get_broadcaster_htlc_key(this_ptr);
    return nativeResponseValue;
}
function TxCreationKeys_set_broadcaster_htlc_key(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_set_broadcaster_htlc_key(this_ptr, val);
// debug statements here
}
function TxCreationKeys_get_countersignatory_htlc_key(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_get_countersignatory_htlc_key(this_ptr);
    return nativeResponseValue;
}
function TxCreationKeys_set_countersignatory_htlc_key(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_set_countersignatory_htlc_key(this_ptr, val);
// debug statements here
}
function TxCreationKeys_get_broadcaster_delayed_payment_key(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_get_broadcaster_delayed_payment_key(this_ptr);
    return nativeResponseValue;
}
function TxCreationKeys_set_broadcaster_delayed_payment_key(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_set_broadcaster_delayed_payment_key(this_ptr, val);
// debug statements here
}
function TxCreationKeys_new(per_commitment_point_arg, revocation_key_arg, broadcaster_htlc_key_arg, countersignatory_htlc_key_arg, broadcaster_delayed_payment_key_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_new(per_commitment_point_arg, revocation_key_arg, broadcaster_htlc_key_arg, countersignatory_htlc_key_arg, broadcaster_delayed_payment_key_arg);
    return nativeResponseValue;
}
function TxCreationKeys_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_clone_ptr(arg);
    return nativeResponseValue;
}
function TxCreationKeys_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_clone(orig);
    return nativeResponseValue;
}
function TxCreationKeys_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_write(obj);
    return nativeResponseValue;
}
function TxCreationKeys_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_read(ser);
    return nativeResponseValue;
}
function ChannelPublicKeys_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelPublicKeys_free(this_obj);
// debug statements here
}
function ChannelPublicKeys_get_funding_pubkey(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelPublicKeys_get_funding_pubkey(this_ptr);
    return nativeResponseValue;
}
function ChannelPublicKeys_set_funding_pubkey(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelPublicKeys_set_funding_pubkey(this_ptr, val);
// debug statements here
}
function ChannelPublicKeys_get_revocation_basepoint(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelPublicKeys_get_revocation_basepoint(this_ptr);
    return nativeResponseValue;
}
function ChannelPublicKeys_set_revocation_basepoint(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelPublicKeys_set_revocation_basepoint(this_ptr, val);
// debug statements here
}
function ChannelPublicKeys_get_payment_point(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelPublicKeys_get_payment_point(this_ptr);
    return nativeResponseValue;
}
function ChannelPublicKeys_set_payment_point(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelPublicKeys_set_payment_point(this_ptr, val);
// debug statements here
}
function ChannelPublicKeys_get_delayed_payment_basepoint(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelPublicKeys_get_delayed_payment_basepoint(this_ptr);
    return nativeResponseValue;
}
function ChannelPublicKeys_set_delayed_payment_basepoint(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelPublicKeys_set_delayed_payment_basepoint(this_ptr, val);
// debug statements here
}
function ChannelPublicKeys_get_htlc_basepoint(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelPublicKeys_get_htlc_basepoint(this_ptr);
    return nativeResponseValue;
}
function ChannelPublicKeys_set_htlc_basepoint(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelPublicKeys_set_htlc_basepoint(this_ptr, val);
// debug statements here
}
function ChannelPublicKeys_new(funding_pubkey_arg, revocation_basepoint_arg, payment_point_arg, delayed_payment_basepoint_arg, htlc_basepoint_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelPublicKeys_new(funding_pubkey_arg, revocation_basepoint_arg, payment_point_arg, delayed_payment_basepoint_arg, htlc_basepoint_arg);
    return nativeResponseValue;
}
function ChannelPublicKeys_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelPublicKeys_clone_ptr(arg);
    return nativeResponseValue;
}
function ChannelPublicKeys_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelPublicKeys_clone(orig);
    return nativeResponseValue;
}
function ChannelPublicKeys_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelPublicKeys_write(obj);
    return nativeResponseValue;
}
function ChannelPublicKeys_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelPublicKeys_read(ser);
    return nativeResponseValue;
}
function TxCreationKeys_derive_new(per_commitment_point, broadcaster_delayed_payment_base, broadcaster_htlc_base, countersignatory_revocation_base, countersignatory_htlc_base) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_derive_new(per_commitment_point, broadcaster_delayed_payment_base, broadcaster_htlc_base, countersignatory_revocation_base, countersignatory_htlc_base);
    return nativeResponseValue;
}
function TxCreationKeys_from_channel_static_keys(per_commitment_point, broadcaster_keys, countersignatory_keys) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TxCreationKeys_from_channel_static_keys(per_commitment_point, broadcaster_keys, countersignatory_keys);
    return nativeResponseValue;
}
function get_revokeable_redeemscript(revocation_key, contest_delay, broadcaster_delayed_payment_key) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_get_revokeable_redeemscript(revocation_key, contest_delay, broadcaster_delayed_payment_key);
    return nativeResponseValue;
}
function HTLCOutputInCommitment_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_free(this_obj);
// debug statements here
}
function HTLCOutputInCommitment_get_offered(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_get_offered(this_ptr);
    return nativeResponseValue;
}
function HTLCOutputInCommitment_set_offered(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_set_offered(this_ptr, val);
// debug statements here
}
function HTLCOutputInCommitment_get_amount_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_get_amount_msat(this_ptr);
    return nativeResponseValue;
}
function HTLCOutputInCommitment_set_amount_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_set_amount_msat(this_ptr, val);
// debug statements here
}
function HTLCOutputInCommitment_get_cltv_expiry(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_get_cltv_expiry(this_ptr);
    return nativeResponseValue;
}
function HTLCOutputInCommitment_set_cltv_expiry(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_set_cltv_expiry(this_ptr, val);
// debug statements here
}
function HTLCOutputInCommitment_get_payment_hash(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_get_payment_hash(this_ptr);
    return nativeResponseValue;
}
function HTLCOutputInCommitment_set_payment_hash(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_set_payment_hash(this_ptr, val);
// debug statements here
}
function HTLCOutputInCommitment_get_transaction_output_index(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_get_transaction_output_index(this_ptr);
    return nativeResponseValue;
}
function HTLCOutputInCommitment_set_transaction_output_index(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_set_transaction_output_index(this_ptr, val);
// debug statements here
}
function HTLCOutputInCommitment_new(offered_arg, amount_msat_arg, cltv_expiry_arg, payment_hash_arg, transaction_output_index_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_new(offered_arg, amount_msat_arg, cltv_expiry_arg, payment_hash_arg, transaction_output_index_arg);
    return nativeResponseValue;
}
function HTLCOutputInCommitment_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_clone_ptr(arg);
    return nativeResponseValue;
}
function HTLCOutputInCommitment_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_clone(orig);
    return nativeResponseValue;
}
function HTLCOutputInCommitment_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_write(obj);
    return nativeResponseValue;
}
function HTLCOutputInCommitment_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_read(ser);
    return nativeResponseValue;
}
function get_htlc_redeemscript(htlc, opt_anchors, keys) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_get_htlc_redeemscript(htlc, opt_anchors, keys);
    return nativeResponseValue;
}
function make_funding_redeemscript(broadcaster, countersignatory) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_make_funding_redeemscript(broadcaster, countersignatory);
    return nativeResponseValue;
}
function build_htlc_transaction(commitment_txid, feerate_per_kw, contest_delay, htlc, opt_anchors, broadcaster_delayed_payment_key, revocation_key) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_build_htlc_transaction(commitment_txid, feerate_per_kw, contest_delay, htlc, opt_anchors, broadcaster_delayed_payment_key, revocation_key);
    return nativeResponseValue;
}
function get_anchor_redeemscript(funding_pubkey) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_get_anchor_redeemscript(funding_pubkey);
    return nativeResponseValue;
}
function ChannelTransactionParameters_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_free(this_obj);
// debug statements here
}
function ChannelTransactionParameters_get_holder_pubkeys(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_holder_pubkeys(this_ptr);
    return nativeResponseValue;
}
function ChannelTransactionParameters_set_holder_pubkeys(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_holder_pubkeys(this_ptr, val);
// debug statements here
}
function ChannelTransactionParameters_get_holder_selected_contest_delay(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_holder_selected_contest_delay(this_ptr);
    return nativeResponseValue;
}
function ChannelTransactionParameters_set_holder_selected_contest_delay(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_holder_selected_contest_delay(this_ptr, val);
// debug statements here
}
function ChannelTransactionParameters_get_is_outbound_from_holder(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_is_outbound_from_holder(this_ptr);
    return nativeResponseValue;
}
function ChannelTransactionParameters_set_is_outbound_from_holder(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_is_outbound_from_holder(this_ptr, val);
// debug statements here
}
function ChannelTransactionParameters_get_counterparty_parameters(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_counterparty_parameters(this_ptr);
    return nativeResponseValue;
}
function ChannelTransactionParameters_set_counterparty_parameters(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_counterparty_parameters(this_ptr, val);
// debug statements here
}
function ChannelTransactionParameters_get_funding_outpoint(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_funding_outpoint(this_ptr);
    return nativeResponseValue;
}
function ChannelTransactionParameters_set_funding_outpoint(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_funding_outpoint(this_ptr, val);
// debug statements here
}
function ChannelTransactionParameters_get_opt_anchors(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_opt_anchors(this_ptr);
    return nativeResponseValue;
}
function ChannelTransactionParameters_set_opt_anchors(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_opt_anchors(this_ptr, val);
// debug statements here
}
function ChannelTransactionParameters_new(holder_pubkeys_arg, holder_selected_contest_delay_arg, is_outbound_from_holder_arg, counterparty_parameters_arg, funding_outpoint_arg, opt_anchors_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_new(holder_pubkeys_arg, holder_selected_contest_delay_arg, is_outbound_from_holder_arg, counterparty_parameters_arg, funding_outpoint_arg, opt_anchors_arg);
    return nativeResponseValue;
}
function ChannelTransactionParameters_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_clone_ptr(arg);
    return nativeResponseValue;
}
function ChannelTransactionParameters_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_clone(orig);
    return nativeResponseValue;
}
function CounterpartyChannelTransactionParameters_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_free(this_obj);
// debug statements here
}
function CounterpartyChannelTransactionParameters_get_pubkeys(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_get_pubkeys(this_ptr);
    return nativeResponseValue;
}
function CounterpartyChannelTransactionParameters_set_pubkeys(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_set_pubkeys(this_ptr, val);
// debug statements here
}
function CounterpartyChannelTransactionParameters_get_selected_contest_delay(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_get_selected_contest_delay(this_ptr);
    return nativeResponseValue;
}
function CounterpartyChannelTransactionParameters_set_selected_contest_delay(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_set_selected_contest_delay(this_ptr, val);
// debug statements here
}
function CounterpartyChannelTransactionParameters_new(pubkeys_arg, selected_contest_delay_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_new(pubkeys_arg, selected_contest_delay_arg);
    return nativeResponseValue;
}
function CounterpartyChannelTransactionParameters_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_clone_ptr(arg);
    return nativeResponseValue;
}
function CounterpartyChannelTransactionParameters_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_clone(orig);
    return nativeResponseValue;
}
function ChannelTransactionParameters_is_populated(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_is_populated(this_arg);
    return nativeResponseValue;
}
function ChannelTransactionParameters_as_holder_broadcastable(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_as_holder_broadcastable(this_arg);
    return nativeResponseValue;
}
function ChannelTransactionParameters_as_counterparty_broadcastable(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_as_counterparty_broadcastable(this_arg);
    return nativeResponseValue;
}
function CounterpartyChannelTransactionParameters_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_write(obj);
    return nativeResponseValue;
}
function CounterpartyChannelTransactionParameters_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_read(ser);
    return nativeResponseValue;
}
function ChannelTransactionParameters_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_write(obj);
    return nativeResponseValue;
}
function ChannelTransactionParameters_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTransactionParameters_read(ser);
    return nativeResponseValue;
}
function DirectedChannelTransactionParameters_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_free(this_obj);
// debug statements here
}
function DirectedChannelTransactionParameters_broadcaster_pubkeys(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_broadcaster_pubkeys(this_arg);
    return nativeResponseValue;
}
function DirectedChannelTransactionParameters_countersignatory_pubkeys(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_countersignatory_pubkeys(this_arg);
    return nativeResponseValue;
}
function DirectedChannelTransactionParameters_contest_delay(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_contest_delay(this_arg);
    return nativeResponseValue;
}
function DirectedChannelTransactionParameters_is_outbound(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_is_outbound(this_arg);
    return nativeResponseValue;
}
function DirectedChannelTransactionParameters_funding_outpoint(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_funding_outpoint(this_arg);
    return nativeResponseValue;
}
function DirectedChannelTransactionParameters_opt_anchors(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_opt_anchors(this_arg);
    return nativeResponseValue;
}
function HolderCommitmentTransaction_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_free(this_obj);
// debug statements here
}
function HolderCommitmentTransaction_get_counterparty_sig(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_get_counterparty_sig(this_ptr);
    return nativeResponseValue;
}
function HolderCommitmentTransaction_set_counterparty_sig(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_set_counterparty_sig(this_ptr, val);
// debug statements here
}
function HolderCommitmentTransaction_set_counterparty_htlc_sigs(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_set_counterparty_htlc_sigs(this_ptr, val);
// debug statements here
}
function HolderCommitmentTransaction_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_clone_ptr(arg);
    return nativeResponseValue;
}
function HolderCommitmentTransaction_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_clone(orig);
    return nativeResponseValue;
}
function HolderCommitmentTransaction_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_write(obj);
    return nativeResponseValue;
}
function HolderCommitmentTransaction_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_read(ser);
    return nativeResponseValue;
}
function HolderCommitmentTransaction_new(commitment_tx, counterparty_sig, counterparty_htlc_sigs, holder_funding_key, counterparty_funding_key) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_new(commitment_tx, counterparty_sig, counterparty_htlc_sigs, holder_funding_key, counterparty_funding_key);
    return nativeResponseValue;
}
function BuiltCommitmentTransaction_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_free(this_obj);
// debug statements here
}
function BuiltCommitmentTransaction_get_transaction(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_get_transaction(this_ptr);
    return nativeResponseValue;
}
function BuiltCommitmentTransaction_set_transaction(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_set_transaction(this_ptr, val);
// debug statements here
}
function BuiltCommitmentTransaction_get_txid(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_get_txid(this_ptr);
    return nativeResponseValue;
}
function BuiltCommitmentTransaction_set_txid(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_set_txid(this_ptr, val);
// debug statements here
}
function BuiltCommitmentTransaction_new(transaction_arg, txid_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_new(transaction_arg, txid_arg);
    return nativeResponseValue;
}
function BuiltCommitmentTransaction_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_clone_ptr(arg);
    return nativeResponseValue;
}
function BuiltCommitmentTransaction_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_clone(orig);
    return nativeResponseValue;
}
function BuiltCommitmentTransaction_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_write(obj);
    return nativeResponseValue;
}
function BuiltCommitmentTransaction_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_read(ser);
    return nativeResponseValue;
}
function BuiltCommitmentTransaction_get_sighash_all(this_arg, funding_redeemscript, channel_value_satoshis) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_get_sighash_all(this_arg, funding_redeemscript, channel_value_satoshis);
    return nativeResponseValue;
}
function BuiltCommitmentTransaction_sign(this_arg, funding_key, funding_redeemscript, channel_value_satoshis) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_sign(this_arg, funding_key, funding_redeemscript, channel_value_satoshis);
    return nativeResponseValue;
}
function ClosingTransaction_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingTransaction_free(this_obj);
// debug statements here
}
function ClosingTransaction_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingTransaction_clone_ptr(arg);
    return nativeResponseValue;
}
function ClosingTransaction_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingTransaction_clone(orig);
    return nativeResponseValue;
}
function ClosingTransaction_hash(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingTransaction_hash(o);
    return nativeResponseValue;
}
function ClosingTransaction_new(to_holder_value_sat, to_counterparty_value_sat, to_holder_script, to_counterparty_script, funding_outpoint) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingTransaction_new(to_holder_value_sat, to_counterparty_value_sat, to_holder_script, to_counterparty_script, funding_outpoint);
    return nativeResponseValue;
}
function ClosingTransaction_trust(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingTransaction_trust(this_arg);
    return nativeResponseValue;
}
function ClosingTransaction_verify(this_arg, funding_outpoint) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingTransaction_verify(this_arg, funding_outpoint);
    return nativeResponseValue;
}
function ClosingTransaction_to_holder_value_sat(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingTransaction_to_holder_value_sat(this_arg);
    return nativeResponseValue;
}
function ClosingTransaction_to_counterparty_value_sat(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingTransaction_to_counterparty_value_sat(this_arg);
    return nativeResponseValue;
}
function ClosingTransaction_to_holder_script(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingTransaction_to_holder_script(this_arg);
    return nativeResponseValue;
}
function ClosingTransaction_to_counterparty_script(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ClosingTransaction_to_counterparty_script(this_arg);
    return nativeResponseValue;
}
function TrustedClosingTransaction_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TrustedClosingTransaction_free(this_obj);
// debug statements here
}
function TrustedClosingTransaction_built_transaction(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TrustedClosingTransaction_built_transaction(this_arg);
    return nativeResponseValue;
}
function TrustedClosingTransaction_get_sighash_all(this_arg, funding_redeemscript, channel_value_satoshis) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TrustedClosingTransaction_get_sighash_all(this_arg, funding_redeemscript, channel_value_satoshis);
    return nativeResponseValue;
}
function TrustedClosingTransaction_sign(this_arg, funding_key, funding_redeemscript, channel_value_satoshis) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TrustedClosingTransaction_sign(this_arg, funding_key, funding_redeemscript, channel_value_satoshis);
    return nativeResponseValue;
}
function CommitmentTransaction_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentTransaction_free(this_obj);
// debug statements here
}
function CommitmentTransaction_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentTransaction_clone_ptr(arg);
    return nativeResponseValue;
}
function CommitmentTransaction_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentTransaction_clone(orig);
    return nativeResponseValue;
}
function CommitmentTransaction_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentTransaction_write(obj);
    return nativeResponseValue;
}
function CommitmentTransaction_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentTransaction_read(ser);
    return nativeResponseValue;
}
function CommitmentTransaction_commitment_number(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentTransaction_commitment_number(this_arg);
    return nativeResponseValue;
}
function CommitmentTransaction_to_broadcaster_value_sat(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentTransaction_to_broadcaster_value_sat(this_arg);
    return nativeResponseValue;
}
function CommitmentTransaction_to_countersignatory_value_sat(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentTransaction_to_countersignatory_value_sat(this_arg);
    return nativeResponseValue;
}
function CommitmentTransaction_feerate_per_kw(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentTransaction_feerate_per_kw(this_arg);
    return nativeResponseValue;
}
function CommitmentTransaction_trust(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentTransaction_trust(this_arg);
    return nativeResponseValue;
}
function CommitmentTransaction_verify(this_arg, channel_parameters, broadcaster_keys, countersignatory_keys) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CommitmentTransaction_verify(this_arg, channel_parameters, broadcaster_keys, countersignatory_keys);
    return nativeResponseValue;
}
function TrustedCommitmentTransaction_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_free(this_obj);
// debug statements here
}
function TrustedCommitmentTransaction_txid(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_txid(this_arg);
    return nativeResponseValue;
}
function TrustedCommitmentTransaction_built_transaction(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_built_transaction(this_arg);
    return nativeResponseValue;
}
function TrustedCommitmentTransaction_keys(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_keys(this_arg);
    return nativeResponseValue;
}
function TrustedCommitmentTransaction_opt_anchors(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_opt_anchors(this_arg);
    return nativeResponseValue;
}
function TrustedCommitmentTransaction_get_htlc_sigs(this_arg, htlc_base_key, channel_parameters) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_get_htlc_sigs(this_arg, htlc_base_key, channel_parameters);
    return nativeResponseValue;
}
function get_commitment_transaction_number_obscure_factor(broadcaster_payment_basepoint, countersignatory_payment_basepoint, outbound_from_broadcaster) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_get_commitment_transaction_number_obscure_factor(broadcaster_payment_basepoint, countersignatory_payment_basepoint, outbound_from_broadcaster);
    return nativeResponseValue;
}
function InitFeatures_eq(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InitFeatures_eq(a, b);
    return nativeResponseValue;
}
function NodeFeatures_eq(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeFeatures_eq(a, b);
    return nativeResponseValue;
}
function ChannelFeatures_eq(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelFeatures_eq(a, b);
    return nativeResponseValue;
}
function InvoiceFeatures_eq(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InvoiceFeatures_eq(a, b);
    return nativeResponseValue;
}
function ChannelTypeFeatures_eq(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTypeFeatures_eq(a, b);
    return nativeResponseValue;
}
function InitFeatures_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InitFeatures_clone_ptr(arg);
    return nativeResponseValue;
}
function InitFeatures_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InitFeatures_clone(orig);
    return nativeResponseValue;
}
function NodeFeatures_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeFeatures_clone_ptr(arg);
    return nativeResponseValue;
}
function NodeFeatures_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeFeatures_clone(orig);
    return nativeResponseValue;
}
function ChannelFeatures_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelFeatures_clone_ptr(arg);
    return nativeResponseValue;
}
function ChannelFeatures_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelFeatures_clone(orig);
    return nativeResponseValue;
}
function InvoiceFeatures_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InvoiceFeatures_clone_ptr(arg);
    return nativeResponseValue;
}
function InvoiceFeatures_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InvoiceFeatures_clone(orig);
    return nativeResponseValue;
}
function ChannelTypeFeatures_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTypeFeatures_clone_ptr(arg);
    return nativeResponseValue;
}
function ChannelTypeFeatures_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTypeFeatures_clone(orig);
    return nativeResponseValue;
}
function InitFeatures_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InitFeatures_free(this_obj);
// debug statements here
}
function NodeFeatures_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeFeatures_free(this_obj);
// debug statements here
}
function ChannelFeatures_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelFeatures_free(this_obj);
// debug statements here
}
function InvoiceFeatures_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InvoiceFeatures_free(this_obj);
// debug statements here
}
function ChannelTypeFeatures_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTypeFeatures_free(this_obj);
// debug statements here
}
function InitFeatures_empty() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InitFeatures_empty();
    return nativeResponseValue;
}
function InitFeatures_known() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InitFeatures_known();
    return nativeResponseValue;
}
function InitFeatures_requires_unknown_bits(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InitFeatures_requires_unknown_bits(this_arg);
    return nativeResponseValue;
}
function NodeFeatures_empty() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeFeatures_empty();
    return nativeResponseValue;
}
function NodeFeatures_known() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeFeatures_known();
    return nativeResponseValue;
}
function NodeFeatures_requires_unknown_bits(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeFeatures_requires_unknown_bits(this_arg);
    return nativeResponseValue;
}
function ChannelFeatures_empty() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelFeatures_empty();
    return nativeResponseValue;
}
function ChannelFeatures_known() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelFeatures_known();
    return nativeResponseValue;
}
function ChannelFeatures_requires_unknown_bits(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelFeatures_requires_unknown_bits(this_arg);
    return nativeResponseValue;
}
function InvoiceFeatures_empty() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InvoiceFeatures_empty();
    return nativeResponseValue;
}
function InvoiceFeatures_known() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InvoiceFeatures_known();
    return nativeResponseValue;
}
function InvoiceFeatures_requires_unknown_bits(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InvoiceFeatures_requires_unknown_bits(this_arg);
    return nativeResponseValue;
}
function ChannelTypeFeatures_empty() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTypeFeatures_empty();
    return nativeResponseValue;
}
function ChannelTypeFeatures_known() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTypeFeatures_known();
    return nativeResponseValue;
}
function ChannelTypeFeatures_requires_unknown_bits(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTypeFeatures_requires_unknown_bits(this_arg);
    return nativeResponseValue;
}
function InitFeatures_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InitFeatures_write(obj);
    return nativeResponseValue;
}
function InitFeatures_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InitFeatures_read(ser);
    return nativeResponseValue;
}
function ChannelFeatures_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelFeatures_write(obj);
    return nativeResponseValue;
}
function ChannelFeatures_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelFeatures_read(ser);
    return nativeResponseValue;
}
function NodeFeatures_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeFeatures_write(obj);
    return nativeResponseValue;
}
function NodeFeatures_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeFeatures_read(ser);
    return nativeResponseValue;
}
function InvoiceFeatures_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InvoiceFeatures_write(obj);
    return nativeResponseValue;
}
function InvoiceFeatures_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InvoiceFeatures_read(ser);
    return nativeResponseValue;
}
function ChannelTypeFeatures_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTypeFeatures_write(obj);
    return nativeResponseValue;
}
function ChannelTypeFeatures_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelTypeFeatures_read(ser);
    return nativeResponseValue;
}
function ShutdownScript_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ShutdownScript_free(this_obj);
// debug statements here
}
function ShutdownScript_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ShutdownScript_clone_ptr(arg);
    return nativeResponseValue;
}
function ShutdownScript_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ShutdownScript_clone(orig);
    return nativeResponseValue;
}
function InvalidShutdownScript_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InvalidShutdownScript_free(this_obj);
// debug statements here
}
function InvalidShutdownScript_get_script(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InvalidShutdownScript_get_script(this_ptr);
    return nativeResponseValue;
}
function InvalidShutdownScript_set_script(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InvalidShutdownScript_set_script(this_ptr, val);
// debug statements here
}
function InvalidShutdownScript_new(script_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InvalidShutdownScript_new(script_arg);
    return nativeResponseValue;
}
function InvalidShutdownScript_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InvalidShutdownScript_clone_ptr(arg);
    return nativeResponseValue;
}
function InvalidShutdownScript_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_InvalidShutdownScript_clone(orig);
    return nativeResponseValue;
}
function ShutdownScript_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ShutdownScript_write(obj);
    return nativeResponseValue;
}
function ShutdownScript_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ShutdownScript_read(ser);
    return nativeResponseValue;
}
function ShutdownScript_new_p2wpkh(pubkey_hash) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ShutdownScript_new_p2wpkh(pubkey_hash);
    return nativeResponseValue;
}
function ShutdownScript_new_p2wsh(script_hash) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ShutdownScript_new_p2wsh(script_hash);
    return nativeResponseValue;
}
function ShutdownScript_new_witness_program(version, program) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ShutdownScript_new_witness_program(version, program);
    return nativeResponseValue;
}
function ShutdownScript_into_inner(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ShutdownScript_into_inner(this_arg);
    return nativeResponseValue;
}
function ShutdownScript_as_legacy_pubkey(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ShutdownScript_as_legacy_pubkey(this_arg);
    return nativeResponseValue;
}
function ShutdownScript_is_compatible(this_arg, features) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ShutdownScript_is_compatible(this_arg, features);
    return nativeResponseValue;
}
function CustomMessageReader_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_CustomMessageReader_free(this_ptr);
// debug statements here
}
function Type_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Type_clone_ptr(arg);
    return nativeResponseValue;
}
function Type_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Type_clone(orig);
    return nativeResponseValue;
}
function Type_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Type_free(this_ptr);
// debug statements here
}
function NodeId_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeId_free(this_obj);
// debug statements here
}
function NodeId_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeId_clone_ptr(arg);
    return nativeResponseValue;
}
function NodeId_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeId_clone(orig);
    return nativeResponseValue;
}
function NodeId_from_pubkey(pubkey) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeId_from_pubkey(pubkey);
    return nativeResponseValue;
}
function NodeId_as_slice(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeId_as_slice(this_arg);
    return nativeResponseValue;
}
function NodeId_hash(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeId_hash(o);
    return nativeResponseValue;
}
function NodeId_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeId_write(obj);
    return nativeResponseValue;
}
function NodeId_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeId_read(ser);
    return nativeResponseValue;
}
function NetworkGraph_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkGraph_free(this_obj);
// debug statements here
}
function NetworkGraph_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkGraph_clone_ptr(arg);
    return nativeResponseValue;
}
function NetworkGraph_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkGraph_clone(orig);
    return nativeResponseValue;
}
function ReadOnlyNetworkGraph_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReadOnlyNetworkGraph_free(this_obj);
// debug statements here
}
function NetworkUpdate_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkUpdate_free(this_ptr);
// debug statements here
}
function NetworkUpdate_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkUpdate_clone_ptr(arg);
    return nativeResponseValue;
}
function NetworkUpdate_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkUpdate_clone(orig);
    return nativeResponseValue;
}
function NetworkUpdate_channel_update_message(msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkUpdate_channel_update_message(msg);
    return nativeResponseValue;
}
function NetworkUpdate_channel_closed(short_channel_id, is_permanent) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkUpdate_channel_closed(short_channel_id, is_permanent);
    return nativeResponseValue;
}
function NetworkUpdate_node_failure(node_id, is_permanent) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkUpdate_node_failure(node_id, is_permanent);
    return nativeResponseValue;
}
function NetworkUpdate_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkUpdate_write(obj);
    return nativeResponseValue;
}
function NetworkUpdate_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkUpdate_read(ser);
    return nativeResponseValue;
}
function NetGraphMsgHandler_as_EventHandler(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetGraphMsgHandler_as_EventHandler(this_arg);
    return nativeResponseValue;
}
function NetGraphMsgHandler_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetGraphMsgHandler_free(this_obj);
// debug statements here
}
function NetGraphMsgHandler_new(network_graph, chain_access, logger) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetGraphMsgHandler_new(network_graph, chain_access, logger);
    return nativeResponseValue;
}
function NetGraphMsgHandler_add_chain_access(this_arg, chain_access) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetGraphMsgHandler_add_chain_access(this_arg, chain_access);
// debug statements here
}
function NetGraphMsgHandler_as_RoutingMessageHandler(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetGraphMsgHandler_as_RoutingMessageHandler(this_arg);
    return nativeResponseValue;
}
function NetGraphMsgHandler_as_MessageSendEventsProvider(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetGraphMsgHandler_as_MessageSendEventsProvider(this_arg);
    return nativeResponseValue;
}
function DirectionalChannelInfo_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_free(this_obj);
// debug statements here
}
function DirectionalChannelInfo_get_last_update(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_get_last_update(this_ptr);
    return nativeResponseValue;
}
function DirectionalChannelInfo_set_last_update(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_set_last_update(this_ptr, val);
// debug statements here
}
function DirectionalChannelInfo_get_enabled(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_get_enabled(this_ptr);
    return nativeResponseValue;
}
function DirectionalChannelInfo_set_enabled(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_set_enabled(this_ptr, val);
// debug statements here
}
function DirectionalChannelInfo_get_cltv_expiry_delta(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_get_cltv_expiry_delta(this_ptr);
    return nativeResponseValue;
}
function DirectionalChannelInfo_set_cltv_expiry_delta(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_set_cltv_expiry_delta(this_ptr, val);
// debug statements here
}
function DirectionalChannelInfo_get_htlc_minimum_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_get_htlc_minimum_msat(this_ptr);
    return nativeResponseValue;
}
function DirectionalChannelInfo_set_htlc_minimum_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_set_htlc_minimum_msat(this_ptr, val);
// debug statements here
}
function DirectionalChannelInfo_get_htlc_maximum_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_get_htlc_maximum_msat(this_ptr);
    return nativeResponseValue;
}
function DirectionalChannelInfo_set_htlc_maximum_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_set_htlc_maximum_msat(this_ptr, val);
// debug statements here
}
function DirectionalChannelInfo_get_fees(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_get_fees(this_ptr);
    return nativeResponseValue;
}
function DirectionalChannelInfo_set_fees(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_set_fees(this_ptr, val);
// debug statements here
}
function DirectionalChannelInfo_get_last_update_message(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_get_last_update_message(this_ptr);
    return nativeResponseValue;
}
function DirectionalChannelInfo_set_last_update_message(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_set_last_update_message(this_ptr, val);
// debug statements here
}
function DirectionalChannelInfo_new(last_update_arg, enabled_arg, cltv_expiry_delta_arg, htlc_minimum_msat_arg, htlc_maximum_msat_arg, fees_arg, last_update_message_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_new(last_update_arg, enabled_arg, cltv_expiry_delta_arg, htlc_minimum_msat_arg, htlc_maximum_msat_arg, fees_arg, last_update_message_arg);
    return nativeResponseValue;
}
function DirectionalChannelInfo_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_clone_ptr(arg);
    return nativeResponseValue;
}
function DirectionalChannelInfo_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_clone(orig);
    return nativeResponseValue;
}
function DirectionalChannelInfo_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_write(obj);
    return nativeResponseValue;
}
function DirectionalChannelInfo_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_DirectionalChannelInfo_read(ser);
    return nativeResponseValue;
}
function ChannelInfo_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_free(this_obj);
// debug statements here
}
function ChannelInfo_get_features(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_get_features(this_ptr);
    return nativeResponseValue;
}
function ChannelInfo_set_features(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_set_features(this_ptr, val);
// debug statements here
}
function ChannelInfo_get_node_one(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_get_node_one(this_ptr);
    return nativeResponseValue;
}
function ChannelInfo_set_node_one(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_set_node_one(this_ptr, val);
// debug statements here
}
function ChannelInfo_get_one_to_two(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_get_one_to_two(this_ptr);
    return nativeResponseValue;
}
function ChannelInfo_set_one_to_two(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_set_one_to_two(this_ptr, val);
// debug statements here
}
function ChannelInfo_get_node_two(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_get_node_two(this_ptr);
    return nativeResponseValue;
}
function ChannelInfo_set_node_two(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_set_node_two(this_ptr, val);
// debug statements here
}
function ChannelInfo_get_two_to_one(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_get_two_to_one(this_ptr);
    return nativeResponseValue;
}
function ChannelInfo_set_two_to_one(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_set_two_to_one(this_ptr, val);
// debug statements here
}
function ChannelInfo_get_capacity_sats(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_get_capacity_sats(this_ptr);
    return nativeResponseValue;
}
function ChannelInfo_set_capacity_sats(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_set_capacity_sats(this_ptr, val);
// debug statements here
}
function ChannelInfo_get_announcement_message(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_get_announcement_message(this_ptr);
    return nativeResponseValue;
}
function ChannelInfo_set_announcement_message(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_set_announcement_message(this_ptr, val);
// debug statements here
}
function ChannelInfo_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_clone_ptr(arg);
    return nativeResponseValue;
}
function ChannelInfo_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_clone(orig);
    return nativeResponseValue;
}
function ChannelInfo_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_write(obj);
    return nativeResponseValue;
}
function ChannelInfo_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ChannelInfo_read(ser);
    return nativeResponseValue;
}
function RoutingFees_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingFees_free(this_obj);
// debug statements here
}
function RoutingFees_get_base_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingFees_get_base_msat(this_ptr);
    return nativeResponseValue;
}
function RoutingFees_set_base_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingFees_set_base_msat(this_ptr, val);
// debug statements here
}
function RoutingFees_get_proportional_millionths(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingFees_get_proportional_millionths(this_ptr);
    return nativeResponseValue;
}
function RoutingFees_set_proportional_millionths(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingFees_set_proportional_millionths(this_ptr, val);
// debug statements here
}
function RoutingFees_new(base_msat_arg, proportional_millionths_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingFees_new(base_msat_arg, proportional_millionths_arg);
    return nativeResponseValue;
}
function RoutingFees_eq(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingFees_eq(a, b);
    return nativeResponseValue;
}
function RoutingFees_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingFees_clone_ptr(arg);
    return nativeResponseValue;
}
function RoutingFees_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingFees_clone(orig);
    return nativeResponseValue;
}
function RoutingFees_hash(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingFees_hash(o);
    return nativeResponseValue;
}
function RoutingFees_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingFees_write(obj);
    return nativeResponseValue;
}
function RoutingFees_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RoutingFees_read(ser);
    return nativeResponseValue;
}
function NodeAnnouncementInfo_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_free(this_obj);
// debug statements here
}
function NodeAnnouncementInfo_get_features(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_get_features(this_ptr);
    return nativeResponseValue;
}
function NodeAnnouncementInfo_set_features(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_features(this_ptr, val);
// debug statements here
}
function NodeAnnouncementInfo_get_last_update(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_get_last_update(this_ptr);
    return nativeResponseValue;
}
function NodeAnnouncementInfo_set_last_update(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_last_update(this_ptr, val);
// debug statements here
}
function NodeAnnouncementInfo_get_rgb(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_get_rgb(this_ptr);
    return nativeResponseValue;
}
function NodeAnnouncementInfo_set_rgb(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_rgb(this_ptr, val);
// debug statements here
}
function NodeAnnouncementInfo_get_alias(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_get_alias(this_ptr);
    return nativeResponseValue;
}
function NodeAnnouncementInfo_set_alias(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_alias(this_ptr, val);
// debug statements here
}
function NodeAnnouncementInfo_set_addresses(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_addresses(this_ptr, val);
// debug statements here
}
function NodeAnnouncementInfo_get_announcement_message(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_get_announcement_message(this_ptr);
    return nativeResponseValue;
}
function NodeAnnouncementInfo_set_announcement_message(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_announcement_message(this_ptr, val);
// debug statements here
}
function NodeAnnouncementInfo_new(features_arg, last_update_arg, rgb_arg, alias_arg, addresses_arg, announcement_message_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_new(features_arg, last_update_arg, rgb_arg, alias_arg, addresses_arg, announcement_message_arg);
    return nativeResponseValue;
}
function NodeAnnouncementInfo_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_clone_ptr(arg);
    return nativeResponseValue;
}
function NodeAnnouncementInfo_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_clone(orig);
    return nativeResponseValue;
}
function NodeAnnouncementInfo_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_write(obj);
    return nativeResponseValue;
}
function NodeAnnouncementInfo_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_read(ser);
    return nativeResponseValue;
}
function NodeInfo_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeInfo_free(this_obj);
// debug statements here
}
function NodeInfo_set_channels(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeInfo_set_channels(this_ptr, val);
// debug statements here
}
function NodeInfo_get_lowest_inbound_channel_fees(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeInfo_get_lowest_inbound_channel_fees(this_ptr);
    return nativeResponseValue;
}
function NodeInfo_set_lowest_inbound_channel_fees(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeInfo_set_lowest_inbound_channel_fees(this_ptr, val);
// debug statements here
}
function NodeInfo_get_announcement_info(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeInfo_get_announcement_info(this_ptr);
    return nativeResponseValue;
}
function NodeInfo_set_announcement_info(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeInfo_set_announcement_info(this_ptr, val);
// debug statements here
}
function NodeInfo_new(channels_arg, lowest_inbound_channel_fees_arg, announcement_info_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeInfo_new(channels_arg, lowest_inbound_channel_fees_arg, announcement_info_arg);
    return nativeResponseValue;
}
function NodeInfo_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeInfo_clone_ptr(arg);
    return nativeResponseValue;
}
function NodeInfo_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeInfo_clone(orig);
    return nativeResponseValue;
}
function NodeInfo_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeInfo_write(obj);
    return nativeResponseValue;
}
function NodeInfo_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NodeInfo_read(ser);
    return nativeResponseValue;
}
function NetworkGraph_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkGraph_write(obj);
    return nativeResponseValue;
}
function NetworkGraph_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkGraph_read(ser);
    return nativeResponseValue;
}
function NetworkGraph_new(genesis_hash) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkGraph_new(genesis_hash);
    return nativeResponseValue;
}
function NetworkGraph_read_only(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkGraph_read_only(this_arg);
    return nativeResponseValue;
}
function NetworkGraph_update_node_from_announcement(this_arg, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkGraph_update_node_from_announcement(this_arg, msg);
    return nativeResponseValue;
}
function NetworkGraph_update_node_from_unsigned_announcement(this_arg, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkGraph_update_node_from_unsigned_announcement(this_arg, msg);
    return nativeResponseValue;
}
function NetworkGraph_update_channel_from_announcement(this_arg, msg, chain_access) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkGraph_update_channel_from_announcement(this_arg, msg, chain_access);
    return nativeResponseValue;
}
function NetworkGraph_update_channel_from_unsigned_announcement(this_arg, msg, chain_access) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkGraph_update_channel_from_unsigned_announcement(this_arg, msg, chain_access);
    return nativeResponseValue;
}
function NetworkGraph_close_channel_from_update(this_arg, short_channel_id, is_permanent) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkGraph_close_channel_from_update(this_arg, short_channel_id, is_permanent);
// debug statements here
}
function NetworkGraph_fail_node(this_arg, _node_id, is_permanent) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkGraph_fail_node(this_arg, _node_id, is_permanent);
// debug statements here
}
function NetworkGraph_remove_stale_channels_with_time(this_arg, current_time_unix) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkGraph_remove_stale_channels_with_time(this_arg, current_time_unix);
// debug statements here
}
function NetworkGraph_update_channel(this_arg, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkGraph_update_channel(this_arg, msg);
    return nativeResponseValue;
}
function NetworkGraph_update_channel_unsigned(this_arg, msg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_NetworkGraph_update_channel_unsigned(this_arg, msg);
    return nativeResponseValue;
}
function ReadOnlyNetworkGraph_get_addresses(this_arg, pubkey) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ReadOnlyNetworkGraph_get_addresses(this_arg, pubkey);
    return nativeResponseValue;
}
function RouteHop_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_free(this_obj);
// debug statements here
}
function RouteHop_get_pubkey(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_get_pubkey(this_ptr);
    return nativeResponseValue;
}
function RouteHop_set_pubkey(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_set_pubkey(this_ptr, val);
// debug statements here
}
function RouteHop_get_node_features(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_get_node_features(this_ptr);
    return nativeResponseValue;
}
function RouteHop_set_node_features(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_set_node_features(this_ptr, val);
// debug statements here
}
function RouteHop_get_short_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_get_short_channel_id(this_ptr);
    return nativeResponseValue;
}
function RouteHop_set_short_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_set_short_channel_id(this_ptr, val);
// debug statements here
}
function RouteHop_get_channel_features(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_get_channel_features(this_ptr);
    return nativeResponseValue;
}
function RouteHop_set_channel_features(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_set_channel_features(this_ptr, val);
// debug statements here
}
function RouteHop_get_fee_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_get_fee_msat(this_ptr);
    return nativeResponseValue;
}
function RouteHop_set_fee_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_set_fee_msat(this_ptr, val);
// debug statements here
}
function RouteHop_get_cltv_expiry_delta(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_get_cltv_expiry_delta(this_ptr);
    return nativeResponseValue;
}
function RouteHop_set_cltv_expiry_delta(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_set_cltv_expiry_delta(this_ptr, val);
// debug statements here
}
function RouteHop_new(pubkey_arg, node_features_arg, short_channel_id_arg, channel_features_arg, fee_msat_arg, cltv_expiry_delta_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_new(pubkey_arg, node_features_arg, short_channel_id_arg, channel_features_arg, fee_msat_arg, cltv_expiry_delta_arg);
    return nativeResponseValue;
}
function RouteHop_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_clone_ptr(arg);
    return nativeResponseValue;
}
function RouteHop_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_clone(orig);
    return nativeResponseValue;
}
function RouteHop_hash(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_hash(o);
    return nativeResponseValue;
}
function RouteHop_eq(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_eq(a, b);
    return nativeResponseValue;
}
function RouteHop_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_write(obj);
    return nativeResponseValue;
}
function RouteHop_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHop_read(ser);
    return nativeResponseValue;
}
function Route_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Route_free(this_obj);
// debug statements here
}
function Route_get_paths(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Route_get_paths(this_ptr);
    return nativeResponseValue;
}
function Route_set_paths(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Route_set_paths(this_ptr, val);
// debug statements here
}
function Route_get_payee(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Route_get_payee(this_ptr);
    return nativeResponseValue;
}
function Route_set_payee(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Route_set_payee(this_ptr, val);
// debug statements here
}
function Route_new(paths_arg, payee_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Route_new(paths_arg, payee_arg);
    return nativeResponseValue;
}
function Route_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Route_clone_ptr(arg);
    return nativeResponseValue;
}
function Route_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Route_clone(orig);
    return nativeResponseValue;
}
function Route_hash(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Route_hash(o);
    return nativeResponseValue;
}
function Route_eq(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Route_eq(a, b);
    return nativeResponseValue;
}
function Route_get_total_fees(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Route_get_total_fees(this_arg);
    return nativeResponseValue;
}
function Route_get_total_amount(this_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Route_get_total_amount(this_arg);
    return nativeResponseValue;
}
function Route_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Route_write(obj);
    return nativeResponseValue;
}
function Route_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Route_read(ser);
    return nativeResponseValue;
}
function RouteParameters_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteParameters_free(this_obj);
// debug statements here
}
function RouteParameters_get_payee(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteParameters_get_payee(this_ptr);
    return nativeResponseValue;
}
function RouteParameters_set_payee(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteParameters_set_payee(this_ptr, val);
// debug statements here
}
function RouteParameters_get_final_value_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteParameters_get_final_value_msat(this_ptr);
    return nativeResponseValue;
}
function RouteParameters_set_final_value_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteParameters_set_final_value_msat(this_ptr, val);
// debug statements here
}
function RouteParameters_get_final_cltv_expiry_delta(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteParameters_get_final_cltv_expiry_delta(this_ptr);
    return nativeResponseValue;
}
function RouteParameters_set_final_cltv_expiry_delta(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteParameters_set_final_cltv_expiry_delta(this_ptr, val);
// debug statements here
}
function RouteParameters_new(payee_arg, final_value_msat_arg, final_cltv_expiry_delta_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteParameters_new(payee_arg, final_value_msat_arg, final_cltv_expiry_delta_arg);
    return nativeResponseValue;
}
function RouteParameters_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteParameters_clone_ptr(arg);
    return nativeResponseValue;
}
function RouteParameters_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteParameters_clone(orig);
    return nativeResponseValue;
}
function RouteParameters_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteParameters_write(obj);
    return nativeResponseValue;
}
function RouteParameters_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteParameters_read(ser);
    return nativeResponseValue;
}
function Payee_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_free(this_obj);
// debug statements here
}
function Payee_get_pubkey(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_get_pubkey(this_ptr);
    return nativeResponseValue;
}
function Payee_set_pubkey(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_set_pubkey(this_ptr, val);
// debug statements here
}
function Payee_get_features(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_get_features(this_ptr);
    return nativeResponseValue;
}
function Payee_set_features(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_set_features(this_ptr, val);
// debug statements here
}
function Payee_get_route_hints(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_get_route_hints(this_ptr);
    return nativeResponseValue;
}
function Payee_set_route_hints(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_set_route_hints(this_ptr, val);
// debug statements here
}
function Payee_get_expiry_time(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_get_expiry_time(this_ptr);
    return nativeResponseValue;
}
function Payee_set_expiry_time(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_set_expiry_time(this_ptr, val);
// debug statements here
}
function Payee_new(pubkey_arg, features_arg, route_hints_arg, expiry_time_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_new(pubkey_arg, features_arg, route_hints_arg, expiry_time_arg);
    return nativeResponseValue;
}
function Payee_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_clone_ptr(arg);
    return nativeResponseValue;
}
function Payee_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_clone(orig);
    return nativeResponseValue;
}
function Payee_hash(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_hash(o);
    return nativeResponseValue;
}
function Payee_eq(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_eq(a, b);
    return nativeResponseValue;
}
function Payee_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_write(obj);
    return nativeResponseValue;
}
function Payee_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_read(ser);
    return nativeResponseValue;
}
function Payee_from_node_id(pubkey) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_from_node_id(pubkey);
    return nativeResponseValue;
}
function Payee_for_keysend(pubkey) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Payee_for_keysend(pubkey);
    return nativeResponseValue;
}
function RouteHint_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHint_free(this_obj);
// debug statements here
}
function RouteHint_get_a(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHint_get_a(this_ptr);
    return nativeResponseValue;
}
function RouteHint_set_a(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHint_set_a(this_ptr, val);
// debug statements here
}
function RouteHint_new(a_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHint_new(a_arg);
    return nativeResponseValue;
}
function RouteHint_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHint_clone_ptr(arg);
    return nativeResponseValue;
}
function RouteHint_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHint_clone(orig);
    return nativeResponseValue;
}
function RouteHint_hash(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHint_hash(o);
    return nativeResponseValue;
}
function RouteHint_eq(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHint_eq(a, b);
    return nativeResponseValue;
}
function RouteHint_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHint_write(obj);
    return nativeResponseValue;
}
function RouteHint_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHint_read(ser);
    return nativeResponseValue;
}
function RouteHintHop_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_free(this_obj);
// debug statements here
}
function RouteHintHop_get_src_node_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_get_src_node_id(this_ptr);
    return nativeResponseValue;
}
function RouteHintHop_set_src_node_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_set_src_node_id(this_ptr, val);
// debug statements here
}
function RouteHintHop_get_short_channel_id(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_get_short_channel_id(this_ptr);
    return nativeResponseValue;
}
function RouteHintHop_set_short_channel_id(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_set_short_channel_id(this_ptr, val);
// debug statements here
}
function RouteHintHop_get_fees(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_get_fees(this_ptr);
    return nativeResponseValue;
}
function RouteHintHop_set_fees(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_set_fees(this_ptr, val);
// debug statements here
}
function RouteHintHop_get_cltv_expiry_delta(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_get_cltv_expiry_delta(this_ptr);
    return nativeResponseValue;
}
function RouteHintHop_set_cltv_expiry_delta(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_set_cltv_expiry_delta(this_ptr, val);
// debug statements here
}
function RouteHintHop_get_htlc_minimum_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_get_htlc_minimum_msat(this_ptr);
    return nativeResponseValue;
}
function RouteHintHop_set_htlc_minimum_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_set_htlc_minimum_msat(this_ptr, val);
// debug statements here
}
function RouteHintHop_get_htlc_maximum_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_get_htlc_maximum_msat(this_ptr);
    return nativeResponseValue;
}
function RouteHintHop_set_htlc_maximum_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_set_htlc_maximum_msat(this_ptr, val);
// debug statements here
}
function RouteHintHop_new(src_node_id_arg, short_channel_id_arg, fees_arg, cltv_expiry_delta_arg, htlc_minimum_msat_arg, htlc_maximum_msat_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_new(src_node_id_arg, short_channel_id_arg, fees_arg, cltv_expiry_delta_arg, htlc_minimum_msat_arg, htlc_maximum_msat_arg);
    return nativeResponseValue;
}
function RouteHintHop_clone_ptr(arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_clone_ptr(arg);
    return nativeResponseValue;
}
function RouteHintHop_clone(orig) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_clone(orig);
    return nativeResponseValue;
}
function RouteHintHop_hash(o) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_hash(o);
    return nativeResponseValue;
}
function RouteHintHop_eq(a, b) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_eq(a, b);
    return nativeResponseValue;
}
function RouteHintHop_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_write(obj);
    return nativeResponseValue;
}
function RouteHintHop_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_RouteHintHop_read(ser);
    return nativeResponseValue;
}
function find_route(our_node_pubkey, params, network, first_hops, logger, scorer) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_find_route(our_node_pubkey, params, network, first_hops, logger, scorer);
    return nativeResponseValue;
}
function Score_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_Score_free(this_ptr);
// debug statements here
}
function LockableScore_free(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_LockableScore_free(this_ptr);
// debug statements here
}
function MultiThreadedLockableScore_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MultiThreadedLockableScore_free(this_obj);
// debug statements here
}
function MultiThreadedLockableScore_new(score) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_MultiThreadedLockableScore_new(score);
    return nativeResponseValue;
}
function ScoringParameters_free(this_obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ScoringParameters_free(this_obj);
// debug statements here
}
function ScoringParameters_get_base_penalty_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ScoringParameters_get_base_penalty_msat(this_ptr);
    return nativeResponseValue;
}
function ScoringParameters_set_base_penalty_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ScoringParameters_set_base_penalty_msat(this_ptr, val);
// debug statements here
}
function ScoringParameters_get_failure_penalty_msat(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ScoringParameters_get_failure_penalty_msat(this_ptr);
    return nativeResponseValue;
}
function ScoringParameters_set_failure_penalty_msat(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ScoringParameters_set_failure_penalty_msat(this_ptr, val);
// debug statements here
}
function ScoringParameters_get_overuse_penalty_start_1024th(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ScoringParameters_get_overuse_penalty_start_1024th(this_ptr);
    return nativeResponseValue;
}
function ScoringParameters_set_overuse_penalty_start_1024th(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ScoringParameters_set_overuse_penalty_start_1024th(this_ptr, val);
// debug statements here
}
function ScoringParameters_get_overuse_penalty_msat_per_1024th(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ScoringParameters_get_overuse_penalty_msat_per_1024th(this_ptr);
    return nativeResponseValue;
}
function ScoringParameters_set_overuse_penalty_msat_per_1024th(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ScoringParameters_set_overuse_penalty_msat_per_1024th(this_ptr, val);
// debug statements here
}
function ScoringParameters_get_failure_penalty_half_life(this_ptr) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ScoringParameters_get_failure_penalty_half_life(this_ptr);
    return nativeResponseValue;
}
function ScoringParameters_set_failure_penalty_half_life(this_ptr, val) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ScoringParameters_set_failure_penalty_half_life(this_ptr, val);
// debug statements here
}
function ScoringParameters_new(base_penalty_msat_arg, failure_penalty_msat_arg, overuse_penalty_start_1024th_arg, overuse_penalty_msat_per_1024th_arg, failure_penalty_half_life_arg) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ScoringParameters_new(base_penalty_msat_arg, failure_penalty_msat_arg, overuse_penalty_start_1024th_arg, overuse_penalty_msat_per_1024th_arg, failure_penalty_half_life_arg);
    return nativeResponseValue;
}
function ScoringParameters_write(obj) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ScoringParameters_write(obj);
    return nativeResponseValue;
}
function ScoringParameters_read(ser) {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ScoringParameters_read(ser);
    return nativeResponseValue;
}
function ScoringParameters_default() {
    if (!isWasmInitialized) throw new Error("initializeWasm() must be awaited first!");
    const nativeResponseValue = wasm.TS_ScoringParameters_default();
    return nativeResponseValue;
}
js_invoke = function(obj_ptr, fn_id, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) {
    const weak = js_objs[obj_ptr];
    if (weak == null || weak == undefined) {
        console.error("Got function call on unknown/free'd JS object!");
        throw new Error("Got function call on unknown/free'd JS object!");
    }
    const obj = weak.deref();
    if (obj == null || obj == undefined) {
        console.error("Got function call on GC'd JS object!");
        throw new Error("Got function call on GC'd JS object!");
    }
    var fn;
    switch(fn_id){
        case 0:
            fn = Object.getOwnPropertyDescriptor(obj, "type_id");
            break;
        case 1:
            fn = Object.getOwnPropertyDescriptor(obj, "debug_str");
            break;
        case 2:
            fn = Object.getOwnPropertyDescriptor(obj, "write");
            break;
        case 3:
            fn = Object.getOwnPropertyDescriptor(obj, "get_per_commitment_point");
            break;
        case 4:
            fn = Object.getOwnPropertyDescriptor(obj, "release_commitment_secret");
            break;
        case 5:
            fn = Object.getOwnPropertyDescriptor(obj, "validate_holder_commitment");
            break;
        case 6:
            fn = Object.getOwnPropertyDescriptor(obj, "channel_keys_id");
            break;
        case 7:
            fn = Object.getOwnPropertyDescriptor(obj, "sign_counterparty_commitment");
            break;
        case 8:
            fn = Object.getOwnPropertyDescriptor(obj, "validate_counterparty_revocation");
            break;
        case 9:
            fn = Object.getOwnPropertyDescriptor(obj, "sign_holder_commitment_and_htlcs");
            break;
        case 10:
            fn = Object.getOwnPropertyDescriptor(obj, "sign_justice_revoked_output");
            break;
        case 11:
            fn = Object.getOwnPropertyDescriptor(obj, "sign_justice_revoked_htlc");
            break;
        case 12:
            fn = Object.getOwnPropertyDescriptor(obj, "sign_counterparty_htlc_transaction");
            break;
        case 13:
            fn = Object.getOwnPropertyDescriptor(obj, "sign_closing_transaction");
            break;
        case 14:
            fn = Object.getOwnPropertyDescriptor(obj, "sign_channel_announcement");
            break;
        case 15:
            fn = Object.getOwnPropertyDescriptor(obj, "ready_channel");
            break;
        case 16:
            fn = Object.getOwnPropertyDescriptor(obj, "write");
            break;
        case 17:
            fn = Object.getOwnPropertyDescriptor(obj, "get_utxo");
            break;
        case 18:
            fn = Object.getOwnPropertyDescriptor(obj, "register_tx");
            break;
        case 19:
            fn = Object.getOwnPropertyDescriptor(obj, "register_output");
            break;
        case 20:
            fn = Object.getOwnPropertyDescriptor(obj, "watch_channel");
            break;
        case 21:
            fn = Object.getOwnPropertyDescriptor(obj, "update_channel");
            break;
        case 22:
            fn = Object.getOwnPropertyDescriptor(obj, "release_pending_monitor_events");
            break;
        case 23:
            fn = Object.getOwnPropertyDescriptor(obj, "broadcast_transaction");
            break;
        case 24:
            fn = Object.getOwnPropertyDescriptor(obj, "get_node_secret");
            break;
        case 25:
            fn = Object.getOwnPropertyDescriptor(obj, "get_destination_script");
            break;
        case 26:
            fn = Object.getOwnPropertyDescriptor(obj, "get_shutdown_scriptpubkey");
            break;
        case 27:
            fn = Object.getOwnPropertyDescriptor(obj, "get_channel_signer");
            break;
        case 28:
            fn = Object.getOwnPropertyDescriptor(obj, "get_secure_random_bytes");
            break;
        case 29:
            fn = Object.getOwnPropertyDescriptor(obj, "read_chan_signer");
            break;
        case 30:
            fn = Object.getOwnPropertyDescriptor(obj, "sign_invoice");
            break;
        case 31:
            fn = Object.getOwnPropertyDescriptor(obj, "get_inbound_payment_key_material");
            break;
        case 32:
            fn = Object.getOwnPropertyDescriptor(obj, "get_est_sat_per_1000_weight");
            break;
        case 33:
            fn = Object.getOwnPropertyDescriptor(obj, "log");
            break;
        case 34:
            fn = Object.getOwnPropertyDescriptor(obj, "get_and_clear_pending_msg_events");
            break;
        case 35:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_event");
            break;
        case 36:
            fn = Object.getOwnPropertyDescriptor(obj, "process_pending_events");
            break;
        case 37:
            fn = Object.getOwnPropertyDescriptor(obj, "block_connected");
            break;
        case 38:
            fn = Object.getOwnPropertyDescriptor(obj, "block_disconnected");
            break;
        case 39:
            fn = Object.getOwnPropertyDescriptor(obj, "transactions_confirmed");
            break;
        case 40:
            fn = Object.getOwnPropertyDescriptor(obj, "transaction_unconfirmed");
            break;
        case 41:
            fn = Object.getOwnPropertyDescriptor(obj, "best_block_updated");
            break;
        case 42:
            fn = Object.getOwnPropertyDescriptor(obj, "get_relevant_txids");
            break;
        case 43:
            fn = Object.getOwnPropertyDescriptor(obj, "persist_new_channel");
            break;
        case 44:
            fn = Object.getOwnPropertyDescriptor(obj, "update_persisted_channel");
            break;
        case 45:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_open_channel");
            break;
        case 46:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_accept_channel");
            break;
        case 47:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_funding_created");
            break;
        case 48:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_funding_signed");
            break;
        case 49:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_funding_locked");
            break;
        case 50:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_shutdown");
            break;
        case 51:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_closing_signed");
            break;
        case 52:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_update_add_htlc");
            break;
        case 53:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_update_fulfill_htlc");
            break;
        case 54:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_update_fail_htlc");
            break;
        case 55:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_update_fail_malformed_htlc");
            break;
        case 56:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_commitment_signed");
            break;
        case 57:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_revoke_and_ack");
            break;
        case 58:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_update_fee");
            break;
        case 59:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_announcement_signatures");
            break;
        case 60:
            fn = Object.getOwnPropertyDescriptor(obj, "peer_disconnected");
            break;
        case 61:
            fn = Object.getOwnPropertyDescriptor(obj, "peer_connected");
            break;
        case 62:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_channel_reestablish");
            break;
        case 63:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_channel_update");
            break;
        case 64:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_error");
            break;
        case 65:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_node_announcement");
            break;
        case 66:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_channel_announcement");
            break;
        case 67:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_channel_update");
            break;
        case 68:
            fn = Object.getOwnPropertyDescriptor(obj, "get_next_channel_announcements");
            break;
        case 69:
            fn = Object.getOwnPropertyDescriptor(obj, "get_next_node_announcements");
            break;
        case 70:
            fn = Object.getOwnPropertyDescriptor(obj, "sync_routing_table");
            break;
        case 71:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_reply_channel_range");
            break;
        case 72:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_reply_short_channel_ids_end");
            break;
        case 73:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_query_channel_range");
            break;
        case 74:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_query_short_channel_ids");
            break;
        case 75:
            fn = Object.getOwnPropertyDescriptor(obj, "read");
            break;
        case 76:
            fn = Object.getOwnPropertyDescriptor(obj, "handle_custom_message");
            break;
        case 77:
            fn = Object.getOwnPropertyDescriptor(obj, "get_and_clear_pending_msg");
            break;
        case 78:
            fn = Object.getOwnPropertyDescriptor(obj, "send_data");
            break;
        case 79:
            fn = Object.getOwnPropertyDescriptor(obj, "disconnect_socket");
            break;
        case 80:
            fn = Object.getOwnPropertyDescriptor(obj, "eq");
            break;
        case 81:
            fn = Object.getOwnPropertyDescriptor(obj, "hash");
            break;
        case 82:
            fn = Object.getOwnPropertyDescriptor(obj, "channel_penalty_msat");
            break;
        case 83:
            fn = Object.getOwnPropertyDescriptor(obj, "payment_path_failed");
            break;
        case 84:
            fn = Object.getOwnPropertyDescriptor(obj, "payment_path_successful");
            break;
        case 85:
            fn = Object.getOwnPropertyDescriptor(obj, "write");
            break;
        case 86:
            fn = Object.getOwnPropertyDescriptor(obj, "lock");
            break;
        default:
            console.error("Got unknown function call from C!");
            throw new Error("Got unknown function call from C!");
    }
    if (fn == null || fn == undefined) {
        console.error("Got function call on incorrect JS object!");
        throw new Error("Got function call on incorrect JS object!");
    }
    return fn.value.bind(obj)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
}; //# sourceMappingURL=bindings.mjs.map

},{"./version.mjs":"39AC6","ef76b51c9c3ce6c8":"biqio","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"39AC6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "get_ldk_java_bindings_version", ()=>get_ldk_java_bindings_version
) //# sourceMappingURL=version.mjs.map
;
function get_ldk_java_bindings_version() {
    return "v0.0.104.1-37-geec046b9";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"biqio":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require('./helpers/bundle-url').getBundleURL('bLxZJ') + "crypto-browserify.b08a2c62.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root('hagNj')
);

},{"./helpers/browser/js-loader":"61B45","./helpers/bundle-url":"lgJ39"}],"61B45":[function(require,module,exports) {
"use strict";
var cacheLoader = require('../cacheLoader');
module.exports = cacheLoader(function(bundle) {
    return new Promise(function(resolve, reject) {
        // Don't insert the same script twice (e.g. if it was already in the HTML)
        var existingScripts = document.getElementsByTagName('script');
        if ([].concat(existingScripts).some(function isCurrentBundle(script) {
            return script.src === bundle;
        })) {
            resolve();
            return;
        }
        var script1 = document.createElement('script');
        script1.async = true;
        script1.type = 'text/javascript';
        script1.charset = 'utf-8';
        script1.src = bundle;
        script1.onerror = function(e) {
            var error = new TypeError("Failed to fetch dynamically imported module: ".concat(bundle, ". Error: ").concat(e.message));
            script1.onerror = script1.onload = null;
            script1.remove();
            reject(error);
        };
        script1.onload = function() {
            script1.onerror = script1.onload = null;
            resolve();
        };
        document.getElementsByTagName('head')[0].appendChild(script1);
    });
});

},{"../cacheLoader":"j49pS"}],"j49pS":[function(require,module,exports) {
"use strict";
var cachedBundles = {
};
var cachedPreloads = {
};
var cachedPrefetches = {
};
function getCache(type) {
    switch(type){
        case 'preload':
            return cachedPreloads;
        case 'prefetch':
            return cachedPrefetches;
        default:
            return cachedBundles;
    }
}
module.exports = function(loader, type) {
    return function(bundle) {
        var cache = getCache(type);
        if (cache[bundle]) return cache[bundle];
        return cache[bundle] = loader.apply(null, arguments).catch(function(e) {
            delete cache[bundle];
            throw e;
        });
    };
};

},{}],"lgJ39":[function(require,module,exports) {
"use strict";
var bundleURL = {
};
function getBundleURLCached(id) {
    var value = bundleURL[id];
    if (!value) {
        value = getBundleURL();
        bundleURL[id] = value;
    }
    return value;
}
function getBundleURL() {
    try {
        throw new Error();
    } catch (err) {
        var matches = ('' + err.stack).match(/(https?|file|ftp):\/\/[^)\n]+/g);
        if (matches) // The first two stack frames will be this function and getBundleURLCached.
        // Use the 3rd one, which will be a runtime in the original bundle.
        return getBaseURL(matches[2]);
    }
    return '/';
}
function getBaseURL(url) {
    return ('' + url).replace(/^((?:https?|file|ftp):\/\/.+)\/[^/]+$/, '$1') + '/';
} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.
function getOrigin(url) {
    var matches = ('' + url).match(/(https?|file|ftp):\/\/[^/]+/);
    if (!matches) throw new Error('Origin not found');
    return matches[0];
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;

},{}],"3syDw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TxOut", ()=>TxOut
) //# sourceMappingURL=TxOut.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class TxOut extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.TxOut_free);
        this.script_pubkey = _bindingsMjs.decodeUint8Array(_bindingsMjs.TxOut_get_script_pubkey(ptr));
        this.value = _bindingsMjs.TxOut_get_value(ptr);
    }
    constructor_new(value, script_pubkey) {
        return new TxOut(null, _bindingsMjs.TxOut_new(_bindingsMjs.encodeUint8Array(script_pubkey), value));
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6QyPK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function freer(f) {
    f();
}
const finalizer = new FinalizationRegistry(freer);
function get_freeer(ptr, free_fn) {
    return ()=>{
        free_fn(ptr);
    };
}
class CommonBase {
    constructor(ptr, free_fn){
        this.ptrs_to = [];
        this.ptr = ptr;
        if (Number.isFinite(ptr) && ptr != 0) finalizer.register(this, get_freeer(ptr, free_fn));
    }
    // In Java, protected means "any subclass can access fields on any other subclass'"
    // In TypeScript, protected means "any subclass can access parent fields on instances of itself"
    // To work around this, we add accessors for other instances' protected fields here.
    static add_ref_from(holder, referent) {
        holder.ptrs_to.push(referent);
    }
    static get_ptr_of(o) {
        return o.ptr;
    }
    static set_null_skip_free(o) {
        o.ptr = 0;
        finalizer.unregister(o);
    }
} //# sourceMappingURL=CommonBase.mjs.map
exports.default = CommonBase;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3kb7t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AccessError", ()=>_bindingsMjs.AccessError
) //# sourceMappingURL=AccessError.mjs.map
;
var _bindingsMjs = require("../bindings.mjs");

},{"../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9Z99Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "COption_NoneZ", ()=>_bindingsMjs.COption_NoneZ
) //# sourceMappingURL=COption_NoneZ.mjs.map
;
var _bindingsMjs = require("../bindings.mjs");

},{"../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hUh9l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChannelMonitorUpdateErr", ()=>_bindingsMjs.ChannelMonitorUpdateErr
) //# sourceMappingURL=ChannelMonitorUpdateErr.mjs.map
;
var _bindingsMjs = require("../bindings.mjs");

},{"../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6CzjF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConfirmationTarget", ()=>_bindingsMjs.ConfirmationTarget
) //# sourceMappingURL=ConfirmationTarget.mjs.map
;
var _bindingsMjs = require("../bindings.mjs");

},{"../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bJcVy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Level", ()=>_bindingsMjs.Level
) //# sourceMappingURL=Level.mjs.map
;
var _bindingsMjs = require("../bindings.mjs");

},{"../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"az8qe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Network", ()=>_bindingsMjs.Network
) //# sourceMappingURL=Network.mjs.map
;
var _bindingsMjs = require("../bindings.mjs");

},{"../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"43LX4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Secp256k1Error", ()=>_bindingsMjs.Secp256k1Error
) //# sourceMappingURL=Secp256k1Error.mjs.map
;
var _bindingsMjs = require("../bindings.mjs");

},{"../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"VmnNM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Options which apply on a per-channel basis and may change at runtime or based on negotiation
 * with our counterparty.
 */ parcelHelpers.export(exports, "ChannelConfig", ()=>ChannelConfig
) //# sourceMappingURL=ChannelConfig.mjs.map
;
var _resultChannelConfigDecodeErrorZMjs = require("../structs/Result_ChannelConfigDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelConfig extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelConfig_free);
    }
    /**
     * Amount (in millionths of a satoshi) charged per satoshi for payments forwarded outbound
     * over the channel.
     * This may be allowed to change at runtime in a later update, however doing so must result in
     * update messages sent to notify all nodes of our updated relay fee.
     *
     * Default value: 0.
     */ get_forwarding_fee_proportional_millionths() {
        const ret = _bindingsMjs.ChannelConfig_get_forwarding_fee_proportional_millionths(this.ptr);
        return ret;
    }
    /**
     * Amount (in millionths of a satoshi) charged per satoshi for payments forwarded outbound
     * over the channel.
     * This may be allowed to change at runtime in a later update, however doing so must result in
     * update messages sent to notify all nodes of our updated relay fee.
     *
     * Default value: 0.
     */ set_forwarding_fee_proportional_millionths(val) {
        _bindingsMjs.ChannelConfig_set_forwarding_fee_proportional_millionths(this.ptr, val);
    }
    /**
     * Amount (in milli-satoshi) charged for payments forwarded outbound over the channel, in
     * excess of [`forwarding_fee_proportional_millionths`].
     * This may be allowed to change at runtime in a later update, however doing so must result in
     * update messages sent to notify all nodes of our updated relay fee.
     *
     * The default value of a single satoshi roughly matches the market rate on many routing nodes
     * as of July 2021. Adjusting it upwards or downwards may change whether nodes route through
     * this node.
     *
     * Default value: 1000.
     *
     * [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
     */ get_forwarding_fee_base_msat() {
        const ret = _bindingsMjs.ChannelConfig_get_forwarding_fee_base_msat(this.ptr);
        return ret;
    }
    /**
     * Amount (in milli-satoshi) charged for payments forwarded outbound over the channel, in
     * excess of [`forwarding_fee_proportional_millionths`].
     * This may be allowed to change at runtime in a later update, however doing so must result in
     * update messages sent to notify all nodes of our updated relay fee.
     *
     * The default value of a single satoshi roughly matches the market rate on many routing nodes
     * as of July 2021. Adjusting it upwards or downwards may change whether nodes route through
     * this node.
     *
     * Default value: 1000.
     *
     * [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
     */ set_forwarding_fee_base_msat(val) {
        _bindingsMjs.ChannelConfig_set_forwarding_fee_base_msat(this.ptr, val);
    }
    /**
     * The difference in the CLTV value between incoming HTLCs and an outbound HTLC forwarded over
     * the channel this config applies to.
     *
     * This is analogous to [`ChannelHandshakeConfig::our_to_self_delay`] but applies to in-flight
     * HTLC balance when a channel appears on-chain whereas
     * [`ChannelHandshakeConfig::our_to_self_delay`] applies to the remaining
     * (non-HTLC-encumbered) balance.
     *
     * Thus, for HTLC-encumbered balances to be enforced on-chain when a channel is force-closed,
     * we (or one of our watchtowers) MUST be online to check for broadcast of the current
     * commitment transaction at least once per this many blocks (minus some margin to allow us
     * enough time to broadcast and confirm a transaction, possibly with time in between to RBF
     * the spending transaction).
     *
     * Default value: 72 (12 hours at an average of 6 blocks/hour).
     * Minimum value: [`MIN_CLTV_EXPIRY_DELTA`], any values less than this will be treated as
     * [`MIN_CLTV_EXPIRY_DELTA`] instead.
     *
     * [`MIN_CLTV_EXPIRY_DELTA`]: crate::ln::channelmanager::MIN_CLTV_EXPIRY_DELTA
     */ get_cltv_expiry_delta() {
        const ret = _bindingsMjs.ChannelConfig_get_cltv_expiry_delta(this.ptr);
        return ret;
    }
    /**
     * The difference in the CLTV value between incoming HTLCs and an outbound HTLC forwarded over
     * the channel this config applies to.
     *
     * This is analogous to [`ChannelHandshakeConfig::our_to_self_delay`] but applies to in-flight
     * HTLC balance when a channel appears on-chain whereas
     * [`ChannelHandshakeConfig::our_to_self_delay`] applies to the remaining
     * (non-HTLC-encumbered) balance.
     *
     * Thus, for HTLC-encumbered balances to be enforced on-chain when a channel is force-closed,
     * we (or one of our watchtowers) MUST be online to check for broadcast of the current
     * commitment transaction at least once per this many blocks (minus some margin to allow us
     * enough time to broadcast and confirm a transaction, possibly with time in between to RBF
     * the spending transaction).
     *
     * Default value: 72 (12 hours at an average of 6 blocks/hour).
     * Minimum value: [`MIN_CLTV_EXPIRY_DELTA`], any values less than this will be treated as
     * [`MIN_CLTV_EXPIRY_DELTA`] instead.
     *
     * [`MIN_CLTV_EXPIRY_DELTA`]: crate::ln::channelmanager::MIN_CLTV_EXPIRY_DELTA
     */ set_cltv_expiry_delta(val) {
        _bindingsMjs.ChannelConfig_set_cltv_expiry_delta(this.ptr, val);
    }
    /**
     * Set to announce the channel publicly and notify all nodes that they can route via this
     * channel.
     *
     * This should only be set to true for nodes which expect to be online reliably.
     *
     * As the node which funds a channel picks this value this will only apply for new outbound
     * channels unless [`ChannelHandshakeLimits::force_announced_channel_preference`] is set.
     *
     * This cannot be changed after the initial channel handshake.
     *
     * Default value: false.
     */ get_announced_channel() {
        const ret = _bindingsMjs.ChannelConfig_get_announced_channel(this.ptr);
        return ret;
    }
    /**
     * Set to announce the channel publicly and notify all nodes that they can route via this
     * channel.
     *
     * This should only be set to true for nodes which expect to be online reliably.
     *
     * As the node which funds a channel picks this value this will only apply for new outbound
     * channels unless [`ChannelHandshakeLimits::force_announced_channel_preference`] is set.
     *
     * This cannot be changed after the initial channel handshake.
     *
     * Default value: false.
     */ set_announced_channel(val) {
        _bindingsMjs.ChannelConfig_set_announced_channel(this.ptr, val);
    }
    /**
     * When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty
     * supports it, they will then enforce the mutual-close output to us matches what we provided
     * at intialization, preventing us from closing to an alternate pubkey.
     *
     * This is set to true by default to provide a slight increase in security, though ultimately
     * any attacker who is able to take control of a channel can just as easily send the funds via
     * lightning payments, so we never require that our counterparties support this option.
     *
     * This cannot be changed after a channel has been initialized.
     *
     * Default value: true.
     */ get_commit_upfront_shutdown_pubkey() {
        const ret = _bindingsMjs.ChannelConfig_get_commit_upfront_shutdown_pubkey(this.ptr);
        return ret;
    }
    /**
     * When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty
     * supports it, they will then enforce the mutual-close output to us matches what we provided
     * at intialization, preventing us from closing to an alternate pubkey.
     *
     * This is set to true by default to provide a slight increase in security, though ultimately
     * any attacker who is able to take control of a channel can just as easily send the funds via
     * lightning payments, so we never require that our counterparties support this option.
     *
     * This cannot be changed after a channel has been initialized.
     *
     * Default value: true.
     */ set_commit_upfront_shutdown_pubkey(val) {
        _bindingsMjs.ChannelConfig_set_commit_upfront_shutdown_pubkey(this.ptr, val);
    }
    /**
     * Limit our total exposure to in-flight HTLCs which are burned to fees as they are too
     * small to claim on-chain.
     *
     * When an HTLC present in one of our channels is below a \"dust\" threshold, the HTLC will
     * not be claimable on-chain, instead being turned into additional miner fees if either
     * party force-closes the channel. Because the threshold is per-HTLC, our total exposure
     * to such payments may be sustantial if there are many dust HTLCs present when the
     * channel is force-closed.
     *
     * This limit is applied for sent, forwarded, and received HTLCs and limits the total
     * exposure across all three types per-channel. Setting this too low may prevent the
     * sending or receipt of low-value HTLCs on high-traffic nodes, and this limit is very
     * important to prevent stealing of dust HTLCs by miners.
     *
     * Default value: 5_000_000 msat.
     */ get_max_dust_htlc_exposure_msat() {
        const ret = _bindingsMjs.ChannelConfig_get_max_dust_htlc_exposure_msat(this.ptr);
        return ret;
    }
    /**
     * Limit our total exposure to in-flight HTLCs which are burned to fees as they are too
     * small to claim on-chain.
     *
     * When an HTLC present in one of our channels is below a \"dust\" threshold, the HTLC will
     * not be claimable on-chain, instead being turned into additional miner fees if either
     * party force-closes the channel. Because the threshold is per-HTLC, our total exposure
     * to such payments may be sustantial if there are many dust HTLCs present when the
     * channel is force-closed.
     *
     * This limit is applied for sent, forwarded, and received HTLCs and limits the total
     * exposure across all three types per-channel. Setting this too low may prevent the
     * sending or receipt of low-value HTLCs on high-traffic nodes, and this limit is very
     * important to prevent stealing of dust HTLCs by miners.
     *
     * Default value: 5_000_000 msat.
     */ set_max_dust_htlc_exposure_msat(val) {
        _bindingsMjs.ChannelConfig_set_max_dust_htlc_exposure_msat(this.ptr, val);
    }
    /**
     * The additional fee we're willing to pay to avoid waiting for the counterparty's
     * `to_self_delay` to reclaim funds.
     *
     * When we close a channel cooperatively with our counterparty, we negotiate a fee for the
     * closing transaction which both sides find acceptable, ultimately paid by the channel
     * funder/initiator.
     *
     * When we are the funder, because we have to pay the channel closing fee, we bound the
     * acceptable fee by our [`Background`] and [`Normal`] fees, with the upper bound increased by
     * this value. Because the on-chain fee we'd pay to force-close the channel is kept near our
     * [`Normal`] feerate during normal operation, this value represents the additional fee we're
     * willing to pay in order to avoid waiting for our counterparty's to_self_delay to reclaim our
     * funds.
     *
     * When we are not the funder, we require the closing transaction fee pay at least our
     * [`Background`] fee estimate, but allow our counterparty to pay as much fee as they like.
     * Thus, this value is ignored when we are not the funder.
     *
     * Default value: 1000 satoshis.
     *
     * [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
     * [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
     */ get_force_close_avoidance_max_fee_satoshis() {
        const ret = _bindingsMjs.ChannelConfig_get_force_close_avoidance_max_fee_satoshis(this.ptr);
        return ret;
    }
    /**
     * The additional fee we're willing to pay to avoid waiting for the counterparty's
     * `to_self_delay` to reclaim funds.
     *
     * When we close a channel cooperatively with our counterparty, we negotiate a fee for the
     * closing transaction which both sides find acceptable, ultimately paid by the channel
     * funder/initiator.
     *
     * When we are the funder, because we have to pay the channel closing fee, we bound the
     * acceptable fee by our [`Background`] and [`Normal`] fees, with the upper bound increased by
     * this value. Because the on-chain fee we'd pay to force-close the channel is kept near our
     * [`Normal`] feerate during normal operation, this value represents the additional fee we're
     * willing to pay in order to avoid waiting for our counterparty's to_self_delay to reclaim our
     * funds.
     *
     * When we are not the funder, we require the closing transaction fee pay at least our
     * [`Background`] fee estimate, but allow our counterparty to pay as much fee as they like.
     * Thus, this value is ignored when we are not the funder.
     *
     * Default value: 1000 satoshis.
     *
     * [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
     * [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
     */ set_force_close_avoidance_max_fee_satoshis(val) {
        _bindingsMjs.ChannelConfig_set_force_close_avoidance_max_fee_satoshis(this.ptr, val);
    }
    /**
     * Constructs a new ChannelConfig given each field
     */ static constructor_new(forwarding_fee_proportional_millionths_arg, forwarding_fee_base_msat_arg, cltv_expiry_delta_arg, announced_channel_arg, commit_upfront_shutdown_pubkey_arg, max_dust_htlc_exposure_msat_arg, force_close_avoidance_max_fee_satoshis_arg) {
        const ret = _bindingsMjs.ChannelConfig_new(forwarding_fee_proportional_millionths_arg, forwarding_fee_base_msat_arg, cltv_expiry_delta_arg, announced_channel_arg, commit_upfront_shutdown_pubkey_arg, max_dust_htlc_exposure_msat_arg, force_close_avoidance_max_fee_satoshis_arg);
        const ret_hu_conv = new ChannelConfig(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ChannelConfig_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelConfig
     */ clone() {
        const ret = _bindingsMjs.ChannelConfig_clone(this.ptr);
        const ret_hu_conv = new ChannelConfig(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a "default" ChannelConfig. See struct and individual field documentaiton for details on which values are used.
     */ static constructor_default() {
        const ret = _bindingsMjs.ChannelConfig_default();
        const ret_hu_conv = new ChannelConfig(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Serialize the ChannelConfig object into a byte array which can be read by ChannelConfig_read
     */ write() {
        const ret = _bindingsMjs.ChannelConfig_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ChannelConfig from a byte array, created by ChannelConfig_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ChannelConfig_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultChannelConfigDecodeErrorZMjs.Result_ChannelConfigDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_ChannelConfigDecodeErrorZ.mjs":"3QTMW","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3QTMW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ChannelConfigDecodeErrorZ", ()=>Result_ChannelConfigDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ChannelConfigDecodeErrorZ_OK", ()=>Result_ChannelConfigDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ChannelConfigDecodeErrorZ_Err", ()=>Result_ChannelConfigDecodeErrorZ_Err
) //# sourceMappingURL=Result_ChannelConfigDecodeErrorZ.mjs.map
;
var _channelConfigMjs = require("../structs/ChannelConfig.mjs");
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ChannelConfigDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ChannelConfigDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ChannelConfigDecodeErrorZ_is_ok(ptr)) return new Result_ChannelConfigDecodeErrorZ_OK(null, ptr);
        else return new Result_ChannelConfigDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ChannelConfigDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ChannelConfigDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ChannelConfigDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ChannelConfigDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ChannelConfigDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ChannelConfigDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ChannelConfigDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_ChannelConfigDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_ChannelConfigDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_ChannelConfigDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_ChannelConfigDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_ChannelConfigDecodeErrorZ_OK extends Result_ChannelConfigDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ChannelConfigDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _channelConfigMjs.ChannelConfig(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ChannelConfigDecodeErrorZ_Err extends Result_ChannelConfigDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ChannelConfigDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/ChannelConfig.mjs":"VmnNM","../structs/DecodeError.mjs":"5KlBi","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5KlBi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An error in decoding a message or struct.
 */ parcelHelpers.export(exports, "DecodeError", ()=>DecodeError
) //# sourceMappingURL=DecodeError.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class DecodeError extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.DecodeError_free);
    }
    clone_ptr() {
        const ret = _bindingsMjs.DecodeError_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the DecodeError
     */ clone() {
        const ret = _bindingsMjs.DecodeError_clone(this.ptr);
        const ret_hu_conv = new DecodeError(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9FTof":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A reference to a transaction output.
 *
 * Differs from bitcoin::blockdata::transaction::OutPoint as the index is a u16 instead of u32
 * due to LN's restrictions on index values. Should reduce (possibly) unsafe conversions this way.
 */ parcelHelpers.export(exports, "OutPoint", ()=>OutPoint
) //# sourceMappingURL=OutPoint.mjs.map
;
var _resultOutPointDecodeErrorZMjs = require("../structs/Result_OutPointDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class OutPoint extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.OutPoint_free);
    }
    /**
     * The referenced transaction's txid.
     */ get_txid() {
        const ret = _bindingsMjs.OutPoint_get_txid(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The referenced transaction's txid.
     */ set_txid(val) {
        _bindingsMjs.OutPoint_set_txid(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The index of the referenced output in its transaction's vout.
     */ get_index() {
        const ret = _bindingsMjs.OutPoint_get_index(this.ptr);
        return ret;
    }
    /**
     * The index of the referenced output in its transaction's vout.
     */ set_index(val) {
        _bindingsMjs.OutPoint_set_index(this.ptr, val);
    }
    /**
     * Constructs a new OutPoint given each field
     */ static constructor_new(txid_arg, index_arg) {
        const ret = _bindingsMjs.OutPoint_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(txid_arg, 32)), index_arg);
        const ret_hu_conv = new OutPoint(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.OutPoint_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the OutPoint
     */ clone() {
        const ret = _bindingsMjs.OutPoint_clone(this.ptr);
        const ret_hu_conv = new OutPoint(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Checks if two OutPoints contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */ eq(b) {
        const ret = _bindingsMjs.OutPoint_eq(this.ptr, b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, b);
        return ret;
    }
    /**
     * Checks if two OutPoints contain equal inner contents.
     */ hash() {
        const ret = _bindingsMjs.OutPoint_hash(this.ptr);
        return ret;
    }
    /**
     * Convert an `OutPoint` to a lightning channel id.
     */ to_channel_id() {
        const ret = _bindingsMjs.OutPoint_to_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Serialize the OutPoint object into a byte array which can be read by OutPoint_read
     */ write() {
        const ret = _bindingsMjs.OutPoint_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a OutPoint from a byte array, created by OutPoint_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.OutPoint_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultOutPointDecodeErrorZMjs.Result_OutPointDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_OutPointDecodeErrorZ.mjs":"15rzH","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"15rzH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_OutPointDecodeErrorZ", ()=>Result_OutPointDecodeErrorZ
);
parcelHelpers.export(exports, "Result_OutPointDecodeErrorZ_OK", ()=>Result_OutPointDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_OutPointDecodeErrorZ_Err", ()=>Result_OutPointDecodeErrorZ_Err
) //# sourceMappingURL=Result_OutPointDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _outPointMjs = require("../structs/OutPoint.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_OutPointDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_OutPointDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_OutPointDecodeErrorZ_is_ok(ptr)) return new Result_OutPointDecodeErrorZ_OK(null, ptr);
        else return new Result_OutPointDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_OutPointDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_OutPointDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_OutPointDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_OutPointDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_OutPointDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_OutPointDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_OutPointDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_OutPointDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_OutPointDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_OutPointDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_OutPointDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_OutPointDecodeErrorZ_OK extends Result_OutPointDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_OutPointDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _outPointMjs.OutPoint(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_OutPointDecodeErrorZ_Err extends Result_OutPointDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_OutPointDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/OutPoint.mjs":"9FTof","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2bthA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_SecretKeyErrorZ", ()=>Result_SecretKeyErrorZ
);
parcelHelpers.export(exports, "Result_SecretKeyErrorZ_OK", ()=>Result_SecretKeyErrorZ_OK
);
parcelHelpers.export(exports, "Result_SecretKeyErrorZ_Err", ()=>Result_SecretKeyErrorZ_Err
) //# sourceMappingURL=Result_SecretKeyErrorZ.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_SecretKeyErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_SecretKeyErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_SecretKeyErrorZ_is_ok(ptr)) return new Result_SecretKeyErrorZ_OK(null, ptr);
        else return new Result_SecretKeyErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_SecretKeyErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_SecretKeyErrorZ_ok(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(o, 32)));
        const ret_hu_conv = Result_SecretKeyErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_SecretKeyErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_SecretKeyErrorZ_err(e);
        const ret_hu_conv = Result_SecretKeyErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_SecretKeyErrorZ_is_ok(this.ptr);
        return ret;
    }
}
class Result_SecretKeyErrorZ_OK extends Result_SecretKeyErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_SecretKeyErrorZ_get_ok(ptr);
        const res_conv = _bindingsMjs.decodeUint8Array(res);
        this.res = res_conv;
    }
}
class Result_SecretKeyErrorZ_Err extends Result_SecretKeyErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        this.err = _bindingsMjs.CResult_SecretKeyErrorZ_get_err(ptr);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dMi2Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_PublicKeyErrorZ", ()=>Result_PublicKeyErrorZ
);
parcelHelpers.export(exports, "Result_PublicKeyErrorZ_OK", ()=>Result_PublicKeyErrorZ_OK
);
parcelHelpers.export(exports, "Result_PublicKeyErrorZ_Err", ()=>Result_PublicKeyErrorZ_Err
) //# sourceMappingURL=Result_PublicKeyErrorZ.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_PublicKeyErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_PublicKeyErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_PublicKeyErrorZ_is_ok(ptr)) return new Result_PublicKeyErrorZ_OK(null, ptr);
        else return new Result_PublicKeyErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_PublicKeyErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_PublicKeyErrorZ_ok(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(o, 33)));
        const ret_hu_conv = Result_PublicKeyErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_PublicKeyErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_PublicKeyErrorZ_err(e);
        const ret_hu_conv = Result_PublicKeyErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_PublicKeyErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_PublicKeyErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_PublicKeyErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_PublicKeyErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_PublicKeyErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_PublicKeyErrorZ_OK extends Result_PublicKeyErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_PublicKeyErrorZ_get_ok(ptr);
        const res_conv = _bindingsMjs.decodeUint8Array(res);
        this.res = res_conv;
    }
}
class Result_PublicKeyErrorZ_Err extends Result_PublicKeyErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        this.err = _bindingsMjs.CResult_PublicKeyErrorZ_get_err(ptr);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gH4iE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The set of public keys which are used in the creation of one commitment transaction.
 * These are derived from the channel base keys and per-commitment data.
 *
 * A broadcaster key is provided from potential broadcaster of the computed transaction.
 * A countersignatory key is coming from a protocol participant unable to broadcast the
 * transaction.
 *
 * These keys are assumed to be good, either because the code derived them from
 * channel basepoints via the new function, or they were obtained via
 * CommitmentTransaction.trust().keys() because we trusted the source of the
 * pre-calculated keys.
 */ parcelHelpers.export(exports, "TxCreationKeys", ()=>TxCreationKeys
) //# sourceMappingURL=TxCreationKeys.mjs.map
;
var _resultTxCreationKeysDecodeErrorZMjs = require("../structs/Result_TxCreationKeysDecodeErrorZ.mjs");
var _resultTxCreationKeysErrorZMjs = require("../structs/Result_TxCreationKeysErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class TxCreationKeys extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.TxCreationKeys_free);
    }
    /**
     * The broadcaster's per-commitment public key which was used to derive the other keys.
     */ get_per_commitment_point() {
        const ret = _bindingsMjs.TxCreationKeys_get_per_commitment_point(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The broadcaster's per-commitment public key which was used to derive the other keys.
     */ set_per_commitment_point(val) {
        _bindingsMjs.TxCreationKeys_set_per_commitment_point(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * The revocation key which is used to allow the broadcaster of the commitment
     * transaction to provide their counterparty the ability to punish them if they broadcast
     * an old state.
     */ get_revocation_key() {
        const ret = _bindingsMjs.TxCreationKeys_get_revocation_key(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The revocation key which is used to allow the broadcaster of the commitment
     * transaction to provide their counterparty the ability to punish them if they broadcast
     * an old state.
     */ set_revocation_key(val) {
        _bindingsMjs.TxCreationKeys_set_revocation_key(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Broadcaster's HTLC Key
     */ get_broadcaster_htlc_key() {
        const ret = _bindingsMjs.TxCreationKeys_get_broadcaster_htlc_key(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Broadcaster's HTLC Key
     */ set_broadcaster_htlc_key(val) {
        _bindingsMjs.TxCreationKeys_set_broadcaster_htlc_key(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Countersignatory's HTLC Key
     */ get_countersignatory_htlc_key() {
        const ret = _bindingsMjs.TxCreationKeys_get_countersignatory_htlc_key(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Countersignatory's HTLC Key
     */ set_countersignatory_htlc_key(val) {
        _bindingsMjs.TxCreationKeys_set_countersignatory_htlc_key(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Broadcaster's Payment Key (which isn't allowed to be spent from for some delay)
     */ get_broadcaster_delayed_payment_key() {
        const ret = _bindingsMjs.TxCreationKeys_get_broadcaster_delayed_payment_key(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Broadcaster's Payment Key (which isn't allowed to be spent from for some delay)
     */ set_broadcaster_delayed_payment_key(val) {
        _bindingsMjs.TxCreationKeys_set_broadcaster_delayed_payment_key(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Constructs a new TxCreationKeys given each field
     */ static constructor_new(per_commitment_point_arg, revocation_key_arg, broadcaster_htlc_key_arg, countersignatory_htlc_key_arg, broadcaster_delayed_payment_key_arg) {
        const ret = _bindingsMjs.TxCreationKeys_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(per_commitment_point_arg, 33)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(revocation_key_arg, 33)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(broadcaster_htlc_key_arg, 33)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(countersignatory_htlc_key_arg, 33)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(broadcaster_delayed_payment_key_arg, 33)));
        const ret_hu_conv = new TxCreationKeys(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.TxCreationKeys_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the TxCreationKeys
     */ clone() {
        const ret = _bindingsMjs.TxCreationKeys_clone(this.ptr);
        const ret_hu_conv = new TxCreationKeys(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the TxCreationKeys object into a byte array which can be read by TxCreationKeys_read
     */ write() {
        const ret = _bindingsMjs.TxCreationKeys_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a TxCreationKeys from a byte array, created by TxCreationKeys_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.TxCreationKeys_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultTxCreationKeysDecodeErrorZMjs.Result_TxCreationKeysDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Create per-state keys from channel base points and the per-commitment point.
     * Key set is asymmetric and can't be used as part of counter-signatory set of transactions.
     */ static constructor_derive_new(per_commitment_point, broadcaster_delayed_payment_base, broadcaster_htlc_base, countersignatory_revocation_base, countersignatory_htlc_base) {
        const ret = _bindingsMjs.TxCreationKeys_derive_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(per_commitment_point, 33)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(broadcaster_delayed_payment_base, 33)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(broadcaster_htlc_base, 33)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(countersignatory_revocation_base, 33)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(countersignatory_htlc_base, 33)));
        const ret_hu_conv = _resultTxCreationKeysErrorZMjs.Result_TxCreationKeysErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Generate per-state keys from channel static keys.
     * Key set is asymmetric and can't be used as part of counter-signatory set of transactions.
     */ static constructor_from_channel_static_keys(per_commitment_point, broadcaster_keys, countersignatory_keys) {
        const ret = _bindingsMjs.TxCreationKeys_from_channel_static_keys(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(per_commitment_point, 33)), broadcaster_keys == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(broadcaster_keys) & -2, countersignatory_keys == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(countersignatory_keys) & -2);
        const ret_hu_conv = _resultTxCreationKeysErrorZMjs.Result_TxCreationKeysErrorZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, broadcaster_keys);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, countersignatory_keys);
        return ret_hu_conv;
    }
}

},{"../structs/Result_TxCreationKeysDecodeErrorZ.mjs":"4ig3m","../structs/Result_TxCreationKeysErrorZ.mjs":"5TrKt","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4ig3m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_TxCreationKeysDecodeErrorZ", ()=>Result_TxCreationKeysDecodeErrorZ
);
parcelHelpers.export(exports, "Result_TxCreationKeysDecodeErrorZ_OK", ()=>Result_TxCreationKeysDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_TxCreationKeysDecodeErrorZ_Err", ()=>Result_TxCreationKeysDecodeErrorZ_Err
) //# sourceMappingURL=Result_TxCreationKeysDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _txCreationKeysMjs = require("../structs/TxCreationKeys.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_TxCreationKeysDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_TxCreationKeysDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_TxCreationKeysDecodeErrorZ_is_ok(ptr)) return new Result_TxCreationKeysDecodeErrorZ_OK(null, ptr);
        else return new Result_TxCreationKeysDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_TxCreationKeysDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_TxCreationKeysDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_TxCreationKeysDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_TxCreationKeysDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_TxCreationKeysDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_TxCreationKeysDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_TxCreationKeysDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_TxCreationKeysDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_TxCreationKeysDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_TxCreationKeysDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_TxCreationKeysDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_TxCreationKeysDecodeErrorZ_OK extends Result_TxCreationKeysDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_TxCreationKeysDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _txCreationKeysMjs.TxCreationKeys(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_TxCreationKeysDecodeErrorZ_Err extends Result_TxCreationKeysDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_TxCreationKeysDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/TxCreationKeys.mjs":"gH4iE","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5TrKt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_TxCreationKeysErrorZ", ()=>Result_TxCreationKeysErrorZ
);
parcelHelpers.export(exports, "Result_TxCreationKeysErrorZ_OK", ()=>Result_TxCreationKeysErrorZ_OK
);
parcelHelpers.export(exports, "Result_TxCreationKeysErrorZ_Err", ()=>Result_TxCreationKeysErrorZ_Err
) //# sourceMappingURL=Result_TxCreationKeysErrorZ.mjs.map
;
var _txCreationKeysMjs = require("../structs/TxCreationKeys.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_TxCreationKeysErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_TxCreationKeysErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_TxCreationKeysErrorZ_is_ok(ptr)) return new Result_TxCreationKeysErrorZ_OK(null, ptr);
        else return new Result_TxCreationKeysErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_TxCreationKeysErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_TxCreationKeysErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_TxCreationKeysErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_TxCreationKeysErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_TxCreationKeysErrorZ_err(e);
        const ret_hu_conv = Result_TxCreationKeysErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_TxCreationKeysErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_TxCreationKeysErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_TxCreationKeysErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_TxCreationKeysErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_TxCreationKeysErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_TxCreationKeysErrorZ_OK extends Result_TxCreationKeysErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_TxCreationKeysErrorZ_get_ok(ptr);
        const res_hu_conv = new _txCreationKeysMjs.TxCreationKeys(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_TxCreationKeysErrorZ_Err extends Result_TxCreationKeysErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        this.err = _bindingsMjs.CResult_TxCreationKeysErrorZ_get_err(ptr);
    }
}

},{"../structs/TxCreationKeys.mjs":"gH4iE","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a8cA2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * One counterparty's public keys which do not change over the life of a channel.
 */ parcelHelpers.export(exports, "ChannelPublicKeys", ()=>ChannelPublicKeys
) //# sourceMappingURL=ChannelPublicKeys.mjs.map
;
var _resultChannelPublicKeysDecodeErrorZMjs = require("../structs/Result_ChannelPublicKeysDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelPublicKeys extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelPublicKeys_free);
    }
    /**
     * The public key which is used to sign all commitment transactions, as it appears in the
     * on-chain channel lock-in 2-of-2 multisig output.
     */ get_funding_pubkey() {
        const ret = _bindingsMjs.ChannelPublicKeys_get_funding_pubkey(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The public key which is used to sign all commitment transactions, as it appears in the
     * on-chain channel lock-in 2-of-2 multisig output.
     */ set_funding_pubkey(val) {
        _bindingsMjs.ChannelPublicKeys_set_funding_pubkey(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * The base point which is used (with derive_public_revocation_key) to derive per-commitment
     * revocation keys. This is combined with the per-commitment-secret generated by the
     * counterparty to create a secret which the counterparty can reveal to revoke previous
     * states.
     */ get_revocation_basepoint() {
        const ret = _bindingsMjs.ChannelPublicKeys_get_revocation_basepoint(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The base point which is used (with derive_public_revocation_key) to derive per-commitment
     * revocation keys. This is combined with the per-commitment-secret generated by the
     * counterparty to create a secret which the counterparty can reveal to revoke previous
     * states.
     */ set_revocation_basepoint(val) {
        _bindingsMjs.ChannelPublicKeys_set_revocation_basepoint(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * The public key on which the non-broadcaster (ie the countersignatory) receives an immediately
     * spendable primary channel balance on the broadcaster's commitment transaction. This key is
     * static across every commitment transaction.
     */ get_payment_point() {
        const ret = _bindingsMjs.ChannelPublicKeys_get_payment_point(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The public key on which the non-broadcaster (ie the countersignatory) receives an immediately
     * spendable primary channel balance on the broadcaster's commitment transaction. This key is
     * static across every commitment transaction.
     */ set_payment_point(val) {
        _bindingsMjs.ChannelPublicKeys_set_payment_point(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * The base point which is used (with derive_public_key) to derive a per-commitment payment
     * public key which receives non-HTLC-encumbered funds which are only available for spending
     * after some delay (or can be claimed via the revocation path).
     */ get_delayed_payment_basepoint() {
        const ret = _bindingsMjs.ChannelPublicKeys_get_delayed_payment_basepoint(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The base point which is used (with derive_public_key) to derive a per-commitment payment
     * public key which receives non-HTLC-encumbered funds which are only available for spending
     * after some delay (or can be claimed via the revocation path).
     */ set_delayed_payment_basepoint(val) {
        _bindingsMjs.ChannelPublicKeys_set_delayed_payment_basepoint(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * The base point which is used (with derive_public_key) to derive a per-commitment public key
     * which is used to encumber HTLC-in-flight outputs.
     */ get_htlc_basepoint() {
        const ret = _bindingsMjs.ChannelPublicKeys_get_htlc_basepoint(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The base point which is used (with derive_public_key) to derive a per-commitment public key
     * which is used to encumber HTLC-in-flight outputs.
     */ set_htlc_basepoint(val) {
        _bindingsMjs.ChannelPublicKeys_set_htlc_basepoint(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Constructs a new ChannelPublicKeys given each field
     */ static constructor_new(funding_pubkey_arg, revocation_basepoint_arg, payment_point_arg, delayed_payment_basepoint_arg, htlc_basepoint_arg) {
        const ret = _bindingsMjs.ChannelPublicKeys_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(funding_pubkey_arg, 33)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(revocation_basepoint_arg, 33)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_point_arg, 33)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(delayed_payment_basepoint_arg, 33)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(htlc_basepoint_arg, 33)));
        const ret_hu_conv = new ChannelPublicKeys(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ChannelPublicKeys_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelPublicKeys
     */ clone() {
        const ret = _bindingsMjs.ChannelPublicKeys_clone(this.ptr);
        const ret_hu_conv = new ChannelPublicKeys(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the ChannelPublicKeys object into a byte array which can be read by ChannelPublicKeys_read
     */ write() {
        const ret = _bindingsMjs.ChannelPublicKeys_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ChannelPublicKeys from a byte array, created by ChannelPublicKeys_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ChannelPublicKeys_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultChannelPublicKeysDecodeErrorZMjs.Result_ChannelPublicKeysDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_ChannelPublicKeysDecodeErrorZ.mjs":"k3vsR","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k3vsR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ChannelPublicKeysDecodeErrorZ", ()=>Result_ChannelPublicKeysDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ChannelPublicKeysDecodeErrorZ_OK", ()=>Result_ChannelPublicKeysDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ChannelPublicKeysDecodeErrorZ_Err", ()=>Result_ChannelPublicKeysDecodeErrorZ_Err
) //# sourceMappingURL=Result_ChannelPublicKeysDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _channelPublicKeysMjs = require("../structs/ChannelPublicKeys.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ChannelPublicKeysDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ChannelPublicKeysDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ChannelPublicKeysDecodeErrorZ_is_ok(ptr)) return new Result_ChannelPublicKeysDecodeErrorZ_OK(null, ptr);
        else return new Result_ChannelPublicKeysDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ChannelPublicKeysDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ChannelPublicKeysDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ChannelPublicKeysDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ChannelPublicKeysDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ChannelPublicKeysDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ChannelPublicKeysDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ChannelPublicKeysDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_ChannelPublicKeysDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_ChannelPublicKeysDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_ChannelPublicKeysDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_ChannelPublicKeysDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_ChannelPublicKeysDecodeErrorZ_OK extends Result_ChannelPublicKeysDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ChannelPublicKeysDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _channelPublicKeysMjs.ChannelPublicKeys(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ChannelPublicKeysDecodeErrorZ_Err extends Result_ChannelPublicKeysDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ChannelPublicKeysDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/ChannelPublicKeys.mjs":"a8cA2","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iQp9f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An enum which can either contain a u32 or not
 */ parcelHelpers.export(exports, "Option_u32Z", ()=>Option_u32Z
);
/** A Option_u32Z of type Some */ parcelHelpers.export(exports, "Option_u32Z_Some", ()=>Option_u32Z_Some
);
/** A Option_u32Z of type None */ parcelHelpers.export(exports, "Option_u32Z_None", ()=>Option_u32Z_None
) //# sourceMappingURL=Option_u32Z.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Option_u32Z extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.COption_u32Z_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKCOption_u32Z_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new Option_u32Z_Some(ptr);
            case 1:
                return new Option_u32Z_None(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    /**
     * Constructs a new COption_u32Z containing a u32
     */ static constructor_some(o) {
        const ret = _bindingsMjs.COption_u32Z_some(o);
        const ret_hu_conv = Option_u32Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Constructs a new COption_u32Z containing nothing
     */ static constructor_none() {
        const ret = _bindingsMjs.COption_u32Z_none();
        const ret_hu_conv = Option_u32Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.COption_u32Z_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new COption_u32Z which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.COption_u32Z_clone(this.ptr);
        const ret_hu_conv = Option_u32Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
class Option_u32Z_Some extends Option_u32Z {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        this.some = _bindingsMjs.LDKCOption_u32Z_Some_get_some(ptr);
    }
}
class Option_u32Z_None extends Option_u32Z {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9o6Rh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Information about an HTLC as it appears in a commitment transaction
 */ parcelHelpers.export(exports, "HTLCOutputInCommitment", ()=>HTLCOutputInCommitment
) //# sourceMappingURL=HTLCOutputInCommitment.mjs.map
;
var _optionU32ZMjs = require("../structs/Option_u32Z.mjs");
var _resultHTLCOutputInCommitmentDecodeErrorZMjs = require("../structs/Result_HTLCOutputInCommitmentDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class HTLCOutputInCommitment extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.HTLCOutputInCommitment_free);
    }
    /**
     * Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction).
     * Note that this is not the same as whether it is ountbound *from us*. To determine that you
     * need to compare this value to whether the commitment transaction in question is that of
     * the counterparty or our own.
     */ get_offered() {
        const ret = _bindingsMjs.HTLCOutputInCommitment_get_offered(this.ptr);
        return ret;
    }
    /**
     * Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction).
     * Note that this is not the same as whether it is ountbound *from us*. To determine that you
     * need to compare this value to whether the commitment transaction in question is that of
     * the counterparty or our own.
     */ set_offered(val) {
        _bindingsMjs.HTLCOutputInCommitment_set_offered(this.ptr, val);
    }
    /**
     * The value, in msat, of the HTLC. The value as it appears in the commitment transaction is
     * this divided by 1000.
     */ get_amount_msat() {
        const ret = _bindingsMjs.HTLCOutputInCommitment_get_amount_msat(this.ptr);
        return ret;
    }
    /**
     * The value, in msat, of the HTLC. The value as it appears in the commitment transaction is
     * this divided by 1000.
     */ set_amount_msat(val) {
        _bindingsMjs.HTLCOutputInCommitment_set_amount_msat(this.ptr, val);
    }
    /**
     * The CLTV lock-time at which this HTLC expires.
     */ get_cltv_expiry() {
        const ret = _bindingsMjs.HTLCOutputInCommitment_get_cltv_expiry(this.ptr);
        return ret;
    }
    /**
     * The CLTV lock-time at which this HTLC expires.
     */ set_cltv_expiry(val) {
        _bindingsMjs.HTLCOutputInCommitment_set_cltv_expiry(this.ptr, val);
    }
    /**
     * The hash of the preimage which unlocks this HTLC.
     */ get_payment_hash() {
        const ret = _bindingsMjs.HTLCOutputInCommitment_get_payment_hash(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The hash of the preimage which unlocks this HTLC.
     */ set_payment_hash(val) {
        _bindingsMjs.HTLCOutputInCommitment_set_payment_hash(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The position within the commitment transactions' outputs. This may be None if the value is
     * below the dust limit (in which case no output appears in the commitment transaction and the
     * value is spent to additional transaction fees).
     */ get_transaction_output_index() {
        const ret = _bindingsMjs.HTLCOutputInCommitment_get_transaction_output_index(this.ptr);
        const ret_hu_conv = _optionU32ZMjs.Option_u32Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The position within the commitment transactions' outputs. This may be None if the value is
     * below the dust limit (in which case no output appears in the commitment transaction and the
     * value is spent to additional transaction fees).
     */ set_transaction_output_index(val) {
        _bindingsMjs.HTLCOutputInCommitment_set_transaction_output_index(this.ptr, _commonBaseMjsDefault.default.get_ptr_of(val));
    }
    /**
     * Constructs a new HTLCOutputInCommitment given each field
     */ static constructor_new(offered_arg, amount_msat_arg, cltv_expiry_arg, payment_hash_arg, transaction_output_index_arg) {
        const ret = _bindingsMjs.HTLCOutputInCommitment_new(offered_arg, amount_msat_arg, cltv_expiry_arg, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_hash_arg, 32)), _commonBaseMjsDefault.default.get_ptr_of(transaction_output_index_arg));
        const ret_hu_conv = new HTLCOutputInCommitment(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.HTLCOutputInCommitment_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the HTLCOutputInCommitment
     */ clone() {
        const ret = _bindingsMjs.HTLCOutputInCommitment_clone(this.ptr);
        const ret_hu_conv = new HTLCOutputInCommitment(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the HTLCOutputInCommitment object into a byte array which can be read by HTLCOutputInCommitment_read
     */ write() {
        const ret = _bindingsMjs.HTLCOutputInCommitment_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a HTLCOutputInCommitment from a byte array, created by HTLCOutputInCommitment_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.HTLCOutputInCommitment_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultHTLCOutputInCommitmentDecodeErrorZMjs.Result_HTLCOutputInCommitmentDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Option_u32Z.mjs":"iQp9f","../structs/Result_HTLCOutputInCommitmentDecodeErrorZ.mjs":"lOokA","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lOokA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_HTLCOutputInCommitmentDecodeErrorZ", ()=>Result_HTLCOutputInCommitmentDecodeErrorZ
);
parcelHelpers.export(exports, "Result_HTLCOutputInCommitmentDecodeErrorZ_OK", ()=>Result_HTLCOutputInCommitmentDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_HTLCOutputInCommitmentDecodeErrorZ_Err", ()=>Result_HTLCOutputInCommitmentDecodeErrorZ_Err
) //# sourceMappingURL=Result_HTLCOutputInCommitmentDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _htlcoutputInCommitmentMjs = require("../structs/HTLCOutputInCommitment.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_HTLCOutputInCommitmentDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_HTLCOutputInCommitmentDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(ptr)) return new Result_HTLCOutputInCommitmentDecodeErrorZ_OK(null, ptr);
        else return new Result_HTLCOutputInCommitmentDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_HTLCOutputInCommitmentDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_HTLCOutputInCommitmentDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_HTLCOutputInCommitmentDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_HTLCOutputInCommitmentDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_HTLCOutputInCommitmentDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_HTLCOutputInCommitmentDecodeErrorZ_OK extends Result_HTLCOutputInCommitmentDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_HTLCOutputInCommitmentDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _htlcoutputInCommitmentMjs.HTLCOutputInCommitment(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_HTLCOutputInCommitmentDecodeErrorZ_Err extends Result_HTLCOutputInCommitmentDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_HTLCOutputInCommitmentDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/HTLCOutputInCommitment.mjs":"9o6Rh","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cJkQt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Late-bound per-channel counterparty data used to build transactions.
 */ parcelHelpers.export(exports, "CounterpartyChannelTransactionParameters", ()=>CounterpartyChannelTransactionParameters
) //# sourceMappingURL=CounterpartyChannelTransactionParameters.mjs.map
;
var _channelPublicKeysMjs = require("../structs/ChannelPublicKeys.mjs");
var _resultCounterpartyChannelTransactionParametersDecodeErrorZMjs = require("../structs/Result_CounterpartyChannelTransactionParametersDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class CounterpartyChannelTransactionParameters extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CounterpartyChannelTransactionParameters_free);
    }
    /**
     * Counter-party public keys
     */ get_pubkeys() {
        const ret = _bindingsMjs.CounterpartyChannelTransactionParameters_get_pubkeys(this.ptr);
        const ret_hu_conv = new _channelPublicKeysMjs.ChannelPublicKeys(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Counter-party public keys
     */ set_pubkeys(val) {
        _bindingsMjs.CounterpartyChannelTransactionParameters_set_pubkeys(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * The contest delay selected by the counterparty, which applies to holder-broadcast transactions
     */ get_selected_contest_delay() {
        const ret = _bindingsMjs.CounterpartyChannelTransactionParameters_get_selected_contest_delay(this.ptr);
        return ret;
    }
    /**
     * The contest delay selected by the counterparty, which applies to holder-broadcast transactions
     */ set_selected_contest_delay(val) {
        _bindingsMjs.CounterpartyChannelTransactionParameters_set_selected_contest_delay(this.ptr, val);
    }
    /**
     * Constructs a new CounterpartyChannelTransactionParameters given each field
     */ static constructor_new(pubkeys_arg, selected_contest_delay_arg) {
        const ret = _bindingsMjs.CounterpartyChannelTransactionParameters_new(pubkeys_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(pubkeys_arg) & -2, selected_contest_delay_arg);
        const ret_hu_conv = new CounterpartyChannelTransactionParameters(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CounterpartyChannelTransactionParameters_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the CounterpartyChannelTransactionParameters
     */ clone() {
        const ret = _bindingsMjs.CounterpartyChannelTransactionParameters_clone(this.ptr);
        const ret_hu_conv = new CounterpartyChannelTransactionParameters(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the CounterpartyChannelTransactionParameters object into a byte array which can be read by CounterpartyChannelTransactionParameters_read
     */ write() {
        const ret = _bindingsMjs.CounterpartyChannelTransactionParameters_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a CounterpartyChannelTransactionParameters from a byte array, created by CounterpartyChannelTransactionParameters_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.CounterpartyChannelTransactionParameters_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultCounterpartyChannelTransactionParametersDecodeErrorZMjs.Result_CounterpartyChannelTransactionParametersDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/ChannelPublicKeys.mjs":"a8cA2","../structs/Result_CounterpartyChannelTransactionParametersDecodeErrorZ.mjs":"2LLTo","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2LLTo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_CounterpartyChannelTransactionParametersDecodeErrorZ", ()=>Result_CounterpartyChannelTransactionParametersDecodeErrorZ
);
parcelHelpers.export(exports, "Result_CounterpartyChannelTransactionParametersDecodeErrorZ_OK", ()=>Result_CounterpartyChannelTransactionParametersDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_CounterpartyChannelTransactionParametersDecodeErrorZ_Err", ()=>Result_CounterpartyChannelTransactionParametersDecodeErrorZ_Err
) //# sourceMappingURL=Result_CounterpartyChannelTransactionParametersDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _counterpartyChannelTransactionParametersMjs = require("../structs/CounterpartyChannelTransactionParameters.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_CounterpartyChannelTransactionParametersDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(ptr)) return new Result_CounterpartyChannelTransactionParametersDecodeErrorZ_OK(null, ptr);
        else return new Result_CounterpartyChannelTransactionParametersDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_CounterpartyChannelTransactionParametersDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_CounterpartyChannelTransactionParametersDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_CounterpartyChannelTransactionParametersDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_CounterpartyChannelTransactionParametersDecodeErrorZ_OK extends Result_CounterpartyChannelTransactionParametersDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _counterpartyChannelTransactionParametersMjs.CounterpartyChannelTransactionParameters(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_CounterpartyChannelTransactionParametersDecodeErrorZ_Err extends Result_CounterpartyChannelTransactionParametersDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/CounterpartyChannelTransactionParameters.mjs":"cJkQt","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dkG9C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Per-channel data used to build transactions in conjunction with the per-commitment data (CommitmentTransaction).
 * The fields are organized by holder/counterparty.
 *
 * Normally, this is converted to the broadcaster/countersignatory-organized DirectedChannelTransactionParameters
 * before use, via the as_holder_broadcastable and as_counterparty_broadcastable functions.
 */ parcelHelpers.export(exports, "ChannelTransactionParameters", ()=>ChannelTransactionParameters
) //# sourceMappingURL=ChannelTransactionParameters.mjs.map
;
var _outPointMjs = require("../structs/OutPoint.mjs");
var _channelPublicKeysMjs = require("../structs/ChannelPublicKeys.mjs");
var _counterpartyChannelTransactionParametersMjs = require("../structs/CounterpartyChannelTransactionParameters.mjs");
var _resultChannelTransactionParametersDecodeErrorZMjs = require("../structs/Result_ChannelTransactionParametersDecodeErrorZ.mjs");
var _directedChannelTransactionParametersMjs = require("../structs/DirectedChannelTransactionParameters.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelTransactionParameters extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelTransactionParameters_free);
    }
    /**
     * Holder public keys
     */ get_holder_pubkeys() {
        const ret = _bindingsMjs.ChannelTransactionParameters_get_holder_pubkeys(this.ptr);
        const ret_hu_conv = new _channelPublicKeysMjs.ChannelPublicKeys(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Holder public keys
     */ set_holder_pubkeys(val) {
        _bindingsMjs.ChannelTransactionParameters_set_holder_pubkeys(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * The contest delay selected by the holder, which applies to counterparty-broadcast transactions
     */ get_holder_selected_contest_delay() {
        const ret = _bindingsMjs.ChannelTransactionParameters_get_holder_selected_contest_delay(this.ptr);
        return ret;
    }
    /**
     * The contest delay selected by the holder, which applies to counterparty-broadcast transactions
     */ set_holder_selected_contest_delay(val) {
        _bindingsMjs.ChannelTransactionParameters_set_holder_selected_contest_delay(this.ptr, val);
    }
    /**
     * Whether the holder is the initiator of this channel.
     * This is an input to the commitment number obscure factor computation.
     */ get_is_outbound_from_holder() {
        const ret = _bindingsMjs.ChannelTransactionParameters_get_is_outbound_from_holder(this.ptr);
        return ret;
    }
    /**
     * Whether the holder is the initiator of this channel.
     * This is an input to the commitment number obscure factor computation.
     */ set_is_outbound_from_holder(val) {
        _bindingsMjs.ChannelTransactionParameters_set_is_outbound_from_holder(this.ptr, val);
    }
    /**
     * The late-bound counterparty channel transaction parameters.
     * These parameters are populated at the point in the protocol where the counterparty provides them.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_counterparty_parameters() {
        const ret = _bindingsMjs.ChannelTransactionParameters_get_counterparty_parameters(this.ptr);
        const ret_hu_conv = new _counterpartyChannelTransactionParametersMjs.CounterpartyChannelTransactionParameters(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The late-bound counterparty channel transaction parameters.
     * These parameters are populated at the point in the protocol where the counterparty provides them.
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_counterparty_parameters(val) {
        _bindingsMjs.ChannelTransactionParameters_set_counterparty_parameters(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * The late-bound funding outpoint
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_funding_outpoint() {
        const ret = _bindingsMjs.ChannelTransactionParameters_get_funding_outpoint(this.ptr);
        const ret_hu_conv = new _outPointMjs.OutPoint(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The late-bound funding outpoint
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_funding_outpoint(val) {
        _bindingsMjs.ChannelTransactionParameters_set_funding_outpoint(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Are anchors used for this channel.  Boolean is serialization backwards-compatible
     */ get_opt_anchors() {
        const ret = _bindingsMjs.ChannelTransactionParameters_get_opt_anchors(this.ptr);
        return ret;
    }
    /**
     * Are anchors used for this channel.  Boolean is serialization backwards-compatible
     */ set_opt_anchors(val) {
        _bindingsMjs.ChannelTransactionParameters_set_opt_anchors(this.ptr, val);
    }
    /**
     * Constructs a new ChannelTransactionParameters given each field
     */ static constructor_new(holder_pubkeys_arg, holder_selected_contest_delay_arg, is_outbound_from_holder_arg, counterparty_parameters_arg, funding_outpoint_arg, opt_anchors_arg) {
        const ret = _bindingsMjs.ChannelTransactionParameters_new(holder_pubkeys_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(holder_pubkeys_arg) & -2, holder_selected_contest_delay_arg, is_outbound_from_holder_arg, counterparty_parameters_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(counterparty_parameters_arg) & -2, funding_outpoint_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(funding_outpoint_arg) & -2, opt_anchors_arg);
        const ret_hu_conv = new ChannelTransactionParameters(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ChannelTransactionParameters_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelTransactionParameters
     */ clone() {
        const ret = _bindingsMjs.ChannelTransactionParameters_clone(this.ptr);
        const ret_hu_conv = new ChannelTransactionParameters(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Whether the late bound parameters are populated.
     */ is_populated() {
        const ret = _bindingsMjs.ChannelTransactionParameters_is_populated(this.ptr);
        return ret;
    }
    /**
     * Convert the holder/counterparty parameters to broadcaster/countersignatory-organized parameters,
     * given that the holder is the broadcaster.
     *
     * self.is_populated() must be true before calling this function.
     */ as_holder_broadcastable() {
        const ret = _bindingsMjs.ChannelTransactionParameters_as_holder_broadcastable(this.ptr);
        const ret_hu_conv = new _directedChannelTransactionParametersMjs.DirectedChannelTransactionParameters(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Convert the holder/counterparty parameters to broadcaster/countersignatory-organized parameters,
     * given that the counterparty is the broadcaster.
     *
     * self.is_populated() must be true before calling this function.
     */ as_counterparty_broadcastable() {
        const ret = _bindingsMjs.ChannelTransactionParameters_as_counterparty_broadcastable(this.ptr);
        const ret_hu_conv = new _directedChannelTransactionParametersMjs.DirectedChannelTransactionParameters(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the ChannelTransactionParameters object into a byte array which can be read by ChannelTransactionParameters_read
     */ write() {
        const ret = _bindingsMjs.ChannelTransactionParameters_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ChannelTransactionParameters from a byte array, created by ChannelTransactionParameters_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ChannelTransactionParameters_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultChannelTransactionParametersDecodeErrorZMjs.Result_ChannelTransactionParametersDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/OutPoint.mjs":"9FTof","../structs/ChannelPublicKeys.mjs":"a8cA2","../structs/CounterpartyChannelTransactionParameters.mjs":"cJkQt","../structs/Result_ChannelTransactionParametersDecodeErrorZ.mjs":"aP1RM","../structs/DirectedChannelTransactionParameters.mjs":"3x7rH","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aP1RM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ChannelTransactionParametersDecodeErrorZ", ()=>Result_ChannelTransactionParametersDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ChannelTransactionParametersDecodeErrorZ_OK", ()=>Result_ChannelTransactionParametersDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ChannelTransactionParametersDecodeErrorZ_Err", ()=>Result_ChannelTransactionParametersDecodeErrorZ_Err
) //# sourceMappingURL=Result_ChannelTransactionParametersDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _channelTransactionParametersMjs = require("../structs/ChannelTransactionParameters.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ChannelTransactionParametersDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ChannelTransactionParametersDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(ptr)) return new Result_ChannelTransactionParametersDecodeErrorZ_OK(null, ptr);
        else return new Result_ChannelTransactionParametersDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ChannelTransactionParametersDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ChannelTransactionParametersDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ChannelTransactionParametersDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ChannelTransactionParametersDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ChannelTransactionParametersDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ChannelTransactionParametersDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_ChannelTransactionParametersDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_ChannelTransactionParametersDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_ChannelTransactionParametersDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_ChannelTransactionParametersDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_ChannelTransactionParametersDecodeErrorZ_OK extends Result_ChannelTransactionParametersDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ChannelTransactionParametersDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _channelTransactionParametersMjs.ChannelTransactionParameters(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ChannelTransactionParametersDecodeErrorZ_Err extends Result_ChannelTransactionParametersDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ChannelTransactionParametersDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/ChannelTransactionParameters.mjs":"dkG9C","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3x7rH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Static channel fields used to build transactions given per-commitment fields, organized by
 * broadcaster/countersignatory.
 *
 * This is derived from the holder/counterparty-organized ChannelTransactionParameters via the
 * as_holder_broadcastable and as_counterparty_broadcastable functions.
 */ parcelHelpers.export(exports, "DirectedChannelTransactionParameters", ()=>DirectedChannelTransactionParameters
) //# sourceMappingURL=DirectedChannelTransactionParameters.mjs.map
;
var _outPointMjs = require("../structs/OutPoint.mjs");
var _channelPublicKeysMjs = require("../structs/ChannelPublicKeys.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class DirectedChannelTransactionParameters extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.DirectedChannelTransactionParameters_free);
    }
    /**
     * Get the channel pubkeys for the broadcaster
     */ broadcaster_pubkeys() {
        const ret = _bindingsMjs.DirectedChannelTransactionParameters_broadcaster_pubkeys(this.ptr);
        const ret_hu_conv = new _channelPublicKeysMjs.ChannelPublicKeys(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Get the channel pubkeys for the countersignatory
     */ countersignatory_pubkeys() {
        const ret = _bindingsMjs.DirectedChannelTransactionParameters_countersignatory_pubkeys(this.ptr);
        const ret_hu_conv = new _channelPublicKeysMjs.ChannelPublicKeys(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Get the contest delay applicable to the transactions.
     * Note that the contest delay was selected by the countersignatory.
     */ contest_delay() {
        const ret = _bindingsMjs.DirectedChannelTransactionParameters_contest_delay(this.ptr);
        return ret;
    }
    /**
     * Whether the channel is outbound from the broadcaster.
     *
     * The boolean representing the side that initiated the channel is
     * an input to the commitment number obscure factor computation.
     */ is_outbound() {
        const ret = _bindingsMjs.DirectedChannelTransactionParameters_is_outbound(this.ptr);
        return ret;
    }
    /**
     * The funding outpoint
     */ funding_outpoint() {
        const ret = _bindingsMjs.DirectedChannelTransactionParameters_funding_outpoint(this.ptr);
        const ret_hu_conv = new _outPointMjs.OutPoint(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Whether to use anchors for this channel
     */ opt_anchors() {
        const ret = _bindingsMjs.DirectedChannelTransactionParameters_opt_anchors(this.ptr);
        return ret;
    }
}

},{"../structs/OutPoint.mjs":"9FTof","../structs/ChannelPublicKeys.mjs":"a8cA2","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gvilr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Information needed to build and sign a holder's commitment transaction.
 *
 * The transaction is only signed once we are ready to broadcast.
 */ parcelHelpers.export(exports, "HolderCommitmentTransaction", ()=>HolderCommitmentTransaction
) //# sourceMappingURL=HolderCommitmentTransaction.mjs.map
;
var _resultHolderCommitmentTransactionDecodeErrorZMjs = require("../structs/Result_HolderCommitmentTransactionDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class HolderCommitmentTransaction extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.HolderCommitmentTransaction_free);
    }
    /**
     * Our counterparty's signature for the transaction
     */ get_counterparty_sig() {
        const ret = _bindingsMjs.HolderCommitmentTransaction_get_counterparty_sig(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Our counterparty's signature for the transaction
     */ set_counterparty_sig(val) {
        _bindingsMjs.HolderCommitmentTransaction_set_counterparty_sig(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 64)));
    }
    /**
     * All non-dust counterparty HTLC signatures, in the order they appear in the transaction
     */ set_counterparty_htlc_sigs(val) {
        _bindingsMjs.HolderCommitmentTransaction_set_counterparty_htlc_sigs(this.ptr, _bindingsMjs.encodeUint32Array(val != null ? val.map((val_conv_12)=>_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val_conv_12, 64))
        ) : null));
    }
    clone_ptr() {
        const ret = _bindingsMjs.HolderCommitmentTransaction_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the HolderCommitmentTransaction
     */ clone() {
        const ret = _bindingsMjs.HolderCommitmentTransaction_clone(this.ptr);
        const ret_hu_conv = new HolderCommitmentTransaction(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the HolderCommitmentTransaction object into a byte array which can be read by HolderCommitmentTransaction_read
     */ write() {
        const ret = _bindingsMjs.HolderCommitmentTransaction_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a HolderCommitmentTransaction from a byte array, created by HolderCommitmentTransaction_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.HolderCommitmentTransaction_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultHolderCommitmentTransactionDecodeErrorZMjs.Result_HolderCommitmentTransactionDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Create a new holder transaction with the given counterparty signatures.
     * The funding keys are used to figure out which signature should go first when building the transaction for broadcast.
     */ static constructor_new(commitment_tx, counterparty_sig, counterparty_htlc_sigs, holder_funding_key, counterparty_funding_key) {
        const ret = _bindingsMjs.HolderCommitmentTransaction_new(commitment_tx == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(commitment_tx) & -2, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(counterparty_sig, 64)), _bindingsMjs.encodeUint32Array(counterparty_htlc_sigs != null ? counterparty_htlc_sigs.map((counterparty_htlc_sigs_conv_12)=>_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(counterparty_htlc_sigs_conv_12, 64))
        ) : null), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(holder_funding_key, 33)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(counterparty_funding_key, 33)));
        const ret_hu_conv = new HolderCommitmentTransaction(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"../structs/Result_HolderCommitmentTransactionDecodeErrorZ.mjs":"9ufPL","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9ufPL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_HolderCommitmentTransactionDecodeErrorZ", ()=>Result_HolderCommitmentTransactionDecodeErrorZ
);
parcelHelpers.export(exports, "Result_HolderCommitmentTransactionDecodeErrorZ_OK", ()=>Result_HolderCommitmentTransactionDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_HolderCommitmentTransactionDecodeErrorZ_Err", ()=>Result_HolderCommitmentTransactionDecodeErrorZ_Err
) //# sourceMappingURL=Result_HolderCommitmentTransactionDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _holderCommitmentTransactionMjs = require("../structs/HolderCommitmentTransaction.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_HolderCommitmentTransactionDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_HolderCommitmentTransactionDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(ptr)) return new Result_HolderCommitmentTransactionDecodeErrorZ_OK(null, ptr);
        else return new Result_HolderCommitmentTransactionDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_HolderCommitmentTransactionDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_HolderCommitmentTransactionDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_HolderCommitmentTransactionDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_HolderCommitmentTransactionDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_HolderCommitmentTransactionDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_HolderCommitmentTransactionDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_HolderCommitmentTransactionDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_HolderCommitmentTransactionDecodeErrorZ_OK extends Result_HolderCommitmentTransactionDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_HolderCommitmentTransactionDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _holderCommitmentTransactionMjs.HolderCommitmentTransaction(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_HolderCommitmentTransactionDecodeErrorZ_Err extends Result_HolderCommitmentTransactionDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_HolderCommitmentTransactionDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/HolderCommitmentTransaction.mjs":"gvilr","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"32tCI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A pre-built Bitcoin commitment transaction and its txid.
 */ parcelHelpers.export(exports, "BuiltCommitmentTransaction", ()=>BuiltCommitmentTransaction
) //# sourceMappingURL=BuiltCommitmentTransaction.mjs.map
;
var _resultBuiltCommitmentTransactionDecodeErrorZMjs = require("../structs/Result_BuiltCommitmentTransactionDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class BuiltCommitmentTransaction extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.BuiltCommitmentTransaction_free);
    }
    /**
     * The commitment transaction
     */ get_transaction() {
        const ret = _bindingsMjs.BuiltCommitmentTransaction_get_transaction(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The commitment transaction
     */ set_transaction(val) {
        _bindingsMjs.BuiltCommitmentTransaction_set_transaction(this.ptr, _bindingsMjs.encodeUint8Array(val));
    }
    /**
     * The txid for the commitment transaction.
     *
     * This is provided as a performance optimization, instead of calling transaction.txid()
     * multiple times.
     */ get_txid() {
        const ret = _bindingsMjs.BuiltCommitmentTransaction_get_txid(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The txid for the commitment transaction.
     *
     * This is provided as a performance optimization, instead of calling transaction.txid()
     * multiple times.
     */ set_txid(val) {
        _bindingsMjs.BuiltCommitmentTransaction_set_txid(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * Constructs a new BuiltCommitmentTransaction given each field
     */ static constructor_new(transaction_arg, txid_arg) {
        const ret = _bindingsMjs.BuiltCommitmentTransaction_new(_bindingsMjs.encodeUint8Array(transaction_arg), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(txid_arg, 32)));
        const ret_hu_conv = new BuiltCommitmentTransaction(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.BuiltCommitmentTransaction_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the BuiltCommitmentTransaction
     */ clone() {
        const ret = _bindingsMjs.BuiltCommitmentTransaction_clone(this.ptr);
        const ret_hu_conv = new BuiltCommitmentTransaction(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the BuiltCommitmentTransaction object into a byte array which can be read by BuiltCommitmentTransaction_read
     */ write() {
        const ret = _bindingsMjs.BuiltCommitmentTransaction_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a BuiltCommitmentTransaction from a byte array, created by BuiltCommitmentTransaction_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.BuiltCommitmentTransaction_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultBuiltCommitmentTransactionDecodeErrorZMjs.Result_BuiltCommitmentTransactionDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Get the SIGHASH_ALL sighash value of the transaction.
     *
     * This can be used to verify a signature.
     */ get_sighash_all(funding_redeemscript, channel_value_satoshis) {
        const ret = _bindingsMjs.BuiltCommitmentTransaction_get_sighash_all(this.ptr, _bindingsMjs.encodeUint8Array(funding_redeemscript), channel_value_satoshis);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Sign a transaction, either because we are counter-signing the counterparty's transaction or
     * because we are about to broadcast a holder transaction.
     */ sign(funding_key, funding_redeemscript, channel_value_satoshis) {
        const ret = _bindingsMjs.BuiltCommitmentTransaction_sign(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(funding_key, 32)), _bindingsMjs.encodeUint8Array(funding_redeemscript), channel_value_satoshis);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
}

},{"../structs/Result_BuiltCommitmentTransactionDecodeErrorZ.mjs":"iI9jh","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iI9jh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_BuiltCommitmentTransactionDecodeErrorZ", ()=>Result_BuiltCommitmentTransactionDecodeErrorZ
);
parcelHelpers.export(exports, "Result_BuiltCommitmentTransactionDecodeErrorZ_OK", ()=>Result_BuiltCommitmentTransactionDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_BuiltCommitmentTransactionDecodeErrorZ_Err", ()=>Result_BuiltCommitmentTransactionDecodeErrorZ_Err
) //# sourceMappingURL=Result_BuiltCommitmentTransactionDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _builtCommitmentTransactionMjs = require("../structs/BuiltCommitmentTransaction.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_BuiltCommitmentTransactionDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_BuiltCommitmentTransactionDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(ptr)) return new Result_BuiltCommitmentTransactionDecodeErrorZ_OK(null, ptr);
        else return new Result_BuiltCommitmentTransactionDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_BuiltCommitmentTransactionDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_BuiltCommitmentTransactionDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_BuiltCommitmentTransactionDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_BuiltCommitmentTransactionDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_BuiltCommitmentTransactionDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_BuiltCommitmentTransactionDecodeErrorZ_OK extends Result_BuiltCommitmentTransactionDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_BuiltCommitmentTransactionDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _builtCommitmentTransactionMjs.BuiltCommitmentTransaction(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_BuiltCommitmentTransactionDecodeErrorZ_Err extends Result_BuiltCommitmentTransactionDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_BuiltCommitmentTransactionDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/BuiltCommitmentTransaction.mjs":"32tCI","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"czsNn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A wrapper on ClosingTransaction indicating that the built bitcoin
 * transaction is trusted.
 *
 * See trust() and verify() functions on CommitmentTransaction.
 *
 * This structure implements Deref.
 */ parcelHelpers.export(exports, "TrustedClosingTransaction", ()=>TrustedClosingTransaction
) //# sourceMappingURL=TrustedClosingTransaction.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class TrustedClosingTransaction extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.TrustedClosingTransaction_free);
    }
    /**
     * The pre-built Bitcoin commitment transaction
     */ built_transaction() {
        const ret = _bindingsMjs.TrustedClosingTransaction_built_transaction(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Get the SIGHASH_ALL sighash value of the transaction.
     *
     * This can be used to verify a signature.
     */ get_sighash_all(funding_redeemscript, channel_value_satoshis) {
        const ret = _bindingsMjs.TrustedClosingTransaction_get_sighash_all(this.ptr, _bindingsMjs.encodeUint8Array(funding_redeemscript), channel_value_satoshis);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Sign a transaction, either because we are counter-signing the counterparty's transaction or
     * because we are about to broadcast a holder transaction.
     */ sign(funding_key, funding_redeemscript, channel_value_satoshis) {
        const ret = _bindingsMjs.TrustedClosingTransaction_sign(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(funding_key, 32)), _bindingsMjs.encodeUint8Array(funding_redeemscript), channel_value_satoshis);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aFYlU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_TrustedClosingTransactionNoneZ", ()=>Result_TrustedClosingTransactionNoneZ
);
parcelHelpers.export(exports, "Result_TrustedClosingTransactionNoneZ_OK", ()=>Result_TrustedClosingTransactionNoneZ_OK
);
parcelHelpers.export(exports, "Result_TrustedClosingTransactionNoneZ_Err", ()=>Result_TrustedClosingTransactionNoneZ_Err
) //# sourceMappingURL=Result_TrustedClosingTransactionNoneZ.mjs.map
;
var _trustedClosingTransactionMjs = require("../structs/TrustedClosingTransaction.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_TrustedClosingTransactionNoneZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_TrustedClosingTransactionNoneZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_TrustedClosingTransactionNoneZ_is_ok(ptr)) return new Result_TrustedClosingTransactionNoneZ_OK(null, ptr);
        else return new Result_TrustedClosingTransactionNoneZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_TrustedClosingTransactionNoneZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_TrustedClosingTransactionNoneZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_TrustedClosingTransactionNoneZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, o);
        // Due to rust's strict-ownership memory model, in some cases we need to "move"
        // an object to pass exclusive ownership to the function being called.
        // In most cases, we avoid ret_hu_conv being visible in GC'd languages by cloning the object
        // at the FFI layer, creating a new object which Rust can claim ownership of
        // However, in some cases (eg here), there is no way to clone an object, and thus
        // we actually have to pass full ownership to Rust.
        // Thus, after ret_hu_conv call, o is reset to null and is now a dummy object.
        _commonBaseMjsDefault.default.set_null_skip_free(o);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_TrustedClosingTransactionNoneZ in the error state.
     */ static constructor_err() {
        const ret = _bindingsMjs.CResult_TrustedClosingTransactionNoneZ_err();
        const ret_hu_conv = Result_TrustedClosingTransactionNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_TrustedClosingTransactionNoneZ_is_ok(this.ptr);
        return ret;
    }
}
class Result_TrustedClosingTransactionNoneZ_OK extends Result_TrustedClosingTransactionNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_TrustedClosingTransactionNoneZ_get_ok(ptr);
        const res_hu_conv = new _trustedClosingTransactionMjs.TrustedClosingTransaction(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_TrustedClosingTransactionNoneZ_Err extends Result_TrustedClosingTransactionNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}

},{"../structs/TrustedClosingTransaction.mjs":"czsNn","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jcnCV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This class tracks the per-transaction information needed to build a commitment transaction and will
 * actually build it and sign.  It is used for holder transactions that we sign only when needed
 * and for transactions we sign for the counterparty.
 *
 * This class can be used inside a signer implementation to generate a signature given the relevant
 * secret key.
 */ parcelHelpers.export(exports, "CommitmentTransaction", ()=>CommitmentTransaction
) //# sourceMappingURL=CommitmentTransaction.mjs.map
;
var _resultCommitmentTransactionDecodeErrorZMjs = require("../structs/Result_CommitmentTransactionDecodeErrorZ.mjs");
var _trustedCommitmentTransactionMjs = require("../structs/TrustedCommitmentTransaction.mjs");
var _resultTrustedCommitmentTransactionNoneZMjs = require("../structs/Result_TrustedCommitmentTransactionNoneZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class CommitmentTransaction extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CommitmentTransaction_free);
    }
    clone_ptr() {
        const ret = _bindingsMjs.CommitmentTransaction_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the CommitmentTransaction
     */ clone() {
        const ret = _bindingsMjs.CommitmentTransaction_clone(this.ptr);
        const ret_hu_conv = new CommitmentTransaction(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the CommitmentTransaction object into a byte array which can be read by CommitmentTransaction_read
     */ write() {
        const ret = _bindingsMjs.CommitmentTransaction_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a CommitmentTransaction from a byte array, created by CommitmentTransaction_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.CommitmentTransaction_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultCommitmentTransactionDecodeErrorZMjs.Result_CommitmentTransactionDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * The backwards-counting commitment number
     */ commitment_number() {
        const ret = _bindingsMjs.CommitmentTransaction_commitment_number(this.ptr);
        return ret;
    }
    /**
     * The value to be sent to the broadcaster
     */ to_broadcaster_value_sat() {
        const ret = _bindingsMjs.CommitmentTransaction_to_broadcaster_value_sat(this.ptr);
        return ret;
    }
    /**
     * The value to be sent to the counterparty
     */ to_countersignatory_value_sat() {
        const ret = _bindingsMjs.CommitmentTransaction_to_countersignatory_value_sat(this.ptr);
        return ret;
    }
    /**
     * The feerate paid per 1000-weight-unit in this commitment transaction.
     */ feerate_per_kw() {
        const ret = _bindingsMjs.CommitmentTransaction_feerate_per_kw(this.ptr);
        return ret;
    }
    /**
     * Trust our pre-built transaction and derived transaction creation public keys.
     *
     * Applies a wrapper which allows access to these fields.
     *
     * This should only be used if you fully trust the builder of this object.  It should not
     * be used by an external signer - instead use the verify function.
     */ trust() {
        const ret = _bindingsMjs.CommitmentTransaction_trust(this.ptr);
        const ret_hu_conv = new _trustedCommitmentTransactionMjs.TrustedCommitmentTransaction(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Verify our pre-built transaction and derived transaction creation public keys.
     *
     * Applies a wrapper which allows access to these fields.
     *
     * An external validating signer must call this method before signing
     * or using the built transaction.
     */ verify(channel_parameters, broadcaster_keys, countersignatory_keys) {
        const ret = _bindingsMjs.CommitmentTransaction_verify(this.ptr, channel_parameters == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(channel_parameters) & -2, broadcaster_keys == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(broadcaster_keys) & -2, countersignatory_keys == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(countersignatory_keys) & -2);
        const ret_hu_conv = _resultTrustedCommitmentTransactionNoneZMjs.Result_TrustedCommitmentTransactionNoneZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, channel_parameters);
        _commonBaseMjsDefault.default.add_ref_from(this, broadcaster_keys);
        _commonBaseMjsDefault.default.add_ref_from(this, countersignatory_keys);
        return ret_hu_conv;
    }
}

},{"../structs/Result_CommitmentTransactionDecodeErrorZ.mjs":"6bKwL","../structs/TrustedCommitmentTransaction.mjs":"j4RrW","../structs/Result_TrustedCommitmentTransactionNoneZ.mjs":"21NFv","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6bKwL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_CommitmentTransactionDecodeErrorZ", ()=>Result_CommitmentTransactionDecodeErrorZ
);
parcelHelpers.export(exports, "Result_CommitmentTransactionDecodeErrorZ_OK", ()=>Result_CommitmentTransactionDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_CommitmentTransactionDecodeErrorZ_Err", ()=>Result_CommitmentTransactionDecodeErrorZ_Err
) //# sourceMappingURL=Result_CommitmentTransactionDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _commitmentTransactionMjs = require("../structs/CommitmentTransaction.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_CommitmentTransactionDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_CommitmentTransactionDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_CommitmentTransactionDecodeErrorZ_is_ok(ptr)) return new Result_CommitmentTransactionDecodeErrorZ_OK(null, ptr);
        else return new Result_CommitmentTransactionDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_CommitmentTransactionDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_CommitmentTransactionDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_CommitmentTransactionDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_CommitmentTransactionDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_CommitmentTransactionDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_CommitmentTransactionDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_CommitmentTransactionDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_CommitmentTransactionDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_CommitmentTransactionDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_CommitmentTransactionDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_CommitmentTransactionDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_CommitmentTransactionDecodeErrorZ_OK extends Result_CommitmentTransactionDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_CommitmentTransactionDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _commitmentTransactionMjs.CommitmentTransaction(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_CommitmentTransactionDecodeErrorZ_Err extends Result_CommitmentTransactionDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_CommitmentTransactionDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/CommitmentTransaction.mjs":"jcnCV","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j4RrW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A wrapper on CommitmentTransaction indicating that the derived fields (the built bitcoin
 * transaction and the transaction creation keys) are trusted.
 *
 * See trust() and verify() functions on CommitmentTransaction.
 *
 * This structure implements Deref.
 */ parcelHelpers.export(exports, "TrustedCommitmentTransaction", ()=>TrustedCommitmentTransaction
) //# sourceMappingURL=TrustedCommitmentTransaction.mjs.map
;
var _txCreationKeysMjs = require("../structs/TxCreationKeys.mjs");
var _builtCommitmentTransactionMjs = require("../structs/BuiltCommitmentTransaction.mjs");
var _resultCVecSignatureZNoneZMjs = require("../structs/Result_CVec_SignatureZNoneZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class TrustedCommitmentTransaction extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.TrustedCommitmentTransaction_free);
    }
    /**
     * The transaction ID of the built Bitcoin transaction
     */ txid() {
        const ret = _bindingsMjs.TrustedCommitmentTransaction_txid(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The pre-built Bitcoin commitment transaction
     */ built_transaction() {
        const ret = _bindingsMjs.TrustedCommitmentTransaction_built_transaction(this.ptr);
        const ret_hu_conv = new _builtCommitmentTransactionMjs.BuiltCommitmentTransaction(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The pre-calculated transaction creation public keys.
     */ keys() {
        const ret = _bindingsMjs.TrustedCommitmentTransaction_keys(this.ptr);
        const ret_hu_conv = new _txCreationKeysMjs.TxCreationKeys(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Should anchors be used.
     */ opt_anchors() {
        const ret = _bindingsMjs.TrustedCommitmentTransaction_opt_anchors(this.ptr);
        return ret;
    }
    /**
     * Get a signature for each HTLC which was included in the commitment transaction (ie for
     * which HTLCOutputInCommitment::transaction_output_index.is_some()).
     *
     * The returned Vec has one entry for each HTLC, and in the same order.
     */ get_htlc_sigs(htlc_base_key, channel_parameters) {
        const ret = _bindingsMjs.TrustedCommitmentTransaction_get_htlc_sigs(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(htlc_base_key, 32)), channel_parameters == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(channel_parameters) & -2);
        const ret_hu_conv = _resultCVecSignatureZNoneZMjs.Result_CVec_SignatureZNoneZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, channel_parameters);
        return ret_hu_conv;
    }
}

},{"../structs/TxCreationKeys.mjs":"gH4iE","../structs/BuiltCommitmentTransaction.mjs":"32tCI","../structs/Result_CVec_SignatureZNoneZ.mjs":"8ZcEN","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8ZcEN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_CVec_SignatureZNoneZ", ()=>Result_CVec_SignatureZNoneZ
);
parcelHelpers.export(exports, "Result_CVec_SignatureZNoneZ_OK", ()=>Result_CVec_SignatureZNoneZ_OK
);
parcelHelpers.export(exports, "Result_CVec_SignatureZNoneZ_Err", ()=>Result_CVec_SignatureZNoneZ_Err
) //# sourceMappingURL=Result_CVec_SignatureZNoneZ.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_CVec_SignatureZNoneZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_CVec_SignatureZNoneZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_CVec_SignatureZNoneZ_is_ok(ptr)) return new Result_CVec_SignatureZNoneZ_OK(null, ptr);
        else return new Result_CVec_SignatureZNoneZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_CVec_SignatureZNoneZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_CVec_SignatureZNoneZ_ok(_bindingsMjs.encodeUint32Array(o != null ? o.map((o_conv_12)=>_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(o_conv_12, 64))
        ) : null));
        const ret_hu_conv = Result_CVec_SignatureZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_CVec_SignatureZNoneZ in the error state.
     */ static constructor_err() {
        const ret = _bindingsMjs.CResult_CVec_SignatureZNoneZ_err();
        const ret_hu_conv = Result_CVec_SignatureZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_CVec_SignatureZNoneZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_CVec_SignatureZNoneZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_CVec_SignatureZNoneZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_CVec_SignatureZNoneZ_clone(this.ptr);
        const ret_hu_conv = Result_CVec_SignatureZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_CVec_SignatureZNoneZ_OK extends Result_CVec_SignatureZNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_CVec_SignatureZNoneZ_get_ok(ptr);
        const res_conv_12_len = _bindingsMjs.getArrayLength(res);
        const res_conv_12_arr = new Array(res_conv_12_len).fill(null);
        for(var m = 0; m < res_conv_12_len; m++){
            const res_conv_12 = _bindingsMjs.getU32ArrayElem(res, m);
            const res_conv_12_conv = _bindingsMjs.decodeUint8Array(res_conv_12);
            res_conv_12_arr[m] = res_conv_12_conv;
        }
        _bindingsMjs.freeWasmMemory(res);
        this.res = res_conv_12_arr;
    }
}
class Result_CVec_SignatureZNoneZ_Err extends Result_CVec_SignatureZNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"21NFv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_TrustedCommitmentTransactionNoneZ", ()=>Result_TrustedCommitmentTransactionNoneZ
);
parcelHelpers.export(exports, "Result_TrustedCommitmentTransactionNoneZ_OK", ()=>Result_TrustedCommitmentTransactionNoneZ_OK
);
parcelHelpers.export(exports, "Result_TrustedCommitmentTransactionNoneZ_Err", ()=>Result_TrustedCommitmentTransactionNoneZ_Err
) //# sourceMappingURL=Result_TrustedCommitmentTransactionNoneZ.mjs.map
;
var _trustedCommitmentTransactionMjs = require("../structs/TrustedCommitmentTransaction.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_TrustedCommitmentTransactionNoneZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_TrustedCommitmentTransactionNoneZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_TrustedCommitmentTransactionNoneZ_is_ok(ptr)) return new Result_TrustedCommitmentTransactionNoneZ_OK(null, ptr);
        else return new Result_TrustedCommitmentTransactionNoneZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_TrustedCommitmentTransactionNoneZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_TrustedCommitmentTransactionNoneZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_TrustedCommitmentTransactionNoneZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, o);
        // Due to rust's strict-ownership memory model, in some cases we need to "move"
        // an object to pass exclusive ownership to the function being called.
        // In most cases, we avoid ret_hu_conv being visible in GC'd languages by cloning the object
        // at the FFI layer, creating a new object which Rust can claim ownership of
        // However, in some cases (eg here), there is no way to clone an object, and thus
        // we actually have to pass full ownership to Rust.
        // Thus, after ret_hu_conv call, o is reset to null and is now a dummy object.
        _commonBaseMjsDefault.default.set_null_skip_free(o);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_TrustedCommitmentTransactionNoneZ in the error state.
     */ static constructor_err() {
        const ret = _bindingsMjs.CResult_TrustedCommitmentTransactionNoneZ_err();
        const ret_hu_conv = Result_TrustedCommitmentTransactionNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_TrustedCommitmentTransactionNoneZ_is_ok(this.ptr);
        return ret;
    }
}
class Result_TrustedCommitmentTransactionNoneZ_OK extends Result_TrustedCommitmentTransactionNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_TrustedCommitmentTransactionNoneZ_get_ok(ptr);
        const res_hu_conv = new _trustedCommitmentTransactionMjs.TrustedCommitmentTransaction(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_TrustedCommitmentTransactionNoneZ_Err extends Result_TrustedCommitmentTransactionNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}

},{"../structs/TrustedCommitmentTransaction.mjs":"j4RrW","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gHaa6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A script pubkey for shutting down a channel as defined by [BOLT #2].
 *
 * [BOLT #2]: https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md
 */ parcelHelpers.export(exports, "ShutdownScript", ()=>ShutdownScript
) //# sourceMappingURL=ShutdownScript.mjs.map
;
var _resultShutdownScriptDecodeErrorZMjs = require("../structs/Result_ShutdownScriptDecodeErrorZ.mjs");
var _resultShutdownScriptInvalidShutdownScriptZMjs = require("../structs/Result_ShutdownScriptInvalidShutdownScriptZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ShutdownScript extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ShutdownScript_free);
    }
    clone_ptr() {
        const ret = _bindingsMjs.ShutdownScript_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ShutdownScript
     */ clone() {
        const ret = _bindingsMjs.ShutdownScript_clone(this.ptr);
        const ret_hu_conv = new ShutdownScript(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the ShutdownScript object into a byte array which can be read by ShutdownScript_read
     */ write() {
        const ret = _bindingsMjs.ShutdownScript_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ShutdownScript from a byte array, created by ShutdownScript_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ShutdownScript_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultShutdownScriptDecodeErrorZMjs.Result_ShutdownScriptDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Generates a P2WPKH script pubkey from the given [`WPubkeyHash`].
     */ static constructor_new_p2wpkh(pubkey_hash) {
        const ret = _bindingsMjs.ShutdownScript_new_p2wpkh(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(pubkey_hash, 20)));
        const ret_hu_conv = new ShutdownScript(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Generates a P2WSH script pubkey from the given [`WScriptHash`].
     */ static constructor_new_p2wsh(script_hash) {
        const ret = _bindingsMjs.ShutdownScript_new_p2wsh(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(script_hash, 32)));
        const ret_hu_conv = new ShutdownScript(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Generates a witness script pubkey from the given segwit version and program.
     *
     * Note for version-zero witness scripts you must use [`ShutdownScript::new_p2wpkh`] or
     * [`ShutdownScript::new_p2wsh`] instead.
     *
     * # Errors
     *
     * This function may return an error if `program` is invalid for the segwit `version`.
     */ static constructor_new_witness_program(version, program) {
        const ret = _bindingsMjs.ShutdownScript_new_witness_program(version, _bindingsMjs.encodeUint8Array(program));
        const ret_hu_conv = _resultShutdownScriptInvalidShutdownScriptZMjs.Result_ShutdownScriptInvalidShutdownScriptZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Converts the shutdown script into the underlying [`Script`].
     */ into_inner() {
        const ret = _bindingsMjs.ShutdownScript_into_inner(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Returns the [`PublicKey`] used for a P2WPKH shutdown script if constructed directly from it.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ as_legacy_pubkey() {
        const ret = _bindingsMjs.ShutdownScript_as_legacy_pubkey(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Returns whether the shutdown script is compatible with the features as defined by BOLT #2.
     *
     * Specifically, checks for compliance with feature `option_shutdown_anysegwit`.
     */ is_compatible(features) {
        const ret = _bindingsMjs.ShutdownScript_is_compatible(this.ptr, features == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(features) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, features);
        return ret;
    }
}

},{"../structs/Result_ShutdownScriptDecodeErrorZ.mjs":"gfkPB","../structs/Result_ShutdownScriptInvalidShutdownScriptZ.mjs":"hMLZ1","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gfkPB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ShutdownScriptDecodeErrorZ", ()=>Result_ShutdownScriptDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ShutdownScriptDecodeErrorZ_OK", ()=>Result_ShutdownScriptDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ShutdownScriptDecodeErrorZ_Err", ()=>Result_ShutdownScriptDecodeErrorZ_Err
) //# sourceMappingURL=Result_ShutdownScriptDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _shutdownScriptMjs = require("../structs/ShutdownScript.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ShutdownScriptDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ShutdownScriptDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ShutdownScriptDecodeErrorZ_is_ok(ptr)) return new Result_ShutdownScriptDecodeErrorZ_OK(null, ptr);
        else return new Result_ShutdownScriptDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ShutdownScriptDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ShutdownScriptDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ShutdownScriptDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ShutdownScriptDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ShutdownScriptDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ShutdownScriptDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ShutdownScriptDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_ShutdownScriptDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_ShutdownScriptDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_ShutdownScriptDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_ShutdownScriptDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_ShutdownScriptDecodeErrorZ_OK extends Result_ShutdownScriptDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ShutdownScriptDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _shutdownScriptMjs.ShutdownScript(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ShutdownScriptDecodeErrorZ_Err extends Result_ShutdownScriptDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ShutdownScriptDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/ShutdownScript.mjs":"gHaa6","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hMLZ1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ShutdownScriptInvalidShutdownScriptZ", ()=>Result_ShutdownScriptInvalidShutdownScriptZ
);
parcelHelpers.export(exports, "Result_ShutdownScriptInvalidShutdownScriptZ_OK", ()=>Result_ShutdownScriptInvalidShutdownScriptZ_OK
);
parcelHelpers.export(exports, "Result_ShutdownScriptInvalidShutdownScriptZ_Err", ()=>Result_ShutdownScriptInvalidShutdownScriptZ_Err
) //# sourceMappingURL=Result_ShutdownScriptInvalidShutdownScriptZ.mjs.map
;
var _shutdownScriptMjs = require("../structs/ShutdownScript.mjs");
var _invalidShutdownScriptMjs = require("../structs/InvalidShutdownScript.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ShutdownScriptInvalidShutdownScriptZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ShutdownScriptInvalidShutdownScriptZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(ptr)) return new Result_ShutdownScriptInvalidShutdownScriptZ_OK(null, ptr);
        else return new Result_ShutdownScriptInvalidShutdownScriptZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ShutdownScriptInvalidShutdownScriptZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ShutdownScriptInvalidShutdownScriptZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ShutdownScriptInvalidShutdownScriptZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ShutdownScriptInvalidShutdownScriptZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_ShutdownScriptInvalidShutdownScriptZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_ShutdownScriptInvalidShutdownScriptZ_clone(this.ptr);
        const ret_hu_conv = Result_ShutdownScriptInvalidShutdownScriptZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_ShutdownScriptInvalidShutdownScriptZ_OK extends Result_ShutdownScriptInvalidShutdownScriptZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ShutdownScriptInvalidShutdownScriptZ_get_ok(ptr);
        const res_hu_conv = new _shutdownScriptMjs.ShutdownScript(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ShutdownScriptInvalidShutdownScriptZ_Err extends Result_ShutdownScriptInvalidShutdownScriptZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ShutdownScriptInvalidShutdownScriptZ_get_err(ptr);
        const err_hu_conv = new _invalidShutdownScriptMjs.InvalidShutdownScript(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/ShutdownScript.mjs":"gHaa6","../structs/InvalidShutdownScript.mjs":"asKI3","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"asKI3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An error occurring when converting from [`Script`] to [`ShutdownScript`].
 */ parcelHelpers.export(exports, "InvalidShutdownScript", ()=>InvalidShutdownScript
) //# sourceMappingURL=InvalidShutdownScript.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class InvalidShutdownScript extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.InvalidShutdownScript_free);
    }
    /**
     * The script that did not meet the requirements from [BOLT #2].
     *
     * [BOLT #2]: https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md
     */ get_script() {
        const ret = _bindingsMjs.InvalidShutdownScript_get_script(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The script that did not meet the requirements from [BOLT #2].
     *
     * [BOLT #2]: https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md
     */ set_script(val) {
        _bindingsMjs.InvalidShutdownScript_set_script(this.ptr, _bindingsMjs.encodeUint8Array(val));
    }
    /**
     * Constructs a new InvalidShutdownScript given each field
     */ static constructor_new(script_arg) {
        const ret = _bindingsMjs.InvalidShutdownScript_new(_bindingsMjs.encodeUint8Array(script_arg));
        const ret_hu_conv = new InvalidShutdownScript(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.InvalidShutdownScript_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the InvalidShutdownScript
     */ clone() {
        const ret = _bindingsMjs.InvalidShutdownScript_clone(this.ptr);
        const ret_hu_conv = new InvalidShutdownScript(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"co77s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Defines a type identifier for sending messages over the wire.
 *
 * Messages implementing this trait specify a type and must be [`Writeable`].
 */ parcelHelpers.export(exports, "Type", ()=>Type
) //# sourceMappingURL=Type.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKTypeHolder {
}
class Type extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Type_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of Type from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKTypeHolder();
        let structImplementation = {
            type_id () {
                const ret = arg.type_id();
                return ret;
            },
            debug_str () {
                const ret = arg.debug_str();
                const result = _bindingsMjs.encodeString(ret);
                return result;
            },
            write () {
                const ret = arg.write();
                const result = _bindingsMjs.encodeUint8Array(ret);
                return result;
            }
        };
        const ptr = _bindingsMjs.LDKType_new(structImplementation);
        impl_holder.held = new Type(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Returns the type identifying the message payload.
     */ type_id() {
        const ret = _bindingsMjs.Type_type_id(this.ptr);
        return ret;
    }
    /**
     * Return a human-readable "debug" string describing this object
     */ debug_str() {
        const ret = _bindingsMjs.Type_debug_str(this.ptr);
        const ret_conv = _bindingsMjs.decodeString(ret);
        return ret_conv;
    }
    /**
     * Serialize the object into a byte array
     */ write() {
        const ret = _bindingsMjs.Type_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.Type_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of a Type
     */ clone() {
        const ret = _bindingsMjs.Type_clone(this.ptr);
        const ret_hu_conv = new Type(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dNsZ3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An enum which can either contain a crate::lightning::ln::wire::Type or not
 */ parcelHelpers.export(exports, "Option_TypeZ", ()=>Option_TypeZ
);
/** A Option_TypeZ of type Some */ parcelHelpers.export(exports, "Option_TypeZ_Some", ()=>Option_TypeZ_Some
);
/** A Option_TypeZ of type None */ parcelHelpers.export(exports, "Option_TypeZ_None", ()=>Option_TypeZ_None
) //# sourceMappingURL=Option_TypeZ.mjs.map
;
var _typeMjs = require("../structs/Type.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Option_TypeZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.COption_TypeZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKCOption_TypeZ_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new Option_TypeZ_Some(ptr);
            case 1:
                return new Option_TypeZ_None(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    /**
     * Constructs a new COption_TypeZ containing a crate::lightning::ln::wire::Type
     */ static constructor_some(o) {
        const ret = _bindingsMjs.COption_TypeZ_some(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o));
        const ret_hu_conv = Option_TypeZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, o);
        return ret_hu_conv;
    }
    /**
     * Constructs a new COption_TypeZ containing nothing
     */ static constructor_none() {
        const ret = _bindingsMjs.COption_TypeZ_none();
        const ret_hu_conv = Option_TypeZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.COption_TypeZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new COption_TypeZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.COption_TypeZ_clone(this.ptr);
        const ret_hu_conv = Option_TypeZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
class Option_TypeZ_Some extends Option_TypeZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const some = _bindingsMjs.LDKCOption_TypeZ_Some_get_some(ptr);
        const ret_hu_conv = new _typeMjs.Type(null, some);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        this.some = ret_hu_conv;
    }
}
class Option_TypeZ_None extends Option_TypeZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}

},{"../structs/Type.mjs":"co77s","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"72w3O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_COption_TypeZDecodeErrorZ", ()=>Result_COption_TypeZDecodeErrorZ
);
parcelHelpers.export(exports, "Result_COption_TypeZDecodeErrorZ_OK", ()=>Result_COption_TypeZDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_COption_TypeZDecodeErrorZ_Err", ()=>Result_COption_TypeZDecodeErrorZ_Err
) //# sourceMappingURL=Result_COption_TypeZDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _optionTypeZMjs = require("../structs/Option_TypeZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_COption_TypeZDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_COption_TypeZDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_COption_TypeZDecodeErrorZ_is_ok(ptr)) return new Result_COption_TypeZDecodeErrorZ_OK(null, ptr);
        else return new Result_COption_TypeZDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_COption_TypeZDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_COption_TypeZDecodeErrorZ_ok(_commonBaseMjsDefault.default.get_ptr_of(o));
        const ret_hu_conv = Result_COption_TypeZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_COption_TypeZDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_COption_TypeZDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_COption_TypeZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_COption_TypeZDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_COption_TypeZDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_COption_TypeZDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_COption_TypeZDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_COption_TypeZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_COption_TypeZDecodeErrorZ_OK extends Result_COption_TypeZDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_COption_TypeZDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = _optionTypeZMjs.Option_TypeZ.constr_from_ptr(res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_COption_TypeZDecodeErrorZ_Err extends Result_COption_TypeZDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_COption_TypeZDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/Option_TypeZ.mjs":"dNsZ3","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bx85V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_StringErrorZ", ()=>Result_StringErrorZ
);
parcelHelpers.export(exports, "Result_StringErrorZ_OK", ()=>Result_StringErrorZ_OK
);
parcelHelpers.export(exports, "Result_StringErrorZ_Err", ()=>Result_StringErrorZ_Err
) //# sourceMappingURL=Result_StringErrorZ.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_StringErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_StringErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_StringErrorZ_is_ok(ptr)) return new Result_StringErrorZ_OK(null, ptr);
        else return new Result_StringErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_StringErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_StringErrorZ_ok(_bindingsMjs.encodeString(o));
        const ret_hu_conv = Result_StringErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_StringErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_StringErrorZ_err(e);
        const ret_hu_conv = Result_StringErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_StringErrorZ_is_ok(this.ptr);
        return ret;
    }
}
class Result_StringErrorZ_OK extends Result_StringErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_StringErrorZ_get_ok(ptr);
        const res_conv = _bindingsMjs.decodeString(res);
        this.res = res_conv;
    }
}
class Result_StringErrorZ_Err extends Result_StringErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        this.err = _bindingsMjs.CResult_StringErrorZ_get_err(ptr);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gEeSd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An update generated by the underlying Channel itself which contains some new information the
 * ChannelMonitor should be made aware of.
 */ parcelHelpers.export(exports, "ChannelMonitorUpdate", ()=>ChannelMonitorUpdate
) //# sourceMappingURL=ChannelMonitorUpdate.mjs.map
;
var _resultChannelMonitorUpdateDecodeErrorZMjs = require("../structs/Result_ChannelMonitorUpdateDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelMonitorUpdate extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelMonitorUpdate_free);
    }
    /**
     * The sequence number of this update. Updates *must* be replayed in-order according to this
     * sequence number (and updates may panic if they are not). The update_id values are strictly
     * increasing and increase by one for each new update, with one exception specified below.
     *
     * This sequence number is also used to track up to which points updates which returned
     * ChannelMonitorUpdateErr::TemporaryFailure have been applied to all copies of a given
     * ChannelMonitor when ChannelManager::channel_monitor_updated is called.
     *
     * The only instance where update_id values are not strictly increasing is the case where we
     * allow post-force-close updates with a special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. See
     * its docs for more details.
     */ get_update_id() {
        const ret = _bindingsMjs.ChannelMonitorUpdate_get_update_id(this.ptr);
        return ret;
    }
    /**
     * The sequence number of this update. Updates *must* be replayed in-order according to this
     * sequence number (and updates may panic if they are not). The update_id values are strictly
     * increasing and increase by one for each new update, with one exception specified below.
     *
     * This sequence number is also used to track up to which points updates which returned
     * ChannelMonitorUpdateErr::TemporaryFailure have been applied to all copies of a given
     * ChannelMonitor when ChannelManager::channel_monitor_updated is called.
     *
     * The only instance where update_id values are not strictly increasing is the case where we
     * allow post-force-close updates with a special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. See
     * its docs for more details.
     */ set_update_id(val) {
        _bindingsMjs.ChannelMonitorUpdate_set_update_id(this.ptr, val);
    }
    clone_ptr() {
        const ret = _bindingsMjs.ChannelMonitorUpdate_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelMonitorUpdate
     */ clone() {
        const ret = _bindingsMjs.ChannelMonitorUpdate_clone(this.ptr);
        const ret_hu_conv = new ChannelMonitorUpdate(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the ChannelMonitorUpdate object into a byte array which can be read by ChannelMonitorUpdate_read
     */ write() {
        const ret = _bindingsMjs.ChannelMonitorUpdate_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ChannelMonitorUpdate from a byte array, created by ChannelMonitorUpdate_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ChannelMonitorUpdate_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultChannelMonitorUpdateDecodeErrorZMjs.Result_ChannelMonitorUpdateDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_ChannelMonitorUpdateDecodeErrorZ.mjs":"5tNQK","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5tNQK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ChannelMonitorUpdateDecodeErrorZ", ()=>Result_ChannelMonitorUpdateDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ChannelMonitorUpdateDecodeErrorZ_OK", ()=>Result_ChannelMonitorUpdateDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ChannelMonitorUpdateDecodeErrorZ_Err", ()=>Result_ChannelMonitorUpdateDecodeErrorZ_Err
) //# sourceMappingURL=Result_ChannelMonitorUpdateDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _channelMonitorUpdateMjs = require("../structs/ChannelMonitorUpdate.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ChannelMonitorUpdateDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ChannelMonitorUpdateDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(ptr)) return new Result_ChannelMonitorUpdateDecodeErrorZ_OK(null, ptr);
        else return new Result_ChannelMonitorUpdateDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ChannelMonitorUpdateDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ChannelMonitorUpdateDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ChannelMonitorUpdateDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ChannelMonitorUpdateDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_ChannelMonitorUpdateDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_ChannelMonitorUpdateDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_ChannelMonitorUpdateDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_ChannelMonitorUpdateDecodeErrorZ_OK extends Result_ChannelMonitorUpdateDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ChannelMonitorUpdateDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _channelMonitorUpdateMjs.ChannelMonitorUpdate(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ChannelMonitorUpdateDecodeErrorZ_Err extends Result_ChannelMonitorUpdateDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ChannelMonitorUpdateDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/ChannelMonitorUpdate.mjs":"gEeSd","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"feVhj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Simple structure sent back by `chain::Watch` when an HTLC from a forward channel is detected on
 * chain. Used to update the corresponding HTLC in the backward channel. Failing to pass the
 * preimage claim backward will lead to loss of funds.
 */ parcelHelpers.export(exports, "HTLCUpdate", ()=>HTLCUpdate
) //# sourceMappingURL=HTLCUpdate.mjs.map
;
var _resultHTLCUpdateDecodeErrorZMjs = require("../structs/Result_HTLCUpdateDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class HTLCUpdate extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.HTLCUpdate_free);
    }
    clone_ptr() {
        const ret = _bindingsMjs.HTLCUpdate_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the HTLCUpdate
     */ clone() {
        const ret = _bindingsMjs.HTLCUpdate_clone(this.ptr);
        const ret_hu_conv = new HTLCUpdate(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the HTLCUpdate object into a byte array which can be read by HTLCUpdate_read
     */ write() {
        const ret = _bindingsMjs.HTLCUpdate_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a HTLCUpdate from a byte array, created by HTLCUpdate_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.HTLCUpdate_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultHTLCUpdateDecodeErrorZMjs.Result_HTLCUpdateDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_HTLCUpdateDecodeErrorZ.mjs":"4Ug4F","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4Ug4F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_HTLCUpdateDecodeErrorZ", ()=>Result_HTLCUpdateDecodeErrorZ
);
parcelHelpers.export(exports, "Result_HTLCUpdateDecodeErrorZ_OK", ()=>Result_HTLCUpdateDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_HTLCUpdateDecodeErrorZ_Err", ()=>Result_HTLCUpdateDecodeErrorZ_Err
) //# sourceMappingURL=Result_HTLCUpdateDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _htlcupdateMjs = require("../structs/HTLCUpdate.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_HTLCUpdateDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_HTLCUpdateDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_HTLCUpdateDecodeErrorZ_is_ok(ptr)) return new Result_HTLCUpdateDecodeErrorZ_OK(null, ptr);
        else return new Result_HTLCUpdateDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_HTLCUpdateDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_HTLCUpdateDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_HTLCUpdateDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_HTLCUpdateDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_HTLCUpdateDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_HTLCUpdateDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_HTLCUpdateDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_HTLCUpdateDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_HTLCUpdateDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_HTLCUpdateDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_HTLCUpdateDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_HTLCUpdateDecodeErrorZ_OK extends Result_HTLCUpdateDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_HTLCUpdateDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _htlcupdateMjs.HTLCUpdate(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_HTLCUpdateDecodeErrorZ_Err extends Result_HTLCUpdateDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_HTLCUpdateDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/HTLCUpdate.mjs":"feVhj","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jGH1U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An event to be processed by the ChannelManager.
 */ parcelHelpers.export(exports, "MonitorEvent", ()=>MonitorEvent
);
/** A MonitorEvent of type HTLCEvent */ parcelHelpers.export(exports, "MonitorEvent_HTLCEvent", ()=>MonitorEvent_HTLCEvent
);
/** A MonitorEvent of type CommitmentTxConfirmed */ parcelHelpers.export(exports, "MonitorEvent_CommitmentTxConfirmed", ()=>MonitorEvent_CommitmentTxConfirmed
);
/** A MonitorEvent of type UpdateCompleted */ parcelHelpers.export(exports, "MonitorEvent_UpdateCompleted", ()=>MonitorEvent_UpdateCompleted
);
/** A MonitorEvent of type UpdateFailed */ parcelHelpers.export(exports, "MonitorEvent_UpdateFailed", ()=>MonitorEvent_UpdateFailed
) //# sourceMappingURL=MonitorEvent.mjs.map
;
var _outPointMjs = require("../structs/OutPoint.mjs");
var _htlcupdateMjs = require("../structs/HTLCUpdate.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class MonitorEvent extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.MonitorEvent_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKMonitorEvent_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new MonitorEvent_HTLCEvent(ptr);
            case 1:
                return new MonitorEvent_CommitmentTxConfirmed(ptr);
            case 2:
                return new MonitorEvent_UpdateCompleted(ptr);
            case 3:
                return new MonitorEvent_UpdateFailed(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = _bindingsMjs.MonitorEvent_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the MonitorEvent
     */ clone() {
        const ret = _bindingsMjs.MonitorEvent_clone(this.ptr);
        const ret_hu_conv = MonitorEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new HTLCEvent-variant MonitorEvent
     */ static constructor_htlcevent(a) {
        const ret = _bindingsMjs.MonitorEvent_htlcevent(a == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(a) & -2);
        const ret_hu_conv = MonitorEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new CommitmentTxConfirmed-variant MonitorEvent
     */ static constructor_commitment_tx_confirmed(a) {
        const ret = _bindingsMjs.MonitorEvent_commitment_tx_confirmed(a == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(a) & -2);
        const ret_hu_conv = MonitorEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new UpdateCompleted-variant MonitorEvent
     */ static constructor_update_completed(funding_txo, monitor_update_id) {
        const ret = _bindingsMjs.MonitorEvent_update_completed(funding_txo == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(funding_txo) & -2, monitor_update_id);
        const ret_hu_conv = MonitorEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new UpdateFailed-variant MonitorEvent
     */ static constructor_update_failed(a) {
        const ret = _bindingsMjs.MonitorEvent_update_failed(a == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(a) & -2);
        const ret_hu_conv = MonitorEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Serialize the MonitorEvent object into a byte array which can be read by MonitorEvent_read
     */ write() {
        const ret = _bindingsMjs.MonitorEvent_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
}
class MonitorEvent_HTLCEvent extends MonitorEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const htlc_event = _bindingsMjs.LDKMonitorEvent_HTLCEvent_get_htlc_event(ptr);
        const htlc_event_hu_conv = new _htlcupdateMjs.HTLCUpdate(null, htlc_event);
        _commonBaseMjsDefault.default.add_ref_from(htlc_event_hu_conv, this);
        this.htlc_event = htlc_event_hu_conv;
    }
}
class MonitorEvent_CommitmentTxConfirmed extends MonitorEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const commitment_tx_confirmed = _bindingsMjs.LDKMonitorEvent_CommitmentTxConfirmed_get_commitment_tx_confirmed(ptr);
        const commitment_tx_confirmed_hu_conv = new _outPointMjs.OutPoint(null, commitment_tx_confirmed);
        _commonBaseMjsDefault.default.add_ref_from(commitment_tx_confirmed_hu_conv, this);
        this.commitment_tx_confirmed = commitment_tx_confirmed_hu_conv;
    }
}
class MonitorEvent_UpdateCompleted extends MonitorEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const funding_txo = _bindingsMjs.LDKMonitorEvent_UpdateCompleted_get_funding_txo(ptr);
        const funding_txo_hu_conv = new _outPointMjs.OutPoint(null, funding_txo);
        _commonBaseMjsDefault.default.add_ref_from(funding_txo_hu_conv, this);
        this.funding_txo = funding_txo_hu_conv;
        this.monitor_update_id = _bindingsMjs.LDKMonitorEvent_UpdateCompleted_get_monitor_update_id(ptr);
    }
}
class MonitorEvent_UpdateFailed extends MonitorEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const update_failed = _bindingsMjs.LDKMonitorEvent_UpdateFailed_get_update_failed(ptr);
        const update_failed_hu_conv = new _outPointMjs.OutPoint(null, update_failed);
        _commonBaseMjsDefault.default.add_ref_from(update_failed_hu_conv, this);
        this.update_failed = update_failed_hu_conv;
    }
}

},{"../structs/OutPoint.mjs":"9FTof","../structs/HTLCUpdate.mjs":"feVhj","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9PM41":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An enum which can either contain a crate::lightning::chain::channelmonitor::MonitorEvent or not
 */ parcelHelpers.export(exports, "Option_MonitorEventZ", ()=>Option_MonitorEventZ
);
/** A Option_MonitorEventZ of type Some */ parcelHelpers.export(exports, "Option_MonitorEventZ_Some", ()=>Option_MonitorEventZ_Some
);
/** A Option_MonitorEventZ of type None */ parcelHelpers.export(exports, "Option_MonitorEventZ_None", ()=>Option_MonitorEventZ_None
) //# sourceMappingURL=Option_MonitorEventZ.mjs.map
;
var _monitorEventMjs = require("../structs/MonitorEvent.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Option_MonitorEventZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.COption_MonitorEventZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKCOption_MonitorEventZ_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new Option_MonitorEventZ_Some(ptr);
            case 1:
                return new Option_MonitorEventZ_None(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    /**
     * Constructs a new COption_MonitorEventZ containing a crate::lightning::chain::channelmonitor::MonitorEvent
     */ static constructor_some(o) {
        const ret = _bindingsMjs.COption_MonitorEventZ_some(_commonBaseMjsDefault.default.get_ptr_of(o));
        const ret_hu_conv = Option_MonitorEventZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Constructs a new COption_MonitorEventZ containing nothing
     */ static constructor_none() {
        const ret = _bindingsMjs.COption_MonitorEventZ_none();
        const ret_hu_conv = Option_MonitorEventZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.COption_MonitorEventZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new COption_MonitorEventZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.COption_MonitorEventZ_clone(this.ptr);
        const ret_hu_conv = Option_MonitorEventZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
class Option_MonitorEventZ_Some extends Option_MonitorEventZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const some = _bindingsMjs.LDKCOption_MonitorEventZ_Some_get_some(ptr);
        const some_hu_conv = _monitorEventMjs.MonitorEvent.constr_from_ptr(some);
        _commonBaseMjsDefault.default.add_ref_from(some_hu_conv, this);
        this.some = some_hu_conv;
    }
}
class Option_MonitorEventZ_None extends Option_MonitorEventZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}

},{"../structs/MonitorEvent.mjs":"jGH1U","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7wIuE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_COption_MonitorEventZDecodeErrorZ", ()=>Result_COption_MonitorEventZDecodeErrorZ
);
parcelHelpers.export(exports, "Result_COption_MonitorEventZDecodeErrorZ_OK", ()=>Result_COption_MonitorEventZDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_COption_MonitorEventZDecodeErrorZ_Err", ()=>Result_COption_MonitorEventZDecodeErrorZ_Err
) //# sourceMappingURL=Result_COption_MonitorEventZDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _optionMonitorEventZMjs = require("../structs/Option_MonitorEventZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_COption_MonitorEventZDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_COption_MonitorEventZDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_COption_MonitorEventZDecodeErrorZ_is_ok(ptr)) return new Result_COption_MonitorEventZDecodeErrorZ_OK(null, ptr);
        else return new Result_COption_MonitorEventZDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_COption_MonitorEventZDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_COption_MonitorEventZDecodeErrorZ_ok(_commonBaseMjsDefault.default.get_ptr_of(o));
        const ret_hu_conv = Result_COption_MonitorEventZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_COption_MonitorEventZDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_COption_MonitorEventZDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_COption_MonitorEventZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_COption_MonitorEventZDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_COption_MonitorEventZDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_COption_MonitorEventZDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_COption_MonitorEventZDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_COption_MonitorEventZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_COption_MonitorEventZDecodeErrorZ_OK extends Result_COption_MonitorEventZDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_COption_MonitorEventZDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = _optionMonitorEventZMjs.Option_MonitorEventZ.constr_from_ptr(res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_COption_MonitorEventZDecodeErrorZ_Err extends Result_COption_MonitorEventZDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_COption_MonitorEventZDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/Option_MonitorEventZ.mjs":"9PM41","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1QnVF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_NoneNoneZ", ()=>Result_NoneNoneZ
);
parcelHelpers.export(exports, "Result_NoneNoneZ_OK", ()=>Result_NoneNoneZ_OK
);
parcelHelpers.export(exports, "Result_NoneNoneZ_Err", ()=>Result_NoneNoneZ_Err
) //# sourceMappingURL=Result_NoneNoneZ.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_NoneNoneZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_NoneNoneZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_NoneNoneZ_is_ok(ptr)) return new Result_NoneNoneZ_OK(null, ptr);
        else return new Result_NoneNoneZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_NoneNoneZ in the success state.
     */ static constructor_ok() {
        const ret = _bindingsMjs.CResult_NoneNoneZ_ok();
        const ret_hu_conv = Result_NoneNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_NoneNoneZ in the error state.
     */ static constructor_err() {
        const ret = _bindingsMjs.CResult_NoneNoneZ_err();
        const ret_hu_conv = Result_NoneNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_NoneNoneZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_NoneNoneZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_NoneNoneZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_NoneNoneZ_clone(this.ptr);
        const ret_hu_conv = Result_NoneNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_NoneNoneZ_OK extends Result_NoneNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}
class Result_NoneNoneZ_Err extends Result_NoneNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"loLPb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Tuple
 */ parcelHelpers.export(exports, "TwoTuple_OutPointScriptZ", ()=>TwoTuple_OutPointScriptZ
) //# sourceMappingURL=TwoTuple_OutPointScriptZ.mjs.map
;
var _outPointMjs = require("../structs/OutPoint.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class TwoTuple_OutPointScriptZ extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.C2Tuple_OutPointScriptZ_free);
    }
    /**
     *
     */ get_a() {
        const ret = _bindingsMjs.C2Tuple_OutPointScriptZ_get_a(this.ptr);
        const ret_hu_conv = new _outPointMjs.OutPoint(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     *
     */ get_b() {
        const ret = _bindingsMjs.C2Tuple_OutPointScriptZ_get_b(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Creates a new C2Tuple_OutPointScriptZ from the contained elements.
     */ static constructor_new(a, b) {
        const ret = _bindingsMjs.C2Tuple_OutPointScriptZ_new(a == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(a) & -2, _bindingsMjs.encodeUint8Array(b));
        const ret_hu_conv = new TwoTuple_OutPointScriptZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"../structs/OutPoint.mjs":"9FTof","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kzt6p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Tuple
 */ parcelHelpers.export(exports, "TwoTuple_u32ScriptZ", ()=>TwoTuple_u32ScriptZ
) //# sourceMappingURL=TwoTuple_u32ScriptZ.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class TwoTuple_u32ScriptZ extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.C2Tuple_u32ScriptZ_free);
    }
    /**
     *
     */ get_a() {
        const ret = _bindingsMjs.C2Tuple_u32ScriptZ_get_a(this.ptr);
        return ret;
    }
    /**
     *
     */ get_b() {
        const ret = _bindingsMjs.C2Tuple_u32ScriptZ_get_b(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Creates a new C2Tuple_u32ScriptZ from the contained elements.
     */ static constructor_new(a, b) {
        const ret = _bindingsMjs.C2Tuple_u32ScriptZ_new(a, _bindingsMjs.encodeUint8Array(b));
        const ret_hu_conv = new TwoTuple_u32ScriptZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fDovr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Tuple
 */ parcelHelpers.export(exports, "TwoTuple_TxidCVec_C2Tuple_u32ScriptZZZ", ()=>TwoTuple_TxidCVec_C2Tuple_u32ScriptZZZ
) //# sourceMappingURL=TwoTuple_TxidCVec_C2Tuple_u32ScriptZZZ.mjs.map
;
var _twoTupleU32ScriptZMjs = require("../structs/TwoTuple_u32ScriptZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class TwoTuple_TxidCVec_C2Tuple_u32ScriptZZZ extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free);
    }
    /**
     *
     */ get_a() {
        const ret = _bindingsMjs.C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_a(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     *
     */ get_b() {
        const ret = _bindingsMjs.C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_b(this.ptr);
        const ret_conv_21_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_21_arr = new Array(ret_conv_21_len).fill(null);
        for(var v = 0; v < ret_conv_21_len; v++){
            const ret_conv_21 = _bindingsMjs.getU32ArrayElem(ret, v);
            const ret_conv_21_hu_conv = new _twoTupleU32ScriptZMjs.TwoTuple_u32ScriptZ(null, ret_conv_21);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_21_hu_conv, this);
            ret_conv_21_arr[v] = ret_conv_21_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_21_arr;
    }
    /**
     * Creates a new C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ from the contained elements.
     */ static constructor_new(a, b) {
        const ret = _bindingsMjs.C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(a, 32)), _bindingsMjs.encodeUint32Array(b != null ? b.map((b_conv_21)=>b_conv_21 != null ? _commonBaseMjsDefault.default.get_ptr_of(b_conv_21) : 0
        ) : null));
        const ret_hu_conv = new TwoTuple_TxidCVec_C2Tuple_u32ScriptZZZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"../structs/TwoTuple_u32ScriptZ.mjs":"kzt6p","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2gW5M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Some information provided on receipt of payment depends on whether the payment received is a
 * spontaneous payment or a \"conventional\" lightning payment that's paying an invoice.
 */ parcelHelpers.export(exports, "PaymentPurpose", ()=>PaymentPurpose
);
/** A PaymentPurpose of type InvoicePayment */ parcelHelpers.export(exports, "PaymentPurpose_InvoicePayment", ()=>PaymentPurpose_InvoicePayment
);
/** A PaymentPurpose of type SpontaneousPayment */ parcelHelpers.export(exports, "PaymentPurpose_SpontaneousPayment", ()=>PaymentPurpose_SpontaneousPayment
) //# sourceMappingURL=PaymentPurpose.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class PaymentPurpose extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.PaymentPurpose_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKPaymentPurpose_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new PaymentPurpose_InvoicePayment(ptr);
            case 1:
                return new PaymentPurpose_SpontaneousPayment(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = _bindingsMjs.PaymentPurpose_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the PaymentPurpose
     */ clone() {
        const ret = _bindingsMjs.PaymentPurpose_clone(this.ptr);
        const ret_hu_conv = PaymentPurpose.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new InvoicePayment-variant PaymentPurpose
     */ static constructor_invoice_payment(payment_preimage, payment_secret) {
        const ret = _bindingsMjs.PaymentPurpose_invoice_payment(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_preimage, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_secret, 32)));
        const ret_hu_conv = PaymentPurpose.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SpontaneousPayment-variant PaymentPurpose
     */ static constructor_spontaneous_payment(a) {
        const ret = _bindingsMjs.PaymentPurpose_spontaneous_payment(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(a, 32)));
        const ret_hu_conv = PaymentPurpose.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}
class PaymentPurpose_InvoicePayment extends PaymentPurpose {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const payment_preimage = _bindingsMjs.LDKPaymentPurpose_InvoicePayment_get_payment_preimage(ptr);
        const payment_preimage_conv = _bindingsMjs.decodeUint8Array(payment_preimage);
        this.payment_preimage = payment_preimage_conv;
        const payment_secret = _bindingsMjs.LDKPaymentPurpose_InvoicePayment_get_payment_secret(ptr);
        const payment_secret_conv = _bindingsMjs.decodeUint8Array(payment_secret);
        this.payment_secret = payment_secret_conv;
    }
}
class PaymentPurpose_SpontaneousPayment extends PaymentPurpose {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const spontaneous_payment = _bindingsMjs.LDKPaymentPurpose_SpontaneousPayment_get_spontaneous_payment(ptr);
        const spontaneous_payment_conv = _bindingsMjs.decodeUint8Array(spontaneous_payment);
        this.spontaneous_payment = spontaneous_payment_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8VC1Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An enum which can either contain a u64 or not
 */ parcelHelpers.export(exports, "Option_u64Z", ()=>Option_u64Z
);
/** A Option_u64Z of type Some */ parcelHelpers.export(exports, "Option_u64Z_Some", ()=>Option_u64Z_Some
);
/** A Option_u64Z of type None */ parcelHelpers.export(exports, "Option_u64Z_None", ()=>Option_u64Z_None
) //# sourceMappingURL=Option_u64Z.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Option_u64Z extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.COption_u64Z_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKCOption_u64Z_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new Option_u64Z_Some(ptr);
            case 1:
                return new Option_u64Z_None(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    /**
     * Constructs a new COption_u64Z containing a u64
     */ static constructor_some(o) {
        const ret = _bindingsMjs.COption_u64Z_some(o);
        const ret_hu_conv = Option_u64Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Constructs a new COption_u64Z containing nothing
     */ static constructor_none() {
        const ret = _bindingsMjs.COption_u64Z_none();
        const ret_hu_conv = Option_u64Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.COption_u64Z_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new COption_u64Z which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.COption_u64Z_clone(this.ptr);
        const ret_hu_conv = Option_u64Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
class Option_u64Z_Some extends Option_u64Z {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        this.some = _bindingsMjs.LDKCOption_u64Z_Some_get_some(ptr);
    }
}
class Option_u64Z_None extends Option_u64Z {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kLaF6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A channel_update message to be sent or received from a peer
 */ parcelHelpers.export(exports, "ChannelUpdate", ()=>ChannelUpdate
) //# sourceMappingURL=ChannelUpdate.mjs.map
;
var _unsignedChannelUpdateMjs = require("../structs/UnsignedChannelUpdate.mjs");
var _resultChannelUpdateDecodeErrorZMjs = require("../structs/Result_ChannelUpdateDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelUpdate extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelUpdate_free);
    }
    /**
     * A signature of the channel update
     */ get_signature() {
        const ret = _bindingsMjs.ChannelUpdate_get_signature(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * A signature of the channel update
     */ set_signature(val) {
        _bindingsMjs.ChannelUpdate_set_signature(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 64)));
    }
    /**
     * The actual channel update
     */ get_contents() {
        const ret = _bindingsMjs.ChannelUpdate_get_contents(this.ptr);
        const ret_hu_conv = new _unsignedChannelUpdateMjs.UnsignedChannelUpdate(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The actual channel update
     */ set_contents(val) {
        _bindingsMjs.ChannelUpdate_set_contents(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Constructs a new ChannelUpdate given each field
     */ static constructor_new(signature_arg, contents_arg) {
        const ret = _bindingsMjs.ChannelUpdate_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(signature_arg, 64)), contents_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(contents_arg) & -2);
        const ret_hu_conv = new ChannelUpdate(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ChannelUpdate_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelUpdate
     */ clone() {
        const ret = _bindingsMjs.ChannelUpdate_clone(this.ptr);
        const ret_hu_conv = new ChannelUpdate(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the ChannelUpdate object into a byte array which can be read by ChannelUpdate_read
     */ write() {
        const ret = _bindingsMjs.ChannelUpdate_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ChannelUpdate from a byte array, created by ChannelUpdate_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ChannelUpdate_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultChannelUpdateDecodeErrorZMjs.Result_ChannelUpdateDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/UnsignedChannelUpdate.mjs":"7IUgV","../structs/Result_ChannelUpdateDecodeErrorZ.mjs":"33S6G","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7IUgV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The unsigned part of a channel_update
 */ parcelHelpers.export(exports, "UnsignedChannelUpdate", ()=>UnsignedChannelUpdate
) //# sourceMappingURL=UnsignedChannelUpdate.mjs.map
;
var _resultUnsignedChannelUpdateDecodeErrorZMjs = require("../structs/Result_UnsignedChannelUpdateDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class UnsignedChannelUpdate extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.UnsignedChannelUpdate_free);
    }
    /**
     * The genesis hash of the blockchain where the channel is to be opened
     */ get_chain_hash() {
        const ret = _bindingsMjs.UnsignedChannelUpdate_get_chain_hash(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The genesis hash of the blockchain where the channel is to be opened
     */ set_chain_hash(val) {
        _bindingsMjs.UnsignedChannelUpdate_set_chain_hash(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The short channel ID
     */ get_short_channel_id() {
        const ret = _bindingsMjs.UnsignedChannelUpdate_get_short_channel_id(this.ptr);
        return ret;
    }
    /**
     * The short channel ID
     */ set_short_channel_id(val) {
        _bindingsMjs.UnsignedChannelUpdate_set_short_channel_id(this.ptr, val);
    }
    /**
     * A strictly monotonic announcement counter, with gaps allowed, specific to this channel
     */ get_timestamp() {
        const ret = _bindingsMjs.UnsignedChannelUpdate_get_timestamp(this.ptr);
        return ret;
    }
    /**
     * A strictly monotonic announcement counter, with gaps allowed, specific to this channel
     */ set_timestamp(val) {
        _bindingsMjs.UnsignedChannelUpdate_set_timestamp(this.ptr, val);
    }
    /**
     * Channel flags
     */ get_flags() {
        const ret = _bindingsMjs.UnsignedChannelUpdate_get_flags(this.ptr);
        return ret;
    }
    /**
     * Channel flags
     */ set_flags(val) {
        _bindingsMjs.UnsignedChannelUpdate_set_flags(this.ptr, val);
    }
    /**
     * The number of blocks such that if:
     * `incoming_htlc.cltv_expiry < outgoing_htlc.cltv_expiry + cltv_expiry_delta`
     * then we need to fail the HTLC backwards. When forwarding an HTLC, cltv_expiry_delta determines
     * the outgoing HTLC's minimum cltv_expiry value -- so, if an incoming HTLC comes in with a
     * cltv_expiry of 100000, and the node we're forwarding to has a cltv_expiry_delta value of 10,
     * then we'll check that the outgoing HTLC's cltv_expiry value is at least 100010 before
     * forwarding. Note that the HTLC sender is the one who originally sets this value when
     * constructing the route.
     */ get_cltv_expiry_delta() {
        const ret = _bindingsMjs.UnsignedChannelUpdate_get_cltv_expiry_delta(this.ptr);
        return ret;
    }
    /**
     * The number of blocks such that if:
     * `incoming_htlc.cltv_expiry < outgoing_htlc.cltv_expiry + cltv_expiry_delta`
     * then we need to fail the HTLC backwards. When forwarding an HTLC, cltv_expiry_delta determines
     * the outgoing HTLC's minimum cltv_expiry value -- so, if an incoming HTLC comes in with a
     * cltv_expiry of 100000, and the node we're forwarding to has a cltv_expiry_delta value of 10,
     * then we'll check that the outgoing HTLC's cltv_expiry value is at least 100010 before
     * forwarding. Note that the HTLC sender is the one who originally sets this value when
     * constructing the route.
     */ set_cltv_expiry_delta(val) {
        _bindingsMjs.UnsignedChannelUpdate_set_cltv_expiry_delta(this.ptr, val);
    }
    /**
     * The minimum HTLC size incoming to sender, in milli-satoshi
     */ get_htlc_minimum_msat() {
        const ret = _bindingsMjs.UnsignedChannelUpdate_get_htlc_minimum_msat(this.ptr);
        return ret;
    }
    /**
     * The minimum HTLC size incoming to sender, in milli-satoshi
     */ set_htlc_minimum_msat(val) {
        _bindingsMjs.UnsignedChannelUpdate_set_htlc_minimum_msat(this.ptr, val);
    }
    /**
     * The base HTLC fee charged by sender, in milli-satoshi
     */ get_fee_base_msat() {
        const ret = _bindingsMjs.UnsignedChannelUpdate_get_fee_base_msat(this.ptr);
        return ret;
    }
    /**
     * The base HTLC fee charged by sender, in milli-satoshi
     */ set_fee_base_msat(val) {
        _bindingsMjs.UnsignedChannelUpdate_set_fee_base_msat(this.ptr, val);
    }
    /**
     * The amount to fee multiplier, in micro-satoshi
     */ get_fee_proportional_millionths() {
        const ret = _bindingsMjs.UnsignedChannelUpdate_get_fee_proportional_millionths(this.ptr);
        return ret;
    }
    /**
     * The amount to fee multiplier, in micro-satoshi
     */ set_fee_proportional_millionths(val) {
        _bindingsMjs.UnsignedChannelUpdate_set_fee_proportional_millionths(this.ptr, val);
    }
    clone_ptr() {
        const ret = _bindingsMjs.UnsignedChannelUpdate_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the UnsignedChannelUpdate
     */ clone() {
        const ret = _bindingsMjs.UnsignedChannelUpdate_clone(this.ptr);
        const ret_hu_conv = new UnsignedChannelUpdate(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the UnsignedChannelUpdate object into a byte array which can be read by UnsignedChannelUpdate_read
     */ write() {
        const ret = _bindingsMjs.UnsignedChannelUpdate_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a UnsignedChannelUpdate from a byte array, created by UnsignedChannelUpdate_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.UnsignedChannelUpdate_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultUnsignedChannelUpdateDecodeErrorZMjs.Result_UnsignedChannelUpdateDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_UnsignedChannelUpdateDecodeErrorZ.mjs":"lnLMt","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lnLMt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_UnsignedChannelUpdateDecodeErrorZ", ()=>Result_UnsignedChannelUpdateDecodeErrorZ
);
parcelHelpers.export(exports, "Result_UnsignedChannelUpdateDecodeErrorZ_OK", ()=>Result_UnsignedChannelUpdateDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_UnsignedChannelUpdateDecodeErrorZ_Err", ()=>Result_UnsignedChannelUpdateDecodeErrorZ_Err
) //# sourceMappingURL=Result_UnsignedChannelUpdateDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _unsignedChannelUpdateMjs = require("../structs/UnsignedChannelUpdate.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_UnsignedChannelUpdateDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_UnsignedChannelUpdateDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(ptr)) return new Result_UnsignedChannelUpdateDecodeErrorZ_OK(null, ptr);
        else return new Result_UnsignedChannelUpdateDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_UnsignedChannelUpdateDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_UnsignedChannelUpdateDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_UnsignedChannelUpdateDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_UnsignedChannelUpdateDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_UnsignedChannelUpdateDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_UnsignedChannelUpdateDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_UnsignedChannelUpdateDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_UnsignedChannelUpdateDecodeErrorZ_OK extends Result_UnsignedChannelUpdateDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_UnsignedChannelUpdateDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _unsignedChannelUpdateMjs.UnsignedChannelUpdate(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_UnsignedChannelUpdateDecodeErrorZ_Err extends Result_UnsignedChannelUpdateDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_UnsignedChannelUpdateDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/UnsignedChannelUpdate.mjs":"7IUgV","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"33S6G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ChannelUpdateDecodeErrorZ", ()=>Result_ChannelUpdateDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ChannelUpdateDecodeErrorZ_OK", ()=>Result_ChannelUpdateDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ChannelUpdateDecodeErrorZ_Err", ()=>Result_ChannelUpdateDecodeErrorZ_Err
) //# sourceMappingURL=Result_ChannelUpdateDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _channelUpdateMjs = require("../structs/ChannelUpdate.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ChannelUpdateDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ChannelUpdateDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ChannelUpdateDecodeErrorZ_is_ok(ptr)) return new Result_ChannelUpdateDecodeErrorZ_OK(null, ptr);
        else return new Result_ChannelUpdateDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ChannelUpdateDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ChannelUpdateDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ChannelUpdateDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ChannelUpdateDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ChannelUpdateDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ChannelUpdateDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ChannelUpdateDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_ChannelUpdateDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_ChannelUpdateDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_ChannelUpdateDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_ChannelUpdateDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_ChannelUpdateDecodeErrorZ_OK extends Result_ChannelUpdateDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ChannelUpdateDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _channelUpdateMjs.ChannelUpdate(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ChannelUpdateDecodeErrorZ_Err extends Result_ChannelUpdateDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ChannelUpdateDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/ChannelUpdate.mjs":"kLaF6","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"heqLn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Update to the [`NetworkGraph`] based on payment failure information conveyed via the Onion
 * return packet by a node along the route. See [BOLT #4] for details.
 *
 * [BOLT #4]: https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md
 */ parcelHelpers.export(exports, "NetworkUpdate", ()=>NetworkUpdate
);
/** A NetworkUpdate of type ChannelUpdateMessage */ parcelHelpers.export(exports, "NetworkUpdate_ChannelUpdateMessage", ()=>NetworkUpdate_ChannelUpdateMessage
);
/** A NetworkUpdate of type ChannelClosed */ parcelHelpers.export(exports, "NetworkUpdate_ChannelClosed", ()=>NetworkUpdate_ChannelClosed
);
/** A NetworkUpdate of type NodeFailure */ parcelHelpers.export(exports, "NetworkUpdate_NodeFailure", ()=>NetworkUpdate_NodeFailure
) //# sourceMappingURL=NetworkUpdate.mjs.map
;
var _channelUpdateMjs = require("../structs/ChannelUpdate.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class NetworkUpdate extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.NetworkUpdate_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKNetworkUpdate_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new NetworkUpdate_ChannelUpdateMessage(ptr);
            case 1:
                return new NetworkUpdate_ChannelClosed(ptr);
            case 2:
                return new NetworkUpdate_NodeFailure(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = _bindingsMjs.NetworkUpdate_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the NetworkUpdate
     */ clone() {
        const ret = _bindingsMjs.NetworkUpdate_clone(this.ptr);
        const ret_hu_conv = NetworkUpdate.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new ChannelUpdateMessage-variant NetworkUpdate
     */ static constructor_channel_update_message(msg) {
        const ret = _bindingsMjs.NetworkUpdate_channel_update_message(msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = NetworkUpdate.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new ChannelClosed-variant NetworkUpdate
     */ static constructor_channel_closed(short_channel_id, is_permanent) {
        const ret = _bindingsMjs.NetworkUpdate_channel_closed(short_channel_id, is_permanent);
        const ret_hu_conv = NetworkUpdate.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new NodeFailure-variant NetworkUpdate
     */ static constructor_node_failure(node_id, is_permanent) {
        const ret = _bindingsMjs.NetworkUpdate_node_failure(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), is_permanent);
        const ret_hu_conv = NetworkUpdate.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Serialize the NetworkUpdate object into a byte array which can be read by NetworkUpdate_read
     */ write() {
        const ret = _bindingsMjs.NetworkUpdate_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
}
class NetworkUpdate_ChannelUpdateMessage extends NetworkUpdate {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const msg = _bindingsMjs.LDKNetworkUpdate_ChannelUpdateMessage_get_msg(ptr);
        const msg_hu_conv = new _channelUpdateMjs.ChannelUpdate(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class NetworkUpdate_ChannelClosed extends NetworkUpdate {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        this.short_channel_id = _bindingsMjs.LDKNetworkUpdate_ChannelClosed_get_short_channel_id(ptr);
        this.is_permanent = _bindingsMjs.LDKNetworkUpdate_ChannelClosed_get_is_permanent(ptr);
    }
}
class NetworkUpdate_NodeFailure extends NetworkUpdate {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKNetworkUpdate_NodeFailure_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        this.is_permanent = _bindingsMjs.LDKNetworkUpdate_NodeFailure_get_is_permanent(ptr);
    }
}

},{"../structs/ChannelUpdate.mjs":"kLaF6","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3mbkX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An enum which can either contain a crate::lightning::routing::network_graph::NetworkUpdate or not
 */ parcelHelpers.export(exports, "Option_NetworkUpdateZ", ()=>Option_NetworkUpdateZ
);
/** A Option_NetworkUpdateZ of type Some */ parcelHelpers.export(exports, "Option_NetworkUpdateZ_Some", ()=>Option_NetworkUpdateZ_Some
);
/** A Option_NetworkUpdateZ of type None */ parcelHelpers.export(exports, "Option_NetworkUpdateZ_None", ()=>Option_NetworkUpdateZ_None
) //# sourceMappingURL=Option_NetworkUpdateZ.mjs.map
;
var _networkUpdateMjs = require("../structs/NetworkUpdate.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Option_NetworkUpdateZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.COption_NetworkUpdateZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKCOption_NetworkUpdateZ_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new Option_NetworkUpdateZ_Some(ptr);
            case 1:
                return new Option_NetworkUpdateZ_None(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    /**
     * Constructs a new COption_NetworkUpdateZ containing a crate::lightning::routing::network_graph::NetworkUpdate
     */ static constructor_some(o) {
        const ret = _bindingsMjs.COption_NetworkUpdateZ_some(_commonBaseMjsDefault.default.get_ptr_of(o));
        const ret_hu_conv = Option_NetworkUpdateZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Constructs a new COption_NetworkUpdateZ containing nothing
     */ static constructor_none() {
        const ret = _bindingsMjs.COption_NetworkUpdateZ_none();
        const ret_hu_conv = Option_NetworkUpdateZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.COption_NetworkUpdateZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new COption_NetworkUpdateZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.COption_NetworkUpdateZ_clone(this.ptr);
        const ret_hu_conv = Option_NetworkUpdateZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
class Option_NetworkUpdateZ_Some extends Option_NetworkUpdateZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const some = _bindingsMjs.LDKCOption_NetworkUpdateZ_Some_get_some(ptr);
        const some_hu_conv = _networkUpdateMjs.NetworkUpdate.constr_from_ptr(some);
        _commonBaseMjsDefault.default.add_ref_from(some_hu_conv, this);
        this.some = some_hu_conv;
    }
}
class Option_NetworkUpdateZ_None extends Option_NetworkUpdateZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}

},{"../structs/NetworkUpdate.mjs":"heqLn","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hQQ4g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A hop in a route
 */ parcelHelpers.export(exports, "RouteHop", ()=>RouteHop
) //# sourceMappingURL=RouteHop.mjs.map
;
var _resultRouteHopDecodeErrorZMjs = require("../structs/Result_RouteHopDecodeErrorZ.mjs");
var _channelFeaturesMjs = require("../structs/ChannelFeatures.mjs");
var _nodeFeaturesMjs = require("../structs/NodeFeatures.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class RouteHop extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.RouteHop_free);
    }
    /**
     * The node_id of the node at this hop.
     */ get_pubkey() {
        const ret = _bindingsMjs.RouteHop_get_pubkey(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The node_id of the node at this hop.
     */ set_pubkey(val) {
        _bindingsMjs.RouteHop_set_pubkey(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * The node_announcement features of the node at this hop. For the last hop, these may be
     * amended to match the features present in the invoice this node generated.
     */ get_node_features() {
        const ret = _bindingsMjs.RouteHop_get_node_features(this.ptr);
        const ret_hu_conv = new _nodeFeaturesMjs.NodeFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The node_announcement features of the node at this hop. For the last hop, these may be
     * amended to match the features present in the invoice this node generated.
     */ set_node_features(val) {
        _bindingsMjs.RouteHop_set_node_features(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * The channel that should be used from the previous hop to reach this node.
     */ get_short_channel_id() {
        const ret = _bindingsMjs.RouteHop_get_short_channel_id(this.ptr);
        return ret;
    }
    /**
     * The channel that should be used from the previous hop to reach this node.
     */ set_short_channel_id(val) {
        _bindingsMjs.RouteHop_set_short_channel_id(this.ptr, val);
    }
    /**
     * The channel_announcement features of the channel that should be used from the previous hop
     * to reach this node.
     */ get_channel_features() {
        const ret = _bindingsMjs.RouteHop_get_channel_features(this.ptr);
        const ret_hu_conv = new _channelFeaturesMjs.ChannelFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The channel_announcement features of the channel that should be used from the previous hop
     * to reach this node.
     */ set_channel_features(val) {
        _bindingsMjs.RouteHop_set_channel_features(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * The fee taken on this hop (for paying for the use of the *next* channel in the path).
     * For the last hop, this should be the full value of the payment (might be more than
     * requested if we had to match htlc_minimum_msat).
     */ get_fee_msat() {
        const ret = _bindingsMjs.RouteHop_get_fee_msat(this.ptr);
        return ret;
    }
    /**
     * The fee taken on this hop (for paying for the use of the *next* channel in the path).
     * For the last hop, this should be the full value of the payment (might be more than
     * requested if we had to match htlc_minimum_msat).
     */ set_fee_msat(val) {
        _bindingsMjs.RouteHop_set_fee_msat(this.ptr, val);
    }
    /**
     * The CLTV delta added for this hop. For the last hop, this should be the full CLTV value
     * expected at the destination, in excess of the current block height.
     */ get_cltv_expiry_delta() {
        const ret = _bindingsMjs.RouteHop_get_cltv_expiry_delta(this.ptr);
        return ret;
    }
    /**
     * The CLTV delta added for this hop. For the last hop, this should be the full CLTV value
     * expected at the destination, in excess of the current block height.
     */ set_cltv_expiry_delta(val) {
        _bindingsMjs.RouteHop_set_cltv_expiry_delta(this.ptr, val);
    }
    /**
     * Constructs a new RouteHop given each field
     */ static constructor_new(pubkey_arg, node_features_arg, short_channel_id_arg, channel_features_arg, fee_msat_arg, cltv_expiry_delta_arg) {
        const ret = _bindingsMjs.RouteHop_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(pubkey_arg, 33)), node_features_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(node_features_arg) & -2, short_channel_id_arg, channel_features_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(channel_features_arg) & -2, fee_msat_arg, cltv_expiry_delta_arg);
        const ret_hu_conv = new RouteHop(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.RouteHop_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the RouteHop
     */ clone() {
        const ret = _bindingsMjs.RouteHop_clone(this.ptr);
        const ret_hu_conv = new RouteHop(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Checks if two RouteHops contain equal inner contents.
     */ hash() {
        const ret = _bindingsMjs.RouteHop_hash(this.ptr);
        return ret;
    }
    /**
     * Checks if two RouteHops contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */ eq(b) {
        const ret = _bindingsMjs.RouteHop_eq(this.ptr, b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, b);
        return ret;
    }
    /**
     * Serialize the RouteHop object into a byte array which can be read by RouteHop_read
     */ write() {
        const ret = _bindingsMjs.RouteHop_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a RouteHop from a byte array, created by RouteHop_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.RouteHop_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultRouteHopDecodeErrorZMjs.Result_RouteHopDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_RouteHopDecodeErrorZ.mjs":"dvgVM","../structs/ChannelFeatures.mjs":"89gCD","../structs/NodeFeatures.mjs":"8eCA6","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dvgVM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_RouteHopDecodeErrorZ", ()=>Result_RouteHopDecodeErrorZ
);
parcelHelpers.export(exports, "Result_RouteHopDecodeErrorZ_OK", ()=>Result_RouteHopDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_RouteHopDecodeErrorZ_Err", ()=>Result_RouteHopDecodeErrorZ_Err
) //# sourceMappingURL=Result_RouteHopDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _routeHopMjs = require("../structs/RouteHop.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_RouteHopDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_RouteHopDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_RouteHopDecodeErrorZ_is_ok(ptr)) return new Result_RouteHopDecodeErrorZ_OK(null, ptr);
        else return new Result_RouteHopDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_RouteHopDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_RouteHopDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_RouteHopDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_RouteHopDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_RouteHopDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_RouteHopDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_RouteHopDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_RouteHopDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_RouteHopDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_RouteHopDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_RouteHopDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_RouteHopDecodeErrorZ_OK extends Result_RouteHopDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_RouteHopDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _routeHopMjs.RouteHop(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_RouteHopDecodeErrorZ_Err extends Result_RouteHopDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_RouteHopDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/RouteHop.mjs":"hQQ4g","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"89gCD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Features used within a `channel_announcement` message.
 */ parcelHelpers.export(exports, "ChannelFeatures", ()=>ChannelFeatures
) //# sourceMappingURL=ChannelFeatures.mjs.map
;
var _resultChannelFeaturesDecodeErrorZMjs = require("../structs/Result_ChannelFeaturesDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelFeatures extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelFeatures_free);
    }
    /**
     * Checks if two ChannelFeaturess contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */ eq(b) {
        const ret = _bindingsMjs.ChannelFeatures_eq(this.ptr, b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, b);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ChannelFeatures_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelFeatures
     */ clone() {
        const ret = _bindingsMjs.ChannelFeatures_clone(this.ptr);
        const ret_hu_conv = new ChannelFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Create a blank Features with no features set
     */ static constructor_empty() {
        const ret = _bindingsMjs.ChannelFeatures_empty();
        const ret_hu_conv = new ChannelFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Creates a Features with the bits set which are known by the implementation
     */ static constructor_known() {
        const ret = _bindingsMjs.ChannelFeatures_known();
        const ret_hu_conv = new ChannelFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Returns true if this `Features` object contains unknown feature flags which are set as
     * \"required\".
     */ requires_unknown_bits() {
        const ret = _bindingsMjs.ChannelFeatures_requires_unknown_bits(this.ptr);
        return ret;
    }
    /**
     * Serialize the ChannelFeatures object into a byte array which can be read by ChannelFeatures_read
     */ write() {
        const ret = _bindingsMjs.ChannelFeatures_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ChannelFeatures from a byte array, created by ChannelFeatures_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ChannelFeatures_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultChannelFeaturesDecodeErrorZMjs.Result_ChannelFeaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_ChannelFeaturesDecodeErrorZ.mjs":"6Sjo8","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Sjo8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ChannelFeaturesDecodeErrorZ", ()=>Result_ChannelFeaturesDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ChannelFeaturesDecodeErrorZ_OK", ()=>Result_ChannelFeaturesDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ChannelFeaturesDecodeErrorZ_Err", ()=>Result_ChannelFeaturesDecodeErrorZ_Err
) //# sourceMappingURL=Result_ChannelFeaturesDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _channelFeaturesMjs = require("../structs/ChannelFeatures.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ChannelFeaturesDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ChannelFeaturesDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ChannelFeaturesDecodeErrorZ_is_ok(ptr)) return new Result_ChannelFeaturesDecodeErrorZ_OK(null, ptr);
        else return new Result_ChannelFeaturesDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ChannelFeaturesDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ChannelFeaturesDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ChannelFeaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ChannelFeaturesDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ChannelFeaturesDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ChannelFeaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ChannelFeaturesDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
}
class Result_ChannelFeaturesDecodeErrorZ_OK extends Result_ChannelFeaturesDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ChannelFeaturesDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _channelFeaturesMjs.ChannelFeatures(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ChannelFeaturesDecodeErrorZ_Err extends Result_ChannelFeaturesDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ChannelFeaturesDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/ChannelFeatures.mjs":"89gCD","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8eCA6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Features used within a `node_announcement` message.
 */ parcelHelpers.export(exports, "NodeFeatures", ()=>NodeFeatures
) //# sourceMappingURL=NodeFeatures.mjs.map
;
var _resultNodeFeaturesDecodeErrorZMjs = require("../structs/Result_NodeFeaturesDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class NodeFeatures extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.NodeFeatures_free);
    }
    /**
     * Checks if two NodeFeaturess contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */ eq(b) {
        const ret = _bindingsMjs.NodeFeatures_eq(this.ptr, b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, b);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.NodeFeatures_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the NodeFeatures
     */ clone() {
        const ret = _bindingsMjs.NodeFeatures_clone(this.ptr);
        const ret_hu_conv = new NodeFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Create a blank Features with no features set
     */ static constructor_empty() {
        const ret = _bindingsMjs.NodeFeatures_empty();
        const ret_hu_conv = new NodeFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Creates a Features with the bits set which are known by the implementation
     */ static constructor_known() {
        const ret = _bindingsMjs.NodeFeatures_known();
        const ret_hu_conv = new NodeFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Returns true if this `Features` object contains unknown feature flags which are set as
     * \"required\".
     */ requires_unknown_bits() {
        const ret = _bindingsMjs.NodeFeatures_requires_unknown_bits(this.ptr);
        return ret;
    }
    /**
     * Serialize the NodeFeatures object into a byte array which can be read by NodeFeatures_read
     */ write() {
        const ret = _bindingsMjs.NodeFeatures_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a NodeFeatures from a byte array, created by NodeFeatures_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.NodeFeatures_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultNodeFeaturesDecodeErrorZMjs.Result_NodeFeaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_NodeFeaturesDecodeErrorZ.mjs":"kdMHz","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kdMHz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_NodeFeaturesDecodeErrorZ", ()=>Result_NodeFeaturesDecodeErrorZ
);
parcelHelpers.export(exports, "Result_NodeFeaturesDecodeErrorZ_OK", ()=>Result_NodeFeaturesDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_NodeFeaturesDecodeErrorZ_Err", ()=>Result_NodeFeaturesDecodeErrorZ_Err
) //# sourceMappingURL=Result_NodeFeaturesDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _nodeFeaturesMjs = require("../structs/NodeFeatures.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_NodeFeaturesDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_NodeFeaturesDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_NodeFeaturesDecodeErrorZ_is_ok(ptr)) return new Result_NodeFeaturesDecodeErrorZ_OK(null, ptr);
        else return new Result_NodeFeaturesDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_NodeFeaturesDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_NodeFeaturesDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_NodeFeaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_NodeFeaturesDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_NodeFeaturesDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_NodeFeaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_NodeFeaturesDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
}
class Result_NodeFeaturesDecodeErrorZ_OK extends Result_NodeFeaturesDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_NodeFeaturesDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _nodeFeaturesMjs.NodeFeatures(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_NodeFeaturesDecodeErrorZ_Err extends Result_NodeFeaturesDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_NodeFeaturesDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/NodeFeatures.mjs":"8eCA6","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2hS5b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Parameters needed to find a [`Route`] for paying a [`Payee`].
 *
 * Passed to [`find_route`] and also provided in [`Event::PaymentPathFailed`] for retrying a failed
 * payment path.
 *
 * [`Event::PaymentPathFailed`]: crate::util::events::Event::PaymentPathFailed
 */ parcelHelpers.export(exports, "RouteParameters", ()=>RouteParameters
) //# sourceMappingURL=RouteParameters.mjs.map
;
var _resultRouteParametersDecodeErrorZMjs = require("../structs/Result_RouteParametersDecodeErrorZ.mjs");
var _payeeMjs = require("../structs/Payee.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class RouteParameters extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.RouteParameters_free);
    }
    /**
     * The recipient of the failed payment path.
     */ get_payee() {
        const ret = _bindingsMjs.RouteParameters_get_payee(this.ptr);
        const ret_hu_conv = new _payeeMjs.Payee(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The recipient of the failed payment path.
     */ set_payee(val) {
        _bindingsMjs.RouteParameters_set_payee(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * The amount in msats sent on the failed payment path.
     */ get_final_value_msat() {
        const ret = _bindingsMjs.RouteParameters_get_final_value_msat(this.ptr);
        return ret;
    }
    /**
     * The amount in msats sent on the failed payment path.
     */ set_final_value_msat(val) {
        _bindingsMjs.RouteParameters_set_final_value_msat(this.ptr, val);
    }
    /**
     * The CLTV on the final hop of the failed payment path.
     */ get_final_cltv_expiry_delta() {
        const ret = _bindingsMjs.RouteParameters_get_final_cltv_expiry_delta(this.ptr);
        return ret;
    }
    /**
     * The CLTV on the final hop of the failed payment path.
     */ set_final_cltv_expiry_delta(val) {
        _bindingsMjs.RouteParameters_set_final_cltv_expiry_delta(this.ptr, val);
    }
    /**
     * Constructs a new RouteParameters given each field
     */ static constructor_new(payee_arg, final_value_msat_arg, final_cltv_expiry_delta_arg) {
        const ret = _bindingsMjs.RouteParameters_new(payee_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(payee_arg) & -2, final_value_msat_arg, final_cltv_expiry_delta_arg);
        const ret_hu_conv = new RouteParameters(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.RouteParameters_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the RouteParameters
     */ clone() {
        const ret = _bindingsMjs.RouteParameters_clone(this.ptr);
        const ret_hu_conv = new RouteParameters(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the RouteParameters object into a byte array which can be read by RouteParameters_read
     */ write() {
        const ret = _bindingsMjs.RouteParameters_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a RouteParameters from a byte array, created by RouteParameters_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.RouteParameters_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultRouteParametersDecodeErrorZMjs.Result_RouteParametersDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_RouteParametersDecodeErrorZ.mjs":"hCItn","../structs/Payee.mjs":"3fxcr","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hCItn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_RouteParametersDecodeErrorZ", ()=>Result_RouteParametersDecodeErrorZ
);
parcelHelpers.export(exports, "Result_RouteParametersDecodeErrorZ_OK", ()=>Result_RouteParametersDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_RouteParametersDecodeErrorZ_Err", ()=>Result_RouteParametersDecodeErrorZ_Err
) //# sourceMappingURL=Result_RouteParametersDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _routeParametersMjs = require("../structs/RouteParameters.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_RouteParametersDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_RouteParametersDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_RouteParametersDecodeErrorZ_is_ok(ptr)) return new Result_RouteParametersDecodeErrorZ_OK(null, ptr);
        else return new Result_RouteParametersDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_RouteParametersDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_RouteParametersDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_RouteParametersDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_RouteParametersDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_RouteParametersDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_RouteParametersDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_RouteParametersDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_RouteParametersDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_RouteParametersDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_RouteParametersDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_RouteParametersDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_RouteParametersDecodeErrorZ_OK extends Result_RouteParametersDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_RouteParametersDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _routeParametersMjs.RouteParameters(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_RouteParametersDecodeErrorZ_Err extends Result_RouteParametersDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_RouteParametersDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/RouteParameters.mjs":"2hS5b","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3fxcr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The recipient of a payment.
 */ parcelHelpers.export(exports, "Payee", ()=>Payee
) //# sourceMappingURL=Payee.mjs.map
;
var _optionU64ZMjs = require("../structs/Option_u64Z.mjs");
var _routeHintMjs = require("../structs/RouteHint.mjs");
var _resultPayeeDecodeErrorZMjs = require("../structs/Result_PayeeDecodeErrorZ.mjs");
var _invoiceFeaturesMjs = require("../structs/InvoiceFeatures.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Payee extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Payee_free);
    }
    /**
     * The node id of the payee.
     */ get_pubkey() {
        const ret = _bindingsMjs.Payee_get_pubkey(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The node id of the payee.
     */ set_pubkey(val) {
        _bindingsMjs.Payee_set_pubkey(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Features supported by the payee.
     *
     * May be set from the payee's invoice or via [`for_keysend`]. May be `None` if the invoice
     * does not contain any features.
     *
     * [`for_keysend`]: Self::for_keysend
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_features() {
        const ret = _bindingsMjs.Payee_get_features(this.ptr);
        const ret_hu_conv = new _invoiceFeaturesMjs.InvoiceFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Features supported by the payee.
     *
     * May be set from the payee's invoice or via [`for_keysend`]. May be `None` if the invoice
     * does not contain any features.
     *
     * [`for_keysend`]: Self::for_keysend
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_features(val) {
        _bindingsMjs.Payee_set_features(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Hints for routing to the payee, containing channels connecting the payee to public nodes.
     */ get_route_hints() {
        const ret = _bindingsMjs.Payee_get_route_hints(this.ptr);
        const ret_conv_11_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_11_arr = new Array(ret_conv_11_len).fill(null);
        for(var l = 0; l < ret_conv_11_len; l++){
            const ret_conv_11 = _bindingsMjs.getU32ArrayElem(ret, l);
            const ret_conv_11_hu_conv = new _routeHintMjs.RouteHint(null, ret_conv_11);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_11_hu_conv, this);
            ret_conv_11_arr[l] = ret_conv_11_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_11_arr;
    }
    /**
     * Hints for routing to the payee, containing channels connecting the payee to public nodes.
     */ set_route_hints(val) {
        _bindingsMjs.Payee_set_route_hints(this.ptr, _bindingsMjs.encodeUint32Array(val != null ? val.map((val_conv_11)=>val_conv_11 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val_conv_11) & -2
        ) : null));
    }
    /**
     * Expiration of a payment to the payee, in seconds relative to the UNIX epoch.
     */ get_expiry_time() {
        const ret = _bindingsMjs.Payee_get_expiry_time(this.ptr);
        const ret_hu_conv = _optionU64ZMjs.Option_u64Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Expiration of a payment to the payee, in seconds relative to the UNIX epoch.
     */ set_expiry_time(val) {
        _bindingsMjs.Payee_set_expiry_time(this.ptr, _commonBaseMjsDefault.default.get_ptr_of(val));
    }
    /**
     * Constructs a new Payee given each field
     */ static constructor_new(pubkey_arg, features_arg, route_hints_arg, expiry_time_arg) {
        const ret = _bindingsMjs.Payee_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(pubkey_arg, 33)), features_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(features_arg) & -2, _bindingsMjs.encodeUint32Array(route_hints_arg != null ? route_hints_arg.map((route_hints_arg_conv_11)=>route_hints_arg_conv_11 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(route_hints_arg_conv_11) & -2
        ) : null), _commonBaseMjsDefault.default.get_ptr_of(expiry_time_arg));
        const ret_hu_conv = new Payee(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.Payee_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the Payee
     */ clone() {
        const ret = _bindingsMjs.Payee_clone(this.ptr);
        const ret_hu_conv = new Payee(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Checks if two Payees contain equal inner contents.
     */ hash() {
        const ret = _bindingsMjs.Payee_hash(this.ptr);
        return ret;
    }
    /**
     * Checks if two Payees contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */ eq(b) {
        const ret = _bindingsMjs.Payee_eq(this.ptr, b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, b);
        return ret;
    }
    /**
     * Serialize the Payee object into a byte array which can be read by Payee_read
     */ write() {
        const ret = _bindingsMjs.Payee_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a Payee from a byte array, created by Payee_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.Payee_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultPayeeDecodeErrorZMjs.Result_PayeeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a payee with the node id of the given `pubkey`.
     */ static constructor_from_node_id(pubkey) {
        const ret = _bindingsMjs.Payee_from_node_id(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(pubkey, 33)));
        const ret_hu_conv = new Payee(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Creates a payee with the node id of the given `pubkey` to use for keysend payments.
     */ static constructor_for_keysend(pubkey) {
        const ret = _bindingsMjs.Payee_for_keysend(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(pubkey, 33)));
        const ret_hu_conv = new Payee(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"../structs/Option_u64Z.mjs":"8VC1Q","../structs/RouteHint.mjs":"bvyYI","../structs/Result_PayeeDecodeErrorZ.mjs":"g3cP6","../structs/InvoiceFeatures.mjs":"1EI2T","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bvyYI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A list of hops along a payment path terminating with a channel to the recipient.
 */ parcelHelpers.export(exports, "RouteHint", ()=>RouteHint
) //# sourceMappingURL=RouteHint.mjs.map
;
var _routeHintHopMjs = require("../structs/RouteHintHop.mjs");
var _resultRouteHintDecodeErrorZMjs = require("../structs/Result_RouteHintDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class RouteHint extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.RouteHint_free);
    }
    get_a() {
        const ret = _bindingsMjs.RouteHint_get_a(this.ptr);
        const ret_conv_14_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_14_arr = new Array(ret_conv_14_len).fill(null);
        for(var o = 0; o < ret_conv_14_len; o++){
            const ret_conv_14 = _bindingsMjs.getU32ArrayElem(ret, o);
            const ret_conv_14_hu_conv = new _routeHintHopMjs.RouteHintHop(null, ret_conv_14);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_14_hu_conv, this);
            ret_conv_14_arr[o] = ret_conv_14_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_14_arr;
    }
    set_a(val) {
        _bindingsMjs.RouteHint_set_a(this.ptr, _bindingsMjs.encodeUint32Array(val != null ? val.map((val_conv_14)=>val_conv_14 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val_conv_14) & -2
        ) : null));
    }
    /**
     * Constructs a new RouteHint given each field
     */ static constructor_new(a_arg) {
        const ret = _bindingsMjs.RouteHint_new(_bindingsMjs.encodeUint32Array(a_arg != null ? a_arg.map((a_arg_conv_14)=>a_arg_conv_14 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(a_arg_conv_14) & -2
        ) : null));
        const ret_hu_conv = new RouteHint(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.RouteHint_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the RouteHint
     */ clone() {
        const ret = _bindingsMjs.RouteHint_clone(this.ptr);
        const ret_hu_conv = new RouteHint(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Checks if two RouteHints contain equal inner contents.
     */ hash() {
        const ret = _bindingsMjs.RouteHint_hash(this.ptr);
        return ret;
    }
    /**
     * Checks if two RouteHints contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */ eq(b) {
        const ret = _bindingsMjs.RouteHint_eq(this.ptr, b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, b);
        return ret;
    }
    /**
     * Serialize the RouteHint object into a byte array which can be read by RouteHint_read
     */ write() {
        const ret = _bindingsMjs.RouteHint_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a RouteHint from a byte array, created by RouteHint_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.RouteHint_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultRouteHintDecodeErrorZMjs.Result_RouteHintDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/RouteHintHop.mjs":"FzGCI","../structs/Result_RouteHintDecodeErrorZ.mjs":"fW09Z","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"FzGCI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A channel descriptor for a hop along a payment path.
 */ parcelHelpers.export(exports, "RouteHintHop", ()=>RouteHintHop
) //# sourceMappingURL=RouteHintHop.mjs.map
;
var _optionU64ZMjs = require("../structs/Option_u64Z.mjs");
var _resultRouteHintHopDecodeErrorZMjs = require("../structs/Result_RouteHintHopDecodeErrorZ.mjs");
var _routingFeesMjs = require("../structs/RoutingFees.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class RouteHintHop extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.RouteHintHop_free);
    }
    /**
     * The node_id of the non-target end of the route
     */ get_src_node_id() {
        const ret = _bindingsMjs.RouteHintHop_get_src_node_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The node_id of the non-target end of the route
     */ set_src_node_id(val) {
        _bindingsMjs.RouteHintHop_set_src_node_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * The short_channel_id of this channel
     */ get_short_channel_id() {
        const ret = _bindingsMjs.RouteHintHop_get_short_channel_id(this.ptr);
        return ret;
    }
    /**
     * The short_channel_id of this channel
     */ set_short_channel_id(val) {
        _bindingsMjs.RouteHintHop_set_short_channel_id(this.ptr, val);
    }
    /**
     * The fees which must be paid to use this channel
     */ get_fees() {
        const ret = _bindingsMjs.RouteHintHop_get_fees(this.ptr);
        const ret_hu_conv = new _routingFeesMjs.RoutingFees(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The fees which must be paid to use this channel
     */ set_fees(val) {
        _bindingsMjs.RouteHintHop_set_fees(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * The difference in CLTV values between this node and the next node.
     */ get_cltv_expiry_delta() {
        const ret = _bindingsMjs.RouteHintHop_get_cltv_expiry_delta(this.ptr);
        return ret;
    }
    /**
     * The difference in CLTV values between this node and the next node.
     */ set_cltv_expiry_delta(val) {
        _bindingsMjs.RouteHintHop_set_cltv_expiry_delta(this.ptr, val);
    }
    /**
     * The minimum value, in msat, which must be relayed to the next hop.
     */ get_htlc_minimum_msat() {
        const ret = _bindingsMjs.RouteHintHop_get_htlc_minimum_msat(this.ptr);
        const ret_hu_conv = _optionU64ZMjs.Option_u64Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The minimum value, in msat, which must be relayed to the next hop.
     */ set_htlc_minimum_msat(val) {
        _bindingsMjs.RouteHintHop_set_htlc_minimum_msat(this.ptr, _commonBaseMjsDefault.default.get_ptr_of(val));
    }
    /**
     * The maximum value in msat available for routing with a single HTLC.
     */ get_htlc_maximum_msat() {
        const ret = _bindingsMjs.RouteHintHop_get_htlc_maximum_msat(this.ptr);
        const ret_hu_conv = _optionU64ZMjs.Option_u64Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The maximum value in msat available for routing with a single HTLC.
     */ set_htlc_maximum_msat(val) {
        _bindingsMjs.RouteHintHop_set_htlc_maximum_msat(this.ptr, _commonBaseMjsDefault.default.get_ptr_of(val));
    }
    /**
     * Constructs a new RouteHintHop given each field
     */ static constructor_new(src_node_id_arg, short_channel_id_arg, fees_arg, cltv_expiry_delta_arg, htlc_minimum_msat_arg, htlc_maximum_msat_arg) {
        const ret = _bindingsMjs.RouteHintHop_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(src_node_id_arg, 33)), short_channel_id_arg, fees_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(fees_arg) & -2, cltv_expiry_delta_arg, _commonBaseMjsDefault.default.get_ptr_of(htlc_minimum_msat_arg), _commonBaseMjsDefault.default.get_ptr_of(htlc_maximum_msat_arg));
        const ret_hu_conv = new RouteHintHop(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.RouteHintHop_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the RouteHintHop
     */ clone() {
        const ret = _bindingsMjs.RouteHintHop_clone(this.ptr);
        const ret_hu_conv = new RouteHintHop(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Checks if two RouteHintHops contain equal inner contents.
     */ hash() {
        const ret = _bindingsMjs.RouteHintHop_hash(this.ptr);
        return ret;
    }
    /**
     * Checks if two RouteHintHops contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */ eq(b) {
        const ret = _bindingsMjs.RouteHintHop_eq(this.ptr, b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, b);
        return ret;
    }
    /**
     * Serialize the RouteHintHop object into a byte array which can be read by RouteHintHop_read
     */ write() {
        const ret = _bindingsMjs.RouteHintHop_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a RouteHintHop from a byte array, created by RouteHintHop_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.RouteHintHop_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultRouteHintHopDecodeErrorZMjs.Result_RouteHintHopDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Option_u64Z.mjs":"8VC1Q","../structs/Result_RouteHintHopDecodeErrorZ.mjs":"8SWYJ","../structs/RoutingFees.mjs":"7CDJ9","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8SWYJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_RouteHintHopDecodeErrorZ", ()=>Result_RouteHintHopDecodeErrorZ
);
parcelHelpers.export(exports, "Result_RouteHintHopDecodeErrorZ_OK", ()=>Result_RouteHintHopDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_RouteHintHopDecodeErrorZ_Err", ()=>Result_RouteHintHopDecodeErrorZ_Err
) //# sourceMappingURL=Result_RouteHintHopDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _routeHintHopMjs = require("../structs/RouteHintHop.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_RouteHintHopDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_RouteHintHopDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_RouteHintHopDecodeErrorZ_is_ok(ptr)) return new Result_RouteHintHopDecodeErrorZ_OK(null, ptr);
        else return new Result_RouteHintHopDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_RouteHintHopDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_RouteHintHopDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_RouteHintHopDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_RouteHintHopDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_RouteHintHopDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_RouteHintHopDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_RouteHintHopDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_RouteHintHopDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_RouteHintHopDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_RouteHintHopDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_RouteHintHopDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_RouteHintHopDecodeErrorZ_OK extends Result_RouteHintHopDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_RouteHintHopDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _routeHintHopMjs.RouteHintHop(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_RouteHintHopDecodeErrorZ_Err extends Result_RouteHintHopDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_RouteHintHopDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/RouteHintHop.mjs":"FzGCI","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7CDJ9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Fees for routing via a given channel or a node
 */ parcelHelpers.export(exports, "RoutingFees", ()=>RoutingFees
) //# sourceMappingURL=RoutingFees.mjs.map
;
var _resultRoutingFeesDecodeErrorZMjs = require("../structs/Result_RoutingFeesDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class RoutingFees extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.RoutingFees_free);
    }
    /**
     * Flat routing fee in satoshis
     */ get_base_msat() {
        const ret = _bindingsMjs.RoutingFees_get_base_msat(this.ptr);
        return ret;
    }
    /**
     * Flat routing fee in satoshis
     */ set_base_msat(val) {
        _bindingsMjs.RoutingFees_set_base_msat(this.ptr, val);
    }
    /**
     * Liquidity-based routing fee in millionths of a routed amount.
     * In other words, 10000 is 1%.
     */ get_proportional_millionths() {
        const ret = _bindingsMjs.RoutingFees_get_proportional_millionths(this.ptr);
        return ret;
    }
    /**
     * Liquidity-based routing fee in millionths of a routed amount.
     * In other words, 10000 is 1%.
     */ set_proportional_millionths(val) {
        _bindingsMjs.RoutingFees_set_proportional_millionths(this.ptr, val);
    }
    /**
     * Constructs a new RoutingFees given each field
     */ static constructor_new(base_msat_arg, proportional_millionths_arg) {
        const ret = _bindingsMjs.RoutingFees_new(base_msat_arg, proportional_millionths_arg);
        const ret_hu_conv = new RoutingFees(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Checks if two RoutingFeess contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */ eq(b) {
        const ret = _bindingsMjs.RoutingFees_eq(this.ptr, b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, b);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.RoutingFees_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the RoutingFees
     */ clone() {
        const ret = _bindingsMjs.RoutingFees_clone(this.ptr);
        const ret_hu_conv = new RoutingFees(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Checks if two RoutingFeess contain equal inner contents.
     */ hash() {
        const ret = _bindingsMjs.RoutingFees_hash(this.ptr);
        return ret;
    }
    /**
     * Serialize the RoutingFees object into a byte array which can be read by RoutingFees_read
     */ write() {
        const ret = _bindingsMjs.RoutingFees_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a RoutingFees from a byte array, created by RoutingFees_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.RoutingFees_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultRoutingFeesDecodeErrorZMjs.Result_RoutingFeesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_RoutingFeesDecodeErrorZ.mjs":"fxfD8","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fxfD8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_RoutingFeesDecodeErrorZ", ()=>Result_RoutingFeesDecodeErrorZ
);
parcelHelpers.export(exports, "Result_RoutingFeesDecodeErrorZ_OK", ()=>Result_RoutingFeesDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_RoutingFeesDecodeErrorZ_Err", ()=>Result_RoutingFeesDecodeErrorZ_Err
) //# sourceMappingURL=Result_RoutingFeesDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _routingFeesMjs = require("../structs/RoutingFees.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_RoutingFeesDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_RoutingFeesDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_RoutingFeesDecodeErrorZ_is_ok(ptr)) return new Result_RoutingFeesDecodeErrorZ_OK(null, ptr);
        else return new Result_RoutingFeesDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_RoutingFeesDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_RoutingFeesDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_RoutingFeesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_RoutingFeesDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_RoutingFeesDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_RoutingFeesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_RoutingFeesDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_RoutingFeesDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_RoutingFeesDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_RoutingFeesDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_RoutingFeesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_RoutingFeesDecodeErrorZ_OK extends Result_RoutingFeesDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_RoutingFeesDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _routingFeesMjs.RoutingFees(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_RoutingFeesDecodeErrorZ_Err extends Result_RoutingFeesDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_RoutingFeesDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/RoutingFees.mjs":"7CDJ9","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fW09Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_RouteHintDecodeErrorZ", ()=>Result_RouteHintDecodeErrorZ
);
parcelHelpers.export(exports, "Result_RouteHintDecodeErrorZ_OK", ()=>Result_RouteHintDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_RouteHintDecodeErrorZ_Err", ()=>Result_RouteHintDecodeErrorZ_Err
) //# sourceMappingURL=Result_RouteHintDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _routeHintMjs = require("../structs/RouteHint.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_RouteHintDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_RouteHintDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_RouteHintDecodeErrorZ_is_ok(ptr)) return new Result_RouteHintDecodeErrorZ_OK(null, ptr);
        else return new Result_RouteHintDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_RouteHintDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_RouteHintDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_RouteHintDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_RouteHintDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_RouteHintDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_RouteHintDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_RouteHintDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_RouteHintDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_RouteHintDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_RouteHintDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_RouteHintDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_RouteHintDecodeErrorZ_OK extends Result_RouteHintDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_RouteHintDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _routeHintMjs.RouteHint(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_RouteHintDecodeErrorZ_Err extends Result_RouteHintDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_RouteHintDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/RouteHint.mjs":"bvyYI","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g3cP6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_PayeeDecodeErrorZ", ()=>Result_PayeeDecodeErrorZ
);
parcelHelpers.export(exports, "Result_PayeeDecodeErrorZ_OK", ()=>Result_PayeeDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_PayeeDecodeErrorZ_Err", ()=>Result_PayeeDecodeErrorZ_Err
) //# sourceMappingURL=Result_PayeeDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _payeeMjs = require("../structs/Payee.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_PayeeDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_PayeeDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_PayeeDecodeErrorZ_is_ok(ptr)) return new Result_PayeeDecodeErrorZ_OK(null, ptr);
        else return new Result_PayeeDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_PayeeDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_PayeeDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_PayeeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_PayeeDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_PayeeDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_PayeeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_PayeeDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_PayeeDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_PayeeDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_PayeeDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_PayeeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_PayeeDecodeErrorZ_OK extends Result_PayeeDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_PayeeDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _payeeMjs.Payee(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_PayeeDecodeErrorZ_Err extends Result_PayeeDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_PayeeDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/Payee.mjs":"3fxcr","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1EI2T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Features used within an invoice.
 */ parcelHelpers.export(exports, "InvoiceFeatures", ()=>InvoiceFeatures
) //# sourceMappingURL=InvoiceFeatures.mjs.map
;
var _resultInvoiceFeaturesDecodeErrorZMjs = require("../structs/Result_InvoiceFeaturesDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class InvoiceFeatures extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.InvoiceFeatures_free);
    }
    /**
     * Checks if two InvoiceFeaturess contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */ eq(b) {
        const ret = _bindingsMjs.InvoiceFeatures_eq(this.ptr, b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, b);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.InvoiceFeatures_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the InvoiceFeatures
     */ clone() {
        const ret = _bindingsMjs.InvoiceFeatures_clone(this.ptr);
        const ret_hu_conv = new InvoiceFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Create a blank Features with no features set
     */ static constructor_empty() {
        const ret = _bindingsMjs.InvoiceFeatures_empty();
        const ret_hu_conv = new InvoiceFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Creates a Features with the bits set which are known by the implementation
     */ static constructor_known() {
        const ret = _bindingsMjs.InvoiceFeatures_known();
        const ret_hu_conv = new InvoiceFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Returns true if this `Features` object contains unknown feature flags which are set as
     * \"required\".
     */ requires_unknown_bits() {
        const ret = _bindingsMjs.InvoiceFeatures_requires_unknown_bits(this.ptr);
        return ret;
    }
    /**
     * Serialize the InvoiceFeatures object into a byte array which can be read by InvoiceFeatures_read
     */ write() {
        const ret = _bindingsMjs.InvoiceFeatures_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a InvoiceFeatures from a byte array, created by InvoiceFeatures_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.InvoiceFeatures_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultInvoiceFeaturesDecodeErrorZMjs.Result_InvoiceFeaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_InvoiceFeaturesDecodeErrorZ.mjs":"1uVDE","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1uVDE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_InvoiceFeaturesDecodeErrorZ", ()=>Result_InvoiceFeaturesDecodeErrorZ
);
parcelHelpers.export(exports, "Result_InvoiceFeaturesDecodeErrorZ_OK", ()=>Result_InvoiceFeaturesDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_InvoiceFeaturesDecodeErrorZ_Err", ()=>Result_InvoiceFeaturesDecodeErrorZ_Err
) //# sourceMappingURL=Result_InvoiceFeaturesDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _invoiceFeaturesMjs = require("../structs/InvoiceFeatures.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_InvoiceFeaturesDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_InvoiceFeaturesDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_InvoiceFeaturesDecodeErrorZ_is_ok(ptr)) return new Result_InvoiceFeaturesDecodeErrorZ_OK(null, ptr);
        else return new Result_InvoiceFeaturesDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_InvoiceFeaturesDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_InvoiceFeaturesDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_InvoiceFeaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_InvoiceFeaturesDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_InvoiceFeaturesDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_InvoiceFeaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_InvoiceFeaturesDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
}
class Result_InvoiceFeaturesDecodeErrorZ_OK extends Result_InvoiceFeaturesDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_InvoiceFeaturesDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _invoiceFeaturesMjs.InvoiceFeatures(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_InvoiceFeaturesDecodeErrorZ_Err extends Result_InvoiceFeaturesDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_InvoiceFeaturesDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/InvoiceFeatures.mjs":"1EI2T","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jKE2O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Information about a spendable output to a P2WSH script. See
 * SpendableOutputDescriptor::DelayedPaymentOutput for more details on how to spend this.
 */ parcelHelpers.export(exports, "DelayedPaymentOutputDescriptor", ()=>DelayedPaymentOutputDescriptor
) //# sourceMappingURL=DelayedPaymentOutputDescriptor.mjs.map
;
var _outPointMjs = require("../structs/OutPoint.mjs");
var _resultDelayedPaymentOutputDescriptorDecodeErrorZMjs = require("../structs/Result_DelayedPaymentOutputDescriptorDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class DelayedPaymentOutputDescriptor extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.DelayedPaymentOutputDescriptor_free);
    }
    /**
     * The outpoint which is spendable
     */ get_outpoint() {
        const ret = _bindingsMjs.DelayedPaymentOutputDescriptor_get_outpoint(this.ptr);
        const ret_hu_conv = new _outPointMjs.OutPoint(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The outpoint which is spendable
     */ set_outpoint(val) {
        _bindingsMjs.DelayedPaymentOutputDescriptor_set_outpoint(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Per commitment point to derive delayed_payment_key by key holder
     */ get_per_commitment_point() {
        const ret = _bindingsMjs.DelayedPaymentOutputDescriptor_get_per_commitment_point(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Per commitment point to derive delayed_payment_key by key holder
     */ set_per_commitment_point(val) {
        _bindingsMjs.DelayedPaymentOutputDescriptor_set_per_commitment_point(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * The nSequence value which must be set in the spending input to satisfy the OP_CSV in
     * the witness_script.
     */ get_to_self_delay() {
        const ret = _bindingsMjs.DelayedPaymentOutputDescriptor_get_to_self_delay(this.ptr);
        return ret;
    }
    /**
     * The nSequence value which must be set in the spending input to satisfy the OP_CSV in
     * the witness_script.
     */ set_to_self_delay(val) {
        _bindingsMjs.DelayedPaymentOutputDescriptor_set_to_self_delay(this.ptr, val);
    }
    /**
     * The output which is referenced by the given outpoint
     */ set_output(val) {
        _bindingsMjs.DelayedPaymentOutputDescriptor_set_output(this.ptr, _commonBaseMjsDefault.default.get_ptr_of(val));
    }
    /**
     * The revocation point specific to the commitment transaction which was broadcast. Used to
     * derive the witnessScript for this output.
     */ get_revocation_pubkey() {
        const ret = _bindingsMjs.DelayedPaymentOutputDescriptor_get_revocation_pubkey(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The revocation point specific to the commitment transaction which was broadcast. Used to
     * derive the witnessScript for this output.
     */ set_revocation_pubkey(val) {
        _bindingsMjs.DelayedPaymentOutputDescriptor_set_revocation_pubkey(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Arbitrary identification information returned by a call to
     * `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
     * the channel to spend the output.
     */ get_channel_keys_id() {
        const ret = _bindingsMjs.DelayedPaymentOutputDescriptor_get_channel_keys_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Arbitrary identification information returned by a call to
     * `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
     * the channel to spend the output.
     */ set_channel_keys_id(val) {
        _bindingsMjs.DelayedPaymentOutputDescriptor_set_channel_keys_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The value of the channel which this output originated from, possibly indirectly.
     */ get_channel_value_satoshis() {
        const ret = _bindingsMjs.DelayedPaymentOutputDescriptor_get_channel_value_satoshis(this.ptr);
        return ret;
    }
    /**
     * The value of the channel which this output originated from, possibly indirectly.
     */ set_channel_value_satoshis(val) {
        _bindingsMjs.DelayedPaymentOutputDescriptor_set_channel_value_satoshis(this.ptr, val);
    }
    /**
     * Constructs a new DelayedPaymentOutputDescriptor given each field
     */ static constructor_new(outpoint_arg, per_commitment_point_arg, to_self_delay_arg, output_arg, revocation_pubkey_arg, channel_keys_id_arg, channel_value_satoshis_arg) {
        const ret = _bindingsMjs.DelayedPaymentOutputDescriptor_new(outpoint_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(outpoint_arg) & -2, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(per_commitment_point_arg, 33)), to_self_delay_arg, _commonBaseMjsDefault.default.get_ptr_of(output_arg), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(revocation_pubkey_arg, 33)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_keys_id_arg, 32)), channel_value_satoshis_arg);
        const ret_hu_conv = new DelayedPaymentOutputDescriptor(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.DelayedPaymentOutputDescriptor_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the DelayedPaymentOutputDescriptor
     */ clone() {
        const ret = _bindingsMjs.DelayedPaymentOutputDescriptor_clone(this.ptr);
        const ret_hu_conv = new DelayedPaymentOutputDescriptor(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the DelayedPaymentOutputDescriptor object into a byte array which can be read by DelayedPaymentOutputDescriptor_read
     */ write() {
        const ret = _bindingsMjs.DelayedPaymentOutputDescriptor_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a DelayedPaymentOutputDescriptor from a byte array, created by DelayedPaymentOutputDescriptor_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.DelayedPaymentOutputDescriptor_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultDelayedPaymentOutputDescriptorDecodeErrorZMjs.Result_DelayedPaymentOutputDescriptorDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/OutPoint.mjs":"9FTof","../structs/Result_DelayedPaymentOutputDescriptorDecodeErrorZ.mjs":"fhjv6","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fhjv6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_DelayedPaymentOutputDescriptorDecodeErrorZ", ()=>Result_DelayedPaymentOutputDescriptorDecodeErrorZ
);
parcelHelpers.export(exports, "Result_DelayedPaymentOutputDescriptorDecodeErrorZ_OK", ()=>Result_DelayedPaymentOutputDescriptorDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_DelayedPaymentOutputDescriptorDecodeErrorZ_Err", ()=>Result_DelayedPaymentOutputDescriptorDecodeErrorZ_Err
) //# sourceMappingURL=Result_DelayedPaymentOutputDescriptorDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _delayedPaymentOutputDescriptorMjs = require("../structs/DelayedPaymentOutputDescriptor.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_DelayedPaymentOutputDescriptorDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(ptr)) return new Result_DelayedPaymentOutputDescriptorDecodeErrorZ_OK(null, ptr);
        else return new Result_DelayedPaymentOutputDescriptorDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_DelayedPaymentOutputDescriptorDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_DelayedPaymentOutputDescriptorDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_DelayedPaymentOutputDescriptorDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_DelayedPaymentOutputDescriptorDecodeErrorZ_OK extends Result_DelayedPaymentOutputDescriptorDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _delayedPaymentOutputDescriptorMjs.DelayedPaymentOutputDescriptor(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_DelayedPaymentOutputDescriptorDecodeErrorZ_Err extends Result_DelayedPaymentOutputDescriptorDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/DelayedPaymentOutputDescriptor.mjs":"jKE2O","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1ffRO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Information about a spendable output to our \"payment key\". See
 * SpendableOutputDescriptor::StaticPaymentOutput for more details on how to spend this.
 */ parcelHelpers.export(exports, "StaticPaymentOutputDescriptor", ()=>StaticPaymentOutputDescriptor
) //# sourceMappingURL=StaticPaymentOutputDescriptor.mjs.map
;
var _outPointMjs = require("../structs/OutPoint.mjs");
var _resultStaticPaymentOutputDescriptorDecodeErrorZMjs = require("../structs/Result_StaticPaymentOutputDescriptorDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class StaticPaymentOutputDescriptor extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.StaticPaymentOutputDescriptor_free);
    }
    /**
     * The outpoint which is spendable
     */ get_outpoint() {
        const ret = _bindingsMjs.StaticPaymentOutputDescriptor_get_outpoint(this.ptr);
        const ret_hu_conv = new _outPointMjs.OutPoint(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The outpoint which is spendable
     */ set_outpoint(val) {
        _bindingsMjs.StaticPaymentOutputDescriptor_set_outpoint(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * The output which is referenced by the given outpoint
     */ set_output(val) {
        _bindingsMjs.StaticPaymentOutputDescriptor_set_output(this.ptr, _commonBaseMjsDefault.default.get_ptr_of(val));
    }
    /**
     * Arbitrary identification information returned by a call to
     * `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
     * the channel to spend the output.
     */ get_channel_keys_id() {
        const ret = _bindingsMjs.StaticPaymentOutputDescriptor_get_channel_keys_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Arbitrary identification information returned by a call to
     * `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
     * the channel to spend the output.
     */ set_channel_keys_id(val) {
        _bindingsMjs.StaticPaymentOutputDescriptor_set_channel_keys_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The value of the channel which this transactions spends.
     */ get_channel_value_satoshis() {
        const ret = _bindingsMjs.StaticPaymentOutputDescriptor_get_channel_value_satoshis(this.ptr);
        return ret;
    }
    /**
     * The value of the channel which this transactions spends.
     */ set_channel_value_satoshis(val) {
        _bindingsMjs.StaticPaymentOutputDescriptor_set_channel_value_satoshis(this.ptr, val);
    }
    /**
     * Constructs a new StaticPaymentOutputDescriptor given each field
     */ static constructor_new(outpoint_arg, output_arg, channel_keys_id_arg, channel_value_satoshis_arg) {
        const ret = _bindingsMjs.StaticPaymentOutputDescriptor_new(outpoint_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(outpoint_arg) & -2, _commonBaseMjsDefault.default.get_ptr_of(output_arg), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_keys_id_arg, 32)), channel_value_satoshis_arg);
        const ret_hu_conv = new StaticPaymentOutputDescriptor(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.StaticPaymentOutputDescriptor_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the StaticPaymentOutputDescriptor
     */ clone() {
        const ret = _bindingsMjs.StaticPaymentOutputDescriptor_clone(this.ptr);
        const ret_hu_conv = new StaticPaymentOutputDescriptor(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the StaticPaymentOutputDescriptor object into a byte array which can be read by StaticPaymentOutputDescriptor_read
     */ write() {
        const ret = _bindingsMjs.StaticPaymentOutputDescriptor_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a StaticPaymentOutputDescriptor from a byte array, created by StaticPaymentOutputDescriptor_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.StaticPaymentOutputDescriptor_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultStaticPaymentOutputDescriptorDecodeErrorZMjs.Result_StaticPaymentOutputDescriptorDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/OutPoint.mjs":"9FTof","../structs/Result_StaticPaymentOutputDescriptorDecodeErrorZ.mjs":"ijsLz","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ijsLz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_StaticPaymentOutputDescriptorDecodeErrorZ", ()=>Result_StaticPaymentOutputDescriptorDecodeErrorZ
);
parcelHelpers.export(exports, "Result_StaticPaymentOutputDescriptorDecodeErrorZ_OK", ()=>Result_StaticPaymentOutputDescriptorDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_StaticPaymentOutputDescriptorDecodeErrorZ_Err", ()=>Result_StaticPaymentOutputDescriptorDecodeErrorZ_Err
) //# sourceMappingURL=Result_StaticPaymentOutputDescriptorDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _staticPaymentOutputDescriptorMjs = require("../structs/StaticPaymentOutputDescriptor.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_StaticPaymentOutputDescriptorDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(ptr)) return new Result_StaticPaymentOutputDescriptorDecodeErrorZ_OK(null, ptr);
        else return new Result_StaticPaymentOutputDescriptorDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_StaticPaymentOutputDescriptorDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_StaticPaymentOutputDescriptorDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_StaticPaymentOutputDescriptorDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_StaticPaymentOutputDescriptorDecodeErrorZ_OK extends Result_StaticPaymentOutputDescriptorDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _staticPaymentOutputDescriptorMjs.StaticPaymentOutputDescriptor(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_StaticPaymentOutputDescriptorDecodeErrorZ_Err extends Result_StaticPaymentOutputDescriptorDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/StaticPaymentOutputDescriptor.mjs":"1ffRO","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gZn9J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * When on-chain outputs are created by rust-lightning (which our counterparty is not able to
 * claim at any point in the future) an event is generated which you must track and be able to
 * spend on-chain. The information needed to do this is provided in this enum, including the
 * outpoint describing which txid and output index is available, the full output which exists at
 * that txid/index, and any keys or other information required to sign.
 */ parcelHelpers.export(exports, "SpendableOutputDescriptor", ()=>SpendableOutputDescriptor
);
/** A SpendableOutputDescriptor of type StaticOutput */ parcelHelpers.export(exports, "SpendableOutputDescriptor_StaticOutput", ()=>SpendableOutputDescriptor_StaticOutput
);
/** A SpendableOutputDescriptor of type DelayedPaymentOutput */ parcelHelpers.export(exports, "SpendableOutputDescriptor_DelayedPaymentOutput", ()=>SpendableOutputDescriptor_DelayedPaymentOutput
);
/** A SpendableOutputDescriptor of type StaticPaymentOutput */ parcelHelpers.export(exports, "SpendableOutputDescriptor_StaticPaymentOutput", ()=>SpendableOutputDescriptor_StaticPaymentOutput
) //# sourceMappingURL=SpendableOutputDescriptor.mjs.map
;
var _txOutMjs = require("../structs/TxOut.mjs");
var _outPointMjs = require("../structs/OutPoint.mjs");
var _delayedPaymentOutputDescriptorMjs = require("../structs/DelayedPaymentOutputDescriptor.mjs");
var _staticPaymentOutputDescriptorMjs = require("../structs/StaticPaymentOutputDescriptor.mjs");
var _resultSpendableOutputDescriptorDecodeErrorZMjs = require("../structs/Result_SpendableOutputDescriptorDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class SpendableOutputDescriptor extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.SpendableOutputDescriptor_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKSpendableOutputDescriptor_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new SpendableOutputDescriptor_StaticOutput(ptr);
            case 1:
                return new SpendableOutputDescriptor_DelayedPaymentOutput(ptr);
            case 2:
                return new SpendableOutputDescriptor_StaticPaymentOutput(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = _bindingsMjs.SpendableOutputDescriptor_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the SpendableOutputDescriptor
     */ clone() {
        const ret = _bindingsMjs.SpendableOutputDescriptor_clone(this.ptr);
        const ret_hu_conv = SpendableOutputDescriptor.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new StaticOutput-variant SpendableOutputDescriptor
     */ static constructor_static_output(outpoint, output) {
        const ret = _bindingsMjs.SpendableOutputDescriptor_static_output(outpoint == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(outpoint) & -2, _commonBaseMjsDefault.default.get_ptr_of(output));
        const ret_hu_conv = SpendableOutputDescriptor.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new DelayedPaymentOutput-variant SpendableOutputDescriptor
     */ static constructor_delayed_payment_output(a) {
        const ret = _bindingsMjs.SpendableOutputDescriptor_delayed_payment_output(a == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(a) & -2);
        const ret_hu_conv = SpendableOutputDescriptor.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new StaticPaymentOutput-variant SpendableOutputDescriptor
     */ static constructor_static_payment_output(a) {
        const ret = _bindingsMjs.SpendableOutputDescriptor_static_payment_output(a == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(a) & -2);
        const ret_hu_conv = SpendableOutputDescriptor.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Serialize the SpendableOutputDescriptor object into a byte array which can be read by SpendableOutputDescriptor_read
     */ write() {
        const ret = _bindingsMjs.SpendableOutputDescriptor_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a SpendableOutputDescriptor from a byte array, created by SpendableOutputDescriptor_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.SpendableOutputDescriptor_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultSpendableOutputDescriptorDecodeErrorZMjs.Result_SpendableOutputDescriptorDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class SpendableOutputDescriptor_StaticOutput extends SpendableOutputDescriptor {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const outpoint = _bindingsMjs.LDKSpendableOutputDescriptor_StaticOutput_get_outpoint(ptr);
        const outpoint_hu_conv = new _outPointMjs.OutPoint(null, outpoint);
        _commonBaseMjsDefault.default.add_ref_from(outpoint_hu_conv, this);
        this.outpoint = outpoint_hu_conv;
        const output = _bindingsMjs.LDKSpendableOutputDescriptor_StaticOutput_get_output(ptr);
        const output_conv = new _txOutMjs.TxOut(null, output);
        this.output = output_conv;
    }
}
class SpendableOutputDescriptor_DelayedPaymentOutput extends SpendableOutputDescriptor {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const delayed_payment_output = _bindingsMjs.LDKSpendableOutputDescriptor_DelayedPaymentOutput_get_delayed_payment_output(ptr);
        const delayed_payment_output_hu_conv = new _delayedPaymentOutputDescriptorMjs.DelayedPaymentOutputDescriptor(null, delayed_payment_output);
        _commonBaseMjsDefault.default.add_ref_from(delayed_payment_output_hu_conv, this);
        this.delayed_payment_output = delayed_payment_output_hu_conv;
    }
}
class SpendableOutputDescriptor_StaticPaymentOutput extends SpendableOutputDescriptor {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const static_payment_output = _bindingsMjs.LDKSpendableOutputDescriptor_StaticPaymentOutput_get_static_payment_output(ptr);
        const static_payment_output_hu_conv = new _staticPaymentOutputDescriptorMjs.StaticPaymentOutputDescriptor(null, static_payment_output);
        _commonBaseMjsDefault.default.add_ref_from(static_payment_output_hu_conv, this);
        this.static_payment_output = static_payment_output_hu_conv;
    }
}

},{"../structs/TxOut.mjs":"3syDw","../structs/OutPoint.mjs":"9FTof","../structs/DelayedPaymentOutputDescriptor.mjs":"jKE2O","../structs/StaticPaymentOutputDescriptor.mjs":"1ffRO","../structs/Result_SpendableOutputDescriptorDecodeErrorZ.mjs":"9SI3U","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9SI3U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_SpendableOutputDescriptorDecodeErrorZ", ()=>Result_SpendableOutputDescriptorDecodeErrorZ
);
parcelHelpers.export(exports, "Result_SpendableOutputDescriptorDecodeErrorZ_OK", ()=>Result_SpendableOutputDescriptorDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_SpendableOutputDescriptorDecodeErrorZ_Err", ()=>Result_SpendableOutputDescriptorDecodeErrorZ_Err
) //# sourceMappingURL=Result_SpendableOutputDescriptorDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _spendableOutputDescriptorMjs = require("../structs/SpendableOutputDescriptor.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_SpendableOutputDescriptorDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_SpendableOutputDescriptorDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(ptr)) return new Result_SpendableOutputDescriptorDecodeErrorZ_OK(null, ptr);
        else return new Result_SpendableOutputDescriptorDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_SpendableOutputDescriptorDecodeErrorZ_ok(_commonBaseMjsDefault.default.get_ptr_of(o));
        const ret_hu_conv = Result_SpendableOutputDescriptorDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_SpendableOutputDescriptorDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_SpendableOutputDescriptorDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_SpendableOutputDescriptorDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_SpendableOutputDescriptorDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_SpendableOutputDescriptorDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_SpendableOutputDescriptorDecodeErrorZ_OK extends Result_SpendableOutputDescriptorDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_SpendableOutputDescriptorDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = _spendableOutputDescriptorMjs.SpendableOutputDescriptor.constr_from_ptr(res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_SpendableOutputDescriptorDecodeErrorZ_Err extends Result_SpendableOutputDescriptorDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_SpendableOutputDescriptorDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/SpendableOutputDescriptor.mjs":"gZn9J","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fttbR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The reason the channel was closed. See individual variants more details.
 */ parcelHelpers.export(exports, "ClosureReason", ()=>ClosureReason
);
/** A ClosureReason of type CounterpartyForceClosed */ parcelHelpers.export(exports, "ClosureReason_CounterpartyForceClosed", ()=>ClosureReason_CounterpartyForceClosed
);
/** A ClosureReason of type HolderForceClosed */ parcelHelpers.export(exports, "ClosureReason_HolderForceClosed", ()=>ClosureReason_HolderForceClosed
);
/** A ClosureReason of type CooperativeClosure */ parcelHelpers.export(exports, "ClosureReason_CooperativeClosure", ()=>ClosureReason_CooperativeClosure
);
/** A ClosureReason of type CommitmentTxConfirmed */ parcelHelpers.export(exports, "ClosureReason_CommitmentTxConfirmed", ()=>ClosureReason_CommitmentTxConfirmed
);
/** A ClosureReason of type FundingTimedOut */ parcelHelpers.export(exports, "ClosureReason_FundingTimedOut", ()=>ClosureReason_FundingTimedOut
);
/** A ClosureReason of type ProcessingError */ parcelHelpers.export(exports, "ClosureReason_ProcessingError", ()=>ClosureReason_ProcessingError
);
/** A ClosureReason of type DisconnectedPeer */ parcelHelpers.export(exports, "ClosureReason_DisconnectedPeer", ()=>ClosureReason_DisconnectedPeer
);
/** A ClosureReason of type OutdatedChannelManager */ parcelHelpers.export(exports, "ClosureReason_OutdatedChannelManager", ()=>ClosureReason_OutdatedChannelManager
) //# sourceMappingURL=ClosureReason.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ClosureReason extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ClosureReason_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKClosureReason_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new ClosureReason_CounterpartyForceClosed(ptr);
            case 1:
                return new ClosureReason_HolderForceClosed(ptr);
            case 2:
                return new ClosureReason_CooperativeClosure(ptr);
            case 3:
                return new ClosureReason_CommitmentTxConfirmed(ptr);
            case 4:
                return new ClosureReason_FundingTimedOut(ptr);
            case 5:
                return new ClosureReason_ProcessingError(ptr);
            case 6:
                return new ClosureReason_DisconnectedPeer(ptr);
            case 7:
                return new ClosureReason_OutdatedChannelManager(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = _bindingsMjs.ClosureReason_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ClosureReason
     */ clone() {
        const ret = _bindingsMjs.ClosureReason_clone(this.ptr);
        const ret_hu_conv = ClosureReason.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new CounterpartyForceClosed-variant ClosureReason
     */ static constructor_counterparty_force_closed(peer_msg) {
        const ret = _bindingsMjs.ClosureReason_counterparty_force_closed(_bindingsMjs.encodeString(peer_msg));
        const ret_hu_conv = ClosureReason.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new HolderForceClosed-variant ClosureReason
     */ static constructor_holder_force_closed() {
        const ret = _bindingsMjs.ClosureReason_holder_force_closed();
        const ret_hu_conv = ClosureReason.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new CooperativeClosure-variant ClosureReason
     */ static constructor_cooperative_closure() {
        const ret = _bindingsMjs.ClosureReason_cooperative_closure();
        const ret_hu_conv = ClosureReason.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new CommitmentTxConfirmed-variant ClosureReason
     */ static constructor_commitment_tx_confirmed() {
        const ret = _bindingsMjs.ClosureReason_commitment_tx_confirmed();
        const ret_hu_conv = ClosureReason.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new FundingTimedOut-variant ClosureReason
     */ static constructor_funding_timed_out() {
        const ret = _bindingsMjs.ClosureReason_funding_timed_out();
        const ret_hu_conv = ClosureReason.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new ProcessingError-variant ClosureReason
     */ static constructor_processing_error(err) {
        const ret = _bindingsMjs.ClosureReason_processing_error(_bindingsMjs.encodeString(err));
        const ret_hu_conv = ClosureReason.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new DisconnectedPeer-variant ClosureReason
     */ static constructor_disconnected_peer() {
        const ret = _bindingsMjs.ClosureReason_disconnected_peer();
        const ret_hu_conv = ClosureReason.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new OutdatedChannelManager-variant ClosureReason
     */ static constructor_outdated_channel_manager() {
        const ret = _bindingsMjs.ClosureReason_outdated_channel_manager();
        const ret_hu_conv = ClosureReason.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Serialize the ClosureReason object into a byte array which can be read by ClosureReason_read
     */ write() {
        const ret = _bindingsMjs.ClosureReason_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
}
class ClosureReason_CounterpartyForceClosed extends ClosureReason {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const peer_msg = _bindingsMjs.LDKClosureReason_CounterpartyForceClosed_get_peer_msg(ptr);
        const peer_msg_conv = _bindingsMjs.decodeString(peer_msg);
        this.peer_msg = peer_msg_conv;
    }
}
class ClosureReason_HolderForceClosed extends ClosureReason {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}
class ClosureReason_CooperativeClosure extends ClosureReason {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}
class ClosureReason_CommitmentTxConfirmed extends ClosureReason {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}
class ClosureReason_FundingTimedOut extends ClosureReason {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}
class ClosureReason_ProcessingError extends ClosureReason {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const err = _bindingsMjs.LDKClosureReason_ProcessingError_get_err(ptr);
        const err_conv = _bindingsMjs.decodeString(err);
        this.err = err_conv;
    }
}
class ClosureReason_DisconnectedPeer extends ClosureReason {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}
class ClosureReason_OutdatedChannelManager extends ClosureReason {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g2Zcr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An Event which you should probably take some action in response to.
 *
 * Note that while Writeable and Readable are implemented for Event, you probably shouldn't use
 * them directly as they don't round-trip exactly (for example FundingGenerationReady is never
 * written as it makes no sense to respond to it after reconnecting to peers).
 */ parcelHelpers.export(exports, "Event", ()=>Event
);
/** A Event of type FundingGenerationReady */ parcelHelpers.export(exports, "Event_FundingGenerationReady", ()=>Event_FundingGenerationReady
);
/** A Event of type PaymentReceived */ parcelHelpers.export(exports, "Event_PaymentReceived", ()=>Event_PaymentReceived
);
/** A Event of type PaymentSent */ parcelHelpers.export(exports, "Event_PaymentSent", ()=>Event_PaymentSent
);
/** A Event of type PaymentPathFailed */ parcelHelpers.export(exports, "Event_PaymentPathFailed", ()=>Event_PaymentPathFailed
);
/** A Event of type PaymentFailed */ parcelHelpers.export(exports, "Event_PaymentFailed", ()=>Event_PaymentFailed
);
/** A Event of type PendingHTLCsForwardable */ parcelHelpers.export(exports, "Event_PendingHTLCsForwardable", ()=>Event_PendingHTLCsForwardable
);
/** A Event of type SpendableOutputs */ parcelHelpers.export(exports, "Event_SpendableOutputs", ()=>Event_SpendableOutputs
);
/** A Event of type PaymentForwarded */ parcelHelpers.export(exports, "Event_PaymentForwarded", ()=>Event_PaymentForwarded
);
/** A Event of type ChannelClosed */ parcelHelpers.export(exports, "Event_ChannelClosed", ()=>Event_ChannelClosed
);
/** A Event of type DiscardFunding */ parcelHelpers.export(exports, "Event_DiscardFunding", ()=>Event_DiscardFunding
);
/** A Event of type PaymentPathSuccessful */ parcelHelpers.export(exports, "Event_PaymentPathSuccessful", ()=>Event_PaymentPathSuccessful
) //# sourceMappingURL=Event.mjs.map
;
var _paymentPurposeMjs = require("../structs/PaymentPurpose.mjs");
var _optionU64ZMjs = require("../structs/Option_u64Z.mjs");
var _optionNetworkUpdateZMjs = require("../structs/Option_NetworkUpdateZ.mjs");
var _routeHopMjs = require("../structs/RouteHop.mjs");
var _routeParametersMjs = require("../structs/RouteParameters.mjs");
var _spendableOutputDescriptorMjs = require("../structs/SpendableOutputDescriptor.mjs");
var _closureReasonMjs = require("../structs/ClosureReason.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Event extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Event_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKEvent_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new Event_FundingGenerationReady(ptr);
            case 1:
                return new Event_PaymentReceived(ptr);
            case 2:
                return new Event_PaymentSent(ptr);
            case 3:
                return new Event_PaymentPathFailed(ptr);
            case 4:
                return new Event_PaymentFailed(ptr);
            case 5:
                return new Event_PendingHTLCsForwardable(ptr);
            case 6:
                return new Event_SpendableOutputs(ptr);
            case 7:
                return new Event_PaymentForwarded(ptr);
            case 8:
                return new Event_ChannelClosed(ptr);
            case 9:
                return new Event_DiscardFunding(ptr);
            case 10:
                return new Event_PaymentPathSuccessful(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = _bindingsMjs.Event_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the Event
     */ clone() {
        const ret = _bindingsMjs.Event_clone(this.ptr);
        const ret_hu_conv = Event.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new FundingGenerationReady-variant Event
     */ static constructor_funding_generation_ready(temporary_channel_id, channel_value_satoshis, output_script, user_channel_id) {
        const ret = _bindingsMjs.Event_funding_generation_ready(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(temporary_channel_id, 32)), channel_value_satoshis, _bindingsMjs.encodeUint8Array(output_script), user_channel_id);
        const ret_hu_conv = Event.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new PaymentReceived-variant Event
     */ static constructor_payment_received(payment_hash, amt, purpose) {
        const ret = _bindingsMjs.Event_payment_received(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_hash, 32)), amt, _commonBaseMjsDefault.default.get_ptr_of(purpose));
        const ret_hu_conv = Event.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new PaymentSent-variant Event
     */ static constructor_payment_sent(payment_id, payment_preimage, payment_hash, fee_paid_msat) {
        const ret = _bindingsMjs.Event_payment_sent(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_id, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_preimage, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_hash, 32)), _commonBaseMjsDefault.default.get_ptr_of(fee_paid_msat));
        const ret_hu_conv = Event.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new PaymentPathFailed-variant Event
     */ static constructor_payment_path_failed(payment_id, payment_hash, rejected_by_dest, network_update, all_paths_failed, path, short_channel_id, retry) {
        const ret = _bindingsMjs.Event_payment_path_failed(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_id, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_hash, 32)), rejected_by_dest, _commonBaseMjsDefault.default.get_ptr_of(network_update), all_paths_failed, _bindingsMjs.encodeUint32Array(path != null ? path.map((path_conv_10)=>path_conv_10 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(path_conv_10) & -2
        ) : null), _commonBaseMjsDefault.default.get_ptr_of(short_channel_id), retry == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(retry) & -2);
        const ret_hu_conv = Event.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new PaymentFailed-variant Event
     */ static constructor_payment_failed(payment_id, payment_hash) {
        const ret = _bindingsMjs.Event_payment_failed(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_id, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_hash, 32)));
        const ret_hu_conv = Event.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new PendingHTLCsForwardable-variant Event
     */ static constructor_pending_htlcs_forwardable(time_forwardable) {
        const ret = _bindingsMjs.Event_pending_htlcs_forwardable(time_forwardable);
        const ret_hu_conv = Event.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SpendableOutputs-variant Event
     */ static constructor_spendable_outputs(outputs) {
        const ret = _bindingsMjs.Event_spendable_outputs(_bindingsMjs.encodeUint32Array(outputs != null ? outputs.map((outputs_conv_27)=>_commonBaseMjsDefault.default.get_ptr_of(outputs_conv_27)
        ) : null));
        const ret_hu_conv = Event.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new PaymentForwarded-variant Event
     */ static constructor_payment_forwarded(fee_earned_msat, claim_from_onchain_tx) {
        const ret = _bindingsMjs.Event_payment_forwarded(_commonBaseMjsDefault.default.get_ptr_of(fee_earned_msat), claim_from_onchain_tx);
        const ret_hu_conv = Event.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new ChannelClosed-variant Event
     */ static constructor_channel_closed(channel_id, user_channel_id, reason) {
        const ret = _bindingsMjs.Event_channel_closed(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_id, 32)), user_channel_id, _commonBaseMjsDefault.default.get_ptr_of(reason));
        const ret_hu_conv = Event.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new DiscardFunding-variant Event
     */ static constructor_discard_funding(channel_id, transaction) {
        const ret = _bindingsMjs.Event_discard_funding(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_id, 32)), _bindingsMjs.encodeUint8Array(transaction));
        const ret_hu_conv = Event.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new PaymentPathSuccessful-variant Event
     */ static constructor_payment_path_successful(payment_id, payment_hash, path) {
        const ret = _bindingsMjs.Event_payment_path_successful(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_id, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_hash, 32)), _bindingsMjs.encodeUint32Array(path != null ? path.map((path_conv_10)=>path_conv_10 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(path_conv_10) & -2
        ) : null));
        const ret_hu_conv = Event.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Serialize the Event object into a byte array which can be read by Event_read
     */ write() {
        const ret = _bindingsMjs.Event_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
}
class Event_FundingGenerationReady extends Event {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const temporary_channel_id = _bindingsMjs.LDKEvent_FundingGenerationReady_get_temporary_channel_id(ptr);
        const temporary_channel_id_conv = _bindingsMjs.decodeUint8Array(temporary_channel_id);
        this.temporary_channel_id = temporary_channel_id_conv;
        this.channel_value_satoshis = _bindingsMjs.LDKEvent_FundingGenerationReady_get_channel_value_satoshis(ptr);
        const output_script = _bindingsMjs.LDKEvent_FundingGenerationReady_get_output_script(ptr);
        const output_script_conv = _bindingsMjs.decodeUint8Array(output_script);
        this.output_script = output_script_conv;
        this.user_channel_id = _bindingsMjs.LDKEvent_FundingGenerationReady_get_user_channel_id(ptr);
    }
}
class Event_PaymentReceived extends Event {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const payment_hash = _bindingsMjs.LDKEvent_PaymentReceived_get_payment_hash(ptr);
        const payment_hash_conv = _bindingsMjs.decodeUint8Array(payment_hash);
        this.payment_hash = payment_hash_conv;
        this.amt = _bindingsMjs.LDKEvent_PaymentReceived_get_amt(ptr);
        const purpose = _bindingsMjs.LDKEvent_PaymentReceived_get_purpose(ptr);
        const purpose_hu_conv = _paymentPurposeMjs.PaymentPurpose.constr_from_ptr(purpose);
        _commonBaseMjsDefault.default.add_ref_from(purpose_hu_conv, this);
        this.purpose = purpose_hu_conv;
    }
}
class Event_PaymentSent extends Event {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const payment_id = _bindingsMjs.LDKEvent_PaymentSent_get_payment_id(ptr);
        const payment_id_conv = _bindingsMjs.decodeUint8Array(payment_id);
        this.payment_id = payment_id_conv;
        const payment_preimage = _bindingsMjs.LDKEvent_PaymentSent_get_payment_preimage(ptr);
        const payment_preimage_conv = _bindingsMjs.decodeUint8Array(payment_preimage);
        this.payment_preimage = payment_preimage_conv;
        const payment_hash = _bindingsMjs.LDKEvent_PaymentSent_get_payment_hash(ptr);
        const payment_hash_conv = _bindingsMjs.decodeUint8Array(payment_hash);
        this.payment_hash = payment_hash_conv;
        const fee_paid_msat = _bindingsMjs.LDKEvent_PaymentSent_get_fee_paid_msat(ptr);
        const fee_paid_msat_hu_conv = _optionU64ZMjs.Option_u64Z.constr_from_ptr(fee_paid_msat);
        _commonBaseMjsDefault.default.add_ref_from(fee_paid_msat_hu_conv, this);
        this.fee_paid_msat = fee_paid_msat_hu_conv;
    }
}
class Event_PaymentPathFailed extends Event {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const payment_id = _bindingsMjs.LDKEvent_PaymentPathFailed_get_payment_id(ptr);
        const payment_id_conv = _bindingsMjs.decodeUint8Array(payment_id);
        this.payment_id = payment_id_conv;
        const payment_hash = _bindingsMjs.LDKEvent_PaymentPathFailed_get_payment_hash(ptr);
        const payment_hash_conv = _bindingsMjs.decodeUint8Array(payment_hash);
        this.payment_hash = payment_hash_conv;
        this.rejected_by_dest = _bindingsMjs.LDKEvent_PaymentPathFailed_get_rejected_by_dest(ptr);
        const network_update = _bindingsMjs.LDKEvent_PaymentPathFailed_get_network_update(ptr);
        const network_update_hu_conv = _optionNetworkUpdateZMjs.Option_NetworkUpdateZ.constr_from_ptr(network_update);
        _commonBaseMjsDefault.default.add_ref_from(network_update_hu_conv, this);
        this.network_update = network_update_hu_conv;
        this.all_paths_failed = _bindingsMjs.LDKEvent_PaymentPathFailed_get_all_paths_failed(ptr);
        const path = _bindingsMjs.LDKEvent_PaymentPathFailed_get_path(ptr);
        const path_conv_10_len = _bindingsMjs.getArrayLength(path);
        const path_conv_10_arr = new Array(path_conv_10_len).fill(null);
        for(var k = 0; k < path_conv_10_len; k++){
            const path_conv_10 = _bindingsMjs.getU32ArrayElem(path, k);
            const path_conv_10_hu_conv = new _routeHopMjs.RouteHop(null, path_conv_10);
            _commonBaseMjsDefault.default.add_ref_from(path_conv_10_hu_conv, this);
            path_conv_10_arr[k] = path_conv_10_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(path);
        this.path = path_conv_10_arr;
        const short_channel_id = _bindingsMjs.LDKEvent_PaymentPathFailed_get_short_channel_id(ptr);
        const short_channel_id_hu_conv = _optionU64ZMjs.Option_u64Z.constr_from_ptr(short_channel_id);
        _commonBaseMjsDefault.default.add_ref_from(short_channel_id_hu_conv, this);
        this.short_channel_id = short_channel_id_hu_conv;
        const retry = _bindingsMjs.LDKEvent_PaymentPathFailed_get_retry(ptr);
        const retry_hu_conv = new _routeParametersMjs.RouteParameters(null, retry);
        _commonBaseMjsDefault.default.add_ref_from(retry_hu_conv, this);
        this.retry = retry_hu_conv;
    }
}
class Event_PaymentFailed extends Event {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const payment_id = _bindingsMjs.LDKEvent_PaymentFailed_get_payment_id(ptr);
        const payment_id_conv = _bindingsMjs.decodeUint8Array(payment_id);
        this.payment_id = payment_id_conv;
        const payment_hash = _bindingsMjs.LDKEvent_PaymentFailed_get_payment_hash(ptr);
        const payment_hash_conv = _bindingsMjs.decodeUint8Array(payment_hash);
        this.payment_hash = payment_hash_conv;
    }
}
class Event_PendingHTLCsForwardable extends Event {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        this.time_forwardable = _bindingsMjs.LDKEvent_PendingHTLCsForwardable_get_time_forwardable(ptr);
    }
}
class Event_SpendableOutputs extends Event {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const outputs = _bindingsMjs.LDKEvent_SpendableOutputs_get_outputs(ptr);
        const outputs_conv_27_len = _bindingsMjs.getArrayLength(outputs);
        const outputs_conv_27_arr = new Array(outputs_conv_27_len).fill(null);
        for(var b = 0; b < outputs_conv_27_len; b++){
            const outputs_conv_27 = _bindingsMjs.getU32ArrayElem(outputs, b);
            const outputs_conv_27_hu_conv = _spendableOutputDescriptorMjs.SpendableOutputDescriptor.constr_from_ptr(outputs_conv_27);
            _commonBaseMjsDefault.default.add_ref_from(outputs_conv_27_hu_conv, this);
            outputs_conv_27_arr[b] = outputs_conv_27_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(outputs);
        this.outputs = outputs_conv_27_arr;
    }
}
class Event_PaymentForwarded extends Event {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const fee_earned_msat = _bindingsMjs.LDKEvent_PaymentForwarded_get_fee_earned_msat(ptr);
        const fee_earned_msat_hu_conv = _optionU64ZMjs.Option_u64Z.constr_from_ptr(fee_earned_msat);
        _commonBaseMjsDefault.default.add_ref_from(fee_earned_msat_hu_conv, this);
        this.fee_earned_msat = fee_earned_msat_hu_conv;
        this.claim_from_onchain_tx = _bindingsMjs.LDKEvent_PaymentForwarded_get_claim_from_onchain_tx(ptr);
    }
}
class Event_ChannelClosed extends Event {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const channel_id = _bindingsMjs.LDKEvent_ChannelClosed_get_channel_id(ptr);
        const channel_id_conv = _bindingsMjs.decodeUint8Array(channel_id);
        this.channel_id = channel_id_conv;
        this.user_channel_id = _bindingsMjs.LDKEvent_ChannelClosed_get_user_channel_id(ptr);
        const reason = _bindingsMjs.LDKEvent_ChannelClosed_get_reason(ptr);
        const reason_hu_conv = _closureReasonMjs.ClosureReason.constr_from_ptr(reason);
        _commonBaseMjsDefault.default.add_ref_from(reason_hu_conv, this);
        this.reason = reason_hu_conv;
    }
}
class Event_DiscardFunding extends Event {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const channel_id = _bindingsMjs.LDKEvent_DiscardFunding_get_channel_id(ptr);
        const channel_id_conv = _bindingsMjs.decodeUint8Array(channel_id);
        this.channel_id = channel_id_conv;
        const transaction = _bindingsMjs.LDKEvent_DiscardFunding_get_transaction(ptr);
        const transaction_conv = _bindingsMjs.decodeUint8Array(transaction);
        this.transaction = transaction_conv;
    }
}
class Event_PaymentPathSuccessful extends Event {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const payment_id = _bindingsMjs.LDKEvent_PaymentPathSuccessful_get_payment_id(ptr);
        const payment_id_conv = _bindingsMjs.decodeUint8Array(payment_id);
        this.payment_id = payment_id_conv;
        const payment_hash = _bindingsMjs.LDKEvent_PaymentPathSuccessful_get_payment_hash(ptr);
        const payment_hash_conv = _bindingsMjs.decodeUint8Array(payment_hash);
        this.payment_hash = payment_hash_conv;
        const path = _bindingsMjs.LDKEvent_PaymentPathSuccessful_get_path(ptr);
        const path_conv_10_len = _bindingsMjs.getArrayLength(path);
        const path_conv_10_arr = new Array(path_conv_10_len).fill(null);
        for(var k = 0; k < path_conv_10_len; k++){
            const path_conv_10 = _bindingsMjs.getU32ArrayElem(path, k);
            const path_conv_10_hu_conv = new _routeHopMjs.RouteHop(null, path_conv_10);
            _commonBaseMjsDefault.default.add_ref_from(path_conv_10_hu_conv, this);
            path_conv_10_arr[k] = path_conv_10_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(path);
        this.path = path_conv_10_arr;
    }
}

},{"../structs/PaymentPurpose.mjs":"2gW5M","../structs/Option_u64Z.mjs":"8VC1Q","../structs/Option_NetworkUpdateZ.mjs":"3mbkX","../structs/RouteHop.mjs":"hQQ4g","../structs/RouteParameters.mjs":"2hS5b","../structs/SpendableOutputDescriptor.mjs":"gZn9J","../structs/ClosureReason.mjs":"fttbR","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k0qa9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Tuple
 */ parcelHelpers.export(exports, "TwoTuple_usizeTransactionZ", ()=>TwoTuple_usizeTransactionZ
) //# sourceMappingURL=TwoTuple_usizeTransactionZ.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class TwoTuple_usizeTransactionZ extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.C2Tuple_usizeTransactionZ_free);
    }
    /**
     *
     */ get_a() {
        const ret = _bindingsMjs.C2Tuple_usizeTransactionZ_get_a(this.ptr);
        return ret;
    }
    /**
     *
     */ get_b() {
        const ret = _bindingsMjs.C2Tuple_usizeTransactionZ_get_b(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.C2Tuple_usizeTransactionZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new tuple which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.C2Tuple_usizeTransactionZ_clone(this.ptr);
        const ret_hu_conv = new TwoTuple_usizeTransactionZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a new C2Tuple_usizeTransactionZ from the contained elements.
     */ static constructor_new(a, b) {
        const ret = _bindingsMjs.C2Tuple_usizeTransactionZ_new(a, _bindingsMjs.encodeUint8Array(b));
        const ret_hu_conv = new TwoTuple_usizeTransactionZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cb1IO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Tuple
 */ parcelHelpers.export(exports, "TwoTuple_u32TxOutZ", ()=>TwoTuple_u32TxOutZ
) //# sourceMappingURL=TwoTuple_u32TxOutZ.mjs.map
;
var _txOutMjs = require("../structs/TxOut.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class TwoTuple_u32TxOutZ extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.C2Tuple_u32TxOutZ_free);
    }
    /**
     *
     */ get_a() {
        const ret = _bindingsMjs.C2Tuple_u32TxOutZ_get_a(this.ptr);
        return ret;
    }
    /**
     *
     */ get_b() {
        const ret = _bindingsMjs.C2Tuple_u32TxOutZ_get_b(this.ptr);
        const ret_conv = new _txOutMjs.TxOut(null, ret);
        return ret_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.C2Tuple_u32TxOutZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new tuple which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.C2Tuple_u32TxOutZ_clone(this.ptr);
        const ret_hu_conv = new TwoTuple_u32TxOutZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a new C2Tuple_u32TxOutZ from the contained elements.
     */ static constructor_new(a, b) {
        const ret = _bindingsMjs.C2Tuple_u32TxOutZ_new(a, _commonBaseMjsDefault.default.get_ptr_of(b));
        const ret_hu_conv = new TwoTuple_u32TxOutZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"../structs/TxOut.mjs":"3syDw","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fieS2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Tuple
 */ parcelHelpers.export(exports, "TwoTuple_TxidCVec_C2Tuple_u32TxOutZZZ", ()=>TwoTuple_TxidCVec_C2Tuple_u32TxOutZZZ
) //# sourceMappingURL=TwoTuple_TxidCVec_C2Tuple_u32TxOutZZZ.mjs.map
;
var _twoTupleU32TxOutZMjs = require("../structs/TwoTuple_u32TxOutZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class TwoTuple_TxidCVec_C2Tuple_u32TxOutZZZ extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free);
    }
    /**
     *
     */ get_a() {
        const ret = _bindingsMjs.C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_a(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     *
     */ get_b() {
        const ret = _bindingsMjs.C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_b(this.ptr);
        const ret_conv_20_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_20_arr = new Array(ret_conv_20_len).fill(null);
        for(var u = 0; u < ret_conv_20_len; u++){
            const ret_conv_20 = _bindingsMjs.getU32ArrayElem(ret, u);
            const ret_conv_20_hu_conv = new _twoTupleU32TxOutZMjs.TwoTuple_u32TxOutZ(null, ret_conv_20);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_20_hu_conv, this);
            ret_conv_20_arr[u] = ret_conv_20_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_20_arr;
    }
    clone_ptr() {
        const ret = _bindingsMjs.C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new tuple which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(this.ptr);
        const ret_hu_conv = new TwoTuple_TxidCVec_C2Tuple_u32TxOutZZZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a new C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ from the contained elements.
     */ static constructor_new(a, b) {
        const ret = _bindingsMjs.C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(a, 32)), _bindingsMjs.encodeUint32Array(b != null ? b.map((b_conv_20)=>b_conv_20 != null ? _commonBaseMjsDefault.default.get_ptr_of(b_conv_20) : 0
        ) : null));
        const ret_hu_conv = new TwoTuple_TxidCVec_C2Tuple_u32TxOutZZZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"../structs/TwoTuple_u32TxOutZ.mjs":"cb1IO","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jbcIa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Details about the balance(s) available for spending once the channel appears on chain.
 *
 * See [`ChannelMonitor::get_claimable_balances`] for more details on when these will or will not
 * be provided.
 */ parcelHelpers.export(exports, "Balance", ()=>Balance
);
/** A Balance of type ClaimableOnChannelClose */ parcelHelpers.export(exports, "Balance_ClaimableOnChannelClose", ()=>Balance_ClaimableOnChannelClose
);
/** A Balance of type ClaimableAwaitingConfirmations */ parcelHelpers.export(exports, "Balance_ClaimableAwaitingConfirmations", ()=>Balance_ClaimableAwaitingConfirmations
);
/** A Balance of type ContentiousClaimable */ parcelHelpers.export(exports, "Balance_ContentiousClaimable", ()=>Balance_ContentiousClaimable
);
/** A Balance of type MaybeClaimableHTLCAwaitingTimeout */ parcelHelpers.export(exports, "Balance_MaybeClaimableHTLCAwaitingTimeout", ()=>Balance_MaybeClaimableHTLCAwaitingTimeout
) //# sourceMappingURL=Balance.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Balance extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Balance_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKBalance_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new Balance_ClaimableOnChannelClose(ptr);
            case 1:
                return new Balance_ClaimableAwaitingConfirmations(ptr);
            case 2:
                return new Balance_ContentiousClaimable(ptr);
            case 3:
                return new Balance_MaybeClaimableHTLCAwaitingTimeout(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = _bindingsMjs.Balance_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the Balance
     */ clone() {
        const ret = _bindingsMjs.Balance_clone(this.ptr);
        const ret_hu_conv = Balance.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new ClaimableOnChannelClose-variant Balance
     */ static constructor_claimable_on_channel_close(claimable_amount_satoshis) {
        const ret = _bindingsMjs.Balance_claimable_on_channel_close(claimable_amount_satoshis);
        const ret_hu_conv = Balance.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new ClaimableAwaitingConfirmations-variant Balance
     */ static constructor_claimable_awaiting_confirmations(claimable_amount_satoshis, confirmation_height) {
        const ret = _bindingsMjs.Balance_claimable_awaiting_confirmations(claimable_amount_satoshis, confirmation_height);
        const ret_hu_conv = Balance.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new ContentiousClaimable-variant Balance
     */ static constructor_contentious_claimable(claimable_amount_satoshis, timeout_height) {
        const ret = _bindingsMjs.Balance_contentious_claimable(claimable_amount_satoshis, timeout_height);
        const ret_hu_conv = Balance.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new MaybeClaimableHTLCAwaitingTimeout-variant Balance
     */ static constructor_maybe_claimable_htlcawaiting_timeout(claimable_amount_satoshis, claimable_height) {
        const ret = _bindingsMjs.Balance_maybe_claimable_htlcawaiting_timeout(claimable_amount_satoshis, claimable_height);
        const ret_hu_conv = Balance.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Checks if two Balances contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     */ eq(b) {
        const ret = _bindingsMjs.Balance_eq(this.ptr, b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b) & -2);
        return ret;
    }
}
class Balance_ClaimableOnChannelClose extends Balance {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        this.claimable_amount_satoshis = _bindingsMjs.LDKBalance_ClaimableOnChannelClose_get_claimable_amount_satoshis(ptr);
    }
}
class Balance_ClaimableAwaitingConfirmations extends Balance {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        this.claimable_amount_satoshis = _bindingsMjs.LDKBalance_ClaimableAwaitingConfirmations_get_claimable_amount_satoshis(ptr);
        this.confirmation_height = _bindingsMjs.LDKBalance_ClaimableAwaitingConfirmations_get_confirmation_height(ptr);
    }
}
class Balance_ContentiousClaimable extends Balance {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        this.claimable_amount_satoshis = _bindingsMjs.LDKBalance_ContentiousClaimable_get_claimable_amount_satoshis(ptr);
        this.timeout_height = _bindingsMjs.LDKBalance_ContentiousClaimable_get_timeout_height(ptr);
    }
}
class Balance_MaybeClaimableHTLCAwaitingTimeout extends Balance {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        this.claimable_amount_satoshis = _bindingsMjs.LDKBalance_MaybeClaimableHTLCAwaitingTimeout_get_claimable_amount_satoshis(ptr);
        this.claimable_height = _bindingsMjs.LDKBalance_MaybeClaimableHTLCAwaitingTimeout_get_claimable_height(ptr);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"73KUF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Tuple
 */ parcelHelpers.export(exports, "TwoTuple_SignatureCVec_SignatureZZ", ()=>TwoTuple_SignatureCVec_SignatureZZ
) //# sourceMappingURL=TwoTuple_SignatureCVec_SignatureZZ.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class TwoTuple_SignatureCVec_SignatureZZ extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.C2Tuple_SignatureCVec_SignatureZZ_free);
    }
    /**
     *
     */ get_a() {
        const ret = _bindingsMjs.C2Tuple_SignatureCVec_SignatureZZ_get_a(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     *
     */ get_b() {
        const ret = _bindingsMjs.C2Tuple_SignatureCVec_SignatureZZ_get_b(this.ptr);
        const ret_conv_12_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_12_arr = new Array(ret_conv_12_len).fill(null);
        for(var m = 0; m < ret_conv_12_len; m++){
            const ret_conv_12 = _bindingsMjs.getU32ArrayElem(ret, m);
            const ret_conv_12_conv = _bindingsMjs.decodeUint8Array(ret_conv_12);
            ret_conv_12_arr[m] = ret_conv_12_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_12_arr;
    }
    clone_ptr() {
        const ret = _bindingsMjs.C2Tuple_SignatureCVec_SignatureZZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new tuple which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.C2Tuple_SignatureCVec_SignatureZZ_clone(this.ptr);
        const ret_hu_conv = new TwoTuple_SignatureCVec_SignatureZZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a new C2Tuple_SignatureCVec_SignatureZZ from the contained elements.
     */ static constructor_new(a, b) {
        const ret = _bindingsMjs.C2Tuple_SignatureCVec_SignatureZZ_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(a, 64)), _bindingsMjs.encodeUint32Array(b != null ? b.map((b_conv_12)=>_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(b_conv_12, 64))
        ) : null));
        const ret_hu_conv = new TwoTuple_SignatureCVec_SignatureZZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l32sF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_C2Tuple_SignatureCVec_SignatureZZNoneZ", ()=>Result_C2Tuple_SignatureCVec_SignatureZZNoneZ
);
parcelHelpers.export(exports, "Result_C2Tuple_SignatureCVec_SignatureZZNoneZ_OK", ()=>Result_C2Tuple_SignatureCVec_SignatureZZNoneZ_OK
);
parcelHelpers.export(exports, "Result_C2Tuple_SignatureCVec_SignatureZZNoneZ_Err", ()=>Result_C2Tuple_SignatureCVec_SignatureZZNoneZ_Err
) //# sourceMappingURL=Result_C2Tuple_SignatureCVec_SignatureZZNoneZ.mjs.map
;
var _twoTupleSignatureCVecSignatureZZMjs = require("../structs/TwoTuple_SignatureCVec_SignatureZZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_C2Tuple_SignatureCVec_SignatureZZNoneZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok(ptr)) return new Result_C2Tuple_SignatureCVec_SignatureZZNoneZ_OK(null, ptr);
        else return new Result_C2Tuple_SignatureCVec_SignatureZZNoneZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(o != null ? _commonBaseMjsDefault.default.get_ptr_of(o) : 0);
        const ret_hu_conv = Result_C2Tuple_SignatureCVec_SignatureZZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ in the error state.
     */ static constructor_err() {
        const ret = _bindingsMjs.CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err();
        const ret_hu_conv = Result_C2Tuple_SignatureCVec_SignatureZZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(this.ptr);
        const ret_hu_conv = Result_C2Tuple_SignatureCVec_SignatureZZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_C2Tuple_SignatureCVec_SignatureZZNoneZ_OK extends Result_C2Tuple_SignatureCVec_SignatureZZNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_ok(ptr);
        const res_hu_conv = new _twoTupleSignatureCVecSignatureZZMjs.TwoTuple_SignatureCVec_SignatureZZ(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_C2Tuple_SignatureCVec_SignatureZZNoneZ_Err extends Result_C2Tuple_SignatureCVec_SignatureZZNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}

},{"../structs/TwoTuple_SignatureCVec_SignatureZZ.mjs":"73KUF","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g8rmm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_SignatureNoneZ", ()=>Result_SignatureNoneZ
);
parcelHelpers.export(exports, "Result_SignatureNoneZ_OK", ()=>Result_SignatureNoneZ_OK
);
parcelHelpers.export(exports, "Result_SignatureNoneZ_Err", ()=>Result_SignatureNoneZ_Err
) //# sourceMappingURL=Result_SignatureNoneZ.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_SignatureNoneZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_SignatureNoneZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_SignatureNoneZ_is_ok(ptr)) return new Result_SignatureNoneZ_OK(null, ptr);
        else return new Result_SignatureNoneZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_SignatureNoneZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_SignatureNoneZ_ok(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(o, 64)));
        const ret_hu_conv = Result_SignatureNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_SignatureNoneZ in the error state.
     */ static constructor_err() {
        const ret = _bindingsMjs.CResult_SignatureNoneZ_err();
        const ret_hu_conv = Result_SignatureNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_SignatureNoneZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_SignatureNoneZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_SignatureNoneZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_SignatureNoneZ_clone(this.ptr);
        const ret_hu_conv = Result_SignatureNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_SignatureNoneZ_OK extends Result_SignatureNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_SignatureNoneZ_get_ok(ptr);
        const res_conv = _bindingsMjs.decodeUint8Array(res);
        this.res = res_conv;
    }
}
class Result_SignatureNoneZ_Err extends Result_SignatureNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6WJpv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This class tracks the per-transaction information needed to build a closing transaction and will
 * actually build it and sign.
 *
 * This class can be used inside a signer implementation to generate a signature given the relevant
 * secret key.
 */ parcelHelpers.export(exports, "ClosingTransaction", ()=>ClosingTransaction
) //# sourceMappingURL=ClosingTransaction.mjs.map
;
var _trustedClosingTransactionMjs = require("../structs/TrustedClosingTransaction.mjs");
var _resultTrustedClosingTransactionNoneZMjs = require("../structs/Result_TrustedClosingTransactionNoneZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ClosingTransaction extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ClosingTransaction_free);
    }
    clone_ptr() {
        const ret = _bindingsMjs.ClosingTransaction_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ClosingTransaction
     */ clone() {
        const ret = _bindingsMjs.ClosingTransaction_clone(this.ptr);
        const ret_hu_conv = new ClosingTransaction(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Checks if two ClosingTransactions contain equal inner contents.
     */ hash() {
        const ret = _bindingsMjs.ClosingTransaction_hash(this.ptr);
        return ret;
    }
    /**
     * Construct an object of the class
     */ static constructor_new(to_holder_value_sat, to_counterparty_value_sat, to_holder_script, to_counterparty_script, funding_outpoint) {
        const ret = _bindingsMjs.ClosingTransaction_new(to_holder_value_sat, to_counterparty_value_sat, _bindingsMjs.encodeUint8Array(to_holder_script), _bindingsMjs.encodeUint8Array(to_counterparty_script), funding_outpoint == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(funding_outpoint) & -2);
        const ret_hu_conv = new ClosingTransaction(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Trust our pre-built transaction.
     *
     * Applies a wrapper which allows access to the transaction.
     *
     * This should only be used if you fully trust the builder of this object. It should not
     * be used by an external signer - instead use the verify function.
     */ trust() {
        const ret = _bindingsMjs.ClosingTransaction_trust(this.ptr);
        const ret_hu_conv = new _trustedClosingTransactionMjs.TrustedClosingTransaction(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Verify our pre-built transaction.
     *
     * Applies a wrapper which allows access to the transaction.
     *
     * An external validating signer must call this method before signing
     * or using the built transaction.
     */ verify(funding_outpoint) {
        const ret = _bindingsMjs.ClosingTransaction_verify(this.ptr, funding_outpoint == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(funding_outpoint) & -2);
        const ret_hu_conv = _resultTrustedClosingTransactionNoneZMjs.Result_TrustedClosingTransactionNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * The value to be sent to the holder, or zero if the output will be omitted
     */ to_holder_value_sat() {
        const ret = _bindingsMjs.ClosingTransaction_to_holder_value_sat(this.ptr);
        return ret;
    }
    /**
     * The value to be sent to the counterparty, or zero if the output will be omitted
     */ to_counterparty_value_sat() {
        const ret = _bindingsMjs.ClosingTransaction_to_counterparty_value_sat(this.ptr);
        return ret;
    }
    /**
     * The destination of the holder's output
     */ to_holder_script() {
        const ret = _bindingsMjs.ClosingTransaction_to_holder_script(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The destination of the counterparty's output
     */ to_counterparty_script() {
        const ret = _bindingsMjs.ClosingTransaction_to_counterparty_script(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
}

},{"../structs/TrustedClosingTransaction.mjs":"czsNn","../structs/Result_TrustedClosingTransactionNoneZ.mjs":"aFYlU","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bwq1O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The unsigned part of a channel_announcement
 */ parcelHelpers.export(exports, "UnsignedChannelAnnouncement", ()=>UnsignedChannelAnnouncement
) //# sourceMappingURL=UnsignedChannelAnnouncement.mjs.map
;
var _channelFeaturesMjs = require("../structs/ChannelFeatures.mjs");
var _resultUnsignedChannelAnnouncementDecodeErrorZMjs = require("../structs/Result_UnsignedChannelAnnouncementDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class UnsignedChannelAnnouncement extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.UnsignedChannelAnnouncement_free);
    }
    /**
     * The advertised channel features
     */ get_features() {
        const ret = _bindingsMjs.UnsignedChannelAnnouncement_get_features(this.ptr);
        const ret_hu_conv = new _channelFeaturesMjs.ChannelFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The advertised channel features
     */ set_features(val) {
        _bindingsMjs.UnsignedChannelAnnouncement_set_features(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * The genesis hash of the blockchain where the channel is to be opened
     */ get_chain_hash() {
        const ret = _bindingsMjs.UnsignedChannelAnnouncement_get_chain_hash(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The genesis hash of the blockchain where the channel is to be opened
     */ set_chain_hash(val) {
        _bindingsMjs.UnsignedChannelAnnouncement_set_chain_hash(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The short channel ID
     */ get_short_channel_id() {
        const ret = _bindingsMjs.UnsignedChannelAnnouncement_get_short_channel_id(this.ptr);
        return ret;
    }
    /**
     * The short channel ID
     */ set_short_channel_id(val) {
        _bindingsMjs.UnsignedChannelAnnouncement_set_short_channel_id(this.ptr, val);
    }
    /**
     * One of the two node_ids which are endpoints of this channel
     */ get_node_id_1() {
        const ret = _bindingsMjs.UnsignedChannelAnnouncement_get_node_id_1(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * One of the two node_ids which are endpoints of this channel
     */ set_node_id_1(val) {
        _bindingsMjs.UnsignedChannelAnnouncement_set_node_id_1(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * The other of the two node_ids which are endpoints of this channel
     */ get_node_id_2() {
        const ret = _bindingsMjs.UnsignedChannelAnnouncement_get_node_id_2(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The other of the two node_ids which are endpoints of this channel
     */ set_node_id_2(val) {
        _bindingsMjs.UnsignedChannelAnnouncement_set_node_id_2(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * The funding key for the first node
     */ get_bitcoin_key_1() {
        const ret = _bindingsMjs.UnsignedChannelAnnouncement_get_bitcoin_key_1(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The funding key for the first node
     */ set_bitcoin_key_1(val) {
        _bindingsMjs.UnsignedChannelAnnouncement_set_bitcoin_key_1(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * The funding key for the second node
     */ get_bitcoin_key_2() {
        const ret = _bindingsMjs.UnsignedChannelAnnouncement_get_bitcoin_key_2(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The funding key for the second node
     */ set_bitcoin_key_2(val) {
        _bindingsMjs.UnsignedChannelAnnouncement_set_bitcoin_key_2(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    clone_ptr() {
        const ret = _bindingsMjs.UnsignedChannelAnnouncement_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the UnsignedChannelAnnouncement
     */ clone() {
        const ret = _bindingsMjs.UnsignedChannelAnnouncement_clone(this.ptr);
        const ret_hu_conv = new UnsignedChannelAnnouncement(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the UnsignedChannelAnnouncement object into a byte array which can be read by UnsignedChannelAnnouncement_read
     */ write() {
        const ret = _bindingsMjs.UnsignedChannelAnnouncement_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a UnsignedChannelAnnouncement from a byte array, created by UnsignedChannelAnnouncement_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.UnsignedChannelAnnouncement_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultUnsignedChannelAnnouncementDecodeErrorZMjs.Result_UnsignedChannelAnnouncementDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/ChannelFeatures.mjs":"89gCD","../structs/Result_UnsignedChannelAnnouncementDecodeErrorZ.mjs":"eHuvZ","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eHuvZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_UnsignedChannelAnnouncementDecodeErrorZ", ()=>Result_UnsignedChannelAnnouncementDecodeErrorZ
);
parcelHelpers.export(exports, "Result_UnsignedChannelAnnouncementDecodeErrorZ_OK", ()=>Result_UnsignedChannelAnnouncementDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_UnsignedChannelAnnouncementDecodeErrorZ_Err", ()=>Result_UnsignedChannelAnnouncementDecodeErrorZ_Err
) //# sourceMappingURL=Result_UnsignedChannelAnnouncementDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _unsignedChannelAnnouncementMjs = require("../structs/UnsignedChannelAnnouncement.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_UnsignedChannelAnnouncementDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_UnsignedChannelAnnouncementDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(ptr)) return new Result_UnsignedChannelAnnouncementDecodeErrorZ_OK(null, ptr);
        else return new Result_UnsignedChannelAnnouncementDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_UnsignedChannelAnnouncementDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_UnsignedChannelAnnouncementDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_UnsignedChannelAnnouncementDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_UnsignedChannelAnnouncementDecodeErrorZ_OK extends Result_UnsignedChannelAnnouncementDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _unsignedChannelAnnouncementMjs.UnsignedChannelAnnouncement(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_UnsignedChannelAnnouncementDecodeErrorZ_Err extends Result_UnsignedChannelAnnouncementDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/UnsignedChannelAnnouncement.mjs":"bwq1O","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4dNuw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A trait to sign lightning channel transactions as described in BOLT 3.
 *
 * Signing services could be implemented on a hardware wallet. In this case,
 * the current Sign would be a front-end on top of a communication
 * channel connected to your secure device and lightning key material wouldn't
 * reside on a hot server. Nevertheless, a this deployment would still need
 * to trust the ChannelManager to avoid loss of funds as this latest component
 * could ask to sign commitment transaction with HTLCs paying to attacker pubkeys.
 *
 * A more secure iteration would be to use hashlock (or payment points) to pair
 * invoice/incoming HTLCs with outgoing HTLCs to implement a no-trust-ChannelManager
 * at the price of more state and computation on the hardware wallet side. In the future,
 * we are looking forward to design such interface.
 *
 * In any case, ChannelMonitor or fallback watchtowers are always going to be trusted
 * to act, as liveness and breach reply correctness are always going to be hard requirements
 * of LN security model, orthogonal of key management issues.
 */ parcelHelpers.export(exports, "BaseSign", ()=>BaseSign
) //# sourceMappingURL=BaseSign.mjs.map
;
var _channelPublicKeysMjs = require("../structs/ChannelPublicKeys.mjs");
var _htlcoutputInCommitmentMjs = require("../structs/HTLCOutputInCommitment.mjs");
var _channelTransactionParametersMjs = require("../structs/ChannelTransactionParameters.mjs");
var _holderCommitmentTransactionMjs = require("../structs/HolderCommitmentTransaction.mjs");
var _commitmentTransactionMjs = require("../structs/CommitmentTransaction.mjs");
var _resultNoneNoneZMjs = require("../structs/Result_NoneNoneZ.mjs");
var _resultC2TupleSignatureCVecSignatureZZNoneZMjs = require("../structs/Result_C2Tuple_SignatureCVec_SignatureZZNoneZ.mjs");
var _resultSignatureNoneZMjs = require("../structs/Result_SignatureNoneZ.mjs");
var _closingTransactionMjs = require("../structs/ClosingTransaction.mjs");
var _unsignedChannelAnnouncementMjs = require("../structs/UnsignedChannelAnnouncement.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKBaseSignHolder {
}
class BaseSign extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.BaseSign_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of BaseSign from a given implementation */ static new_impl(arg, pubkeys) {
        const impl_holder = new LDKBaseSignHolder();
        let structImplementation = {
            get_per_commitment_point (idx) {
                const ret = arg.get_per_commitment_point(idx);
                const result = _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(ret, 33));
                return result;
            },
            release_commitment_secret (idx) {
                const ret = arg.release_commitment_secret(idx);
                const result = _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(ret, 32));
                return result;
            },
            validate_holder_commitment (holder_tx) {
                const holder_tx_hu_conv = new _holderCommitmentTransactionMjs.HolderCommitmentTransaction(null, holder_tx);
                const ret = arg.validate_holder_commitment(holder_tx_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            channel_keys_id () {
                const ret = arg.channel_keys_id();
                const result = _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(ret, 32));
                return result;
            },
            sign_counterparty_commitment (commitment_tx) {
                const commitment_tx_hu_conv = new _commitmentTransactionMjs.CommitmentTransaction(null, commitment_tx);
                const ret = arg.sign_counterparty_commitment(commitment_tx_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            validate_counterparty_revocation (idx, secret) {
                const secret_conv = _bindingsMjs.decodeUint8Array(secret);
                const ret = arg.validate_counterparty_revocation(idx, secret_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            sign_holder_commitment_and_htlcs (commitment_tx) {
                const commitment_tx_hu_conv = new _holderCommitmentTransactionMjs.HolderCommitmentTransaction(null, commitment_tx);
                const ret = arg.sign_holder_commitment_and_htlcs(commitment_tx_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            sign_justice_revoked_output (justice_tx, input, amount, per_commitment_key) {
                const justice_tx_conv = _bindingsMjs.decodeUint8Array(justice_tx);
                const per_commitment_key_conv = _bindingsMjs.decodeUint8Array(per_commitment_key);
                const ret = arg.sign_justice_revoked_output(justice_tx_conv, input, amount, per_commitment_key_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            sign_justice_revoked_htlc (justice_tx, input, amount, per_commitment_key, htlc) {
                const justice_tx_conv = _bindingsMjs.decodeUint8Array(justice_tx);
                const per_commitment_key_conv = _bindingsMjs.decodeUint8Array(per_commitment_key);
                const htlc_hu_conv = new _htlcoutputInCommitmentMjs.HTLCOutputInCommitment(null, htlc);
                const ret = arg.sign_justice_revoked_htlc(justice_tx_conv, input, amount, per_commitment_key_conv, htlc_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            sign_counterparty_htlc_transaction (htlc_tx, input, amount, per_commitment_point, htlc) {
                const htlc_tx_conv = _bindingsMjs.decodeUint8Array(htlc_tx);
                const per_commitment_point_conv = _bindingsMjs.decodeUint8Array(per_commitment_point);
                const htlc_hu_conv = new _htlcoutputInCommitmentMjs.HTLCOutputInCommitment(null, htlc);
                const ret = arg.sign_counterparty_htlc_transaction(htlc_tx_conv, input, amount, per_commitment_point_conv, htlc_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            sign_closing_transaction (closing_tx) {
                const closing_tx_hu_conv = new _closingTransactionMjs.ClosingTransaction(null, closing_tx);
                const ret = arg.sign_closing_transaction(closing_tx_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            sign_channel_announcement (msg) {
                const msg_hu_conv = new _unsignedChannelAnnouncementMjs.UnsignedChannelAnnouncement(null, msg);
                const ret = arg.sign_channel_announcement(msg_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            ready_channel (channel_parameters) {
                const channel_parameters_hu_conv = new _channelTransactionParametersMjs.ChannelTransactionParameters(null, channel_parameters);
                arg.ready_channel(channel_parameters_hu_conv);
            }
        };
        const ptr = _bindingsMjs.LDKBaseSign_new(structImplementation, pubkeys == null ? 0 : pubkeys.clone_ptr());
        impl_holder.held = new BaseSign(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Gets the per-commitment point for a specific commitment number
     *
     * Note that the commitment number starts at (1 << 48) - 1 and counts backwards.
     */ get_per_commitment_point(idx) {
        const ret = _bindingsMjs.BaseSign_get_per_commitment_point(this.ptr, idx);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Gets the commitment secret for a specific commitment number as part of the revocation process
     *
     * An external signer implementation should error here if the commitment was already signed
     * and should refuse to sign it in the future.
     *
     * May be called more than once for the same index.
     *
     * Note that the commitment number starts at (1 << 48) - 1 and counts backwards.
     */ release_commitment_secret(idx) {
        const ret = _bindingsMjs.BaseSign_release_commitment_secret(this.ptr, idx);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Validate the counterparty's signatures on the holder commitment transaction and HTLCs.
     *
     * This is required in order for the signer to make sure that releasing a commitment
     * secret won't leave us without a broadcastable holder transaction.
     * Policy checks should be implemented in this function, including checking the amount
     * sent to us and checking the HTLCs.
     */ validate_holder_commitment(holder_tx) {
        const ret = _bindingsMjs.BaseSign_validate_holder_commitment(this.ptr, holder_tx == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(holder_tx) & -2);
        const ret_hu_conv = _resultNoneNoneZMjs.Result_NoneNoneZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, holder_tx);
        return ret_hu_conv;
    }
    /**
     * Gets an arbitrary identifier describing the set of keys which are provided back to you in
     * some SpendableOutputDescriptor types. This should be sufficient to identify this
     * Sign object uniquely and lookup or re-derive its keys.
     */ channel_keys_id() {
        const ret = _bindingsMjs.BaseSign_channel_keys_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Create a signature for a counterparty's commitment transaction and associated HTLC transactions.
     *
     * Note that if signing fails or is rejected, the channel will be force-closed.
     *
     * Policy checks should be implemented in this function, including checking the amount
     * sent to us and checking the HTLCs.
     */ sign_counterparty_commitment(commitment_tx) {
        const ret = _bindingsMjs.BaseSign_sign_counterparty_commitment(this.ptr, commitment_tx == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(commitment_tx) & -2);
        const ret_hu_conv = _resultC2TupleSignatureCVecSignatureZZNoneZMjs.Result_C2Tuple_SignatureCVec_SignatureZZNoneZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, commitment_tx);
        return ret_hu_conv;
    }
    /**
     * Validate the counterparty's revocation.
     *
     * This is required in order for the signer to make sure that the state has moved
     * forward and it is safe to sign the next counterparty commitment.
     */ validate_counterparty_revocation(idx, secret) {
        const ret = _bindingsMjs.BaseSign_validate_counterparty_revocation(this.ptr, idx, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(secret, 32)));
        const ret_hu_conv = _resultNoneNoneZMjs.Result_NoneNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Create a signatures for a holder's commitment transaction and its claiming HTLC transactions.
     * This will only ever be called with a non-revoked commitment_tx.  This will be called with the
     * latest commitment_tx when we initiate a force-close.
     * This will be called with the previous latest, just to get claiming HTLC signatures, if we are
     * reacting to a ChannelMonitor replica that decided to broadcast before it had been updated to
     * the latest.
     * This may be called multiple times for the same transaction.
     *
     * An external signer implementation should check that the commitment has not been revoked.
     *
     * May return Err if key derivation fails.  Callers, such as ChannelMonitor, will panic in such a case.
     */ sign_holder_commitment_and_htlcs(commitment_tx) {
        const ret = _bindingsMjs.BaseSign_sign_holder_commitment_and_htlcs(this.ptr, commitment_tx == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(commitment_tx) & -2);
        const ret_hu_conv = _resultC2TupleSignatureCVecSignatureZZNoneZMjs.Result_C2Tuple_SignatureCVec_SignatureZZNoneZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, commitment_tx);
        return ret_hu_conv;
    }
    /**
     * Create a signature for the given input in a transaction spending an HTLC transaction output
     * or a commitment transaction `to_local` output when our counterparty broadcasts an old state.
     *
     * A justice transaction may claim multiple outputs at the same time if timelocks are
     * similar, but only a signature for the input at index `input` should be signed for here.
     * It may be called multiple times for same output(s) if a fee-bump is needed with regards
     * to an upcoming timelock expiration.
     *
     * Amount is value of the output spent by this input, committed to in the BIP 143 signature.
     *
     * per_commitment_key is revocation secret which was provided by our counterparty when they
     * revoked the state which they eventually broadcast. It's not a _holder_ secret key and does
     * not allow the spending of any funds by itself (you need our holder revocation_secret to do
     * so).
     */ sign_justice_revoked_output(justice_tx, input, amount, per_commitment_key) {
        const ret = _bindingsMjs.BaseSign_sign_justice_revoked_output(this.ptr, _bindingsMjs.encodeUint8Array(justice_tx), input, amount, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(per_commitment_key, 32)));
        const ret_hu_conv = _resultSignatureNoneZMjs.Result_SignatureNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Create a signature for the given input in a transaction spending a commitment transaction
     * HTLC output when our counterparty broadcasts an old state.
     *
     * A justice transaction may claim multiple outputs at the same time if timelocks are
     * similar, but only a signature for the input at index `input` should be signed for here.
     * It may be called multiple times for same output(s) if a fee-bump is needed with regards
     * to an upcoming timelock expiration.
     *
     * Amount is value of the output spent by this input, committed to in the BIP 143 signature.
     *
     * per_commitment_key is revocation secret which was provided by our counterparty when they
     * revoked the state which they eventually broadcast. It's not a _holder_ secret key and does
     * not allow the spending of any funds by itself (you need our holder revocation_secret to do
     * so).
     *
     * htlc holds HTLC elements (hash, timelock), thus changing the format of the witness script
     * (which is committed to in the BIP 143 signatures).
     */ sign_justice_revoked_htlc(justice_tx, input, amount, per_commitment_key, htlc) {
        const ret = _bindingsMjs.BaseSign_sign_justice_revoked_htlc(this.ptr, _bindingsMjs.encodeUint8Array(justice_tx), input, amount, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(per_commitment_key, 32)), htlc == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(htlc) & -2);
        const ret_hu_conv = _resultSignatureNoneZMjs.Result_SignatureNoneZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, htlc);
        return ret_hu_conv;
    }
    /**
     * Create a signature for a claiming transaction for a HTLC output on a counterparty's commitment
     * transaction, either offered or received.
     *
     * Such a transaction may claim multiples offered outputs at same time if we know the
     * preimage for each when we create it, but only the input at index `input` should be
     * signed for here. It may be called multiple times for same output(s) if a fee-bump is
     * needed with regards to an upcoming timelock expiration.
     *
     * Witness_script is either a offered or received script as defined in BOLT3 for HTLC
     * outputs.
     *
     * Amount is value of the output spent by this input, committed to in the BIP 143 signature.
     *
     * Per_commitment_point is the dynamic point corresponding to the channel state
     * detected onchain. It has been generated by our counterparty and is used to derive
     * channel state keys, which are then included in the witness script and committed to in the
     * BIP 143 signature.
     */ sign_counterparty_htlc_transaction(htlc_tx, input, amount, per_commitment_point, htlc) {
        const ret = _bindingsMjs.BaseSign_sign_counterparty_htlc_transaction(this.ptr, _bindingsMjs.encodeUint8Array(htlc_tx), input, amount, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(per_commitment_point, 33)), htlc == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(htlc) & -2);
        const ret_hu_conv = _resultSignatureNoneZMjs.Result_SignatureNoneZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, htlc);
        return ret_hu_conv;
    }
    /**
     * Create a signature for a (proposed) closing transaction.
     *
     * Note that, due to rounding, there may be one \"missing\" satoshi, and either party may have
     * chosen to forgo their output as dust.
     */ sign_closing_transaction(closing_tx) {
        const ret = _bindingsMjs.BaseSign_sign_closing_transaction(this.ptr, closing_tx == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(closing_tx) & -2);
        const ret_hu_conv = _resultSignatureNoneZMjs.Result_SignatureNoneZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, closing_tx);
        return ret_hu_conv;
    }
    /**
     * Signs a channel announcement message with our funding key, proving it comes from one
     * of the channel participants.
     *
     * Note that if this fails or is rejected, the channel will not be publicly announced and
     * our counterparty may (though likely will not) close the channel on us for violating the
     * protocol.
     */ sign_channel_announcement(msg) {
        const ret = _bindingsMjs.BaseSign_sign_channel_announcement(this.ptr, msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = _resultSignatureNoneZMjs.Result_SignatureNoneZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
        return ret_hu_conv;
    }
    /**
     * Set the counterparty static channel data, including basepoints,
     * counterparty_selected/holder_selected_contest_delay and funding outpoint.
     * This is done as soon as the funding outpoint is known.  Since these are static channel data,
     * they MUST NOT be allowed to change to different values once set.
     *
     * channel_parameters.is_populated() MUST be true.
     *
     * We bind holder_selected_contest_delay late here for API convenience.
     *
     * Will be called before any signatures are applied.
     */ ready_channel(channel_parameters) {
        _bindingsMjs.BaseSign_ready_channel(this.ptr, channel_parameters == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(channel_parameters) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, channel_parameters);
    }
    /**
     * Frees any resources associated with this object given its this_arg pointer.
     * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
     */ get_pubkeys() {
        const ret = _bindingsMjs.BaseSign_get_pubkeys(this.ptr);
        const ret_hu_conv = new _channelPublicKeysMjs.ChannelPublicKeys(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"../structs/ChannelPublicKeys.mjs":"a8cA2","../structs/HTLCOutputInCommitment.mjs":"9o6Rh","../structs/ChannelTransactionParameters.mjs":"dkG9C","../structs/HolderCommitmentTransaction.mjs":"gvilr","../structs/CommitmentTransaction.mjs":"jcnCV","../structs/Result_NoneNoneZ.mjs":"1QnVF","../structs/Result_C2Tuple_SignatureCVec_SignatureZZNoneZ.mjs":"l32sF","../structs/Result_SignatureNoneZ.mjs":"g8rmm","../structs/ClosingTransaction.mjs":"6WJpv","../structs/UnsignedChannelAnnouncement.mjs":"bwq1O","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jgkjb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A cloneable signer.
 *
 * Although we require signers to be cloneable, it may be useful for developers to be able to use
 * signers in an un-sized way, for example as `dyn BaseSign`. Therefore we separate the Clone trait,
 * which implies Sized, into this derived trait.
 */ parcelHelpers.export(exports, "Sign", ()=>Sign
) //# sourceMappingURL=Sign.mjs.map
;
var _baseSignMjs = require("../structs/BaseSign.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKSignHolder {
}
class Sign extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Sign_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of Sign from a given implementation */ static new_impl(arg, baseSign_impl, pubkeys) {
        const impl_holder = new LDKSignHolder();
        let structImplementation = {
            write () {
                const ret = arg.write();
                const result = _bindingsMjs.encodeUint8Array(ret);
                return result;
            }
        };
        const baseSign = _baseSignMjs.BaseSign.new_impl(baseSign_impl, pubkeys);
        const ptr = _bindingsMjs.LDKSign_new(structImplementation, baseSign.bindings_instance, pubkeys == null ? 0 : pubkeys.clone_ptr());
        impl_holder.held = new Sign(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        impl_holder.held.ptrs_to.push(baseSign);
        return impl_holder.held;
    }
    /**
     * Serialize the object into a byte array
     */ write() {
        const ret = _bindingsMjs.Sign_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.Sign_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of a Sign
     */ clone() {
        const ret = _bindingsMjs.Sign_clone(this.ptr);
        const ret_hu_conv = new Sign(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"../structs/BaseSign.mjs":"4dNuw","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ebdYy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A ChannelMonitor handles chain events (blocks connected and disconnected) and generates
 * on-chain transactions to ensure no loss of funds occurs.
 *
 * You MUST ensure that no ChannelMonitors for a given channel anywhere contain out-of-date
 * information and are actively monitoring the chain.
 *
 * Pending Events or updated HTLCs which have not yet been read out by
 * get_and_clear_pending_monitor_events or get_and_clear_pending_events are serialized to disk and
 * reloaded at deserialize-time. Thus, you must ensure that, when handling events, all events
 * gotten are fully handled before re-serializing the new state.
 *
 * Note that the deserializer is only implemented for (BlockHash, ChannelMonitor), which
 * tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
 * the \"reorg path\" (ie disconnecting blocks until you find a common ancestor from both the
 * returned block hash and the the current chain and then reconnecting blocks to get to the
 * best chain) upon deserializing the object!
 */ parcelHelpers.export(exports, "ChannelMonitor", ()=>ChannelMonitor
) //# sourceMappingURL=ChannelMonitor.mjs.map
;
var _monitorEventMjs = require("../structs/MonitorEvent.mjs");
var _resultNoneNoneZMjs = require("../structs/Result_NoneNoneZ.mjs");
var _twoTupleOutPointScriptZMjs = require("../structs/TwoTuple_OutPointScriptZ.mjs");
var _twoTupleTxidCVecC2TupleU32ScriptZZZMjs = require("../structs/TwoTuple_TxidCVec_C2Tuple_u32ScriptZZZ.mjs");
var _eventMjs = require("../structs/Event.mjs");
var _twoTupleTxidCVecC2TupleU32TxOutZZZMjs = require("../structs/TwoTuple_TxidCVec_C2Tuple_u32TxOutZZZ.mjs");
var _balanceMjs = require("../structs/Balance.mjs");
var _bestBlockMjs = require("../structs/BestBlock.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelMonitor extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelMonitor_free);
    }
    clone_ptr() {
        const ret = _bindingsMjs.ChannelMonitor_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelMonitor
     */ clone() {
        const ret = _bindingsMjs.ChannelMonitor_clone(this.ptr);
        const ret_hu_conv = new ChannelMonitor(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the ChannelMonitor object into a byte array which can be read by ChannelMonitor_read
     */ write() {
        const ret = _bindingsMjs.ChannelMonitor_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Updates a ChannelMonitor on the basis of some new information provided by the Channel
     * itself.
     *
     * panics if the given update is not the next update by update_id.
     */ update_monitor(updates, broadcaster, fee_estimator, logger) {
        const ret = _bindingsMjs.ChannelMonitor_update_monitor(this.ptr, updates == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(updates) & -2, broadcaster == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(broadcaster), fee_estimator == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(fee_estimator), logger == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(logger));
        const ret_hu_conv = _resultNoneNoneZMjs.Result_NoneNoneZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, updates);
        _commonBaseMjsDefault.default.add_ref_from(this, broadcaster);
        _commonBaseMjsDefault.default.add_ref_from(this, fee_estimator);
        _commonBaseMjsDefault.default.add_ref_from(this, logger);
        return ret_hu_conv;
    }
    /**
     * Gets the update_id from the latest ChannelMonitorUpdate which was applied to this
     * ChannelMonitor.
     */ get_latest_update_id() {
        const ret = _bindingsMjs.ChannelMonitor_get_latest_update_id(this.ptr);
        return ret;
    }
    /**
     * Gets the funding transaction outpoint of the channel this ChannelMonitor is monitoring for.
     */ get_funding_txo() {
        const ret = _bindingsMjs.ChannelMonitor_get_funding_txo(this.ptr);
        const ret_hu_conv = new _twoTupleOutPointScriptZMjs.TwoTuple_OutPointScriptZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Gets a list of txids, with their output scripts (in the order they appear in the
     * transaction), which we must learn about spends of via block_connected().
     */ get_outputs_to_watch() {
        const ret = _bindingsMjs.ChannelMonitor_get_outputs_to_watch(this.ptr);
        const ret_conv_40_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_40_arr = new Array(ret_conv_40_len).fill(null);
        for(var o = 0; o < ret_conv_40_len; o++){
            const ret_conv_40 = _bindingsMjs.getU32ArrayElem(ret, o);
            const ret_conv_40_hu_conv = new _twoTupleTxidCVecC2TupleU32ScriptZZZMjs.TwoTuple_TxidCVec_C2Tuple_u32ScriptZZZ(null, ret_conv_40);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_40_hu_conv, this);
            ret_conv_40_arr[o] = ret_conv_40_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_40_arr;
    }
    /**
     * Loads the funding txo and outputs to watch into the given `chain::Filter` by repeatedly
     * calling `chain::Filter::register_output` and `chain::Filter::register_tx` until all outputs
     * have been registered.
     */ load_outputs_to_watch(filter) {
        _bindingsMjs.ChannelMonitor_load_outputs_to_watch(this.ptr, filter == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(filter));
        _commonBaseMjsDefault.default.add_ref_from(this, filter);
    }
    /**
     * Get the list of HTLCs who's status has been updated on chain. This should be called by
     * ChannelManager via [`chain::Watch::release_pending_monitor_events`].
     */ get_and_clear_pending_monitor_events() {
        const ret = _bindingsMjs.ChannelMonitor_get_and_clear_pending_monitor_events(this.ptr);
        const ret_conv_14_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_14_arr = new Array(ret_conv_14_len).fill(null);
        for(var o = 0; o < ret_conv_14_len; o++){
            const ret_conv_14 = _bindingsMjs.getU32ArrayElem(ret, o);
            const ret_conv_14_hu_conv = _monitorEventMjs.MonitorEvent.constr_from_ptr(ret_conv_14);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_14_hu_conv, this);
            ret_conv_14_arr[o] = ret_conv_14_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_14_arr;
    }
    /**
     * Gets the list of pending events which were generated by previous actions, clearing the list
     * in the process.
     *
     * This is called by ChainMonitor::get_and_clear_pending_events() and is equivalent to
     * EventsProvider::get_and_clear_pending_events() except that it requires &mut self as we do
     * no internal locking in ChannelMonitors.
     */ get_and_clear_pending_events() {
        const ret = _bindingsMjs.ChannelMonitor_get_and_clear_pending_events(this.ptr);
        const ret_conv_7_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_7_arr = new Array(ret_conv_7_len).fill(null);
        for(var h = 0; h < ret_conv_7_len; h++){
            const ret_conv_7 = _bindingsMjs.getU32ArrayElem(ret, h);
            const ret_conv_7_hu_conv = _eventMjs.Event.constr_from_ptr(ret_conv_7);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_7_hu_conv, this);
            ret_conv_7_arr[h] = ret_conv_7_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_7_arr;
    }
    /**
     * Used by ChannelManager deserialization to broadcast the latest holder state if its copy of
     * the Channel was out-of-date. You may use it to get a broadcastable holder toxic tx in case of
     * fallen-behind, i.e when receiving a channel_reestablish with a proof that our counterparty side knows
     * a higher revocation secret than the holder commitment number we are aware of. Broadcasting these
     * transactions are UNSAFE, as they allow counterparty side to punish you. Nevertheless you may want to
     * broadcast them if counterparty don't close channel with his higher commitment transaction after a
     * substantial amount of time (a month or even a year) to get back funds. Best may be to contact
     * out-of-band the other node operator to coordinate with him if option is available to you.
     * In any-case, choice is up to the user.
     */ get_latest_holder_commitment_txn(logger) {
        const ret = _bindingsMjs.ChannelMonitor_get_latest_holder_commitment_txn(this.ptr, logger == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(logger));
        const ret_conv_12_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_12_arr = new Array(ret_conv_12_len).fill(null);
        for(var m = 0; m < ret_conv_12_len; m++){
            const ret_conv_12 = _bindingsMjs.getU32ArrayElem(ret, m);
            const ret_conv_12_conv = _bindingsMjs.decodeUint8Array(ret_conv_12);
            ret_conv_12_arr[m] = ret_conv_12_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, logger);
        return ret_conv_12_arr;
    }
    /**
     * Processes transactions in a newly connected block, which may result in any of the following:
     * - update the monitor's state against resolved HTLCs
     * - punish the counterparty in the case of seeing a revoked commitment transaction
     * - force close the channel and claim/timeout incoming/outgoing HTLCs if near expiration
     * - detect settled outputs for later spending
     * - schedule and bump any in-flight claims
     *
     * Returns any new outputs to watch from `txdata`; after called, these are also included in
     * [`get_outputs_to_watch`].
     *
     * [`get_outputs_to_watch`]: #method.get_outputs_to_watch
     */ block_connected(header, txdata, height, broadcaster, fee_estimator, logger) {
        const ret = _bindingsMjs.ChannelMonitor_block_connected(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(header, 80)), _bindingsMjs.encodeUint32Array(txdata != null ? txdata.map((txdata_conv_28)=>txdata_conv_28 != null ? _commonBaseMjsDefault.default.get_ptr_of(txdata_conv_28) : 0
        ) : null), height, broadcaster == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(broadcaster), fee_estimator == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(fee_estimator), logger == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(logger));
        const ret_conv_39_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_39_arr = new Array(ret_conv_39_len).fill(null);
        for(var n = 0; n < ret_conv_39_len; n++){
            const ret_conv_39 = _bindingsMjs.getU32ArrayElem(ret, n);
            const ret_conv_39_hu_conv = new _twoTupleTxidCVecC2TupleU32TxOutZZZMjs.TwoTuple_TxidCVec_C2Tuple_u32TxOutZZZ(null, ret_conv_39);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_39_hu_conv, this);
            ret_conv_39_arr[n] = ret_conv_39_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, broadcaster);
        _commonBaseMjsDefault.default.add_ref_from(this, fee_estimator);
        _commonBaseMjsDefault.default.add_ref_from(this, logger);
        return ret_conv_39_arr;
    }
    /**
     * Determines if the disconnected block contained any transactions of interest and updates
     * appropriately.
     */ block_disconnected(header, height, broadcaster, fee_estimator, logger) {
        _bindingsMjs.ChannelMonitor_block_disconnected(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(header, 80)), height, broadcaster == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(broadcaster), fee_estimator == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(fee_estimator), logger == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(logger));
        _commonBaseMjsDefault.default.add_ref_from(this, broadcaster);
        _commonBaseMjsDefault.default.add_ref_from(this, fee_estimator);
        _commonBaseMjsDefault.default.add_ref_from(this, logger);
    }
    /**
     * Processes transactions confirmed in a block with the given header and height, returning new
     * outputs to watch. See [`block_connected`] for details.
     *
     * Used instead of [`block_connected`] by clients that are notified of transactions rather than
     * blocks. See [`chain::Confirm`] for calling expectations.
     *
     * [`block_connected`]: Self::block_connected
     */ transactions_confirmed(header, txdata, height, broadcaster, fee_estimator, logger) {
        const ret = _bindingsMjs.ChannelMonitor_transactions_confirmed(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(header, 80)), _bindingsMjs.encodeUint32Array(txdata != null ? txdata.map((txdata_conv_28)=>txdata_conv_28 != null ? _commonBaseMjsDefault.default.get_ptr_of(txdata_conv_28) : 0
        ) : null), height, broadcaster == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(broadcaster), fee_estimator == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(fee_estimator), logger == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(logger));
        const ret_conv_39_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_39_arr = new Array(ret_conv_39_len).fill(null);
        for(var n = 0; n < ret_conv_39_len; n++){
            const ret_conv_39 = _bindingsMjs.getU32ArrayElem(ret, n);
            const ret_conv_39_hu_conv = new _twoTupleTxidCVecC2TupleU32TxOutZZZMjs.TwoTuple_TxidCVec_C2Tuple_u32TxOutZZZ(null, ret_conv_39);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_39_hu_conv, this);
            ret_conv_39_arr[n] = ret_conv_39_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, broadcaster);
        _commonBaseMjsDefault.default.add_ref_from(this, fee_estimator);
        _commonBaseMjsDefault.default.add_ref_from(this, logger);
        return ret_conv_39_arr;
    }
    /**
     * Processes a transaction that was reorganized out of the chain.
     *
     * Used instead of [`block_disconnected`] by clients that are notified of transactions rather
     * than blocks. See [`chain::Confirm`] for calling expectations.
     *
     * [`block_disconnected`]: Self::block_disconnected
     */ transaction_unconfirmed(txid, broadcaster, fee_estimator, logger) {
        _bindingsMjs.ChannelMonitor_transaction_unconfirmed(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(txid, 32)), broadcaster == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(broadcaster), fee_estimator == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(fee_estimator), logger == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(logger));
        _commonBaseMjsDefault.default.add_ref_from(this, broadcaster);
        _commonBaseMjsDefault.default.add_ref_from(this, fee_estimator);
        _commonBaseMjsDefault.default.add_ref_from(this, logger);
    }
    /**
     * Updates the monitor with the current best chain tip, returning new outputs to watch. See
     * [`block_connected`] for details.
     *
     * Used instead of [`block_connected`] by clients that are notified of transactions rather than
     * blocks. See [`chain::Confirm`] for calling expectations.
     *
     * [`block_connected`]: Self::block_connected
     */ best_block_updated(header, height, broadcaster, fee_estimator, logger) {
        const ret = _bindingsMjs.ChannelMonitor_best_block_updated(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(header, 80)), height, broadcaster == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(broadcaster), fee_estimator == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(fee_estimator), logger == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(logger));
        const ret_conv_39_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_39_arr = new Array(ret_conv_39_len).fill(null);
        for(var n = 0; n < ret_conv_39_len; n++){
            const ret_conv_39 = _bindingsMjs.getU32ArrayElem(ret, n);
            const ret_conv_39_hu_conv = new _twoTupleTxidCVecC2TupleU32TxOutZZZMjs.TwoTuple_TxidCVec_C2Tuple_u32TxOutZZZ(null, ret_conv_39);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_39_hu_conv, this);
            ret_conv_39_arr[n] = ret_conv_39_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, broadcaster);
        _commonBaseMjsDefault.default.add_ref_from(this, fee_estimator);
        _commonBaseMjsDefault.default.add_ref_from(this, logger);
        return ret_conv_39_arr;
    }
    /**
     * Returns the set of txids that should be monitored for re-organization out of the chain.
     */ get_relevant_txids() {
        const ret = _bindingsMjs.ChannelMonitor_get_relevant_txids(this.ptr);
        const ret_conv_12_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_12_arr = new Array(ret_conv_12_len).fill(null);
        for(var m = 0; m < ret_conv_12_len; m++){
            const ret_conv_12 = _bindingsMjs.getU32ArrayElem(ret, m);
            const ret_conv_12_conv = _bindingsMjs.decodeUint8Array(ret_conv_12);
            ret_conv_12_arr[m] = ret_conv_12_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_12_arr;
    }
    /**
     * Gets the latest best block which was connected either via the [`chain::Listen`] or
     * [`chain::Confirm`] interfaces.
     */ current_best_block() {
        const ret = _bindingsMjs.ChannelMonitor_current_best_block(this.ptr);
        const ret_hu_conv = new _bestBlockMjs.BestBlock(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Gets the balances in this channel which are either claimable by us if we were to
     * force-close the channel now or which are claimable on-chain (possibly awaiting
     * confirmation).
     *
     * Any balances in the channel which are available on-chain (excluding on-chain fees) are
     * included here until an [`Event::SpendableOutputs`] event has been generated for the
     * balance, or until our counterparty has claimed the balance and accrued several
     * confirmations on the claim transaction.
     *
     * Note that the balances available when you or your counterparty have broadcasted revoked
     * state(s) may not be fully captured here.
     *
     * See [`Balance`] for additional details on the types of claimable balances which
     * may be returned here and their meanings.
     */ get_claimable_balances() {
        const ret = _bindingsMjs.ChannelMonitor_get_claimable_balances(this.ptr);
        const ret_conv_9_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_9_arr = new Array(ret_conv_9_len).fill(null);
        for(var j = 0; j < ret_conv_9_len; j++){
            const ret_conv_9 = _bindingsMjs.getU32ArrayElem(ret, j);
            const ret_conv_9_hu_conv = _balanceMjs.Balance.constr_from_ptr(ret_conv_9);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_9_hu_conv, this);
            ret_conv_9_arr[j] = ret_conv_9_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_9_arr;
    }
}

},{"../structs/MonitorEvent.mjs":"jGH1U","../structs/Result_NoneNoneZ.mjs":"1QnVF","../structs/TwoTuple_OutPointScriptZ.mjs":"loLPb","../structs/TwoTuple_TxidCVec_C2Tuple_u32ScriptZZZ.mjs":"fDovr","../structs/Event.mjs":"g2Zcr","../structs/TwoTuple_TxidCVec_C2Tuple_u32TxOutZZZ.mjs":"fieS2","../structs/Balance.mjs":"jbcIa","../structs/BestBlock.mjs":"1czxO","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1czxO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The best known block as identified by its hash and height.
 */ parcelHelpers.export(exports, "BestBlock", ()=>BestBlock
) //# sourceMappingURL=BestBlock.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class BestBlock extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.BestBlock_free);
    }
    clone_ptr() {
        const ret = _bindingsMjs.BestBlock_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the BestBlock
     */ clone() {
        const ret = _bindingsMjs.BestBlock_clone(this.ptr);
        const ret_hu_conv = new BestBlock(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a `BestBlock` that represents the genesis block at height 0 of the given
     * network.
     */ static constructor_from_genesis(network) {
        const ret = _bindingsMjs.BestBlock_from_genesis(network);
        const ret_hu_conv = new BestBlock(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Returns a `BestBlock` as identified by the given block hash and height.
     */ static constructor_new(block_hash, height) {
        const ret = _bindingsMjs.BestBlock_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(block_hash, 32)), height);
        const ret_hu_conv = new BestBlock(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Returns the best block hash.
     */ block_hash() {
        const ret = _bindingsMjs.BestBlock_block_hash(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Returns the best block height.
     */ height() {
        const ret = _bindingsMjs.BestBlock_height(this.ptr);
        return ret;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hqqnc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Tuple
 */ parcelHelpers.export(exports, "TwoTuple_BlockHashChannelMonitorZ", ()=>TwoTuple_BlockHashChannelMonitorZ
) //# sourceMappingURL=TwoTuple_BlockHashChannelMonitorZ.mjs.map
;
var _channelMonitorMjs = require("../structs/ChannelMonitor.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class TwoTuple_BlockHashChannelMonitorZ extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.C2Tuple_BlockHashChannelMonitorZ_free);
    }
    /**
     *
     */ get_a() {
        const ret = _bindingsMjs.C2Tuple_BlockHashChannelMonitorZ_get_a(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     *
     */ get_b() {
        const ret = _bindingsMjs.C2Tuple_BlockHashChannelMonitorZ_get_b(this.ptr);
        const ret_hu_conv = new _channelMonitorMjs.ChannelMonitor(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.C2Tuple_BlockHashChannelMonitorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new tuple which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.C2Tuple_BlockHashChannelMonitorZ_clone(this.ptr);
        const ret_hu_conv = new TwoTuple_BlockHashChannelMonitorZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a new C2Tuple_BlockHashChannelMonitorZ from the contained elements.
     */ static constructor_new(a, b) {
        const ret = _bindingsMjs.C2Tuple_BlockHashChannelMonitorZ_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(a, 32)), b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b) & -2);
        const ret_hu_conv = new TwoTuple_BlockHashChannelMonitorZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"../structs/ChannelMonitor.mjs":"ebdYy","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jDvbr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ", ()=>Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ
);
parcelHelpers.export(exports, "Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_OK", ()=>Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_Err", ()=>Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_Err
) //# sourceMappingURL=Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _twoTupleBlockHashChannelMonitorZMjs = require("../structs/TwoTuple_BlockHashChannelMonitorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok(ptr)) return new Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_OK(null, ptr);
        else return new Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(o != null ? _commonBaseMjsDefault.default.get_ptr_of(o) : 0);
        const ret_hu_conv = Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_OK extends Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _twoTupleBlockHashChannelMonitorZMjs.TwoTuple_BlockHashChannelMonitorZ(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_Err extends Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/TwoTuple_BlockHashChannelMonitorZ.mjs":"hqqnc","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eZydB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A route directs a payment from the sender (us) to the recipient. If the recipient supports MPP,
 * it can take multiple paths. Each path is composed of one or more hops through the network.
 */ parcelHelpers.export(exports, "Route", ()=>Route
) //# sourceMappingURL=Route.mjs.map
;
var _routeHopMjs = require("../structs/RouteHop.mjs");
var _resultRouteDecodeErrorZMjs = require("../structs/Result_RouteDecodeErrorZ.mjs");
var _payeeMjs = require("../structs/Payee.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Route extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Route_free);
    }
    /**
     * The list of routes taken for a single (potentially-)multi-part payment. The pubkey of the
     * last RouteHop in each path must be the same.
     * Each entry represents a list of hops, NOT INCLUDING our own, where the last hop is the
     * destination. Thus, this must always be at least length one. While the maximum length of any
     * given path is variable, keeping the length of any path to less than 20 should currently
     * ensure it is viable.
     */ get_paths() {
        const ret = _bindingsMjs.Route_get_paths(this.ptr);
        const ret_conv_12_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_12_arr = new Array(ret_conv_12_len).fill(null);
        for(var m = 0; m < ret_conv_12_len; m++){
            const ret_conv_12 = _bindingsMjs.getU32ArrayElem(ret, m);
            const ret_conv_12_conv_10_len = _bindingsMjs.getArrayLength(ret_conv_12);
            const ret_conv_12_conv_10_arr = new Array(ret_conv_12_conv_10_len).fill(null);
            for(var k = 0; k < ret_conv_12_conv_10_len; k++){
                const ret_conv_12_conv_10 = _bindingsMjs.getU32ArrayElem(ret_conv_12, k);
                const ret_conv_12_conv_10_hu_conv = new _routeHopMjs.RouteHop(null, ret_conv_12_conv_10);
                _commonBaseMjsDefault.default.add_ref_from(ret_conv_12_conv_10_hu_conv, this);
                ret_conv_12_conv_10_arr[k] = ret_conv_12_conv_10_hu_conv;
            }
            _bindingsMjs.freeWasmMemory(ret_conv_12);
            ret_conv_12_arr[m] = ret_conv_12_conv_10_arr;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_12_arr;
    }
    /**
     * The list of routes taken for a single (potentially-)multi-part payment. The pubkey of the
     * last RouteHop in each path must be the same.
     * Each entry represents a list of hops, NOT INCLUDING our own, where the last hop is the
     * destination. Thus, this must always be at least length one. While the maximum length of any
     * given path is variable, keeping the length of any path to less than 20 should currently
     * ensure it is viable.
     */ set_paths(val) {
        _bindingsMjs.Route_set_paths(this.ptr, _bindingsMjs.encodeUint32Array(val != null ? val.map((val_conv_12)=>_bindingsMjs.encodeUint32Array(val_conv_12 != null ? val_conv_12.map((val_conv_12_conv_10)=>val_conv_12_conv_10 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val_conv_12_conv_10) & -2
            ) : null)
        ) : null));
    }
    /**
     * The `payee` parameter passed to [`find_route`].
     * This is used by `ChannelManager` to track information which may be required for retries,
     * provided back to you via [`Event::PaymentPathFailed`].
     *
     * [`Event::PaymentPathFailed`]: crate::util::events::Event::PaymentPathFailed
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_payee() {
        const ret = _bindingsMjs.Route_get_payee(this.ptr);
        const ret_hu_conv = new _payeeMjs.Payee(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The `payee` parameter passed to [`find_route`].
     * This is used by `ChannelManager` to track information which may be required for retries,
     * provided back to you via [`Event::PaymentPathFailed`].
     *
     * [`Event::PaymentPathFailed`]: crate::util::events::Event::PaymentPathFailed
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_payee(val) {
        _bindingsMjs.Route_set_payee(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Constructs a new Route given each field
     */ static constructor_new(paths_arg, payee_arg) {
        const ret = _bindingsMjs.Route_new(_bindingsMjs.encodeUint32Array(paths_arg != null ? paths_arg.map((paths_arg_conv_12)=>_bindingsMjs.encodeUint32Array(paths_arg_conv_12 != null ? paths_arg_conv_12.map((paths_arg_conv_12_conv_10)=>paths_arg_conv_12_conv_10 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(paths_arg_conv_12_conv_10) & -2
            ) : null)
        ) : null), payee_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(payee_arg) & -2);
        const ret_hu_conv = new Route(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.Route_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the Route
     */ clone() {
        const ret = _bindingsMjs.Route_clone(this.ptr);
        const ret_hu_conv = new Route(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Checks if two Routes contain equal inner contents.
     */ hash() {
        const ret = _bindingsMjs.Route_hash(this.ptr);
        return ret;
    }
    /**
     * Checks if two Routes contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */ eq(b) {
        const ret = _bindingsMjs.Route_eq(this.ptr, b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, b);
        return ret;
    }
    /**
     * Returns the total amount of fees paid on this [`Route`].
     *
     * This doesn't include any extra payment made to the recipient, which can happen in excess of
     * the amount passed to [`find_route`]'s `params.final_value_msat`.
     */ get_total_fees() {
        const ret = _bindingsMjs.Route_get_total_fees(this.ptr);
        return ret;
    }
    /**
     * Returns the total amount paid on this [`Route`], excluding the fees.
     */ get_total_amount() {
        const ret = _bindingsMjs.Route_get_total_amount(this.ptr);
        return ret;
    }
    /**
     * Serialize the Route object into a byte array which can be read by Route_read
     */ write() {
        const ret = _bindingsMjs.Route_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a Route from a byte array, created by Route_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.Route_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultRouteDecodeErrorZMjs.Result_RouteDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/RouteHop.mjs":"hQQ4g","../structs/Result_RouteDecodeErrorZ.mjs":"2RBQ3","../structs/Payee.mjs":"3fxcr","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2RBQ3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_RouteDecodeErrorZ", ()=>Result_RouteDecodeErrorZ
);
parcelHelpers.export(exports, "Result_RouteDecodeErrorZ_OK", ()=>Result_RouteDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_RouteDecodeErrorZ_Err", ()=>Result_RouteDecodeErrorZ_Err
) //# sourceMappingURL=Result_RouteDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _routeMjs = require("../structs/Route.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_RouteDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_RouteDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_RouteDecodeErrorZ_is_ok(ptr)) return new Result_RouteDecodeErrorZ_OK(null, ptr);
        else return new Result_RouteDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_RouteDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_RouteDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_RouteDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_RouteDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_RouteDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_RouteDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_RouteDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_RouteDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_RouteDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_RouteDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_RouteDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_RouteDecodeErrorZ_OK extends Result_RouteDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_RouteDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _routeMjs.Route(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_RouteDecodeErrorZ_Err extends Result_RouteDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_RouteDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/Route.mjs":"eZydB","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bIXdf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Details of a channel, as returned by ChannelManager::list_channels and ChannelManager::list_usable_channels
 */ parcelHelpers.export(exports, "ChannelDetails", ()=>ChannelDetails
) //# sourceMappingURL=ChannelDetails.mjs.map
;
var _outPointMjs = require("../structs/OutPoint.mjs");
var _optionU32ZMjs = require("../structs/Option_u32Z.mjs");
var _optionU64ZMjs = require("../structs/Option_u64Z.mjs");
var _optionU16ZMjs = require("../structs/Option_u16Z.mjs");
var _channelCounterpartyMjs = require("../structs/ChannelCounterparty.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelDetails extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelDetails_free);
    }
    /**
     * The channel's ID (prior to funding transaction generation, this is a random 32 bytes,
     * thereafter this is the txid of the funding transaction xor the funding transaction output).
     * Note that this means this value is *not* persistent - it can change once during the
     * lifetime of the channel.
     */ get_channel_id() {
        const ret = _bindingsMjs.ChannelDetails_get_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The channel's ID (prior to funding transaction generation, this is a random 32 bytes,
     * thereafter this is the txid of the funding transaction xor the funding transaction output).
     * Note that this means this value is *not* persistent - it can change once during the
     * lifetime of the channel.
     */ set_channel_id(val) {
        _bindingsMjs.ChannelDetails_set_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * Parameters which apply to our counterparty. See individual fields for more information.
     */ get_counterparty() {
        const ret = _bindingsMjs.ChannelDetails_get_counterparty(this.ptr);
        const ret_hu_conv = new _channelCounterpartyMjs.ChannelCounterparty(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Parameters which apply to our counterparty. See individual fields for more information.
     */ set_counterparty(val) {
        _bindingsMjs.ChannelDetails_set_counterparty(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * The Channel's funding transaction output, if we've negotiated the funding transaction with
     * our counterparty already.
     *
     * Note that, if this has been set, `channel_id` will be equivalent to
     * `funding_txo.unwrap().to_channel_id()`.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_funding_txo() {
        const ret = _bindingsMjs.ChannelDetails_get_funding_txo(this.ptr);
        const ret_hu_conv = new _outPointMjs.OutPoint(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The Channel's funding transaction output, if we've negotiated the funding transaction with
     * our counterparty already.
     *
     * Note that, if this has been set, `channel_id` will be equivalent to
     * `funding_txo.unwrap().to_channel_id()`.
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_funding_txo(val) {
        _bindingsMjs.ChannelDetails_set_funding_txo(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * The position of the funding transaction in the chain. None if the funding transaction has
     * not yet been confirmed and the channel fully opened.
     */ get_short_channel_id() {
        const ret = _bindingsMjs.ChannelDetails_get_short_channel_id(this.ptr);
        const ret_hu_conv = _optionU64ZMjs.Option_u64Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The position of the funding transaction in the chain. None if the funding transaction has
     * not yet been confirmed and the channel fully opened.
     */ set_short_channel_id(val) {
        _bindingsMjs.ChannelDetails_set_short_channel_id(this.ptr, _commonBaseMjsDefault.default.get_ptr_of(val));
    }
    /**
     * The value, in satoshis, of this channel as appears in the funding output
     */ get_channel_value_satoshis() {
        const ret = _bindingsMjs.ChannelDetails_get_channel_value_satoshis(this.ptr);
        return ret;
    }
    /**
     * The value, in satoshis, of this channel as appears in the funding output
     */ set_channel_value_satoshis(val) {
        _bindingsMjs.ChannelDetails_set_channel_value_satoshis(this.ptr, val);
    }
    /**
     * The value, in satoshis, that must always be held in the channel for us. This value ensures
     * that if we broadcast a revoked state, our counterparty can punish us by claiming at least
     * this value on chain.
     *
     * This value is not included in [`outbound_capacity_msat`] as it can never be spent.
     *
     * This value will be `None` for outbound channels until the counterparty accepts the channel.
     *
     * [`outbound_capacity_msat`]: ChannelDetails::outbound_capacity_msat
     */ get_unspendable_punishment_reserve() {
        const ret = _bindingsMjs.ChannelDetails_get_unspendable_punishment_reserve(this.ptr);
        const ret_hu_conv = _optionU64ZMjs.Option_u64Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The value, in satoshis, that must always be held in the channel for us. This value ensures
     * that if we broadcast a revoked state, our counterparty can punish us by claiming at least
     * this value on chain.
     *
     * This value is not included in [`outbound_capacity_msat`] as it can never be spent.
     *
     * This value will be `None` for outbound channels until the counterparty accepts the channel.
     *
     * [`outbound_capacity_msat`]: ChannelDetails::outbound_capacity_msat
     */ set_unspendable_punishment_reserve(val) {
        _bindingsMjs.ChannelDetails_set_unspendable_punishment_reserve(this.ptr, _commonBaseMjsDefault.default.get_ptr_of(val));
    }
    /**
     * The `user_channel_id` passed in to create_channel, or 0 if the channel was inbound.
     */ get_user_channel_id() {
        const ret = _bindingsMjs.ChannelDetails_get_user_channel_id(this.ptr);
        return ret;
    }
    /**
     * The `user_channel_id` passed in to create_channel, or 0 if the channel was inbound.
     */ set_user_channel_id(val) {
        _bindingsMjs.ChannelDetails_set_user_channel_id(this.ptr, val);
    }
    /**
     * Our total balance.  This is the amount we would get if we close the channel.
     * This value is not exact. Due to various in-flight changes and feerate changes, exactly this
     * amount is not likely to be recoverable on close.
     *
     * This does not include any pending HTLCs which are not yet fully resolved (and, thus, whose
     * balance is not available for inclusion in new outbound HTLCs). This further does not include
     * any pending outgoing HTLCs which are awaiting some other resolution to be sent.
     * This does not consider any on-chain fees.
     *
     * See also [`ChannelDetails::outbound_capacity_msat`]
     */ get_balance_msat() {
        const ret = _bindingsMjs.ChannelDetails_get_balance_msat(this.ptr);
        return ret;
    }
    /**
     * Our total balance.  This is the amount we would get if we close the channel.
     * This value is not exact. Due to various in-flight changes and feerate changes, exactly this
     * amount is not likely to be recoverable on close.
     *
     * This does not include any pending HTLCs which are not yet fully resolved (and, thus, whose
     * balance is not available for inclusion in new outbound HTLCs). This further does not include
     * any pending outgoing HTLCs which are awaiting some other resolution to be sent.
     * This does not consider any on-chain fees.
     *
     * See also [`ChannelDetails::outbound_capacity_msat`]
     */ set_balance_msat(val) {
        _bindingsMjs.ChannelDetails_set_balance_msat(this.ptr, val);
    }
    /**
     * The available outbound capacity for sending HTLCs to the remote peer. This does not include
     * any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
     * available for inclusion in new outbound HTLCs). This further does not include any pending
     * outgoing HTLCs which are awaiting some other resolution to be sent.
     *
     * See also [`ChannelDetails::balance_msat`]
     *
     * This value is not exact. Due to various in-flight changes, feerate changes, and our
     * conflict-avoidance policy, exactly this amount is not likely to be spendable. However, we
     * should be able to spend nearly this amount.
     */ get_outbound_capacity_msat() {
        const ret = _bindingsMjs.ChannelDetails_get_outbound_capacity_msat(this.ptr);
        return ret;
    }
    /**
     * The available outbound capacity for sending HTLCs to the remote peer. This does not include
     * any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
     * available for inclusion in new outbound HTLCs). This further does not include any pending
     * outgoing HTLCs which are awaiting some other resolution to be sent.
     *
     * See also [`ChannelDetails::balance_msat`]
     *
     * This value is not exact. Due to various in-flight changes, feerate changes, and our
     * conflict-avoidance policy, exactly this amount is not likely to be spendable. However, we
     * should be able to spend nearly this amount.
     */ set_outbound_capacity_msat(val) {
        _bindingsMjs.ChannelDetails_set_outbound_capacity_msat(this.ptr, val);
    }
    /**
     * The available inbound capacity for the remote peer to send HTLCs to us. This does not
     * include any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
     * available for inclusion in new inbound HTLCs).
     * Note that there are some corner cases not fully handled here, so the actual available
     * inbound capacity may be slightly higher than this.
     *
     * This value is not exact. Due to various in-flight changes, feerate changes, and our
     * counterparty's conflict-avoidance policy, exactly this amount is not likely to be spendable.
     * However, our counterparty should be able to spend nearly this amount.
     */ get_inbound_capacity_msat() {
        const ret = _bindingsMjs.ChannelDetails_get_inbound_capacity_msat(this.ptr);
        return ret;
    }
    /**
     * The available inbound capacity for the remote peer to send HTLCs to us. This does not
     * include any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
     * available for inclusion in new inbound HTLCs).
     * Note that there are some corner cases not fully handled here, so the actual available
     * inbound capacity may be slightly higher than this.
     *
     * This value is not exact. Due to various in-flight changes, feerate changes, and our
     * counterparty's conflict-avoidance policy, exactly this amount is not likely to be spendable.
     * However, our counterparty should be able to spend nearly this amount.
     */ set_inbound_capacity_msat(val) {
        _bindingsMjs.ChannelDetails_set_inbound_capacity_msat(this.ptr, val);
    }
    /**
     * The number of required confirmations on the funding transaction before the funding will be
     * considered \"locked\". This number is selected by the channel fundee (i.e. us if
     * [`is_outbound`] is *not* set), and can be selected for inbound channels with
     * [`ChannelHandshakeConfig::minimum_depth`] or limited for outbound channels with
     * [`ChannelHandshakeLimits::max_minimum_depth`].
     *
     * This value will be `None` for outbound channels until the counterparty accepts the channel.
     *
     * [`is_outbound`]: ChannelDetails::is_outbound
     * [`ChannelHandshakeConfig::minimum_depth`]: crate::util::config::ChannelHandshakeConfig::minimum_depth
     * [`ChannelHandshakeLimits::max_minimum_depth`]: crate::util::config::ChannelHandshakeLimits::max_minimum_depth
     */ get_confirmations_required() {
        const ret = _bindingsMjs.ChannelDetails_get_confirmations_required(this.ptr);
        const ret_hu_conv = _optionU32ZMjs.Option_u32Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The number of required confirmations on the funding transaction before the funding will be
     * considered \"locked\". This number is selected by the channel fundee (i.e. us if
     * [`is_outbound`] is *not* set), and can be selected for inbound channels with
     * [`ChannelHandshakeConfig::minimum_depth`] or limited for outbound channels with
     * [`ChannelHandshakeLimits::max_minimum_depth`].
     *
     * This value will be `None` for outbound channels until the counterparty accepts the channel.
     *
     * [`is_outbound`]: ChannelDetails::is_outbound
     * [`ChannelHandshakeConfig::minimum_depth`]: crate::util::config::ChannelHandshakeConfig::minimum_depth
     * [`ChannelHandshakeLimits::max_minimum_depth`]: crate::util::config::ChannelHandshakeLimits::max_minimum_depth
     */ set_confirmations_required(val) {
        _bindingsMjs.ChannelDetails_set_confirmations_required(this.ptr, _commonBaseMjsDefault.default.get_ptr_of(val));
    }
    /**
     * The number of blocks (after our commitment transaction confirms) that we will need to wait
     * until we can claim our funds after we force-close the channel. During this time our
     * counterparty is allowed to punish us if we broadcasted a stale state. If our counterparty
     * force-closes the channel and broadcasts a commitment transaction we do not have to wait any
     * time to claim our non-HTLC-encumbered funds.
     *
     * This value will be `None` for outbound channels until the counterparty accepts the channel.
     */ get_force_close_spend_delay() {
        const ret = _bindingsMjs.ChannelDetails_get_force_close_spend_delay(this.ptr);
        const ret_hu_conv = _optionU16ZMjs.Option_u16Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The number of blocks (after our commitment transaction confirms) that we will need to wait
     * until we can claim our funds after we force-close the channel. During this time our
     * counterparty is allowed to punish us if we broadcasted a stale state. If our counterparty
     * force-closes the channel and broadcasts a commitment transaction we do not have to wait any
     * time to claim our non-HTLC-encumbered funds.
     *
     * This value will be `None` for outbound channels until the counterparty accepts the channel.
     */ set_force_close_spend_delay(val) {
        _bindingsMjs.ChannelDetails_set_force_close_spend_delay(this.ptr, _commonBaseMjsDefault.default.get_ptr_of(val));
    }
    /**
     * True if the channel was initiated (and thus funded) by us.
     */ get_is_outbound() {
        const ret = _bindingsMjs.ChannelDetails_get_is_outbound(this.ptr);
        return ret;
    }
    /**
     * True if the channel was initiated (and thus funded) by us.
     */ set_is_outbound(val) {
        _bindingsMjs.ChannelDetails_set_is_outbound(this.ptr, val);
    }
    /**
     * True if the channel is confirmed, funding_locked messages have been exchanged, and the
     * channel is not currently being shut down. `funding_locked` message exchange implies the
     * required confirmation count has been reached (and we were connected to the peer at some
     * point after the funding transaction received enough confirmations). The required
     * confirmation count is provided in [`confirmations_required`].
     *
     * [`confirmations_required`]: ChannelDetails::confirmations_required
     */ get_is_funding_locked() {
        const ret = _bindingsMjs.ChannelDetails_get_is_funding_locked(this.ptr);
        return ret;
    }
    /**
     * True if the channel is confirmed, funding_locked messages have been exchanged, and the
     * channel is not currently being shut down. `funding_locked` message exchange implies the
     * required confirmation count has been reached (and we were connected to the peer at some
     * point after the funding transaction received enough confirmations). The required
     * confirmation count is provided in [`confirmations_required`].
     *
     * [`confirmations_required`]: ChannelDetails::confirmations_required
     */ set_is_funding_locked(val) {
        _bindingsMjs.ChannelDetails_set_is_funding_locked(this.ptr, val);
    }
    /**
     * True if the channel is (a) confirmed and funding_locked messages have been exchanged, (b)
     * the peer is connected, and (c) the channel is not currently negotiating a shutdown.
     *
     * This is a strict superset of `is_funding_locked`.
     */ get_is_usable() {
        const ret = _bindingsMjs.ChannelDetails_get_is_usable(this.ptr);
        return ret;
    }
    /**
     * True if the channel is (a) confirmed and funding_locked messages have been exchanged, (b)
     * the peer is connected, and (c) the channel is not currently negotiating a shutdown.
     *
     * This is a strict superset of `is_funding_locked`.
     */ set_is_usable(val) {
        _bindingsMjs.ChannelDetails_set_is_usable(this.ptr, val);
    }
    /**
     * True if this channel is (or will be) publicly-announced.
     */ get_is_public() {
        const ret = _bindingsMjs.ChannelDetails_get_is_public(this.ptr);
        return ret;
    }
    /**
     * True if this channel is (or will be) publicly-announced.
     */ set_is_public(val) {
        _bindingsMjs.ChannelDetails_set_is_public(this.ptr, val);
    }
    /**
     * Constructs a new ChannelDetails given each field
     */ static constructor_new(channel_id_arg, counterparty_arg, funding_txo_arg, short_channel_id_arg, channel_value_satoshis_arg, unspendable_punishment_reserve_arg, user_channel_id_arg, balance_msat_arg, outbound_capacity_msat_arg, inbound_capacity_msat_arg, confirmations_required_arg, force_close_spend_delay_arg, is_outbound_arg, is_funding_locked_arg, is_usable_arg, is_public_arg) {
        const ret = _bindingsMjs.ChannelDetails_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_id_arg, 32)), counterparty_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(counterparty_arg) & -2, funding_txo_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(funding_txo_arg) & -2, _commonBaseMjsDefault.default.get_ptr_of(short_channel_id_arg), channel_value_satoshis_arg, _commonBaseMjsDefault.default.get_ptr_of(unspendable_punishment_reserve_arg), user_channel_id_arg, balance_msat_arg, outbound_capacity_msat_arg, inbound_capacity_msat_arg, _commonBaseMjsDefault.default.get_ptr_of(confirmations_required_arg), _commonBaseMjsDefault.default.get_ptr_of(force_close_spend_delay_arg), is_outbound_arg, is_funding_locked_arg, is_usable_arg, is_public_arg);
        const ret_hu_conv = new ChannelDetails(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ChannelDetails_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelDetails
     */ clone() {
        const ret = _bindingsMjs.ChannelDetails_clone(this.ptr);
        const ret_hu_conv = new ChannelDetails(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"../structs/OutPoint.mjs":"9FTof","../structs/Option_u32Z.mjs":"iQp9f","../structs/Option_u64Z.mjs":"8VC1Q","../structs/Option_u16Z.mjs":"fDG4a","../structs/ChannelCounterparty.mjs":"VkgBn","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fDG4a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An enum which can either contain a u16 or not
 */ parcelHelpers.export(exports, "Option_u16Z", ()=>Option_u16Z
);
/** A Option_u16Z of type Some */ parcelHelpers.export(exports, "Option_u16Z_Some", ()=>Option_u16Z_Some
);
/** A Option_u16Z of type None */ parcelHelpers.export(exports, "Option_u16Z_None", ()=>Option_u16Z_None
) //# sourceMappingURL=Option_u16Z.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Option_u16Z extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.COption_u16Z_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKCOption_u16Z_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new Option_u16Z_Some(ptr);
            case 1:
                return new Option_u16Z_None(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    /**
     * Constructs a new COption_u16Z containing a u16
     */ static constructor_some(o) {
        const ret = _bindingsMjs.COption_u16Z_some(o);
        const ret_hu_conv = Option_u16Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Constructs a new COption_u16Z containing nothing
     */ static constructor_none() {
        const ret = _bindingsMjs.COption_u16Z_none();
        const ret_hu_conv = Option_u16Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.COption_u16Z_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new COption_u16Z which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.COption_u16Z_clone(this.ptr);
        const ret_hu_conv = Option_u16Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
class Option_u16Z_Some extends Option_u16Z {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        this.some = _bindingsMjs.LDKCOption_u16Z_Some_get_some(ptr);
    }
}
class Option_u16Z_None extends Option_u16Z {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"VkgBn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Channel parameters which apply to our counterparty. These are split out from [`ChannelDetails`]
 * to better separate parameters.
 */ parcelHelpers.export(exports, "ChannelCounterparty", ()=>ChannelCounterparty
) //# sourceMappingURL=ChannelCounterparty.mjs.map
;
var _initFeaturesMjs = require("../structs/InitFeatures.mjs");
var _counterpartyForwardingInfoMjs = require("../structs/CounterpartyForwardingInfo.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelCounterparty extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelCounterparty_free);
    }
    /**
     * The node_id of our counterparty
     */ get_node_id() {
        const ret = _bindingsMjs.ChannelCounterparty_get_node_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The node_id of our counterparty
     */ set_node_id(val) {
        _bindingsMjs.ChannelCounterparty_set_node_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * The Features the channel counterparty provided upon last connection.
     * Useful for routing as it is the most up-to-date copy of the counterparty's features and
     * many routing-relevant features are present in the init context.
     */ get_features() {
        const ret = _bindingsMjs.ChannelCounterparty_get_features(this.ptr);
        const ret_hu_conv = new _initFeaturesMjs.InitFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The Features the channel counterparty provided upon last connection.
     * Useful for routing as it is the most up-to-date copy of the counterparty's features and
     * many routing-relevant features are present in the init context.
     */ set_features(val) {
        _bindingsMjs.ChannelCounterparty_set_features(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * The value, in satoshis, that must always be held in the channel for our counterparty. This
     * value ensures that if our counterparty broadcasts a revoked state, we can punish them by
     * claiming at least this value on chain.
     *
     * This value is not included in [`inbound_capacity_msat`] as it can never be spent.
     *
     * [`inbound_capacity_msat`]: ChannelDetails::inbound_capacity_msat
     */ get_unspendable_punishment_reserve() {
        const ret = _bindingsMjs.ChannelCounterparty_get_unspendable_punishment_reserve(this.ptr);
        return ret;
    }
    /**
     * The value, in satoshis, that must always be held in the channel for our counterparty. This
     * value ensures that if our counterparty broadcasts a revoked state, we can punish them by
     * claiming at least this value on chain.
     *
     * This value is not included in [`inbound_capacity_msat`] as it can never be spent.
     *
     * [`inbound_capacity_msat`]: ChannelDetails::inbound_capacity_msat
     */ set_unspendable_punishment_reserve(val) {
        _bindingsMjs.ChannelCounterparty_set_unspendable_punishment_reserve(this.ptr, val);
    }
    /**
     * Information on the fees and requirements that the counterparty requires when forwarding
     * payments to us through this channel.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_forwarding_info() {
        const ret = _bindingsMjs.ChannelCounterparty_get_forwarding_info(this.ptr);
        const ret_hu_conv = new _counterpartyForwardingInfoMjs.CounterpartyForwardingInfo(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Information on the fees and requirements that the counterparty requires when forwarding
     * payments to us through this channel.
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_forwarding_info(val) {
        _bindingsMjs.ChannelCounterparty_set_forwarding_info(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Constructs a new ChannelCounterparty given each field
     */ static constructor_new(node_id_arg, features_arg, unspendable_punishment_reserve_arg, forwarding_info_arg) {
        const ret = _bindingsMjs.ChannelCounterparty_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id_arg, 33)), features_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(features_arg) & -2, unspendable_punishment_reserve_arg, forwarding_info_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(forwarding_info_arg) & -2);
        const ret_hu_conv = new ChannelCounterparty(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ChannelCounterparty_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelCounterparty
     */ clone() {
        const ret = _bindingsMjs.ChannelCounterparty_clone(this.ptr);
        const ret_hu_conv = new ChannelCounterparty(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"../structs/InitFeatures.mjs":"iilSK","../structs/CounterpartyForwardingInfo.mjs":"aroHM","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iilSK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Features used within an `init` message.
 */ parcelHelpers.export(exports, "InitFeatures", ()=>InitFeatures
) //# sourceMappingURL=InitFeatures.mjs.map
;
var _resultInitFeaturesDecodeErrorZMjs = require("../structs/Result_InitFeaturesDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class InitFeatures extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.InitFeatures_free);
    }
    /**
     * Checks if two InitFeaturess contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */ eq(b) {
        const ret = _bindingsMjs.InitFeatures_eq(this.ptr, b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, b);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.InitFeatures_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the InitFeatures
     */ clone() {
        const ret = _bindingsMjs.InitFeatures_clone(this.ptr);
        const ret_hu_conv = new InitFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Create a blank Features with no features set
     */ static constructor_empty() {
        const ret = _bindingsMjs.InitFeatures_empty();
        const ret_hu_conv = new InitFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Creates a Features with the bits set which are known by the implementation
     */ static constructor_known() {
        const ret = _bindingsMjs.InitFeatures_known();
        const ret_hu_conv = new InitFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Returns true if this `Features` object contains unknown feature flags which are set as
     * \"required\".
     */ requires_unknown_bits() {
        const ret = _bindingsMjs.InitFeatures_requires_unknown_bits(this.ptr);
        return ret;
    }
    /**
     * Serialize the InitFeatures object into a byte array which can be read by InitFeatures_read
     */ write() {
        const ret = _bindingsMjs.InitFeatures_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a InitFeatures from a byte array, created by InitFeatures_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.InitFeatures_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultInitFeaturesDecodeErrorZMjs.Result_InitFeaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_InitFeaturesDecodeErrorZ.mjs":"eyRVn","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eyRVn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_InitFeaturesDecodeErrorZ", ()=>Result_InitFeaturesDecodeErrorZ
);
parcelHelpers.export(exports, "Result_InitFeaturesDecodeErrorZ_OK", ()=>Result_InitFeaturesDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_InitFeaturesDecodeErrorZ_Err", ()=>Result_InitFeaturesDecodeErrorZ_Err
) //# sourceMappingURL=Result_InitFeaturesDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _initFeaturesMjs = require("../structs/InitFeatures.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_InitFeaturesDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_InitFeaturesDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_InitFeaturesDecodeErrorZ_is_ok(ptr)) return new Result_InitFeaturesDecodeErrorZ_OK(null, ptr);
        else return new Result_InitFeaturesDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_InitFeaturesDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_InitFeaturesDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_InitFeaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_InitFeaturesDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_InitFeaturesDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_InitFeaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_InitFeaturesDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
}
class Result_InitFeaturesDecodeErrorZ_OK extends Result_InitFeaturesDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_InitFeaturesDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _initFeaturesMjs.InitFeatures(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_InitFeaturesDecodeErrorZ_Err extends Result_InitFeaturesDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_InitFeaturesDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/InitFeatures.mjs":"iilSK","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aroHM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Information needed for constructing an invoice route hint for this channel.
 */ parcelHelpers.export(exports, "CounterpartyForwardingInfo", ()=>CounterpartyForwardingInfo
) //# sourceMappingURL=CounterpartyForwardingInfo.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class CounterpartyForwardingInfo extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CounterpartyForwardingInfo_free);
    }
    /**
     * Base routing fee in millisatoshis.
     */ get_fee_base_msat() {
        const ret = _bindingsMjs.CounterpartyForwardingInfo_get_fee_base_msat(this.ptr);
        return ret;
    }
    /**
     * Base routing fee in millisatoshis.
     */ set_fee_base_msat(val) {
        _bindingsMjs.CounterpartyForwardingInfo_set_fee_base_msat(this.ptr, val);
    }
    /**
     * Amount in millionths of a satoshi the channel will charge per transferred satoshi.
     */ get_fee_proportional_millionths() {
        const ret = _bindingsMjs.CounterpartyForwardingInfo_get_fee_proportional_millionths(this.ptr);
        return ret;
    }
    /**
     * Amount in millionths of a satoshi the channel will charge per transferred satoshi.
     */ set_fee_proportional_millionths(val) {
        _bindingsMjs.CounterpartyForwardingInfo_set_fee_proportional_millionths(this.ptr, val);
    }
    /**
     * The minimum difference in cltv_expiry between an ingoing HTLC and its outgoing counterpart,
     * such that the outgoing HTLC is forwardable to this counterparty. See `msgs::ChannelUpdate`'s
     * `cltv_expiry_delta` for more details.
     */ get_cltv_expiry_delta() {
        const ret = _bindingsMjs.CounterpartyForwardingInfo_get_cltv_expiry_delta(this.ptr);
        return ret;
    }
    /**
     * The minimum difference in cltv_expiry between an ingoing HTLC and its outgoing counterpart,
     * such that the outgoing HTLC is forwardable to this counterparty. See `msgs::ChannelUpdate`'s
     * `cltv_expiry_delta` for more details.
     */ set_cltv_expiry_delta(val) {
        _bindingsMjs.CounterpartyForwardingInfo_set_cltv_expiry_delta(this.ptr, val);
    }
    /**
     * Constructs a new CounterpartyForwardingInfo given each field
     */ static constructor_new(fee_base_msat_arg, fee_proportional_millionths_arg, cltv_expiry_delta_arg) {
        const ret = _bindingsMjs.CounterpartyForwardingInfo_new(fee_base_msat_arg, fee_proportional_millionths_arg, cltv_expiry_delta_arg);
        const ret_hu_conv = new CounterpartyForwardingInfo(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CounterpartyForwardingInfo_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the CounterpartyForwardingInfo
     */ clone() {
        const ret = _bindingsMjs.CounterpartyForwardingInfo_clone(this.ptr);
        const ret_hu_conv = new CounterpartyForwardingInfo(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"TGHq7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An Err type for failure to process messages.
 */ parcelHelpers.export(exports, "LightningError", ()=>LightningError
) //# sourceMappingURL=LightningError.mjs.map
;
var _errorActionMjs = require("../structs/ErrorAction.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LightningError extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.LightningError_free);
    }
    /**
     * A human-readable message describing the error
     */ get_err() {
        const ret = _bindingsMjs.LightningError_get_err(this.ptr);
        const ret_conv = _bindingsMjs.decodeString(ret);
        return ret_conv;
    }
    /**
     * A human-readable message describing the error
     */ set_err(val) {
        _bindingsMjs.LightningError_set_err(this.ptr, _bindingsMjs.encodeString(val));
    }
    /**
     * The action which should be taken against the offending peer.
     */ get_action() {
        const ret = _bindingsMjs.LightningError_get_action(this.ptr);
        const ret_hu_conv = _errorActionMjs.ErrorAction.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The action which should be taken against the offending peer.
     */ set_action(val) {
        _bindingsMjs.LightningError_set_action(this.ptr, _commonBaseMjsDefault.default.get_ptr_of(val));
    }
    /**
     * Constructs a new LightningError given each field
     */ static constructor_new(err_arg, action_arg) {
        const ret = _bindingsMjs.LightningError_new(_bindingsMjs.encodeString(err_arg), _commonBaseMjsDefault.default.get_ptr_of(action_arg));
        const ret_hu_conv = new LightningError(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.LightningError_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the LightningError
     */ clone() {
        const ret = _bindingsMjs.LightningError_clone(this.ptr);
        const ret_hu_conv = new LightningError(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"../structs/ErrorAction.mjs":"fezfr","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fezfr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Used to put an error message in a LightningError
 */ parcelHelpers.export(exports, "ErrorAction", ()=>ErrorAction
);
/** A ErrorAction of type DisconnectPeer */ parcelHelpers.export(exports, "ErrorAction_DisconnectPeer", ()=>ErrorAction_DisconnectPeer
);
/** A ErrorAction of type IgnoreError */ parcelHelpers.export(exports, "ErrorAction_IgnoreError", ()=>ErrorAction_IgnoreError
);
/** A ErrorAction of type IgnoreAndLog */ parcelHelpers.export(exports, "ErrorAction_IgnoreAndLog", ()=>ErrorAction_IgnoreAndLog
);
/** A ErrorAction of type IgnoreDuplicateGossip */ parcelHelpers.export(exports, "ErrorAction_IgnoreDuplicateGossip", ()=>ErrorAction_IgnoreDuplicateGossip
);
/** A ErrorAction of type SendErrorMessage */ parcelHelpers.export(exports, "ErrorAction_SendErrorMessage", ()=>ErrorAction_SendErrorMessage
) //# sourceMappingURL=ErrorAction.mjs.map
;
var _errorMessageMjs = require("../structs/ErrorMessage.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ErrorAction extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ErrorAction_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKErrorAction_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new ErrorAction_DisconnectPeer(ptr);
            case 1:
                return new ErrorAction_IgnoreError(ptr);
            case 2:
                return new ErrorAction_IgnoreAndLog(ptr);
            case 3:
                return new ErrorAction_IgnoreDuplicateGossip(ptr);
            case 4:
                return new ErrorAction_SendErrorMessage(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = _bindingsMjs.ErrorAction_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ErrorAction
     */ clone() {
        const ret = _bindingsMjs.ErrorAction_clone(this.ptr);
        const ret_hu_conv = ErrorAction.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new DisconnectPeer-variant ErrorAction
     */ static constructor_disconnect_peer(msg) {
        const ret = _bindingsMjs.ErrorAction_disconnect_peer(msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = ErrorAction.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new IgnoreError-variant ErrorAction
     */ static constructor_ignore_error() {
        const ret = _bindingsMjs.ErrorAction_ignore_error();
        const ret_hu_conv = ErrorAction.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new IgnoreAndLog-variant ErrorAction
     */ static constructor_ignore_and_log(a) {
        const ret = _bindingsMjs.ErrorAction_ignore_and_log(a);
        const ret_hu_conv = ErrorAction.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new IgnoreDuplicateGossip-variant ErrorAction
     */ static constructor_ignore_duplicate_gossip() {
        const ret = _bindingsMjs.ErrorAction_ignore_duplicate_gossip();
        const ret_hu_conv = ErrorAction.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SendErrorMessage-variant ErrorAction
     */ static constructor_send_error_message(msg) {
        const ret = _bindingsMjs.ErrorAction_send_error_message(msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = ErrorAction.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}
class ErrorAction_DisconnectPeer extends ErrorAction {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const msg = _bindingsMjs.LDKErrorAction_DisconnectPeer_get_msg(ptr);
        const msg_hu_conv = new _errorMessageMjs.ErrorMessage(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class ErrorAction_IgnoreError extends ErrorAction {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}
class ErrorAction_IgnoreAndLog extends ErrorAction {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        this.ignore_and_log = _bindingsMjs.LDKErrorAction_IgnoreAndLog_get_ignore_and_log(ptr);
    }
}
class ErrorAction_IgnoreDuplicateGossip extends ErrorAction {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}
class ErrorAction_SendErrorMessage extends ErrorAction {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const msg = _bindingsMjs.LDKErrorAction_SendErrorMessage_get_msg(ptr);
        const msg_hu_conv = new _errorMessageMjs.ErrorMessage(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}

},{"../structs/ErrorMessage.mjs":"9WeY0","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9WeY0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An error message to be sent or received from a peer
 */ parcelHelpers.export(exports, "ErrorMessage", ()=>ErrorMessage
) //# sourceMappingURL=ErrorMessage.mjs.map
;
var _resultErrorMessageDecodeErrorZMjs = require("../structs/Result_ErrorMessageDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ErrorMessage extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ErrorMessage_free);
    }
    /**
     * The channel ID involved in the error
     */ get_channel_id() {
        const ret = _bindingsMjs.ErrorMessage_get_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The channel ID involved in the error
     */ set_channel_id(val) {
        _bindingsMjs.ErrorMessage_set_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * A possibly human-readable error description.
     * The string should be sanitized before it is used (e.g. emitted to logs
     * or printed to stdout).  Otherwise, a well crafted error message may trigger a security
     * vulnerability in the terminal emulator or the logging subsystem.
     */ get_data() {
        const ret = _bindingsMjs.ErrorMessage_get_data(this.ptr);
        const ret_conv = _bindingsMjs.decodeString(ret);
        return ret_conv;
    }
    /**
     * A possibly human-readable error description.
     * The string should be sanitized before it is used (e.g. emitted to logs
     * or printed to stdout).  Otherwise, a well crafted error message may trigger a security
     * vulnerability in the terminal emulator or the logging subsystem.
     */ set_data(val) {
        _bindingsMjs.ErrorMessage_set_data(this.ptr, _bindingsMjs.encodeString(val));
    }
    /**
     * Constructs a new ErrorMessage given each field
     */ static constructor_new(channel_id_arg, data_arg) {
        const ret = _bindingsMjs.ErrorMessage_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_id_arg, 32)), _bindingsMjs.encodeString(data_arg));
        const ret_hu_conv = new ErrorMessage(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ErrorMessage_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ErrorMessage
     */ clone() {
        const ret = _bindingsMjs.ErrorMessage_clone(this.ptr);
        const ret_hu_conv = new ErrorMessage(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the ErrorMessage object into a byte array which can be read by ErrorMessage_read
     */ write() {
        const ret = _bindingsMjs.ErrorMessage_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ErrorMessage from a byte array, created by ErrorMessage_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ErrorMessage_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultErrorMessageDecodeErrorZMjs.Result_ErrorMessageDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_ErrorMessageDecodeErrorZ.mjs":"6l86i","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6l86i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ErrorMessageDecodeErrorZ", ()=>Result_ErrorMessageDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ErrorMessageDecodeErrorZ_OK", ()=>Result_ErrorMessageDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ErrorMessageDecodeErrorZ_Err", ()=>Result_ErrorMessageDecodeErrorZ_Err
) //# sourceMappingURL=Result_ErrorMessageDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _errorMessageMjs = require("../structs/ErrorMessage.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ErrorMessageDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ErrorMessageDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ErrorMessageDecodeErrorZ_is_ok(ptr)) return new Result_ErrorMessageDecodeErrorZ_OK(null, ptr);
        else return new Result_ErrorMessageDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ErrorMessageDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ErrorMessageDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ErrorMessageDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ErrorMessageDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ErrorMessageDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ErrorMessageDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ErrorMessageDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_ErrorMessageDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_ErrorMessageDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_ErrorMessageDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_ErrorMessageDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_ErrorMessageDecodeErrorZ_OK extends Result_ErrorMessageDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ErrorMessageDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _errorMessageMjs.ErrorMessage(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ErrorMessageDecodeErrorZ_Err extends Result_ErrorMessageDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ErrorMessageDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/ErrorMessage.mjs":"9WeY0","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fWmwa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_RouteLightningErrorZ", ()=>Result_RouteLightningErrorZ
);
parcelHelpers.export(exports, "Result_RouteLightningErrorZ_OK", ()=>Result_RouteLightningErrorZ_OK
);
parcelHelpers.export(exports, "Result_RouteLightningErrorZ_Err", ()=>Result_RouteLightningErrorZ_Err
) //# sourceMappingURL=Result_RouteLightningErrorZ.mjs.map
;
var _routeMjs = require("../structs/Route.mjs");
var _lightningErrorMjs = require("../structs/LightningError.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_RouteLightningErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_RouteLightningErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_RouteLightningErrorZ_is_ok(ptr)) return new Result_RouteLightningErrorZ_OK(null, ptr);
        else return new Result_RouteLightningErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_RouteLightningErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_RouteLightningErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_RouteLightningErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_RouteLightningErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_RouteLightningErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_RouteLightningErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_RouteLightningErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_RouteLightningErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_RouteLightningErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_RouteLightningErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_RouteLightningErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_RouteLightningErrorZ_OK extends Result_RouteLightningErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_RouteLightningErrorZ_get_ok(ptr);
        const res_hu_conv = new _routeMjs.Route(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_RouteLightningErrorZ_Err extends Result_RouteLightningErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_RouteLightningErrorZ_get_err(ptr);
        const err_hu_conv = new _lightningErrorMjs.LightningError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/Route.mjs":"eZydB","../structs/LightningError.mjs":"TGHq7","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"TA9p3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_NoneLightningErrorZ", ()=>Result_NoneLightningErrorZ
);
parcelHelpers.export(exports, "Result_NoneLightningErrorZ_OK", ()=>Result_NoneLightningErrorZ_OK
);
parcelHelpers.export(exports, "Result_NoneLightningErrorZ_Err", ()=>Result_NoneLightningErrorZ_Err
) //# sourceMappingURL=Result_NoneLightningErrorZ.mjs.map
;
var _lightningErrorMjs = require("../structs/LightningError.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_NoneLightningErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_NoneLightningErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_NoneLightningErrorZ_is_ok(ptr)) return new Result_NoneLightningErrorZ_OK(null, ptr);
        else return new Result_NoneLightningErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_NoneLightningErrorZ in the success state.
     */ static constructor_ok() {
        const ret = _bindingsMjs.CResult_NoneLightningErrorZ_ok();
        const ret_hu_conv = Result_NoneLightningErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_NoneLightningErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_NoneLightningErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_NoneLightningErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_NoneLightningErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_NoneLightningErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_NoneLightningErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_NoneLightningErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_NoneLightningErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_NoneLightningErrorZ_OK extends Result_NoneLightningErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}
class Result_NoneLightningErrorZ_Err extends Result_NoneLightningErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_NoneLightningErrorZ_get_err(ptr);
        const err_hu_conv = new _lightningErrorMjs.LightningError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/LightningError.mjs":"TGHq7","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cA97j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Tuple
 */ parcelHelpers.export(exports, "TwoTuple_PublicKeyTypeZ", ()=>TwoTuple_PublicKeyTypeZ
) //# sourceMappingURL=TwoTuple_PublicKeyTypeZ.mjs.map
;
var _typeMjs = require("../structs/Type.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class TwoTuple_PublicKeyTypeZ extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.C2Tuple_PublicKeyTypeZ_free);
    }
    /**
     *
     */ get_a() {
        const ret = _bindingsMjs.C2Tuple_PublicKeyTypeZ_get_a(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     *
     */ get_b() {
        const ret = _bindingsMjs.C2Tuple_PublicKeyTypeZ_get_b(this.ptr);
        const ret_hu_conv = new _typeMjs.Type(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.C2Tuple_PublicKeyTypeZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new tuple which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.C2Tuple_PublicKeyTypeZ_clone(this.ptr);
        const ret_hu_conv = new TwoTuple_PublicKeyTypeZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a new C2Tuple_PublicKeyTypeZ from the contained elements.
     */ static constructor_new(a, b) {
        const ret = _bindingsMjs.C2Tuple_PublicKeyTypeZ_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(a, 33)), b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b));
        const ret_hu_conv = new TwoTuple_PublicKeyTypeZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, b);
        return ret_hu_conv;
    }
}

},{"../structs/Type.mjs":"co77s","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7niKR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An accept_channel message to be sent or received from a peer
 */ parcelHelpers.export(exports, "AcceptChannel", ()=>AcceptChannel
) //# sourceMappingURL=AcceptChannel.mjs.map
;
var _resultAcceptChannelDecodeErrorZMjs = require("../structs/Result_AcceptChannelDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class AcceptChannel extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.AcceptChannel_free);
    }
    /**
     * A temporary channel ID, until the funding outpoint is announced
     */ get_temporary_channel_id() {
        const ret = _bindingsMjs.AcceptChannel_get_temporary_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * A temporary channel ID, until the funding outpoint is announced
     */ set_temporary_channel_id(val) {
        _bindingsMjs.AcceptChannel_set_temporary_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The threshold below which outputs on transactions broadcast by sender will be omitted
     */ get_dust_limit_satoshis() {
        const ret = _bindingsMjs.AcceptChannel_get_dust_limit_satoshis(this.ptr);
        return ret;
    }
    /**
     * The threshold below which outputs on transactions broadcast by sender will be omitted
     */ set_dust_limit_satoshis(val) {
        _bindingsMjs.AcceptChannel_set_dust_limit_satoshis(this.ptr, val);
    }
    /**
     * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
     */ get_max_htlc_value_in_flight_msat() {
        const ret = _bindingsMjs.AcceptChannel_get_max_htlc_value_in_flight_msat(this.ptr);
        return ret;
    }
    /**
     * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
     */ set_max_htlc_value_in_flight_msat(val) {
        _bindingsMjs.AcceptChannel_set_max_htlc_value_in_flight_msat(this.ptr, val);
    }
    /**
     * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
     */ get_channel_reserve_satoshis() {
        const ret = _bindingsMjs.AcceptChannel_get_channel_reserve_satoshis(this.ptr);
        return ret;
    }
    /**
     * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
     */ set_channel_reserve_satoshis(val) {
        _bindingsMjs.AcceptChannel_set_channel_reserve_satoshis(this.ptr, val);
    }
    /**
     * The minimum HTLC size incoming to sender, in milli-satoshi
     */ get_htlc_minimum_msat() {
        const ret = _bindingsMjs.AcceptChannel_get_htlc_minimum_msat(this.ptr);
        return ret;
    }
    /**
     * The minimum HTLC size incoming to sender, in milli-satoshi
     */ set_htlc_minimum_msat(val) {
        _bindingsMjs.AcceptChannel_set_htlc_minimum_msat(this.ptr, val);
    }
    /**
     * Minimum depth of the funding transaction before the channel is considered open
     */ get_minimum_depth() {
        const ret = _bindingsMjs.AcceptChannel_get_minimum_depth(this.ptr);
        return ret;
    }
    /**
     * Minimum depth of the funding transaction before the channel is considered open
     */ set_minimum_depth(val) {
        _bindingsMjs.AcceptChannel_set_minimum_depth(this.ptr, val);
    }
    /**
     * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
     */ get_to_self_delay() {
        const ret = _bindingsMjs.AcceptChannel_get_to_self_delay(this.ptr);
        return ret;
    }
    /**
     * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
     */ set_to_self_delay(val) {
        _bindingsMjs.AcceptChannel_set_to_self_delay(this.ptr, val);
    }
    /**
     * The maximum number of inbound HTLCs towards sender
     */ get_max_accepted_htlcs() {
        const ret = _bindingsMjs.AcceptChannel_get_max_accepted_htlcs(this.ptr);
        return ret;
    }
    /**
     * The maximum number of inbound HTLCs towards sender
     */ set_max_accepted_htlcs(val) {
        _bindingsMjs.AcceptChannel_set_max_accepted_htlcs(this.ptr, val);
    }
    /**
     * The sender's key controlling the funding transaction
     */ get_funding_pubkey() {
        const ret = _bindingsMjs.AcceptChannel_get_funding_pubkey(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The sender's key controlling the funding transaction
     */ set_funding_pubkey(val) {
        _bindingsMjs.AcceptChannel_set_funding_pubkey(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Used to derive a revocation key for transactions broadcast by counterparty
     */ get_revocation_basepoint() {
        const ret = _bindingsMjs.AcceptChannel_get_revocation_basepoint(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Used to derive a revocation key for transactions broadcast by counterparty
     */ set_revocation_basepoint(val) {
        _bindingsMjs.AcceptChannel_set_revocation_basepoint(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * A payment key to sender for transactions broadcast by counterparty
     */ get_payment_point() {
        const ret = _bindingsMjs.AcceptChannel_get_payment_point(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * A payment key to sender for transactions broadcast by counterparty
     */ set_payment_point(val) {
        _bindingsMjs.AcceptChannel_set_payment_point(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Used to derive a payment key to sender for transactions broadcast by sender
     */ get_delayed_payment_basepoint() {
        const ret = _bindingsMjs.AcceptChannel_get_delayed_payment_basepoint(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Used to derive a payment key to sender for transactions broadcast by sender
     */ set_delayed_payment_basepoint(val) {
        _bindingsMjs.AcceptChannel_set_delayed_payment_basepoint(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Used to derive an HTLC payment key to sender for transactions broadcast by counterparty
     */ get_htlc_basepoint() {
        const ret = _bindingsMjs.AcceptChannel_get_htlc_basepoint(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Used to derive an HTLC payment key to sender for transactions broadcast by counterparty
     */ set_htlc_basepoint(val) {
        _bindingsMjs.AcceptChannel_set_htlc_basepoint(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * The first to-be-broadcast-by-sender transaction's per commitment point
     */ get_first_per_commitment_point() {
        const ret = _bindingsMjs.AcceptChannel_get_first_per_commitment_point(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The first to-be-broadcast-by-sender transaction's per commitment point
     */ set_first_per_commitment_point(val) {
        _bindingsMjs.AcceptChannel_set_first_per_commitment_point(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    clone_ptr() {
        const ret = _bindingsMjs.AcceptChannel_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the AcceptChannel
     */ clone() {
        const ret = _bindingsMjs.AcceptChannel_clone(this.ptr);
        const ret_hu_conv = new AcceptChannel(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the AcceptChannel object into a byte array which can be read by AcceptChannel_read
     */ write() {
        const ret = _bindingsMjs.AcceptChannel_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a AcceptChannel from a byte array, created by AcceptChannel_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.AcceptChannel_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultAcceptChannelDecodeErrorZMjs.Result_AcceptChannelDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_AcceptChannelDecodeErrorZ.mjs":"jqWMH","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jqWMH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_AcceptChannelDecodeErrorZ", ()=>Result_AcceptChannelDecodeErrorZ
);
parcelHelpers.export(exports, "Result_AcceptChannelDecodeErrorZ_OK", ()=>Result_AcceptChannelDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_AcceptChannelDecodeErrorZ_Err", ()=>Result_AcceptChannelDecodeErrorZ_Err
) //# sourceMappingURL=Result_AcceptChannelDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _acceptChannelMjs = require("../structs/AcceptChannel.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_AcceptChannelDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_AcceptChannelDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_AcceptChannelDecodeErrorZ_is_ok(ptr)) return new Result_AcceptChannelDecodeErrorZ_OK(null, ptr);
        else return new Result_AcceptChannelDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_AcceptChannelDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_AcceptChannelDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_AcceptChannelDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_AcceptChannelDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_AcceptChannelDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_AcceptChannelDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_AcceptChannelDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_AcceptChannelDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_AcceptChannelDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_AcceptChannelDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_AcceptChannelDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_AcceptChannelDecodeErrorZ_OK extends Result_AcceptChannelDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_AcceptChannelDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _acceptChannelMjs.AcceptChannel(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_AcceptChannelDecodeErrorZ_Err extends Result_AcceptChannelDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_AcceptChannelDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/AcceptChannel.mjs":"7niKR","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"36LuB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An open_channel message to be sent or received from a peer
 */ parcelHelpers.export(exports, "OpenChannel", ()=>OpenChannel
) //# sourceMappingURL=OpenChannel.mjs.map
;
var _channelTypeFeaturesMjs = require("../structs/ChannelTypeFeatures.mjs");
var _resultOpenChannelDecodeErrorZMjs = require("../structs/Result_OpenChannelDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class OpenChannel extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.OpenChannel_free);
    }
    /**
     * The genesis hash of the blockchain where the channel is to be opened
     */ get_chain_hash() {
        const ret = _bindingsMjs.OpenChannel_get_chain_hash(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The genesis hash of the blockchain where the channel is to be opened
     */ set_chain_hash(val) {
        _bindingsMjs.OpenChannel_set_chain_hash(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * A temporary channel ID, until the funding outpoint is announced
     */ get_temporary_channel_id() {
        const ret = _bindingsMjs.OpenChannel_get_temporary_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * A temporary channel ID, until the funding outpoint is announced
     */ set_temporary_channel_id(val) {
        _bindingsMjs.OpenChannel_set_temporary_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The channel value
     */ get_funding_satoshis() {
        const ret = _bindingsMjs.OpenChannel_get_funding_satoshis(this.ptr);
        return ret;
    }
    /**
     * The channel value
     */ set_funding_satoshis(val) {
        _bindingsMjs.OpenChannel_set_funding_satoshis(this.ptr, val);
    }
    /**
     * The amount to push to the counterparty as part of the open, in milli-satoshi
     */ get_push_msat() {
        const ret = _bindingsMjs.OpenChannel_get_push_msat(this.ptr);
        return ret;
    }
    /**
     * The amount to push to the counterparty as part of the open, in milli-satoshi
     */ set_push_msat(val) {
        _bindingsMjs.OpenChannel_set_push_msat(this.ptr, val);
    }
    /**
     * The threshold below which outputs on transactions broadcast by sender will be omitted
     */ get_dust_limit_satoshis() {
        const ret = _bindingsMjs.OpenChannel_get_dust_limit_satoshis(this.ptr);
        return ret;
    }
    /**
     * The threshold below which outputs on transactions broadcast by sender will be omitted
     */ set_dust_limit_satoshis(val) {
        _bindingsMjs.OpenChannel_set_dust_limit_satoshis(this.ptr, val);
    }
    /**
     * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
     */ get_max_htlc_value_in_flight_msat() {
        const ret = _bindingsMjs.OpenChannel_get_max_htlc_value_in_flight_msat(this.ptr);
        return ret;
    }
    /**
     * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
     */ set_max_htlc_value_in_flight_msat(val) {
        _bindingsMjs.OpenChannel_set_max_htlc_value_in_flight_msat(this.ptr, val);
    }
    /**
     * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
     */ get_channel_reserve_satoshis() {
        const ret = _bindingsMjs.OpenChannel_get_channel_reserve_satoshis(this.ptr);
        return ret;
    }
    /**
     * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
     */ set_channel_reserve_satoshis(val) {
        _bindingsMjs.OpenChannel_set_channel_reserve_satoshis(this.ptr, val);
    }
    /**
     * The minimum HTLC size incoming to sender, in milli-satoshi
     */ get_htlc_minimum_msat() {
        const ret = _bindingsMjs.OpenChannel_get_htlc_minimum_msat(this.ptr);
        return ret;
    }
    /**
     * The minimum HTLC size incoming to sender, in milli-satoshi
     */ set_htlc_minimum_msat(val) {
        _bindingsMjs.OpenChannel_set_htlc_minimum_msat(this.ptr, val);
    }
    /**
     * The feerate per 1000-weight of sender generated transactions, until updated by update_fee
     */ get_feerate_per_kw() {
        const ret = _bindingsMjs.OpenChannel_get_feerate_per_kw(this.ptr);
        return ret;
    }
    /**
     * The feerate per 1000-weight of sender generated transactions, until updated by update_fee
     */ set_feerate_per_kw(val) {
        _bindingsMjs.OpenChannel_set_feerate_per_kw(this.ptr, val);
    }
    /**
     * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
     */ get_to_self_delay() {
        const ret = _bindingsMjs.OpenChannel_get_to_self_delay(this.ptr);
        return ret;
    }
    /**
     * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
     */ set_to_self_delay(val) {
        _bindingsMjs.OpenChannel_set_to_self_delay(this.ptr, val);
    }
    /**
     * The maximum number of inbound HTLCs towards sender
     */ get_max_accepted_htlcs() {
        const ret = _bindingsMjs.OpenChannel_get_max_accepted_htlcs(this.ptr);
        return ret;
    }
    /**
     * The maximum number of inbound HTLCs towards sender
     */ set_max_accepted_htlcs(val) {
        _bindingsMjs.OpenChannel_set_max_accepted_htlcs(this.ptr, val);
    }
    /**
     * The sender's key controlling the funding transaction
     */ get_funding_pubkey() {
        const ret = _bindingsMjs.OpenChannel_get_funding_pubkey(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The sender's key controlling the funding transaction
     */ set_funding_pubkey(val) {
        _bindingsMjs.OpenChannel_set_funding_pubkey(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Used to derive a revocation key for transactions broadcast by counterparty
     */ get_revocation_basepoint() {
        const ret = _bindingsMjs.OpenChannel_get_revocation_basepoint(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Used to derive a revocation key for transactions broadcast by counterparty
     */ set_revocation_basepoint(val) {
        _bindingsMjs.OpenChannel_set_revocation_basepoint(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * A payment key to sender for transactions broadcast by counterparty
     */ get_payment_point() {
        const ret = _bindingsMjs.OpenChannel_get_payment_point(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * A payment key to sender for transactions broadcast by counterparty
     */ set_payment_point(val) {
        _bindingsMjs.OpenChannel_set_payment_point(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Used to derive a payment key to sender for transactions broadcast by sender
     */ get_delayed_payment_basepoint() {
        const ret = _bindingsMjs.OpenChannel_get_delayed_payment_basepoint(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Used to derive a payment key to sender for transactions broadcast by sender
     */ set_delayed_payment_basepoint(val) {
        _bindingsMjs.OpenChannel_set_delayed_payment_basepoint(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Used to derive an HTLC payment key to sender
     */ get_htlc_basepoint() {
        const ret = _bindingsMjs.OpenChannel_get_htlc_basepoint(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Used to derive an HTLC payment key to sender
     */ set_htlc_basepoint(val) {
        _bindingsMjs.OpenChannel_set_htlc_basepoint(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * The first to-be-broadcast-by-sender transaction's per commitment point
     */ get_first_per_commitment_point() {
        const ret = _bindingsMjs.OpenChannel_get_first_per_commitment_point(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The first to-be-broadcast-by-sender transaction's per commitment point
     */ set_first_per_commitment_point(val) {
        _bindingsMjs.OpenChannel_set_first_per_commitment_point(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Channel flags
     */ get_channel_flags() {
        const ret = _bindingsMjs.OpenChannel_get_channel_flags(this.ptr);
        return ret;
    }
    /**
     * Channel flags
     */ set_channel_flags(val) {
        _bindingsMjs.OpenChannel_set_channel_flags(this.ptr, val);
    }
    /**
     * The channel type that this channel will represent. If none is set, we derive the channel
     * type from the intersection of our feature bits with our counterparty's feature bits from
     * the Init message.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_channel_type() {
        const ret = _bindingsMjs.OpenChannel_get_channel_type(this.ptr);
        const ret_hu_conv = new _channelTypeFeaturesMjs.ChannelTypeFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The channel type that this channel will represent. If none is set, we derive the channel
     * type from the intersection of our feature bits with our counterparty's feature bits from
     * the Init message.
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_channel_type(val) {
        _bindingsMjs.OpenChannel_set_channel_type(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    clone_ptr() {
        const ret = _bindingsMjs.OpenChannel_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the OpenChannel
     */ clone() {
        const ret = _bindingsMjs.OpenChannel_clone(this.ptr);
        const ret_hu_conv = new OpenChannel(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the OpenChannel object into a byte array which can be read by OpenChannel_read
     */ write() {
        const ret = _bindingsMjs.OpenChannel_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a OpenChannel from a byte array, created by OpenChannel_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.OpenChannel_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultOpenChannelDecodeErrorZMjs.Result_OpenChannelDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/ChannelTypeFeatures.mjs":"7Mxrh","../structs/Result_OpenChannelDecodeErrorZ.mjs":"9EnEs","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Mxrh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Features used within the channel_type field in an OpenChannel message.
 *
 * A channel is always of some known \"type\", describing the transaction formats used and the exact
 * semantics of our interaction with our peer.
 *
 * Note that because a channel is a specific type which is proposed by the opener and accepted by
 * the counterparty, only required features are allowed here.
 *
 * This is serialized differently from other feature types - it is not prefixed by a length, and
 * thus must only appear inside a TLV where its length is known in advance.
 */ parcelHelpers.export(exports, "ChannelTypeFeatures", ()=>ChannelTypeFeatures
) //# sourceMappingURL=ChannelTypeFeatures.mjs.map
;
var _resultChannelTypeFeaturesDecodeErrorZMjs = require("../structs/Result_ChannelTypeFeaturesDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelTypeFeatures extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelTypeFeatures_free);
    }
    /**
     * Checks if two ChannelTypeFeaturess contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */ eq(b) {
        const ret = _bindingsMjs.ChannelTypeFeatures_eq(this.ptr, b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, b);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ChannelTypeFeatures_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelTypeFeatures
     */ clone() {
        const ret = _bindingsMjs.ChannelTypeFeatures_clone(this.ptr);
        const ret_hu_conv = new ChannelTypeFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Create a blank Features with no features set
     */ static constructor_empty() {
        const ret = _bindingsMjs.ChannelTypeFeatures_empty();
        const ret_hu_conv = new ChannelTypeFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Creates a Features with the bits set which are known by the implementation
     */ static constructor_known() {
        const ret = _bindingsMjs.ChannelTypeFeatures_known();
        const ret_hu_conv = new ChannelTypeFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Returns true if this `Features` object contains unknown feature flags which are set as
     * \"required\".
     */ requires_unknown_bits() {
        const ret = _bindingsMjs.ChannelTypeFeatures_requires_unknown_bits(this.ptr);
        return ret;
    }
    /**
     * Serialize the ChannelTypeFeatures object into a byte array which can be read by ChannelTypeFeatures_read
     */ write() {
        const ret = _bindingsMjs.ChannelTypeFeatures_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ChannelTypeFeatures from a byte array, created by ChannelTypeFeatures_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ChannelTypeFeatures_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultChannelTypeFeaturesDecodeErrorZMjs.Result_ChannelTypeFeaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_ChannelTypeFeaturesDecodeErrorZ.mjs":"5tfos","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5tfos":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ChannelTypeFeaturesDecodeErrorZ", ()=>Result_ChannelTypeFeaturesDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ChannelTypeFeaturesDecodeErrorZ_OK", ()=>Result_ChannelTypeFeaturesDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ChannelTypeFeaturesDecodeErrorZ_Err", ()=>Result_ChannelTypeFeaturesDecodeErrorZ_Err
) //# sourceMappingURL=Result_ChannelTypeFeaturesDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _channelTypeFeaturesMjs = require("../structs/ChannelTypeFeatures.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ChannelTypeFeaturesDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ChannelTypeFeaturesDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(ptr)) return new Result_ChannelTypeFeaturesDecodeErrorZ_OK(null, ptr);
        else return new Result_ChannelTypeFeaturesDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ChannelTypeFeaturesDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ChannelTypeFeaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ChannelTypeFeaturesDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ChannelTypeFeaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
}
class Result_ChannelTypeFeaturesDecodeErrorZ_OK extends Result_ChannelTypeFeaturesDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ChannelTypeFeaturesDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _channelTypeFeaturesMjs.ChannelTypeFeatures(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ChannelTypeFeaturesDecodeErrorZ_Err extends Result_ChannelTypeFeaturesDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ChannelTypeFeaturesDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/ChannelTypeFeatures.mjs":"7Mxrh","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9EnEs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_OpenChannelDecodeErrorZ", ()=>Result_OpenChannelDecodeErrorZ
);
parcelHelpers.export(exports, "Result_OpenChannelDecodeErrorZ_OK", ()=>Result_OpenChannelDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_OpenChannelDecodeErrorZ_Err", ()=>Result_OpenChannelDecodeErrorZ_Err
) //# sourceMappingURL=Result_OpenChannelDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _openChannelMjs = require("../structs/OpenChannel.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_OpenChannelDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_OpenChannelDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_OpenChannelDecodeErrorZ_is_ok(ptr)) return new Result_OpenChannelDecodeErrorZ_OK(null, ptr);
        else return new Result_OpenChannelDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_OpenChannelDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_OpenChannelDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_OpenChannelDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_OpenChannelDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_OpenChannelDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_OpenChannelDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_OpenChannelDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_OpenChannelDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_OpenChannelDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_OpenChannelDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_OpenChannelDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_OpenChannelDecodeErrorZ_OK extends Result_OpenChannelDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_OpenChannelDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _openChannelMjs.OpenChannel(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_OpenChannelDecodeErrorZ_Err extends Result_OpenChannelDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_OpenChannelDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/OpenChannel.mjs":"36LuB","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5WOqU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A funding_created message to be sent or received from a peer
 */ parcelHelpers.export(exports, "FundingCreated", ()=>FundingCreated
) //# sourceMappingURL=FundingCreated.mjs.map
;
var _resultFundingCreatedDecodeErrorZMjs = require("../structs/Result_FundingCreatedDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class FundingCreated extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.FundingCreated_free);
    }
    /**
     * A temporary channel ID, until the funding is established
     */ get_temporary_channel_id() {
        const ret = _bindingsMjs.FundingCreated_get_temporary_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * A temporary channel ID, until the funding is established
     */ set_temporary_channel_id(val) {
        _bindingsMjs.FundingCreated_set_temporary_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The funding transaction ID
     */ get_funding_txid() {
        const ret = _bindingsMjs.FundingCreated_get_funding_txid(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The funding transaction ID
     */ set_funding_txid(val) {
        _bindingsMjs.FundingCreated_set_funding_txid(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The specific output index funding this channel
     */ get_funding_output_index() {
        const ret = _bindingsMjs.FundingCreated_get_funding_output_index(this.ptr);
        return ret;
    }
    /**
     * The specific output index funding this channel
     */ set_funding_output_index(val) {
        _bindingsMjs.FundingCreated_set_funding_output_index(this.ptr, val);
    }
    /**
     * The signature of the channel initiator (funder) on the initial commitment transaction
     */ get_signature() {
        const ret = _bindingsMjs.FundingCreated_get_signature(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The signature of the channel initiator (funder) on the initial commitment transaction
     */ set_signature(val) {
        _bindingsMjs.FundingCreated_set_signature(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 64)));
    }
    /**
     * Constructs a new FundingCreated given each field
     */ static constructor_new(temporary_channel_id_arg, funding_txid_arg, funding_output_index_arg, signature_arg) {
        const ret = _bindingsMjs.FundingCreated_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(temporary_channel_id_arg, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(funding_txid_arg, 32)), funding_output_index_arg, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(signature_arg, 64)));
        const ret_hu_conv = new FundingCreated(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.FundingCreated_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the FundingCreated
     */ clone() {
        const ret = _bindingsMjs.FundingCreated_clone(this.ptr);
        const ret_hu_conv = new FundingCreated(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the FundingCreated object into a byte array which can be read by FundingCreated_read
     */ write() {
        const ret = _bindingsMjs.FundingCreated_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a FundingCreated from a byte array, created by FundingCreated_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.FundingCreated_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultFundingCreatedDecodeErrorZMjs.Result_FundingCreatedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_FundingCreatedDecodeErrorZ.mjs":"fpj9X","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fpj9X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_FundingCreatedDecodeErrorZ", ()=>Result_FundingCreatedDecodeErrorZ
);
parcelHelpers.export(exports, "Result_FundingCreatedDecodeErrorZ_OK", ()=>Result_FundingCreatedDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_FundingCreatedDecodeErrorZ_Err", ()=>Result_FundingCreatedDecodeErrorZ_Err
) //# sourceMappingURL=Result_FundingCreatedDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _fundingCreatedMjs = require("../structs/FundingCreated.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_FundingCreatedDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_FundingCreatedDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_FundingCreatedDecodeErrorZ_is_ok(ptr)) return new Result_FundingCreatedDecodeErrorZ_OK(null, ptr);
        else return new Result_FundingCreatedDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_FundingCreatedDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_FundingCreatedDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_FundingCreatedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_FundingCreatedDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_FundingCreatedDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_FundingCreatedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_FundingCreatedDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_FundingCreatedDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_FundingCreatedDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_FundingCreatedDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_FundingCreatedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_FundingCreatedDecodeErrorZ_OK extends Result_FundingCreatedDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_FundingCreatedDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _fundingCreatedMjs.FundingCreated(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_FundingCreatedDecodeErrorZ_Err extends Result_FundingCreatedDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_FundingCreatedDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/FundingCreated.mjs":"5WOqU","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jlNPc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A funding_signed message to be sent or received from a peer
 */ parcelHelpers.export(exports, "FundingSigned", ()=>FundingSigned
) //# sourceMappingURL=FundingSigned.mjs.map
;
var _resultFundingSignedDecodeErrorZMjs = require("../structs/Result_FundingSignedDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class FundingSigned extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.FundingSigned_free);
    }
    /**
     * The channel ID
     */ get_channel_id() {
        const ret = _bindingsMjs.FundingSigned_get_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The channel ID
     */ set_channel_id(val) {
        _bindingsMjs.FundingSigned_set_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The signature of the channel acceptor (fundee) on the initial commitment transaction
     */ get_signature() {
        const ret = _bindingsMjs.FundingSigned_get_signature(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The signature of the channel acceptor (fundee) on the initial commitment transaction
     */ set_signature(val) {
        _bindingsMjs.FundingSigned_set_signature(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 64)));
    }
    /**
     * Constructs a new FundingSigned given each field
     */ static constructor_new(channel_id_arg, signature_arg) {
        const ret = _bindingsMjs.FundingSigned_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_id_arg, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(signature_arg, 64)));
        const ret_hu_conv = new FundingSigned(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.FundingSigned_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the FundingSigned
     */ clone() {
        const ret = _bindingsMjs.FundingSigned_clone(this.ptr);
        const ret_hu_conv = new FundingSigned(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the FundingSigned object into a byte array which can be read by FundingSigned_read
     */ write() {
        const ret = _bindingsMjs.FundingSigned_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a FundingSigned from a byte array, created by FundingSigned_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.FundingSigned_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultFundingSignedDecodeErrorZMjs.Result_FundingSignedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_FundingSignedDecodeErrorZ.mjs":"jFbb5","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jFbb5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_FundingSignedDecodeErrorZ", ()=>Result_FundingSignedDecodeErrorZ
);
parcelHelpers.export(exports, "Result_FundingSignedDecodeErrorZ_OK", ()=>Result_FundingSignedDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_FundingSignedDecodeErrorZ_Err", ()=>Result_FundingSignedDecodeErrorZ_Err
) //# sourceMappingURL=Result_FundingSignedDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _fundingSignedMjs = require("../structs/FundingSigned.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_FundingSignedDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_FundingSignedDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_FundingSignedDecodeErrorZ_is_ok(ptr)) return new Result_FundingSignedDecodeErrorZ_OK(null, ptr);
        else return new Result_FundingSignedDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_FundingSignedDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_FundingSignedDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_FundingSignedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_FundingSignedDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_FundingSignedDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_FundingSignedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_FundingSignedDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_FundingSignedDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_FundingSignedDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_FundingSignedDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_FundingSignedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_FundingSignedDecodeErrorZ_OK extends Result_FundingSignedDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_FundingSignedDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _fundingSignedMjs.FundingSigned(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_FundingSignedDecodeErrorZ_Err extends Result_FundingSignedDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_FundingSignedDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/FundingSigned.mjs":"jlNPc","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kN90K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A funding_locked message to be sent or received from a peer
 */ parcelHelpers.export(exports, "FundingLocked", ()=>FundingLocked
) //# sourceMappingURL=FundingLocked.mjs.map
;
var _resultFundingLockedDecodeErrorZMjs = require("../structs/Result_FundingLockedDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class FundingLocked extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.FundingLocked_free);
    }
    /**
     * The channel ID
     */ get_channel_id() {
        const ret = _bindingsMjs.FundingLocked_get_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The channel ID
     */ set_channel_id(val) {
        _bindingsMjs.FundingLocked_set_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The per-commitment point of the second commitment transaction
     */ get_next_per_commitment_point() {
        const ret = _bindingsMjs.FundingLocked_get_next_per_commitment_point(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The per-commitment point of the second commitment transaction
     */ set_next_per_commitment_point(val) {
        _bindingsMjs.FundingLocked_set_next_per_commitment_point(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Constructs a new FundingLocked given each field
     */ static constructor_new(channel_id_arg, next_per_commitment_point_arg) {
        const ret = _bindingsMjs.FundingLocked_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_id_arg, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(next_per_commitment_point_arg, 33)));
        const ret_hu_conv = new FundingLocked(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.FundingLocked_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the FundingLocked
     */ clone() {
        const ret = _bindingsMjs.FundingLocked_clone(this.ptr);
        const ret_hu_conv = new FundingLocked(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the FundingLocked object into a byte array which can be read by FundingLocked_read
     */ write() {
        const ret = _bindingsMjs.FundingLocked_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a FundingLocked from a byte array, created by FundingLocked_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.FundingLocked_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultFundingLockedDecodeErrorZMjs.Result_FundingLockedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_FundingLockedDecodeErrorZ.mjs":"dR30H","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dR30H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_FundingLockedDecodeErrorZ", ()=>Result_FundingLockedDecodeErrorZ
);
parcelHelpers.export(exports, "Result_FundingLockedDecodeErrorZ_OK", ()=>Result_FundingLockedDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_FundingLockedDecodeErrorZ_Err", ()=>Result_FundingLockedDecodeErrorZ_Err
) //# sourceMappingURL=Result_FundingLockedDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _fundingLockedMjs = require("../structs/FundingLocked.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_FundingLockedDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_FundingLockedDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_FundingLockedDecodeErrorZ_is_ok(ptr)) return new Result_FundingLockedDecodeErrorZ_OK(null, ptr);
        else return new Result_FundingLockedDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_FundingLockedDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_FundingLockedDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_FundingLockedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_FundingLockedDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_FundingLockedDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_FundingLockedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_FundingLockedDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_FundingLockedDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_FundingLockedDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_FundingLockedDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_FundingLockedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_FundingLockedDecodeErrorZ_OK extends Result_FundingLockedDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_FundingLockedDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _fundingLockedMjs.FundingLocked(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_FundingLockedDecodeErrorZ_Err extends Result_FundingLockedDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_FundingLockedDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/FundingLocked.mjs":"kN90K","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lrgLp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An announcement_signatures message to be sent or received from a peer
 */ parcelHelpers.export(exports, "AnnouncementSignatures", ()=>AnnouncementSignatures
) //# sourceMappingURL=AnnouncementSignatures.mjs.map
;
var _resultAnnouncementSignaturesDecodeErrorZMjs = require("../structs/Result_AnnouncementSignaturesDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class AnnouncementSignatures extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.AnnouncementSignatures_free);
    }
    /**
     * The channel ID
     */ get_channel_id() {
        const ret = _bindingsMjs.AnnouncementSignatures_get_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The channel ID
     */ set_channel_id(val) {
        _bindingsMjs.AnnouncementSignatures_set_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The short channel ID
     */ get_short_channel_id() {
        const ret = _bindingsMjs.AnnouncementSignatures_get_short_channel_id(this.ptr);
        return ret;
    }
    /**
     * The short channel ID
     */ set_short_channel_id(val) {
        _bindingsMjs.AnnouncementSignatures_set_short_channel_id(this.ptr, val);
    }
    /**
     * A signature by the node key
     */ get_node_signature() {
        const ret = _bindingsMjs.AnnouncementSignatures_get_node_signature(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * A signature by the node key
     */ set_node_signature(val) {
        _bindingsMjs.AnnouncementSignatures_set_node_signature(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 64)));
    }
    /**
     * A signature by the funding key
     */ get_bitcoin_signature() {
        const ret = _bindingsMjs.AnnouncementSignatures_get_bitcoin_signature(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * A signature by the funding key
     */ set_bitcoin_signature(val) {
        _bindingsMjs.AnnouncementSignatures_set_bitcoin_signature(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 64)));
    }
    /**
     * Constructs a new AnnouncementSignatures given each field
     */ static constructor_new(channel_id_arg, short_channel_id_arg, node_signature_arg, bitcoin_signature_arg) {
        const ret = _bindingsMjs.AnnouncementSignatures_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_id_arg, 32)), short_channel_id_arg, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_signature_arg, 64)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(bitcoin_signature_arg, 64)));
        const ret_hu_conv = new AnnouncementSignatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.AnnouncementSignatures_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the AnnouncementSignatures
     */ clone() {
        const ret = _bindingsMjs.AnnouncementSignatures_clone(this.ptr);
        const ret_hu_conv = new AnnouncementSignatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the AnnouncementSignatures object into a byte array which can be read by AnnouncementSignatures_read
     */ write() {
        const ret = _bindingsMjs.AnnouncementSignatures_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a AnnouncementSignatures from a byte array, created by AnnouncementSignatures_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.AnnouncementSignatures_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultAnnouncementSignaturesDecodeErrorZMjs.Result_AnnouncementSignaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_AnnouncementSignaturesDecodeErrorZ.mjs":"ly0FJ","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ly0FJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_AnnouncementSignaturesDecodeErrorZ", ()=>Result_AnnouncementSignaturesDecodeErrorZ
);
parcelHelpers.export(exports, "Result_AnnouncementSignaturesDecodeErrorZ_OK", ()=>Result_AnnouncementSignaturesDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_AnnouncementSignaturesDecodeErrorZ_Err", ()=>Result_AnnouncementSignaturesDecodeErrorZ_Err
) //# sourceMappingURL=Result_AnnouncementSignaturesDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _announcementSignaturesMjs = require("../structs/AnnouncementSignatures.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_AnnouncementSignaturesDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_AnnouncementSignaturesDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(ptr)) return new Result_AnnouncementSignaturesDecodeErrorZ_OK(null, ptr);
        else return new Result_AnnouncementSignaturesDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_AnnouncementSignaturesDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_AnnouncementSignaturesDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_AnnouncementSignaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_AnnouncementSignaturesDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_AnnouncementSignaturesDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_AnnouncementSignaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_AnnouncementSignaturesDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_AnnouncementSignaturesDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_AnnouncementSignaturesDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_AnnouncementSignaturesDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_AnnouncementSignaturesDecodeErrorZ_OK extends Result_AnnouncementSignaturesDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_AnnouncementSignaturesDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _announcementSignaturesMjs.AnnouncementSignatures(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_AnnouncementSignaturesDecodeErrorZ_Err extends Result_AnnouncementSignaturesDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_AnnouncementSignaturesDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/AnnouncementSignatures.mjs":"lrgLp","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"21YmD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Struct used to return values from revoke_and_ack messages, containing a bunch of commitment
 * transaction updates if they were pending.
 */ parcelHelpers.export(exports, "CommitmentUpdate", ()=>CommitmentUpdate
) //# sourceMappingURL=CommitmentUpdate.mjs.map
;
var _updateAddHTLCMjs = require("../structs/UpdateAddHTLC.mjs");
var _updateFulfillHTLCMjs = require("../structs/UpdateFulfillHTLC.mjs");
var _updateFailHTLCMjs = require("../structs/UpdateFailHTLC.mjs");
var _updateFailMalformedHTLCMjs = require("../structs/UpdateFailMalformedHTLC.mjs");
var _commitmentSignedMjs = require("../structs/CommitmentSigned.mjs");
var _updateFeeMjs = require("../structs/UpdateFee.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class CommitmentUpdate extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CommitmentUpdate_free);
    }
    /**
     * update_add_htlc messages which should be sent
     */ get_update_add_htlcs() {
        const ret = _bindingsMjs.CommitmentUpdate_get_update_add_htlcs(this.ptr);
        const ret_conv_15_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_15_arr = new Array(ret_conv_15_len).fill(null);
        for(var p = 0; p < ret_conv_15_len; p++){
            const ret_conv_15 = _bindingsMjs.getU32ArrayElem(ret, p);
            const ret_conv_15_hu_conv = new _updateAddHTLCMjs.UpdateAddHTLC(null, ret_conv_15);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_15_hu_conv, this);
            ret_conv_15_arr[p] = ret_conv_15_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_15_arr;
    }
    /**
     * update_add_htlc messages which should be sent
     */ set_update_add_htlcs(val) {
        _bindingsMjs.CommitmentUpdate_set_update_add_htlcs(this.ptr, _bindingsMjs.encodeUint32Array(val != null ? val.map((val_conv_15)=>val_conv_15 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val_conv_15) & -2
        ) : null));
    }
    /**
     * update_fulfill_htlc messages which should be sent
     */ get_update_fulfill_htlcs() {
        const ret = _bindingsMjs.CommitmentUpdate_get_update_fulfill_htlcs(this.ptr);
        const ret_conv_19_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_19_arr = new Array(ret_conv_19_len).fill(null);
        for(var t = 0; t < ret_conv_19_len; t++){
            const ret_conv_19 = _bindingsMjs.getU32ArrayElem(ret, t);
            const ret_conv_19_hu_conv = new _updateFulfillHTLCMjs.UpdateFulfillHTLC(null, ret_conv_19);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_19_hu_conv, this);
            ret_conv_19_arr[t] = ret_conv_19_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_19_arr;
    }
    /**
     * update_fulfill_htlc messages which should be sent
     */ set_update_fulfill_htlcs(val) {
        _bindingsMjs.CommitmentUpdate_set_update_fulfill_htlcs(this.ptr, _bindingsMjs.encodeUint32Array(val != null ? val.map((val_conv_19)=>val_conv_19 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val_conv_19) & -2
        ) : null));
    }
    /**
     * update_fail_htlc messages which should be sent
     */ get_update_fail_htlcs() {
        const ret = _bindingsMjs.CommitmentUpdate_get_update_fail_htlcs(this.ptr);
        const ret_conv_16_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_16_arr = new Array(ret_conv_16_len).fill(null);
        for(var q = 0; q < ret_conv_16_len; q++){
            const ret_conv_16 = _bindingsMjs.getU32ArrayElem(ret, q);
            const ret_conv_16_hu_conv = new _updateFailHTLCMjs.UpdateFailHTLC(null, ret_conv_16);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_16_hu_conv, this);
            ret_conv_16_arr[q] = ret_conv_16_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_16_arr;
    }
    /**
     * update_fail_htlc messages which should be sent
     */ set_update_fail_htlcs(val) {
        _bindingsMjs.CommitmentUpdate_set_update_fail_htlcs(this.ptr, _bindingsMjs.encodeUint32Array(val != null ? val.map((val_conv_16)=>val_conv_16 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val_conv_16) & -2
        ) : null));
    }
    /**
     * update_fail_malformed_htlc messages which should be sent
     */ get_update_fail_malformed_htlcs() {
        const ret = _bindingsMjs.CommitmentUpdate_get_update_fail_malformed_htlcs(this.ptr);
        const ret_conv_25_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_25_arr = new Array(ret_conv_25_len).fill(null);
        for(var z = 0; z < ret_conv_25_len; z++){
            const ret_conv_25 = _bindingsMjs.getU32ArrayElem(ret, z);
            const ret_conv_25_hu_conv = new _updateFailMalformedHTLCMjs.UpdateFailMalformedHTLC(null, ret_conv_25);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_25_hu_conv, this);
            ret_conv_25_arr[z] = ret_conv_25_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_25_arr;
    }
    /**
     * update_fail_malformed_htlc messages which should be sent
     */ set_update_fail_malformed_htlcs(val) {
        _bindingsMjs.CommitmentUpdate_set_update_fail_malformed_htlcs(this.ptr, _bindingsMjs.encodeUint32Array(val != null ? val.map((val_conv_25)=>val_conv_25 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val_conv_25) & -2
        ) : null));
    }
    /**
     * An update_fee message which should be sent
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_update_fee() {
        const ret = _bindingsMjs.CommitmentUpdate_get_update_fee(this.ptr);
        const ret_hu_conv = new _updateFeeMjs.UpdateFee(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * An update_fee message which should be sent
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_update_fee(val) {
        _bindingsMjs.CommitmentUpdate_set_update_fee(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Finally, the commitment_signed message which should be sent
     */ get_commitment_signed() {
        const ret = _bindingsMjs.CommitmentUpdate_get_commitment_signed(this.ptr);
        const ret_hu_conv = new _commitmentSignedMjs.CommitmentSigned(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Finally, the commitment_signed message which should be sent
     */ set_commitment_signed(val) {
        _bindingsMjs.CommitmentUpdate_set_commitment_signed(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Constructs a new CommitmentUpdate given each field
     */ static constructor_new(update_add_htlcs_arg, update_fulfill_htlcs_arg, update_fail_htlcs_arg, update_fail_malformed_htlcs_arg, update_fee_arg, commitment_signed_arg) {
        const ret = _bindingsMjs.CommitmentUpdate_new(_bindingsMjs.encodeUint32Array(update_add_htlcs_arg != null ? update_add_htlcs_arg.map((update_add_htlcs_arg_conv_15)=>update_add_htlcs_arg_conv_15 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(update_add_htlcs_arg_conv_15) & -2
        ) : null), _bindingsMjs.encodeUint32Array(update_fulfill_htlcs_arg != null ? update_fulfill_htlcs_arg.map((update_fulfill_htlcs_arg_conv_19)=>update_fulfill_htlcs_arg_conv_19 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(update_fulfill_htlcs_arg_conv_19) & -2
        ) : null), _bindingsMjs.encodeUint32Array(update_fail_htlcs_arg != null ? update_fail_htlcs_arg.map((update_fail_htlcs_arg_conv_16)=>update_fail_htlcs_arg_conv_16 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(update_fail_htlcs_arg_conv_16) & -2
        ) : null), _bindingsMjs.encodeUint32Array(update_fail_malformed_htlcs_arg != null ? update_fail_malformed_htlcs_arg.map((update_fail_malformed_htlcs_arg_conv_25)=>update_fail_malformed_htlcs_arg_conv_25 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(update_fail_malformed_htlcs_arg_conv_25) & -2
        ) : null), update_fee_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(update_fee_arg) & -2, commitment_signed_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(commitment_signed_arg) & -2);
        const ret_hu_conv = new CommitmentUpdate(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CommitmentUpdate_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the CommitmentUpdate
     */ clone() {
        const ret = _bindingsMjs.CommitmentUpdate_clone(this.ptr);
        const ret_hu_conv = new CommitmentUpdate(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"../structs/UpdateAddHTLC.mjs":"9vrgO","../structs/UpdateFulfillHTLC.mjs":"cr92W","../structs/UpdateFailHTLC.mjs":"4WevC","../structs/UpdateFailMalformedHTLC.mjs":"jLR8a","../structs/CommitmentSigned.mjs":"fowBl","../structs/UpdateFee.mjs":"8XTZ4","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9vrgO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An update_add_htlc message to be sent or received from a peer
 */ parcelHelpers.export(exports, "UpdateAddHTLC", ()=>UpdateAddHTLC
) //# sourceMappingURL=UpdateAddHTLC.mjs.map
;
var _resultUpdateAddHTLCDecodeErrorZMjs = require("../structs/Result_UpdateAddHTLCDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class UpdateAddHTLC extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.UpdateAddHTLC_free);
    }
    /**
     * The channel ID
     */ get_channel_id() {
        const ret = _bindingsMjs.UpdateAddHTLC_get_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The channel ID
     */ set_channel_id(val) {
        _bindingsMjs.UpdateAddHTLC_set_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The HTLC ID
     */ get_htlc_id() {
        const ret = _bindingsMjs.UpdateAddHTLC_get_htlc_id(this.ptr);
        return ret;
    }
    /**
     * The HTLC ID
     */ set_htlc_id(val) {
        _bindingsMjs.UpdateAddHTLC_set_htlc_id(this.ptr, val);
    }
    /**
     * The HTLC value in milli-satoshi
     */ get_amount_msat() {
        const ret = _bindingsMjs.UpdateAddHTLC_get_amount_msat(this.ptr);
        return ret;
    }
    /**
     * The HTLC value in milli-satoshi
     */ set_amount_msat(val) {
        _bindingsMjs.UpdateAddHTLC_set_amount_msat(this.ptr, val);
    }
    /**
     * The payment hash, the pre-image of which controls HTLC redemption
     */ get_payment_hash() {
        const ret = _bindingsMjs.UpdateAddHTLC_get_payment_hash(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The payment hash, the pre-image of which controls HTLC redemption
     */ set_payment_hash(val) {
        _bindingsMjs.UpdateAddHTLC_set_payment_hash(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The expiry height of the HTLC
     */ get_cltv_expiry() {
        const ret = _bindingsMjs.UpdateAddHTLC_get_cltv_expiry(this.ptr);
        return ret;
    }
    /**
     * The expiry height of the HTLC
     */ set_cltv_expiry(val) {
        _bindingsMjs.UpdateAddHTLC_set_cltv_expiry(this.ptr, val);
    }
    clone_ptr() {
        const ret = _bindingsMjs.UpdateAddHTLC_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the UpdateAddHTLC
     */ clone() {
        const ret = _bindingsMjs.UpdateAddHTLC_clone(this.ptr);
        const ret_hu_conv = new UpdateAddHTLC(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the UpdateAddHTLC object into a byte array which can be read by UpdateAddHTLC_read
     */ write() {
        const ret = _bindingsMjs.UpdateAddHTLC_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a UpdateAddHTLC from a byte array, created by UpdateAddHTLC_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.UpdateAddHTLC_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultUpdateAddHTLCDecodeErrorZMjs.Result_UpdateAddHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_UpdateAddHTLCDecodeErrorZ.mjs":"bxIFB","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bxIFB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_UpdateAddHTLCDecodeErrorZ", ()=>Result_UpdateAddHTLCDecodeErrorZ
);
parcelHelpers.export(exports, "Result_UpdateAddHTLCDecodeErrorZ_OK", ()=>Result_UpdateAddHTLCDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_UpdateAddHTLCDecodeErrorZ_Err", ()=>Result_UpdateAddHTLCDecodeErrorZ_Err
) //# sourceMappingURL=Result_UpdateAddHTLCDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _updateAddHTLCMjs = require("../structs/UpdateAddHTLC.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_UpdateAddHTLCDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_UpdateAddHTLCDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_UpdateAddHTLCDecodeErrorZ_is_ok(ptr)) return new Result_UpdateAddHTLCDecodeErrorZ_OK(null, ptr);
        else return new Result_UpdateAddHTLCDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_UpdateAddHTLCDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_UpdateAddHTLCDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_UpdateAddHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_UpdateAddHTLCDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_UpdateAddHTLCDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_UpdateAddHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_UpdateAddHTLCDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_UpdateAddHTLCDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_UpdateAddHTLCDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_UpdateAddHTLCDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_UpdateAddHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_UpdateAddHTLCDecodeErrorZ_OK extends Result_UpdateAddHTLCDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_UpdateAddHTLCDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _updateAddHTLCMjs.UpdateAddHTLC(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_UpdateAddHTLCDecodeErrorZ_Err extends Result_UpdateAddHTLCDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_UpdateAddHTLCDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/UpdateAddHTLC.mjs":"9vrgO","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cr92W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An update_fulfill_htlc message to be sent or received from a peer
 */ parcelHelpers.export(exports, "UpdateFulfillHTLC", ()=>UpdateFulfillHTLC
) //# sourceMappingURL=UpdateFulfillHTLC.mjs.map
;
var _resultUpdateFulfillHTLCDecodeErrorZMjs = require("../structs/Result_UpdateFulfillHTLCDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class UpdateFulfillHTLC extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.UpdateFulfillHTLC_free);
    }
    /**
     * The channel ID
     */ get_channel_id() {
        const ret = _bindingsMjs.UpdateFulfillHTLC_get_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The channel ID
     */ set_channel_id(val) {
        _bindingsMjs.UpdateFulfillHTLC_set_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The HTLC ID
     */ get_htlc_id() {
        const ret = _bindingsMjs.UpdateFulfillHTLC_get_htlc_id(this.ptr);
        return ret;
    }
    /**
     * The HTLC ID
     */ set_htlc_id(val) {
        _bindingsMjs.UpdateFulfillHTLC_set_htlc_id(this.ptr, val);
    }
    /**
     * The pre-image of the payment hash, allowing HTLC redemption
     */ get_payment_preimage() {
        const ret = _bindingsMjs.UpdateFulfillHTLC_get_payment_preimage(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The pre-image of the payment hash, allowing HTLC redemption
     */ set_payment_preimage(val) {
        _bindingsMjs.UpdateFulfillHTLC_set_payment_preimage(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * Constructs a new UpdateFulfillHTLC given each field
     */ static constructor_new(channel_id_arg, htlc_id_arg, payment_preimage_arg) {
        const ret = _bindingsMjs.UpdateFulfillHTLC_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_id_arg, 32)), htlc_id_arg, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_preimage_arg, 32)));
        const ret_hu_conv = new UpdateFulfillHTLC(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.UpdateFulfillHTLC_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the UpdateFulfillHTLC
     */ clone() {
        const ret = _bindingsMjs.UpdateFulfillHTLC_clone(this.ptr);
        const ret_hu_conv = new UpdateFulfillHTLC(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the UpdateFulfillHTLC object into a byte array which can be read by UpdateFulfillHTLC_read
     */ write() {
        const ret = _bindingsMjs.UpdateFulfillHTLC_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a UpdateFulfillHTLC from a byte array, created by UpdateFulfillHTLC_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.UpdateFulfillHTLC_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultUpdateFulfillHTLCDecodeErrorZMjs.Result_UpdateFulfillHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_UpdateFulfillHTLCDecodeErrorZ.mjs":"a6EKN","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a6EKN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_UpdateFulfillHTLCDecodeErrorZ", ()=>Result_UpdateFulfillHTLCDecodeErrorZ
);
parcelHelpers.export(exports, "Result_UpdateFulfillHTLCDecodeErrorZ_OK", ()=>Result_UpdateFulfillHTLCDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_UpdateFulfillHTLCDecodeErrorZ_Err", ()=>Result_UpdateFulfillHTLCDecodeErrorZ_Err
) //# sourceMappingURL=Result_UpdateFulfillHTLCDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _updateFulfillHTLCMjs = require("../structs/UpdateFulfillHTLC.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_UpdateFulfillHTLCDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_UpdateFulfillHTLCDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(ptr)) return new Result_UpdateFulfillHTLCDecodeErrorZ_OK(null, ptr);
        else return new Result_UpdateFulfillHTLCDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_UpdateFulfillHTLCDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_UpdateFulfillHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_UpdateFulfillHTLCDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_UpdateFulfillHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_UpdateFulfillHTLCDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_UpdateFulfillHTLCDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_UpdateFulfillHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_UpdateFulfillHTLCDecodeErrorZ_OK extends Result_UpdateFulfillHTLCDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_UpdateFulfillHTLCDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _updateFulfillHTLCMjs.UpdateFulfillHTLC(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_UpdateFulfillHTLCDecodeErrorZ_Err extends Result_UpdateFulfillHTLCDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_UpdateFulfillHTLCDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/UpdateFulfillHTLC.mjs":"cr92W","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4WevC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An update_fail_htlc message to be sent or received from a peer
 */ parcelHelpers.export(exports, "UpdateFailHTLC", ()=>UpdateFailHTLC
) //# sourceMappingURL=UpdateFailHTLC.mjs.map
;
var _resultUpdateFailHTLCDecodeErrorZMjs = require("../structs/Result_UpdateFailHTLCDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class UpdateFailHTLC extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.UpdateFailHTLC_free);
    }
    /**
     * The channel ID
     */ get_channel_id() {
        const ret = _bindingsMjs.UpdateFailHTLC_get_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The channel ID
     */ set_channel_id(val) {
        _bindingsMjs.UpdateFailHTLC_set_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The HTLC ID
     */ get_htlc_id() {
        const ret = _bindingsMjs.UpdateFailHTLC_get_htlc_id(this.ptr);
        return ret;
    }
    /**
     * The HTLC ID
     */ set_htlc_id(val) {
        _bindingsMjs.UpdateFailHTLC_set_htlc_id(this.ptr, val);
    }
    clone_ptr() {
        const ret = _bindingsMjs.UpdateFailHTLC_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the UpdateFailHTLC
     */ clone() {
        const ret = _bindingsMjs.UpdateFailHTLC_clone(this.ptr);
        const ret_hu_conv = new UpdateFailHTLC(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the UpdateFailHTLC object into a byte array which can be read by UpdateFailHTLC_read
     */ write() {
        const ret = _bindingsMjs.UpdateFailHTLC_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a UpdateFailHTLC from a byte array, created by UpdateFailHTLC_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.UpdateFailHTLC_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultUpdateFailHTLCDecodeErrorZMjs.Result_UpdateFailHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_UpdateFailHTLCDecodeErrorZ.mjs":"h4ypb","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h4ypb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_UpdateFailHTLCDecodeErrorZ", ()=>Result_UpdateFailHTLCDecodeErrorZ
);
parcelHelpers.export(exports, "Result_UpdateFailHTLCDecodeErrorZ_OK", ()=>Result_UpdateFailHTLCDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_UpdateFailHTLCDecodeErrorZ_Err", ()=>Result_UpdateFailHTLCDecodeErrorZ_Err
) //# sourceMappingURL=Result_UpdateFailHTLCDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _updateFailHTLCMjs = require("../structs/UpdateFailHTLC.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_UpdateFailHTLCDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_UpdateFailHTLCDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_UpdateFailHTLCDecodeErrorZ_is_ok(ptr)) return new Result_UpdateFailHTLCDecodeErrorZ_OK(null, ptr);
        else return new Result_UpdateFailHTLCDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_UpdateFailHTLCDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_UpdateFailHTLCDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_UpdateFailHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_UpdateFailHTLCDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_UpdateFailHTLCDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_UpdateFailHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_UpdateFailHTLCDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_UpdateFailHTLCDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_UpdateFailHTLCDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_UpdateFailHTLCDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_UpdateFailHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_UpdateFailHTLCDecodeErrorZ_OK extends Result_UpdateFailHTLCDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_UpdateFailHTLCDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _updateFailHTLCMjs.UpdateFailHTLC(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_UpdateFailHTLCDecodeErrorZ_Err extends Result_UpdateFailHTLCDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_UpdateFailHTLCDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/UpdateFailHTLC.mjs":"4WevC","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jLR8a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An update_fail_malformed_htlc message to be sent or received from a peer
 */ parcelHelpers.export(exports, "UpdateFailMalformedHTLC", ()=>UpdateFailMalformedHTLC
) //# sourceMappingURL=UpdateFailMalformedHTLC.mjs.map
;
var _resultUpdateFailMalformedHTLCDecodeErrorZMjs = require("../structs/Result_UpdateFailMalformedHTLCDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class UpdateFailMalformedHTLC extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.UpdateFailMalformedHTLC_free);
    }
    /**
     * The channel ID
     */ get_channel_id() {
        const ret = _bindingsMjs.UpdateFailMalformedHTLC_get_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The channel ID
     */ set_channel_id(val) {
        _bindingsMjs.UpdateFailMalformedHTLC_set_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The HTLC ID
     */ get_htlc_id() {
        const ret = _bindingsMjs.UpdateFailMalformedHTLC_get_htlc_id(this.ptr);
        return ret;
    }
    /**
     * The HTLC ID
     */ set_htlc_id(val) {
        _bindingsMjs.UpdateFailMalformedHTLC_set_htlc_id(this.ptr, val);
    }
    /**
     * The failure code
     */ get_failure_code() {
        const ret = _bindingsMjs.UpdateFailMalformedHTLC_get_failure_code(this.ptr);
        return ret;
    }
    /**
     * The failure code
     */ set_failure_code(val) {
        _bindingsMjs.UpdateFailMalformedHTLC_set_failure_code(this.ptr, val);
    }
    clone_ptr() {
        const ret = _bindingsMjs.UpdateFailMalformedHTLC_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the UpdateFailMalformedHTLC
     */ clone() {
        const ret = _bindingsMjs.UpdateFailMalformedHTLC_clone(this.ptr);
        const ret_hu_conv = new UpdateFailMalformedHTLC(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the UpdateFailMalformedHTLC object into a byte array which can be read by UpdateFailMalformedHTLC_read
     */ write() {
        const ret = _bindingsMjs.UpdateFailMalformedHTLC_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a UpdateFailMalformedHTLC from a byte array, created by UpdateFailMalformedHTLC_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.UpdateFailMalformedHTLC_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultUpdateFailMalformedHTLCDecodeErrorZMjs.Result_UpdateFailMalformedHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_UpdateFailMalformedHTLCDecodeErrorZ.mjs":"6xLv3","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6xLv3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_UpdateFailMalformedHTLCDecodeErrorZ", ()=>Result_UpdateFailMalformedHTLCDecodeErrorZ
);
parcelHelpers.export(exports, "Result_UpdateFailMalformedHTLCDecodeErrorZ_OK", ()=>Result_UpdateFailMalformedHTLCDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_UpdateFailMalformedHTLCDecodeErrorZ_Err", ()=>Result_UpdateFailMalformedHTLCDecodeErrorZ_Err
) //# sourceMappingURL=Result_UpdateFailMalformedHTLCDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _updateFailMalformedHTLCMjs = require("../structs/UpdateFailMalformedHTLC.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_UpdateFailMalformedHTLCDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_UpdateFailMalformedHTLCDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(ptr)) return new Result_UpdateFailMalformedHTLCDecodeErrorZ_OK(null, ptr);
        else return new Result_UpdateFailMalformedHTLCDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_UpdateFailMalformedHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_UpdateFailMalformedHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_UpdateFailMalformedHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_UpdateFailMalformedHTLCDecodeErrorZ_OK extends Result_UpdateFailMalformedHTLCDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _updateFailMalformedHTLCMjs.UpdateFailMalformedHTLC(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_UpdateFailMalformedHTLCDecodeErrorZ_Err extends Result_UpdateFailMalformedHTLCDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/UpdateFailMalformedHTLC.mjs":"jLR8a","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fowBl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A commitment_signed message to be sent or received from a peer
 */ parcelHelpers.export(exports, "CommitmentSigned", ()=>CommitmentSigned
) //# sourceMappingURL=CommitmentSigned.mjs.map
;
var _resultCommitmentSignedDecodeErrorZMjs = require("../structs/Result_CommitmentSignedDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class CommitmentSigned extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CommitmentSigned_free);
    }
    /**
     * The channel ID
     */ get_channel_id() {
        const ret = _bindingsMjs.CommitmentSigned_get_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The channel ID
     */ set_channel_id(val) {
        _bindingsMjs.CommitmentSigned_set_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * A signature on the commitment transaction
     */ get_signature() {
        const ret = _bindingsMjs.CommitmentSigned_get_signature(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * A signature on the commitment transaction
     */ set_signature(val) {
        _bindingsMjs.CommitmentSigned_set_signature(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 64)));
    }
    /**
     * Signatures on the HTLC transactions
     */ set_htlc_signatures(val) {
        _bindingsMjs.CommitmentSigned_set_htlc_signatures(this.ptr, _bindingsMjs.encodeUint32Array(val != null ? val.map((val_conv_12)=>_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val_conv_12, 64))
        ) : null));
    }
    /**
     * Constructs a new CommitmentSigned given each field
     */ static constructor_new(channel_id_arg, signature_arg, htlc_signatures_arg) {
        const ret = _bindingsMjs.CommitmentSigned_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_id_arg, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(signature_arg, 64)), _bindingsMjs.encodeUint32Array(htlc_signatures_arg != null ? htlc_signatures_arg.map((htlc_signatures_arg_conv_12)=>_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(htlc_signatures_arg_conv_12, 64))
        ) : null));
        const ret_hu_conv = new CommitmentSigned(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CommitmentSigned_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the CommitmentSigned
     */ clone() {
        const ret = _bindingsMjs.CommitmentSigned_clone(this.ptr);
        const ret_hu_conv = new CommitmentSigned(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the CommitmentSigned object into a byte array which can be read by CommitmentSigned_read
     */ write() {
        const ret = _bindingsMjs.CommitmentSigned_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a CommitmentSigned from a byte array, created by CommitmentSigned_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.CommitmentSigned_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultCommitmentSignedDecodeErrorZMjs.Result_CommitmentSignedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_CommitmentSignedDecodeErrorZ.mjs":"8d2oW","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8d2oW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_CommitmentSignedDecodeErrorZ", ()=>Result_CommitmentSignedDecodeErrorZ
);
parcelHelpers.export(exports, "Result_CommitmentSignedDecodeErrorZ_OK", ()=>Result_CommitmentSignedDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_CommitmentSignedDecodeErrorZ_Err", ()=>Result_CommitmentSignedDecodeErrorZ_Err
) //# sourceMappingURL=Result_CommitmentSignedDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _commitmentSignedMjs = require("../structs/CommitmentSigned.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_CommitmentSignedDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_CommitmentSignedDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_CommitmentSignedDecodeErrorZ_is_ok(ptr)) return new Result_CommitmentSignedDecodeErrorZ_OK(null, ptr);
        else return new Result_CommitmentSignedDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_CommitmentSignedDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_CommitmentSignedDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_CommitmentSignedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_CommitmentSignedDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_CommitmentSignedDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_CommitmentSignedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_CommitmentSignedDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_CommitmentSignedDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_CommitmentSignedDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_CommitmentSignedDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_CommitmentSignedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_CommitmentSignedDecodeErrorZ_OK extends Result_CommitmentSignedDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_CommitmentSignedDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _commitmentSignedMjs.CommitmentSigned(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_CommitmentSignedDecodeErrorZ_Err extends Result_CommitmentSignedDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_CommitmentSignedDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/CommitmentSigned.mjs":"fowBl","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8XTZ4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An update_fee message to be sent or received from a peer
 */ parcelHelpers.export(exports, "UpdateFee", ()=>UpdateFee
) //# sourceMappingURL=UpdateFee.mjs.map
;
var _resultUpdateFeeDecodeErrorZMjs = require("../structs/Result_UpdateFeeDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class UpdateFee extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.UpdateFee_free);
    }
    /**
     * The channel ID
     */ get_channel_id() {
        const ret = _bindingsMjs.UpdateFee_get_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The channel ID
     */ set_channel_id(val) {
        _bindingsMjs.UpdateFee_set_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * Fee rate per 1000-weight of the transaction
     */ get_feerate_per_kw() {
        const ret = _bindingsMjs.UpdateFee_get_feerate_per_kw(this.ptr);
        return ret;
    }
    /**
     * Fee rate per 1000-weight of the transaction
     */ set_feerate_per_kw(val) {
        _bindingsMjs.UpdateFee_set_feerate_per_kw(this.ptr, val);
    }
    /**
     * Constructs a new UpdateFee given each field
     */ static constructor_new(channel_id_arg, feerate_per_kw_arg) {
        const ret = _bindingsMjs.UpdateFee_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_id_arg, 32)), feerate_per_kw_arg);
        const ret_hu_conv = new UpdateFee(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.UpdateFee_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the UpdateFee
     */ clone() {
        const ret = _bindingsMjs.UpdateFee_clone(this.ptr);
        const ret_hu_conv = new UpdateFee(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the UpdateFee object into a byte array which can be read by UpdateFee_read
     */ write() {
        const ret = _bindingsMjs.UpdateFee_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a UpdateFee from a byte array, created by UpdateFee_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.UpdateFee_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultUpdateFeeDecodeErrorZMjs.Result_UpdateFeeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_UpdateFeeDecodeErrorZ.mjs":"f8zxh","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f8zxh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_UpdateFeeDecodeErrorZ", ()=>Result_UpdateFeeDecodeErrorZ
);
parcelHelpers.export(exports, "Result_UpdateFeeDecodeErrorZ_OK", ()=>Result_UpdateFeeDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_UpdateFeeDecodeErrorZ_Err", ()=>Result_UpdateFeeDecodeErrorZ_Err
) //# sourceMappingURL=Result_UpdateFeeDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _updateFeeMjs = require("../structs/UpdateFee.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_UpdateFeeDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_UpdateFeeDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_UpdateFeeDecodeErrorZ_is_ok(ptr)) return new Result_UpdateFeeDecodeErrorZ_OK(null, ptr);
        else return new Result_UpdateFeeDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_UpdateFeeDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_UpdateFeeDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_UpdateFeeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_UpdateFeeDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_UpdateFeeDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_UpdateFeeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_UpdateFeeDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_UpdateFeeDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_UpdateFeeDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_UpdateFeeDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_UpdateFeeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_UpdateFeeDecodeErrorZ_OK extends Result_UpdateFeeDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_UpdateFeeDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _updateFeeMjs.UpdateFee(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_UpdateFeeDecodeErrorZ_Err extends Result_UpdateFeeDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_UpdateFeeDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/UpdateFee.mjs":"8XTZ4","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hocx7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A revoke_and_ack message to be sent or received from a peer
 */ parcelHelpers.export(exports, "RevokeAndACK", ()=>RevokeAndACK
) //# sourceMappingURL=RevokeAndACK.mjs.map
;
var _resultRevokeAndACKDecodeErrorZMjs = require("../structs/Result_RevokeAndACKDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class RevokeAndACK extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.RevokeAndACK_free);
    }
    /**
     * The channel ID
     */ get_channel_id() {
        const ret = _bindingsMjs.RevokeAndACK_get_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The channel ID
     */ set_channel_id(val) {
        _bindingsMjs.RevokeAndACK_set_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The secret corresponding to the per-commitment point
     */ get_per_commitment_secret() {
        const ret = _bindingsMjs.RevokeAndACK_get_per_commitment_secret(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The secret corresponding to the per-commitment point
     */ set_per_commitment_secret(val) {
        _bindingsMjs.RevokeAndACK_set_per_commitment_secret(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The next sender-broadcast commitment transaction's per-commitment point
     */ get_next_per_commitment_point() {
        const ret = _bindingsMjs.RevokeAndACK_get_next_per_commitment_point(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The next sender-broadcast commitment transaction's per-commitment point
     */ set_next_per_commitment_point(val) {
        _bindingsMjs.RevokeAndACK_set_next_per_commitment_point(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Constructs a new RevokeAndACK given each field
     */ static constructor_new(channel_id_arg, per_commitment_secret_arg, next_per_commitment_point_arg) {
        const ret = _bindingsMjs.RevokeAndACK_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_id_arg, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(per_commitment_secret_arg, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(next_per_commitment_point_arg, 33)));
        const ret_hu_conv = new RevokeAndACK(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.RevokeAndACK_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the RevokeAndACK
     */ clone() {
        const ret = _bindingsMjs.RevokeAndACK_clone(this.ptr);
        const ret_hu_conv = new RevokeAndACK(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the RevokeAndACK object into a byte array which can be read by RevokeAndACK_read
     */ write() {
        const ret = _bindingsMjs.RevokeAndACK_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a RevokeAndACK from a byte array, created by RevokeAndACK_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.RevokeAndACK_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultRevokeAndACKDecodeErrorZMjs.Result_RevokeAndACKDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_RevokeAndACKDecodeErrorZ.mjs":"5nbNc","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5nbNc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_RevokeAndACKDecodeErrorZ", ()=>Result_RevokeAndACKDecodeErrorZ
);
parcelHelpers.export(exports, "Result_RevokeAndACKDecodeErrorZ_OK", ()=>Result_RevokeAndACKDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_RevokeAndACKDecodeErrorZ_Err", ()=>Result_RevokeAndACKDecodeErrorZ_Err
) //# sourceMappingURL=Result_RevokeAndACKDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _revokeAndACKMjs = require("../structs/RevokeAndACK.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_RevokeAndACKDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_RevokeAndACKDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_RevokeAndACKDecodeErrorZ_is_ok(ptr)) return new Result_RevokeAndACKDecodeErrorZ_OK(null, ptr);
        else return new Result_RevokeAndACKDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_RevokeAndACKDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_RevokeAndACKDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_RevokeAndACKDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_RevokeAndACKDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_RevokeAndACKDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_RevokeAndACKDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_RevokeAndACKDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_RevokeAndACKDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_RevokeAndACKDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_RevokeAndACKDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_RevokeAndACKDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_RevokeAndACKDecodeErrorZ_OK extends Result_RevokeAndACKDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_RevokeAndACKDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _revokeAndACKMjs.RevokeAndACK(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_RevokeAndACKDecodeErrorZ_Err extends Result_RevokeAndACKDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_RevokeAndACKDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/RevokeAndACK.mjs":"hocx7","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"drMrL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A closing_signed message to be sent or received from a peer
 */ parcelHelpers.export(exports, "ClosingSigned", ()=>ClosingSigned
) //# sourceMappingURL=ClosingSigned.mjs.map
;
var _resultClosingSignedDecodeErrorZMjs = require("../structs/Result_ClosingSignedDecodeErrorZ.mjs");
var _closingSignedFeeRangeMjs = require("../structs/ClosingSignedFeeRange.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ClosingSigned extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ClosingSigned_free);
    }
    /**
     * The channel ID
     */ get_channel_id() {
        const ret = _bindingsMjs.ClosingSigned_get_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The channel ID
     */ set_channel_id(val) {
        _bindingsMjs.ClosingSigned_set_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The proposed total fee for the closing transaction
     */ get_fee_satoshis() {
        const ret = _bindingsMjs.ClosingSigned_get_fee_satoshis(this.ptr);
        return ret;
    }
    /**
     * The proposed total fee for the closing transaction
     */ set_fee_satoshis(val) {
        _bindingsMjs.ClosingSigned_set_fee_satoshis(this.ptr, val);
    }
    /**
     * A signature on the closing transaction
     */ get_signature() {
        const ret = _bindingsMjs.ClosingSigned_get_signature(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * A signature on the closing transaction
     */ set_signature(val) {
        _bindingsMjs.ClosingSigned_set_signature(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 64)));
    }
    /**
     * The minimum and maximum fees which the sender is willing to accept, provided only by new
     * nodes.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_fee_range() {
        const ret = _bindingsMjs.ClosingSigned_get_fee_range(this.ptr);
        const ret_hu_conv = new _closingSignedFeeRangeMjs.ClosingSignedFeeRange(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The minimum and maximum fees which the sender is willing to accept, provided only by new
     * nodes.
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_fee_range(val) {
        _bindingsMjs.ClosingSigned_set_fee_range(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Constructs a new ClosingSigned given each field
     */ static constructor_new(channel_id_arg, fee_satoshis_arg, signature_arg, fee_range_arg) {
        const ret = _bindingsMjs.ClosingSigned_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_id_arg, 32)), fee_satoshis_arg, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(signature_arg, 64)), fee_range_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(fee_range_arg) & -2);
        const ret_hu_conv = new ClosingSigned(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ClosingSigned_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ClosingSigned
     */ clone() {
        const ret = _bindingsMjs.ClosingSigned_clone(this.ptr);
        const ret_hu_conv = new ClosingSigned(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the ClosingSigned object into a byte array which can be read by ClosingSigned_read
     */ write() {
        const ret = _bindingsMjs.ClosingSigned_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ClosingSigned from a byte array, created by ClosingSigned_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ClosingSigned_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultClosingSignedDecodeErrorZMjs.Result_ClosingSignedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_ClosingSignedDecodeErrorZ.mjs":"3GrS9","../structs/ClosingSignedFeeRange.mjs":"dcrS6","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3GrS9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ClosingSignedDecodeErrorZ", ()=>Result_ClosingSignedDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ClosingSignedDecodeErrorZ_OK", ()=>Result_ClosingSignedDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ClosingSignedDecodeErrorZ_Err", ()=>Result_ClosingSignedDecodeErrorZ_Err
) //# sourceMappingURL=Result_ClosingSignedDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _closingSignedMjs = require("../structs/ClosingSigned.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ClosingSignedDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ClosingSignedDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ClosingSignedDecodeErrorZ_is_ok(ptr)) return new Result_ClosingSignedDecodeErrorZ_OK(null, ptr);
        else return new Result_ClosingSignedDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ClosingSignedDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ClosingSignedDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ClosingSignedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ClosingSignedDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ClosingSignedDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ClosingSignedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ClosingSignedDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_ClosingSignedDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_ClosingSignedDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_ClosingSignedDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_ClosingSignedDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_ClosingSignedDecodeErrorZ_OK extends Result_ClosingSignedDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ClosingSignedDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _closingSignedMjs.ClosingSigned(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ClosingSignedDecodeErrorZ_Err extends Result_ClosingSignedDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ClosingSignedDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/ClosingSigned.mjs":"drMrL","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dcrS6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The minimum and maximum fees which the sender is willing to place on the closing transaction.
 * This is provided in [`ClosingSigned`] by both sides to indicate the fee range they are willing
 * to use.
 */ parcelHelpers.export(exports, "ClosingSignedFeeRange", ()=>ClosingSignedFeeRange
) //# sourceMappingURL=ClosingSignedFeeRange.mjs.map
;
var _resultClosingSignedFeeRangeDecodeErrorZMjs = require("../structs/Result_ClosingSignedFeeRangeDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ClosingSignedFeeRange extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ClosingSignedFeeRange_free);
    }
    /**
     * The minimum absolute fee, in satoshis, which the sender is willing to place on the closing
     * transaction.
     */ get_min_fee_satoshis() {
        const ret = _bindingsMjs.ClosingSignedFeeRange_get_min_fee_satoshis(this.ptr);
        return ret;
    }
    /**
     * The minimum absolute fee, in satoshis, which the sender is willing to place on the closing
     * transaction.
     */ set_min_fee_satoshis(val) {
        _bindingsMjs.ClosingSignedFeeRange_set_min_fee_satoshis(this.ptr, val);
    }
    /**
     * The maximum absolute fee, in satoshis, which the sender is willing to place on the closing
     * transaction.
     */ get_max_fee_satoshis() {
        const ret = _bindingsMjs.ClosingSignedFeeRange_get_max_fee_satoshis(this.ptr);
        return ret;
    }
    /**
     * The maximum absolute fee, in satoshis, which the sender is willing to place on the closing
     * transaction.
     */ set_max_fee_satoshis(val) {
        _bindingsMjs.ClosingSignedFeeRange_set_max_fee_satoshis(this.ptr, val);
    }
    /**
     * Constructs a new ClosingSignedFeeRange given each field
     */ static constructor_new(min_fee_satoshis_arg, max_fee_satoshis_arg) {
        const ret = _bindingsMjs.ClosingSignedFeeRange_new(min_fee_satoshis_arg, max_fee_satoshis_arg);
        const ret_hu_conv = new ClosingSignedFeeRange(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ClosingSignedFeeRange_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ClosingSignedFeeRange
     */ clone() {
        const ret = _bindingsMjs.ClosingSignedFeeRange_clone(this.ptr);
        const ret_hu_conv = new ClosingSignedFeeRange(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the ClosingSignedFeeRange object into a byte array which can be read by ClosingSignedFeeRange_read
     */ write() {
        const ret = _bindingsMjs.ClosingSignedFeeRange_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ClosingSignedFeeRange from a byte array, created by ClosingSignedFeeRange_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ClosingSignedFeeRange_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultClosingSignedFeeRangeDecodeErrorZMjs.Result_ClosingSignedFeeRangeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_ClosingSignedFeeRangeDecodeErrorZ.mjs":"ljdvx","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ljdvx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ClosingSignedFeeRangeDecodeErrorZ", ()=>Result_ClosingSignedFeeRangeDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ClosingSignedFeeRangeDecodeErrorZ_OK", ()=>Result_ClosingSignedFeeRangeDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ClosingSignedFeeRangeDecodeErrorZ_Err", ()=>Result_ClosingSignedFeeRangeDecodeErrorZ_Err
) //# sourceMappingURL=Result_ClosingSignedFeeRangeDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _closingSignedFeeRangeMjs = require("../structs/ClosingSignedFeeRange.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ClosingSignedFeeRangeDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ClosingSignedFeeRangeDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(ptr)) return new Result_ClosingSignedFeeRangeDecodeErrorZ_OK(null, ptr);
        else return new Result_ClosingSignedFeeRangeDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ClosingSignedFeeRangeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ClosingSignedFeeRangeDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ClosingSignedFeeRangeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_ClosingSignedFeeRangeDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_ClosingSignedFeeRangeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_ClosingSignedFeeRangeDecodeErrorZ_OK extends Result_ClosingSignedFeeRangeDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ClosingSignedFeeRangeDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _closingSignedFeeRangeMjs.ClosingSignedFeeRange(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ClosingSignedFeeRangeDecodeErrorZ_Err extends Result_ClosingSignedFeeRangeDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ClosingSignedFeeRangeDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/ClosingSignedFeeRange.mjs":"dcrS6","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3oLVK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A shutdown message to be sent or received from a peer
 */ parcelHelpers.export(exports, "Shutdown", ()=>Shutdown
) //# sourceMappingURL=Shutdown.mjs.map
;
var _resultShutdownDecodeErrorZMjs = require("../structs/Result_ShutdownDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Shutdown extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Shutdown_free);
    }
    /**
     * The channel ID
     */ get_channel_id() {
        const ret = _bindingsMjs.Shutdown_get_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The channel ID
     */ set_channel_id(val) {
        _bindingsMjs.Shutdown_set_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The destination of this peer's funds on closing.
     * Must be in one of these forms: p2pkh, p2sh, p2wpkh, p2wsh.
     */ get_scriptpubkey() {
        const ret = _bindingsMjs.Shutdown_get_scriptpubkey(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The destination of this peer's funds on closing.
     * Must be in one of these forms: p2pkh, p2sh, p2wpkh, p2wsh.
     */ set_scriptpubkey(val) {
        _bindingsMjs.Shutdown_set_scriptpubkey(this.ptr, _bindingsMjs.encodeUint8Array(val));
    }
    /**
     * Constructs a new Shutdown given each field
     */ static constructor_new(channel_id_arg, scriptpubkey_arg) {
        const ret = _bindingsMjs.Shutdown_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_id_arg, 32)), _bindingsMjs.encodeUint8Array(scriptpubkey_arg));
        const ret_hu_conv = new Shutdown(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.Shutdown_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the Shutdown
     */ clone() {
        const ret = _bindingsMjs.Shutdown_clone(this.ptr);
        const ret_hu_conv = new Shutdown(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the Shutdown object into a byte array which can be read by Shutdown_read
     */ write() {
        const ret = _bindingsMjs.Shutdown_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a Shutdown from a byte array, created by Shutdown_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.Shutdown_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultShutdownDecodeErrorZMjs.Result_ShutdownDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_ShutdownDecodeErrorZ.mjs":"4YNVE","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4YNVE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ShutdownDecodeErrorZ", ()=>Result_ShutdownDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ShutdownDecodeErrorZ_OK", ()=>Result_ShutdownDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ShutdownDecodeErrorZ_Err", ()=>Result_ShutdownDecodeErrorZ_Err
) //# sourceMappingURL=Result_ShutdownDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _shutdownMjs = require("../structs/Shutdown.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ShutdownDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ShutdownDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ShutdownDecodeErrorZ_is_ok(ptr)) return new Result_ShutdownDecodeErrorZ_OK(null, ptr);
        else return new Result_ShutdownDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ShutdownDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ShutdownDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ShutdownDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ShutdownDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ShutdownDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ShutdownDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ShutdownDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_ShutdownDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_ShutdownDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_ShutdownDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_ShutdownDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_ShutdownDecodeErrorZ_OK extends Result_ShutdownDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ShutdownDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _shutdownMjs.Shutdown(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ShutdownDecodeErrorZ_Err extends Result_ShutdownDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ShutdownDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/Shutdown.mjs":"3oLVK","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1pMS7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A channel_reestablish message to be sent or received from a peer
 */ parcelHelpers.export(exports, "ChannelReestablish", ()=>ChannelReestablish
) //# sourceMappingURL=ChannelReestablish.mjs.map
;
var _resultChannelReestablishDecodeErrorZMjs = require("../structs/Result_ChannelReestablishDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelReestablish extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelReestablish_free);
    }
    /**
     * The channel ID
     */ get_channel_id() {
        const ret = _bindingsMjs.ChannelReestablish_get_channel_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The channel ID
     */ set_channel_id(val) {
        _bindingsMjs.ChannelReestablish_set_channel_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The next commitment number for the sender
     */ get_next_local_commitment_number() {
        const ret = _bindingsMjs.ChannelReestablish_get_next_local_commitment_number(this.ptr);
        return ret;
    }
    /**
     * The next commitment number for the sender
     */ set_next_local_commitment_number(val) {
        _bindingsMjs.ChannelReestablish_set_next_local_commitment_number(this.ptr, val);
    }
    /**
     * The next commitment number for the recipient
     */ get_next_remote_commitment_number() {
        const ret = _bindingsMjs.ChannelReestablish_get_next_remote_commitment_number(this.ptr);
        return ret;
    }
    /**
     * The next commitment number for the recipient
     */ set_next_remote_commitment_number(val) {
        _bindingsMjs.ChannelReestablish_set_next_remote_commitment_number(this.ptr, val);
    }
    clone_ptr() {
        const ret = _bindingsMjs.ChannelReestablish_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelReestablish
     */ clone() {
        const ret = _bindingsMjs.ChannelReestablish_clone(this.ptr);
        const ret_hu_conv = new ChannelReestablish(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the ChannelReestablish object into a byte array which can be read by ChannelReestablish_read
     */ write() {
        const ret = _bindingsMjs.ChannelReestablish_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ChannelReestablish from a byte array, created by ChannelReestablish_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ChannelReestablish_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultChannelReestablishDecodeErrorZMjs.Result_ChannelReestablishDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_ChannelReestablishDecodeErrorZ.mjs":"c5iVY","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c5iVY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ChannelReestablishDecodeErrorZ", ()=>Result_ChannelReestablishDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ChannelReestablishDecodeErrorZ_OK", ()=>Result_ChannelReestablishDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ChannelReestablishDecodeErrorZ_Err", ()=>Result_ChannelReestablishDecodeErrorZ_Err
) //# sourceMappingURL=Result_ChannelReestablishDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _channelReestablishMjs = require("../structs/ChannelReestablish.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ChannelReestablishDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ChannelReestablishDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ChannelReestablishDecodeErrorZ_is_ok(ptr)) return new Result_ChannelReestablishDecodeErrorZ_OK(null, ptr);
        else return new Result_ChannelReestablishDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ChannelReestablishDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ChannelReestablishDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ChannelReestablishDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ChannelReestablishDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ChannelReestablishDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ChannelReestablishDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ChannelReestablishDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_ChannelReestablishDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_ChannelReestablishDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_ChannelReestablishDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_ChannelReestablishDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_ChannelReestablishDecodeErrorZ_OK extends Result_ChannelReestablishDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ChannelReestablishDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _channelReestablishMjs.ChannelReestablish(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ChannelReestablishDecodeErrorZ_Err extends Result_ChannelReestablishDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ChannelReestablishDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/ChannelReestablish.mjs":"1pMS7","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5JqYl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A channel_announcement message to be sent or received from a peer
 */ parcelHelpers.export(exports, "ChannelAnnouncement", ()=>ChannelAnnouncement
) //# sourceMappingURL=ChannelAnnouncement.mjs.map
;
var _unsignedChannelAnnouncementMjs = require("../structs/UnsignedChannelAnnouncement.mjs");
var _resultChannelAnnouncementDecodeErrorZMjs = require("../structs/Result_ChannelAnnouncementDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelAnnouncement extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelAnnouncement_free);
    }
    /**
     * Authentication of the announcement by the first public node
     */ get_node_signature_1() {
        const ret = _bindingsMjs.ChannelAnnouncement_get_node_signature_1(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Authentication of the announcement by the first public node
     */ set_node_signature_1(val) {
        _bindingsMjs.ChannelAnnouncement_set_node_signature_1(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 64)));
    }
    /**
     * Authentication of the announcement by the second public node
     */ get_node_signature_2() {
        const ret = _bindingsMjs.ChannelAnnouncement_get_node_signature_2(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Authentication of the announcement by the second public node
     */ set_node_signature_2(val) {
        _bindingsMjs.ChannelAnnouncement_set_node_signature_2(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 64)));
    }
    /**
     * Proof of funding UTXO ownership by the first public node
     */ get_bitcoin_signature_1() {
        const ret = _bindingsMjs.ChannelAnnouncement_get_bitcoin_signature_1(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Proof of funding UTXO ownership by the first public node
     */ set_bitcoin_signature_1(val) {
        _bindingsMjs.ChannelAnnouncement_set_bitcoin_signature_1(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 64)));
    }
    /**
     * Proof of funding UTXO ownership by the second public node
     */ get_bitcoin_signature_2() {
        const ret = _bindingsMjs.ChannelAnnouncement_get_bitcoin_signature_2(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Proof of funding UTXO ownership by the second public node
     */ set_bitcoin_signature_2(val) {
        _bindingsMjs.ChannelAnnouncement_set_bitcoin_signature_2(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 64)));
    }
    /**
     * The actual announcement
     */ get_contents() {
        const ret = _bindingsMjs.ChannelAnnouncement_get_contents(this.ptr);
        const ret_hu_conv = new _unsignedChannelAnnouncementMjs.UnsignedChannelAnnouncement(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The actual announcement
     */ set_contents(val) {
        _bindingsMjs.ChannelAnnouncement_set_contents(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Constructs a new ChannelAnnouncement given each field
     */ static constructor_new(node_signature_1_arg, node_signature_2_arg, bitcoin_signature_1_arg, bitcoin_signature_2_arg, contents_arg) {
        const ret = _bindingsMjs.ChannelAnnouncement_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_signature_1_arg, 64)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_signature_2_arg, 64)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(bitcoin_signature_1_arg, 64)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(bitcoin_signature_2_arg, 64)), contents_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(contents_arg) & -2);
        const ret_hu_conv = new ChannelAnnouncement(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ChannelAnnouncement_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelAnnouncement
     */ clone() {
        const ret = _bindingsMjs.ChannelAnnouncement_clone(this.ptr);
        const ret_hu_conv = new ChannelAnnouncement(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the ChannelAnnouncement object into a byte array which can be read by ChannelAnnouncement_read
     */ write() {
        const ret = _bindingsMjs.ChannelAnnouncement_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ChannelAnnouncement from a byte array, created by ChannelAnnouncement_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ChannelAnnouncement_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultChannelAnnouncementDecodeErrorZMjs.Result_ChannelAnnouncementDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/UnsignedChannelAnnouncement.mjs":"bwq1O","../structs/Result_ChannelAnnouncementDecodeErrorZ.mjs":"8Xlge","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Xlge":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ChannelAnnouncementDecodeErrorZ", ()=>Result_ChannelAnnouncementDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ChannelAnnouncementDecodeErrorZ_OK", ()=>Result_ChannelAnnouncementDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ChannelAnnouncementDecodeErrorZ_Err", ()=>Result_ChannelAnnouncementDecodeErrorZ_Err
) //# sourceMappingURL=Result_ChannelAnnouncementDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _channelAnnouncementMjs = require("../structs/ChannelAnnouncement.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ChannelAnnouncementDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ChannelAnnouncementDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ChannelAnnouncementDecodeErrorZ_is_ok(ptr)) return new Result_ChannelAnnouncementDecodeErrorZ_OK(null, ptr);
        else return new Result_ChannelAnnouncementDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ChannelAnnouncementDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ChannelAnnouncementDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ChannelAnnouncementDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ChannelAnnouncementDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ChannelAnnouncementDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ChannelAnnouncementDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ChannelAnnouncementDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_ChannelAnnouncementDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_ChannelAnnouncementDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_ChannelAnnouncementDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_ChannelAnnouncementDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_ChannelAnnouncementDecodeErrorZ_OK extends Result_ChannelAnnouncementDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ChannelAnnouncementDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _channelAnnouncementMjs.ChannelAnnouncement(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ChannelAnnouncementDecodeErrorZ_Err extends Result_ChannelAnnouncementDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ChannelAnnouncementDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/ChannelAnnouncement.mjs":"5JqYl","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"549dY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A node_announcement message to be sent or received from a peer
 */ parcelHelpers.export(exports, "NodeAnnouncement", ()=>NodeAnnouncement
) //# sourceMappingURL=NodeAnnouncement.mjs.map
;
var _unsignedNodeAnnouncementMjs = require("../structs/UnsignedNodeAnnouncement.mjs");
var _resultNodeAnnouncementDecodeErrorZMjs = require("../structs/Result_NodeAnnouncementDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class NodeAnnouncement extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.NodeAnnouncement_free);
    }
    /**
     * The signature by the node key
     */ get_signature() {
        const ret = _bindingsMjs.NodeAnnouncement_get_signature(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The signature by the node key
     */ set_signature(val) {
        _bindingsMjs.NodeAnnouncement_set_signature(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 64)));
    }
    /**
     * The actual content of the announcement
     */ get_contents() {
        const ret = _bindingsMjs.NodeAnnouncement_get_contents(this.ptr);
        const ret_hu_conv = new _unsignedNodeAnnouncementMjs.UnsignedNodeAnnouncement(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The actual content of the announcement
     */ set_contents(val) {
        _bindingsMjs.NodeAnnouncement_set_contents(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Constructs a new NodeAnnouncement given each field
     */ static constructor_new(signature_arg, contents_arg) {
        const ret = _bindingsMjs.NodeAnnouncement_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(signature_arg, 64)), contents_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(contents_arg) & -2);
        const ret_hu_conv = new NodeAnnouncement(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.NodeAnnouncement_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the NodeAnnouncement
     */ clone() {
        const ret = _bindingsMjs.NodeAnnouncement_clone(this.ptr);
        const ret_hu_conv = new NodeAnnouncement(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the NodeAnnouncement object into a byte array which can be read by NodeAnnouncement_read
     */ write() {
        const ret = _bindingsMjs.NodeAnnouncement_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a NodeAnnouncement from a byte array, created by NodeAnnouncement_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.NodeAnnouncement_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultNodeAnnouncementDecodeErrorZMjs.Result_NodeAnnouncementDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/UnsignedNodeAnnouncement.mjs":"7Y2hY","../structs/Result_NodeAnnouncementDecodeErrorZ.mjs":"4ZWeG","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Y2hY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The unsigned part of a node_announcement
 */ parcelHelpers.export(exports, "UnsignedNodeAnnouncement", ()=>UnsignedNodeAnnouncement
) //# sourceMappingURL=UnsignedNodeAnnouncement.mjs.map
;
var _nodeFeaturesMjs = require("../structs/NodeFeatures.mjs");
var _resultUnsignedNodeAnnouncementDecodeErrorZMjs = require("../structs/Result_UnsignedNodeAnnouncementDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class UnsignedNodeAnnouncement extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.UnsignedNodeAnnouncement_free);
    }
    /**
     * The advertised features
     */ get_features() {
        const ret = _bindingsMjs.UnsignedNodeAnnouncement_get_features(this.ptr);
        const ret_hu_conv = new _nodeFeaturesMjs.NodeFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The advertised features
     */ set_features(val) {
        _bindingsMjs.UnsignedNodeAnnouncement_set_features(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * A strictly monotonic announcement counter, with gaps allowed
     */ get_timestamp() {
        const ret = _bindingsMjs.UnsignedNodeAnnouncement_get_timestamp(this.ptr);
        return ret;
    }
    /**
     * A strictly monotonic announcement counter, with gaps allowed
     */ set_timestamp(val) {
        _bindingsMjs.UnsignedNodeAnnouncement_set_timestamp(this.ptr, val);
    }
    /**
     * The node_id this announcement originated from (don't rebroadcast the node_announcement back
     * to this node).
     */ get_node_id() {
        const ret = _bindingsMjs.UnsignedNodeAnnouncement_get_node_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The node_id this announcement originated from (don't rebroadcast the node_announcement back
     * to this node).
     */ set_node_id(val) {
        _bindingsMjs.UnsignedNodeAnnouncement_set_node_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * An RGB color for UI purposes
     */ get_rgb() {
        const ret = _bindingsMjs.UnsignedNodeAnnouncement_get_rgb(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * An RGB color for UI purposes
     */ set_rgb(val) {
        _bindingsMjs.UnsignedNodeAnnouncement_set_rgb(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 3)));
    }
    /**
     * An alias, for UI purposes.  This should be sanitized before use.  There is no guarantee
     * of uniqueness.
     */ get_alias() {
        const ret = _bindingsMjs.UnsignedNodeAnnouncement_get_alias(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * An alias, for UI purposes.  This should be sanitized before use.  There is no guarantee
     * of uniqueness.
     */ set_alias(val) {
        _bindingsMjs.UnsignedNodeAnnouncement_set_alias(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * List of addresses on which this node is reachable
     */ set_addresses(val) {
        _bindingsMjs.UnsignedNodeAnnouncement_set_addresses(this.ptr, _bindingsMjs.encodeUint32Array(val != null ? val.map((val_conv_12)=>_commonBaseMjsDefault.default.get_ptr_of(val_conv_12)
        ) : null));
    }
    clone_ptr() {
        const ret = _bindingsMjs.UnsignedNodeAnnouncement_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the UnsignedNodeAnnouncement
     */ clone() {
        const ret = _bindingsMjs.UnsignedNodeAnnouncement_clone(this.ptr);
        const ret_hu_conv = new UnsignedNodeAnnouncement(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the UnsignedNodeAnnouncement object into a byte array which can be read by UnsignedNodeAnnouncement_read
     */ write() {
        const ret = _bindingsMjs.UnsignedNodeAnnouncement_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a UnsignedNodeAnnouncement from a byte array, created by UnsignedNodeAnnouncement_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.UnsignedNodeAnnouncement_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultUnsignedNodeAnnouncementDecodeErrorZMjs.Result_UnsignedNodeAnnouncementDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/NodeFeatures.mjs":"8eCA6","../structs/Result_UnsignedNodeAnnouncementDecodeErrorZ.mjs":"45jo9","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"45jo9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_UnsignedNodeAnnouncementDecodeErrorZ", ()=>Result_UnsignedNodeAnnouncementDecodeErrorZ
);
parcelHelpers.export(exports, "Result_UnsignedNodeAnnouncementDecodeErrorZ_OK", ()=>Result_UnsignedNodeAnnouncementDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_UnsignedNodeAnnouncementDecodeErrorZ_Err", ()=>Result_UnsignedNodeAnnouncementDecodeErrorZ_Err
) //# sourceMappingURL=Result_UnsignedNodeAnnouncementDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _unsignedNodeAnnouncementMjs = require("../structs/UnsignedNodeAnnouncement.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_UnsignedNodeAnnouncementDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_UnsignedNodeAnnouncementDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(ptr)) return new Result_UnsignedNodeAnnouncementDecodeErrorZ_OK(null, ptr);
        else return new Result_UnsignedNodeAnnouncementDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_UnsignedNodeAnnouncementDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_UnsignedNodeAnnouncementDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_UnsignedNodeAnnouncementDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_UnsignedNodeAnnouncementDecodeErrorZ_OK extends Result_UnsignedNodeAnnouncementDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _unsignedNodeAnnouncementMjs.UnsignedNodeAnnouncement(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_UnsignedNodeAnnouncementDecodeErrorZ_Err extends Result_UnsignedNodeAnnouncementDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/UnsignedNodeAnnouncement.mjs":"7Y2hY","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4ZWeG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_NodeAnnouncementDecodeErrorZ", ()=>Result_NodeAnnouncementDecodeErrorZ
);
parcelHelpers.export(exports, "Result_NodeAnnouncementDecodeErrorZ_OK", ()=>Result_NodeAnnouncementDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_NodeAnnouncementDecodeErrorZ_Err", ()=>Result_NodeAnnouncementDecodeErrorZ_Err
) //# sourceMappingURL=Result_NodeAnnouncementDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _nodeAnnouncementMjs = require("../structs/NodeAnnouncement.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_NodeAnnouncementDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_NodeAnnouncementDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_NodeAnnouncementDecodeErrorZ_is_ok(ptr)) return new Result_NodeAnnouncementDecodeErrorZ_OK(null, ptr);
        else return new Result_NodeAnnouncementDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_NodeAnnouncementDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_NodeAnnouncementDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_NodeAnnouncementDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_NodeAnnouncementDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_NodeAnnouncementDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_NodeAnnouncementDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_NodeAnnouncementDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_NodeAnnouncementDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_NodeAnnouncementDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_NodeAnnouncementDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_NodeAnnouncementDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_NodeAnnouncementDecodeErrorZ_OK extends Result_NodeAnnouncementDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_NodeAnnouncementDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _nodeAnnouncementMjs.NodeAnnouncement(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_NodeAnnouncementDecodeErrorZ_Err extends Result_NodeAnnouncementDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_NodeAnnouncementDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/NodeAnnouncement.mjs":"549dY","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"83Xki":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A query_channel_range message is used to query a peer for channel
 * UTXOs in a range of blocks. The recipient of a query makes a best
 * effort to reply to the query using one or more reply_channel_range
 * messages.
 */ parcelHelpers.export(exports, "QueryChannelRange", ()=>QueryChannelRange
) //# sourceMappingURL=QueryChannelRange.mjs.map
;
var _resultQueryChannelRangeDecodeErrorZMjs = require("../structs/Result_QueryChannelRangeDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class QueryChannelRange extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.QueryChannelRange_free);
    }
    /**
     * The genesis hash of the blockchain being queried
     */ get_chain_hash() {
        const ret = _bindingsMjs.QueryChannelRange_get_chain_hash(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The genesis hash of the blockchain being queried
     */ set_chain_hash(val) {
        _bindingsMjs.QueryChannelRange_set_chain_hash(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The height of the first block for the channel UTXOs being queried
     */ get_first_blocknum() {
        const ret = _bindingsMjs.QueryChannelRange_get_first_blocknum(this.ptr);
        return ret;
    }
    /**
     * The height of the first block for the channel UTXOs being queried
     */ set_first_blocknum(val) {
        _bindingsMjs.QueryChannelRange_set_first_blocknum(this.ptr, val);
    }
    /**
     * The number of blocks to include in the query results
     */ get_number_of_blocks() {
        const ret = _bindingsMjs.QueryChannelRange_get_number_of_blocks(this.ptr);
        return ret;
    }
    /**
     * The number of blocks to include in the query results
     */ set_number_of_blocks(val) {
        _bindingsMjs.QueryChannelRange_set_number_of_blocks(this.ptr, val);
    }
    /**
     * Constructs a new QueryChannelRange given each field
     */ static constructor_new(chain_hash_arg, first_blocknum_arg, number_of_blocks_arg) {
        const ret = _bindingsMjs.QueryChannelRange_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(chain_hash_arg, 32)), first_blocknum_arg, number_of_blocks_arg);
        const ret_hu_conv = new QueryChannelRange(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.QueryChannelRange_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the QueryChannelRange
     */ clone() {
        const ret = _bindingsMjs.QueryChannelRange_clone(this.ptr);
        const ret_hu_conv = new QueryChannelRange(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * \n\t * Calculates the overflow safe ending block height for the query.\n\t * Overflow returns `0xffffffff`, otherwise returns `first_blocknum + number_of_blocks`\n\t
     */ end_blocknum() {
        const ret = _bindingsMjs.QueryChannelRange_end_blocknum(this.ptr);
        return ret;
    }
    /**
     * Serialize the QueryChannelRange object into a byte array which can be read by QueryChannelRange_read
     */ write() {
        const ret = _bindingsMjs.QueryChannelRange_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a QueryChannelRange from a byte array, created by QueryChannelRange_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.QueryChannelRange_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultQueryChannelRangeDecodeErrorZMjs.Result_QueryChannelRangeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_QueryChannelRangeDecodeErrorZ.mjs":"iNK5Y","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iNK5Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_QueryChannelRangeDecodeErrorZ", ()=>Result_QueryChannelRangeDecodeErrorZ
);
parcelHelpers.export(exports, "Result_QueryChannelRangeDecodeErrorZ_OK", ()=>Result_QueryChannelRangeDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_QueryChannelRangeDecodeErrorZ_Err", ()=>Result_QueryChannelRangeDecodeErrorZ_Err
) //# sourceMappingURL=Result_QueryChannelRangeDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _queryChannelRangeMjs = require("../structs/QueryChannelRange.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_QueryChannelRangeDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_QueryChannelRangeDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_QueryChannelRangeDecodeErrorZ_is_ok(ptr)) return new Result_QueryChannelRangeDecodeErrorZ_OK(null, ptr);
        else return new Result_QueryChannelRangeDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_QueryChannelRangeDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_QueryChannelRangeDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_QueryChannelRangeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_QueryChannelRangeDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_QueryChannelRangeDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_QueryChannelRangeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_QueryChannelRangeDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_QueryChannelRangeDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_QueryChannelRangeDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_QueryChannelRangeDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_QueryChannelRangeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_QueryChannelRangeDecodeErrorZ_OK extends Result_QueryChannelRangeDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_QueryChannelRangeDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _queryChannelRangeMjs.QueryChannelRange(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_QueryChannelRangeDecodeErrorZ_Err extends Result_QueryChannelRangeDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_QueryChannelRangeDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/QueryChannelRange.mjs":"83Xki","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1G6O6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A query_short_channel_ids message is used to query a peer for
 * routing gossip messages related to one or more short_channel_ids.
 * The query recipient will reply with the latest, if available,
 * channel_announcement, channel_update and node_announcement messages
 * it maintains for the requested short_channel_ids followed by a
 * reply_short_channel_ids_end message. The short_channel_ids sent in
 * this query are encoded. We only support encoding_type=0 uncompressed
 * serialization and do not support encoding_type=1 zlib serialization.
 */ parcelHelpers.export(exports, "QueryShortChannelIds", ()=>QueryShortChannelIds
) //# sourceMappingURL=QueryShortChannelIds.mjs.map
;
var _resultQueryShortChannelIdsDecodeErrorZMjs = require("../structs/Result_QueryShortChannelIdsDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class QueryShortChannelIds extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.QueryShortChannelIds_free);
    }
    /**
     * The genesis hash of the blockchain being queried
     */ get_chain_hash() {
        const ret = _bindingsMjs.QueryShortChannelIds_get_chain_hash(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The genesis hash of the blockchain being queried
     */ set_chain_hash(val) {
        _bindingsMjs.QueryShortChannelIds_set_chain_hash(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The short_channel_ids that are being queried
     */ set_short_channel_ids(val) {
        _bindingsMjs.QueryShortChannelIds_set_short_channel_ids(this.ptr, _bindingsMjs.encodeUint64Array(val));
    }
    /**
     * Constructs a new QueryShortChannelIds given each field
     */ static constructor_new(chain_hash_arg, short_channel_ids_arg) {
        const ret = _bindingsMjs.QueryShortChannelIds_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(chain_hash_arg, 32)), _bindingsMjs.encodeUint64Array(short_channel_ids_arg));
        const ret_hu_conv = new QueryShortChannelIds(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.QueryShortChannelIds_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the QueryShortChannelIds
     */ clone() {
        const ret = _bindingsMjs.QueryShortChannelIds_clone(this.ptr);
        const ret_hu_conv = new QueryShortChannelIds(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Read a QueryShortChannelIds from a byte array, created by QueryShortChannelIds_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.QueryShortChannelIds_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultQueryShortChannelIdsDecodeErrorZMjs.Result_QueryShortChannelIdsDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Serialize the QueryShortChannelIds object into a byte array which can be read by QueryShortChannelIds_read
     */ write() {
        const ret = _bindingsMjs.QueryShortChannelIds_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
}

},{"../structs/Result_QueryShortChannelIdsDecodeErrorZ.mjs":"8cJrP","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8cJrP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_QueryShortChannelIdsDecodeErrorZ", ()=>Result_QueryShortChannelIdsDecodeErrorZ
);
parcelHelpers.export(exports, "Result_QueryShortChannelIdsDecodeErrorZ_OK", ()=>Result_QueryShortChannelIdsDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_QueryShortChannelIdsDecodeErrorZ_Err", ()=>Result_QueryShortChannelIdsDecodeErrorZ_Err
) //# sourceMappingURL=Result_QueryShortChannelIdsDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _queryShortChannelIdsMjs = require("../structs/QueryShortChannelIds.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_QueryShortChannelIdsDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_QueryShortChannelIdsDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(ptr)) return new Result_QueryShortChannelIdsDecodeErrorZ_OK(null, ptr);
        else return new Result_QueryShortChannelIdsDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_QueryShortChannelIdsDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_QueryShortChannelIdsDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_QueryShortChannelIdsDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_QueryShortChannelIdsDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_QueryShortChannelIdsDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_QueryShortChannelIdsDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_QueryShortChannelIdsDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_QueryShortChannelIdsDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_QueryShortChannelIdsDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_QueryShortChannelIdsDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_QueryShortChannelIdsDecodeErrorZ_OK extends Result_QueryShortChannelIdsDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_QueryShortChannelIdsDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _queryShortChannelIdsMjs.QueryShortChannelIds(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_QueryShortChannelIdsDecodeErrorZ_Err extends Result_QueryShortChannelIdsDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_QueryShortChannelIdsDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/QueryShortChannelIds.mjs":"1G6O6","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l9iKG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A reply_channel_range message is a reply to a query_channel_range
 * message. Multiple reply_channel_range messages can be sent in reply
 * to a single query_channel_range message. The query recipient makes a
 * best effort to respond based on their local network view which may
 * not be a perfect view of the network. The short_channel_ids in the
 * reply are encoded. We only support encoding_type=0 uncompressed
 * serialization and do not support encoding_type=1 zlib serialization.
 */ parcelHelpers.export(exports, "ReplyChannelRange", ()=>ReplyChannelRange
) //# sourceMappingURL=ReplyChannelRange.mjs.map
;
var _resultReplyChannelRangeDecodeErrorZMjs = require("../structs/Result_ReplyChannelRangeDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ReplyChannelRange extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ReplyChannelRange_free);
    }
    /**
     * The genesis hash of the blockchain being queried
     */ get_chain_hash() {
        const ret = _bindingsMjs.ReplyChannelRange_get_chain_hash(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The genesis hash of the blockchain being queried
     */ set_chain_hash(val) {
        _bindingsMjs.ReplyChannelRange_set_chain_hash(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The height of the first block in the range of the reply
     */ get_first_blocknum() {
        const ret = _bindingsMjs.ReplyChannelRange_get_first_blocknum(this.ptr);
        return ret;
    }
    /**
     * The height of the first block in the range of the reply
     */ set_first_blocknum(val) {
        _bindingsMjs.ReplyChannelRange_set_first_blocknum(this.ptr, val);
    }
    /**
     * The number of blocks included in the range of the reply
     */ get_number_of_blocks() {
        const ret = _bindingsMjs.ReplyChannelRange_get_number_of_blocks(this.ptr);
        return ret;
    }
    /**
     * The number of blocks included in the range of the reply
     */ set_number_of_blocks(val) {
        _bindingsMjs.ReplyChannelRange_set_number_of_blocks(this.ptr, val);
    }
    /**
     * True when this is the final reply for a query
     */ get_sync_complete() {
        const ret = _bindingsMjs.ReplyChannelRange_get_sync_complete(this.ptr);
        return ret;
    }
    /**
     * True when this is the final reply for a query
     */ set_sync_complete(val) {
        _bindingsMjs.ReplyChannelRange_set_sync_complete(this.ptr, val);
    }
    /**
     * The short_channel_ids in the channel range
     */ set_short_channel_ids(val) {
        _bindingsMjs.ReplyChannelRange_set_short_channel_ids(this.ptr, _bindingsMjs.encodeUint64Array(val));
    }
    /**
     * Constructs a new ReplyChannelRange given each field
     */ static constructor_new(chain_hash_arg, first_blocknum_arg, number_of_blocks_arg, sync_complete_arg, short_channel_ids_arg) {
        const ret = _bindingsMjs.ReplyChannelRange_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(chain_hash_arg, 32)), first_blocknum_arg, number_of_blocks_arg, sync_complete_arg, _bindingsMjs.encodeUint64Array(short_channel_ids_arg));
        const ret_hu_conv = new ReplyChannelRange(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ReplyChannelRange_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ReplyChannelRange
     */ clone() {
        const ret = _bindingsMjs.ReplyChannelRange_clone(this.ptr);
        const ret_hu_conv = new ReplyChannelRange(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Read a ReplyChannelRange from a byte array, created by ReplyChannelRange_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ReplyChannelRange_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultReplyChannelRangeDecodeErrorZMjs.Result_ReplyChannelRangeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Serialize the ReplyChannelRange object into a byte array which can be read by ReplyChannelRange_read
     */ write() {
        const ret = _bindingsMjs.ReplyChannelRange_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
}

},{"../structs/Result_ReplyChannelRangeDecodeErrorZ.mjs":"7VeWG","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7VeWG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ReplyChannelRangeDecodeErrorZ", ()=>Result_ReplyChannelRangeDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ReplyChannelRangeDecodeErrorZ_OK", ()=>Result_ReplyChannelRangeDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ReplyChannelRangeDecodeErrorZ_Err", ()=>Result_ReplyChannelRangeDecodeErrorZ_Err
) //# sourceMappingURL=Result_ReplyChannelRangeDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _replyChannelRangeMjs = require("../structs/ReplyChannelRange.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ReplyChannelRangeDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ReplyChannelRangeDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ReplyChannelRangeDecodeErrorZ_is_ok(ptr)) return new Result_ReplyChannelRangeDecodeErrorZ_OK(null, ptr);
        else return new Result_ReplyChannelRangeDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ReplyChannelRangeDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ReplyChannelRangeDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ReplyChannelRangeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ReplyChannelRangeDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ReplyChannelRangeDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ReplyChannelRangeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ReplyChannelRangeDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_ReplyChannelRangeDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_ReplyChannelRangeDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_ReplyChannelRangeDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_ReplyChannelRangeDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_ReplyChannelRangeDecodeErrorZ_OK extends Result_ReplyChannelRangeDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ReplyChannelRangeDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _replyChannelRangeMjs.ReplyChannelRange(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ReplyChannelRangeDecodeErrorZ_Err extends Result_ReplyChannelRangeDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ReplyChannelRangeDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/ReplyChannelRange.mjs":"l9iKG","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hFzDz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An event generated by ChannelManager which indicates a message should be sent to a peer (or
 * broadcast to most peers).
 * These events are handled by PeerManager::process_events if you are using a PeerManager.
 */ parcelHelpers.export(exports, "MessageSendEvent", ()=>MessageSendEvent
);
/** A MessageSendEvent of type SendAcceptChannel */ parcelHelpers.export(exports, "MessageSendEvent_SendAcceptChannel", ()=>MessageSendEvent_SendAcceptChannel
);
/** A MessageSendEvent of type SendOpenChannel */ parcelHelpers.export(exports, "MessageSendEvent_SendOpenChannel", ()=>MessageSendEvent_SendOpenChannel
);
/** A MessageSendEvent of type SendFundingCreated */ parcelHelpers.export(exports, "MessageSendEvent_SendFundingCreated", ()=>MessageSendEvent_SendFundingCreated
);
/** A MessageSendEvent of type SendFundingSigned */ parcelHelpers.export(exports, "MessageSendEvent_SendFundingSigned", ()=>MessageSendEvent_SendFundingSigned
);
/** A MessageSendEvent of type SendFundingLocked */ parcelHelpers.export(exports, "MessageSendEvent_SendFundingLocked", ()=>MessageSendEvent_SendFundingLocked
);
/** A MessageSendEvent of type SendAnnouncementSignatures */ parcelHelpers.export(exports, "MessageSendEvent_SendAnnouncementSignatures", ()=>MessageSendEvent_SendAnnouncementSignatures
);
/** A MessageSendEvent of type UpdateHTLCs */ parcelHelpers.export(exports, "MessageSendEvent_UpdateHTLCs", ()=>MessageSendEvent_UpdateHTLCs
);
/** A MessageSendEvent of type SendRevokeAndACK */ parcelHelpers.export(exports, "MessageSendEvent_SendRevokeAndACK", ()=>MessageSendEvent_SendRevokeAndACK
);
/** A MessageSendEvent of type SendClosingSigned */ parcelHelpers.export(exports, "MessageSendEvent_SendClosingSigned", ()=>MessageSendEvent_SendClosingSigned
);
/** A MessageSendEvent of type SendShutdown */ parcelHelpers.export(exports, "MessageSendEvent_SendShutdown", ()=>MessageSendEvent_SendShutdown
);
/** A MessageSendEvent of type SendChannelReestablish */ parcelHelpers.export(exports, "MessageSendEvent_SendChannelReestablish", ()=>MessageSendEvent_SendChannelReestablish
);
/** A MessageSendEvent of type BroadcastChannelAnnouncement */ parcelHelpers.export(exports, "MessageSendEvent_BroadcastChannelAnnouncement", ()=>MessageSendEvent_BroadcastChannelAnnouncement
);
/** A MessageSendEvent of type BroadcastNodeAnnouncement */ parcelHelpers.export(exports, "MessageSendEvent_BroadcastNodeAnnouncement", ()=>MessageSendEvent_BroadcastNodeAnnouncement
);
/** A MessageSendEvent of type BroadcastChannelUpdate */ parcelHelpers.export(exports, "MessageSendEvent_BroadcastChannelUpdate", ()=>MessageSendEvent_BroadcastChannelUpdate
);
/** A MessageSendEvent of type SendChannelUpdate */ parcelHelpers.export(exports, "MessageSendEvent_SendChannelUpdate", ()=>MessageSendEvent_SendChannelUpdate
);
/** A MessageSendEvent of type HandleError */ parcelHelpers.export(exports, "MessageSendEvent_HandleError", ()=>MessageSendEvent_HandleError
);
/** A MessageSendEvent of type SendChannelRangeQuery */ parcelHelpers.export(exports, "MessageSendEvent_SendChannelRangeQuery", ()=>MessageSendEvent_SendChannelRangeQuery
);
/** A MessageSendEvent of type SendShortIdsQuery */ parcelHelpers.export(exports, "MessageSendEvent_SendShortIdsQuery", ()=>MessageSendEvent_SendShortIdsQuery
);
/** A MessageSendEvent of type SendReplyChannelRange */ parcelHelpers.export(exports, "MessageSendEvent_SendReplyChannelRange", ()=>MessageSendEvent_SendReplyChannelRange
) //# sourceMappingURL=MessageSendEvent.mjs.map
;
var _channelUpdateMjs = require("../structs/ChannelUpdate.mjs");
var _acceptChannelMjs = require("../structs/AcceptChannel.mjs");
var _openChannelMjs = require("../structs/OpenChannel.mjs");
var _fundingCreatedMjs = require("../structs/FundingCreated.mjs");
var _fundingSignedMjs = require("../structs/FundingSigned.mjs");
var _fundingLockedMjs = require("../structs/FundingLocked.mjs");
var _announcementSignaturesMjs = require("../structs/AnnouncementSignatures.mjs");
var _commitmentUpdateMjs = require("../structs/CommitmentUpdate.mjs");
var _revokeAndACKMjs = require("../structs/RevokeAndACK.mjs");
var _closingSignedMjs = require("../structs/ClosingSigned.mjs");
var _shutdownMjs = require("../structs/Shutdown.mjs");
var _channelReestablishMjs = require("../structs/ChannelReestablish.mjs");
var _channelAnnouncementMjs = require("../structs/ChannelAnnouncement.mjs");
var _nodeAnnouncementMjs = require("../structs/NodeAnnouncement.mjs");
var _errorActionMjs = require("../structs/ErrorAction.mjs");
var _queryChannelRangeMjs = require("../structs/QueryChannelRange.mjs");
var _queryShortChannelIdsMjs = require("../structs/QueryShortChannelIds.mjs");
var _replyChannelRangeMjs = require("../structs/ReplyChannelRange.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class MessageSendEvent extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.MessageSendEvent_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKMessageSendEvent_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new MessageSendEvent_SendAcceptChannel(ptr);
            case 1:
                return new MessageSendEvent_SendOpenChannel(ptr);
            case 2:
                return new MessageSendEvent_SendFundingCreated(ptr);
            case 3:
                return new MessageSendEvent_SendFundingSigned(ptr);
            case 4:
                return new MessageSendEvent_SendFundingLocked(ptr);
            case 5:
                return new MessageSendEvent_SendAnnouncementSignatures(ptr);
            case 6:
                return new MessageSendEvent_UpdateHTLCs(ptr);
            case 7:
                return new MessageSendEvent_SendRevokeAndACK(ptr);
            case 8:
                return new MessageSendEvent_SendClosingSigned(ptr);
            case 9:
                return new MessageSendEvent_SendShutdown(ptr);
            case 10:
                return new MessageSendEvent_SendChannelReestablish(ptr);
            case 11:
                return new MessageSendEvent_BroadcastChannelAnnouncement(ptr);
            case 12:
                return new MessageSendEvent_BroadcastNodeAnnouncement(ptr);
            case 13:
                return new MessageSendEvent_BroadcastChannelUpdate(ptr);
            case 14:
                return new MessageSendEvent_SendChannelUpdate(ptr);
            case 15:
                return new MessageSendEvent_HandleError(ptr);
            case 16:
                return new MessageSendEvent_SendChannelRangeQuery(ptr);
            case 17:
                return new MessageSendEvent_SendShortIdsQuery(ptr);
            case 18:
                return new MessageSendEvent_SendReplyChannelRange(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = _bindingsMjs.MessageSendEvent_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the MessageSendEvent
     */ clone() {
        const ret = _bindingsMjs.MessageSendEvent_clone(this.ptr);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SendAcceptChannel-variant MessageSendEvent
     */ static constructor_send_accept_channel(node_id, msg) {
        const ret = _bindingsMjs.MessageSendEvent_send_accept_channel(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SendOpenChannel-variant MessageSendEvent
     */ static constructor_send_open_channel(node_id, msg) {
        const ret = _bindingsMjs.MessageSendEvent_send_open_channel(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SendFundingCreated-variant MessageSendEvent
     */ static constructor_send_funding_created(node_id, msg) {
        const ret = _bindingsMjs.MessageSendEvent_send_funding_created(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SendFundingSigned-variant MessageSendEvent
     */ static constructor_send_funding_signed(node_id, msg) {
        const ret = _bindingsMjs.MessageSendEvent_send_funding_signed(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SendFundingLocked-variant MessageSendEvent
     */ static constructor_send_funding_locked(node_id, msg) {
        const ret = _bindingsMjs.MessageSendEvent_send_funding_locked(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SendAnnouncementSignatures-variant MessageSendEvent
     */ static constructor_send_announcement_signatures(node_id, msg) {
        const ret = _bindingsMjs.MessageSendEvent_send_announcement_signatures(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new UpdateHTLCs-variant MessageSendEvent
     */ static constructor_update_htlcs(node_id, updates) {
        const ret = _bindingsMjs.MessageSendEvent_update_htlcs(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), updates == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(updates) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SendRevokeAndACK-variant MessageSendEvent
     */ static constructor_send_revoke_and_ack(node_id, msg) {
        const ret = _bindingsMjs.MessageSendEvent_send_revoke_and_ack(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SendClosingSigned-variant MessageSendEvent
     */ static constructor_send_closing_signed(node_id, msg) {
        const ret = _bindingsMjs.MessageSendEvent_send_closing_signed(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SendShutdown-variant MessageSendEvent
     */ static constructor_send_shutdown(node_id, msg) {
        const ret = _bindingsMjs.MessageSendEvent_send_shutdown(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SendChannelReestablish-variant MessageSendEvent
     */ static constructor_send_channel_reestablish(node_id, msg) {
        const ret = _bindingsMjs.MessageSendEvent_send_channel_reestablish(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new BroadcastChannelAnnouncement-variant MessageSendEvent
     */ static constructor_broadcast_channel_announcement(msg, update_msg) {
        const ret = _bindingsMjs.MessageSendEvent_broadcast_channel_announcement(msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2, update_msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(update_msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new BroadcastNodeAnnouncement-variant MessageSendEvent
     */ static constructor_broadcast_node_announcement(msg) {
        const ret = _bindingsMjs.MessageSendEvent_broadcast_node_announcement(msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new BroadcastChannelUpdate-variant MessageSendEvent
     */ static constructor_broadcast_channel_update(msg) {
        const ret = _bindingsMjs.MessageSendEvent_broadcast_channel_update(msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SendChannelUpdate-variant MessageSendEvent
     */ static constructor_send_channel_update(node_id, msg) {
        const ret = _bindingsMjs.MessageSendEvent_send_channel_update(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new HandleError-variant MessageSendEvent
     */ static constructor_handle_error(node_id, action) {
        const ret = _bindingsMjs.MessageSendEvent_handle_error(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), _commonBaseMjsDefault.default.get_ptr_of(action));
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SendChannelRangeQuery-variant MessageSendEvent
     */ static constructor_send_channel_range_query(node_id, msg) {
        const ret = _bindingsMjs.MessageSendEvent_send_channel_range_query(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SendShortIdsQuery-variant MessageSendEvent
     */ static constructor_send_short_ids_query(node_id, msg) {
        const ret = _bindingsMjs.MessageSendEvent_send_short_ids_query(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new SendReplyChannelRange-variant MessageSendEvent
     */ static constructor_send_reply_channel_range(node_id, msg) {
        const ret = _bindingsMjs.MessageSendEvent_send_reply_channel_range(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = MessageSendEvent.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}
class MessageSendEvent_SendAcceptChannel extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKMessageSendEvent_SendAcceptChannel_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        const msg = _bindingsMjs.LDKMessageSendEvent_SendAcceptChannel_get_msg(ptr);
        const msg_hu_conv = new _acceptChannelMjs.AcceptChannel(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class MessageSendEvent_SendOpenChannel extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKMessageSendEvent_SendOpenChannel_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        const msg = _bindingsMjs.LDKMessageSendEvent_SendOpenChannel_get_msg(ptr);
        const msg_hu_conv = new _openChannelMjs.OpenChannel(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class MessageSendEvent_SendFundingCreated extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKMessageSendEvent_SendFundingCreated_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        const msg = _bindingsMjs.LDKMessageSendEvent_SendFundingCreated_get_msg(ptr);
        const msg_hu_conv = new _fundingCreatedMjs.FundingCreated(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class MessageSendEvent_SendFundingSigned extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKMessageSendEvent_SendFundingSigned_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        const msg = _bindingsMjs.LDKMessageSendEvent_SendFundingSigned_get_msg(ptr);
        const msg_hu_conv = new _fundingSignedMjs.FundingSigned(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class MessageSendEvent_SendFundingLocked extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKMessageSendEvent_SendFundingLocked_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        const msg = _bindingsMjs.LDKMessageSendEvent_SendFundingLocked_get_msg(ptr);
        const msg_hu_conv = new _fundingLockedMjs.FundingLocked(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class MessageSendEvent_SendAnnouncementSignatures extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKMessageSendEvent_SendAnnouncementSignatures_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        const msg = _bindingsMjs.LDKMessageSendEvent_SendAnnouncementSignatures_get_msg(ptr);
        const msg_hu_conv = new _announcementSignaturesMjs.AnnouncementSignatures(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class MessageSendEvent_UpdateHTLCs extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKMessageSendEvent_UpdateHTLCs_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        const updates = _bindingsMjs.LDKMessageSendEvent_UpdateHTLCs_get_updates(ptr);
        const updates_hu_conv = new _commitmentUpdateMjs.CommitmentUpdate(null, updates);
        _commonBaseMjsDefault.default.add_ref_from(updates_hu_conv, this);
        this.updates = updates_hu_conv;
    }
}
class MessageSendEvent_SendRevokeAndACK extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKMessageSendEvent_SendRevokeAndACK_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        const msg = _bindingsMjs.LDKMessageSendEvent_SendRevokeAndACK_get_msg(ptr);
        const msg_hu_conv = new _revokeAndACKMjs.RevokeAndACK(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class MessageSendEvent_SendClosingSigned extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKMessageSendEvent_SendClosingSigned_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        const msg = _bindingsMjs.LDKMessageSendEvent_SendClosingSigned_get_msg(ptr);
        const msg_hu_conv = new _closingSignedMjs.ClosingSigned(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class MessageSendEvent_SendShutdown extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKMessageSendEvent_SendShutdown_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        const msg = _bindingsMjs.LDKMessageSendEvent_SendShutdown_get_msg(ptr);
        const msg_hu_conv = new _shutdownMjs.Shutdown(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class MessageSendEvent_SendChannelReestablish extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKMessageSendEvent_SendChannelReestablish_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        const msg = _bindingsMjs.LDKMessageSendEvent_SendChannelReestablish_get_msg(ptr);
        const msg_hu_conv = new _channelReestablishMjs.ChannelReestablish(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class MessageSendEvent_BroadcastChannelAnnouncement extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const msg = _bindingsMjs.LDKMessageSendEvent_BroadcastChannelAnnouncement_get_msg(ptr);
        const msg_hu_conv = new _channelAnnouncementMjs.ChannelAnnouncement(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
        const update_msg = _bindingsMjs.LDKMessageSendEvent_BroadcastChannelAnnouncement_get_update_msg(ptr);
        const update_msg_hu_conv = new _channelUpdateMjs.ChannelUpdate(null, update_msg);
        _commonBaseMjsDefault.default.add_ref_from(update_msg_hu_conv, this);
        this.update_msg = update_msg_hu_conv;
    }
}
class MessageSendEvent_BroadcastNodeAnnouncement extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const msg = _bindingsMjs.LDKMessageSendEvent_BroadcastNodeAnnouncement_get_msg(ptr);
        const msg_hu_conv = new _nodeAnnouncementMjs.NodeAnnouncement(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class MessageSendEvent_BroadcastChannelUpdate extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const msg = _bindingsMjs.LDKMessageSendEvent_BroadcastChannelUpdate_get_msg(ptr);
        const msg_hu_conv = new _channelUpdateMjs.ChannelUpdate(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class MessageSendEvent_SendChannelUpdate extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKMessageSendEvent_SendChannelUpdate_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        const msg = _bindingsMjs.LDKMessageSendEvent_SendChannelUpdate_get_msg(ptr);
        const msg_hu_conv = new _channelUpdateMjs.ChannelUpdate(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class MessageSendEvent_HandleError extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKMessageSendEvent_HandleError_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        const action = _bindingsMjs.LDKMessageSendEvent_HandleError_get_action(ptr);
        const action_hu_conv = _errorActionMjs.ErrorAction.constr_from_ptr(action);
        _commonBaseMjsDefault.default.add_ref_from(action_hu_conv, this);
        this.action = action_hu_conv;
    }
}
class MessageSendEvent_SendChannelRangeQuery extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKMessageSendEvent_SendChannelRangeQuery_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        const msg = _bindingsMjs.LDKMessageSendEvent_SendChannelRangeQuery_get_msg(ptr);
        const msg_hu_conv = new _queryChannelRangeMjs.QueryChannelRange(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class MessageSendEvent_SendShortIdsQuery extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKMessageSendEvent_SendShortIdsQuery_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        const msg = _bindingsMjs.LDKMessageSendEvent_SendShortIdsQuery_get_msg(ptr);
        const msg_hu_conv = new _queryShortChannelIdsMjs.QueryShortChannelIds(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}
class MessageSendEvent_SendReplyChannelRange extends MessageSendEvent {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const node_id = _bindingsMjs.LDKMessageSendEvent_SendReplyChannelRange_get_node_id(ptr);
        const node_id_conv = _bindingsMjs.decodeUint8Array(node_id);
        this.node_id = node_id_conv;
        const msg = _bindingsMjs.LDKMessageSendEvent_SendReplyChannelRange_get_msg(ptr);
        const msg_hu_conv = new _replyChannelRangeMjs.ReplyChannelRange(null, msg);
        _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
        this.msg = msg_hu_conv;
    }
}

},{"../structs/ChannelUpdate.mjs":"kLaF6","../structs/AcceptChannel.mjs":"7niKR","../structs/OpenChannel.mjs":"36LuB","../structs/FundingCreated.mjs":"5WOqU","../structs/FundingSigned.mjs":"jlNPc","../structs/FundingLocked.mjs":"kN90K","../structs/AnnouncementSignatures.mjs":"lrgLp","../structs/CommitmentUpdate.mjs":"21YmD","../structs/RevokeAndACK.mjs":"hocx7","../structs/ClosingSigned.mjs":"drMrL","../structs/Shutdown.mjs":"3oLVK","../structs/ChannelReestablish.mjs":"1pMS7","../structs/ChannelAnnouncement.mjs":"5JqYl","../structs/NodeAnnouncement.mjs":"549dY","../structs/ErrorAction.mjs":"fezfr","../structs/QueryChannelRange.mjs":"83Xki","../structs/QueryShortChannelIds.mjs":"1G6O6","../structs/ReplyChannelRange.mjs":"l9iKG","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9hmM8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_boolLightningErrorZ", ()=>Result_boolLightningErrorZ
);
parcelHelpers.export(exports, "Result_boolLightningErrorZ_OK", ()=>Result_boolLightningErrorZ_OK
);
parcelHelpers.export(exports, "Result_boolLightningErrorZ_Err", ()=>Result_boolLightningErrorZ_Err
) //# sourceMappingURL=Result_boolLightningErrorZ.mjs.map
;
var _lightningErrorMjs = require("../structs/LightningError.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_boolLightningErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_boolLightningErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_boolLightningErrorZ_is_ok(ptr)) return new Result_boolLightningErrorZ_OK(null, ptr);
        else return new Result_boolLightningErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_boolLightningErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_boolLightningErrorZ_ok(o);
        const ret_hu_conv = Result_boolLightningErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_boolLightningErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_boolLightningErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_boolLightningErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_boolLightningErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_boolLightningErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_boolLightningErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_boolLightningErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_boolLightningErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_boolLightningErrorZ_OK extends Result_boolLightningErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        this.res = _bindingsMjs.CResult_boolLightningErrorZ_get_ok(ptr);
    }
}
class Result_boolLightningErrorZ_Err extends Result_boolLightningErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_boolLightningErrorZ_get_err(ptr);
        const err_hu_conv = new _lightningErrorMjs.LightningError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/LightningError.mjs":"TGHq7","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jVg18":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Tuple
 */ parcelHelpers.export(exports, "ThreeTuple_ChannelAnnouncementChannelUpdateChannelUpdateZ", ()=>ThreeTuple_ChannelAnnouncementChannelUpdateChannelUpdateZ
) //# sourceMappingURL=ThreeTuple_ChannelAnnouncementChannelUpdateChannelUpdateZ.mjs.map
;
var _channelUpdateMjs = require("../structs/ChannelUpdate.mjs");
var _channelAnnouncementMjs = require("../structs/ChannelAnnouncement.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ThreeTuple_ChannelAnnouncementChannelUpdateChannelUpdateZ extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free);
    }
    /**
     *
     */ get_a() {
        const ret = _bindingsMjs.C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_a(this.ptr);
        const ret_hu_conv = new _channelAnnouncementMjs.ChannelAnnouncement(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     *
     */ get_b() {
        const ret = _bindingsMjs.C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_b(this.ptr);
        const ret_hu_conv = new _channelUpdateMjs.ChannelUpdate(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     *
     */ get_c() {
        const ret = _bindingsMjs.C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_c(this.ptr);
        const ret_hu_conv = new _channelUpdateMjs.ChannelUpdate(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new tuple which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(this.ptr);
        const ret_hu_conv = new ThreeTuple_ChannelAnnouncementChannelUpdateChannelUpdateZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a new C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ from the contained elements.
     */ static constructor_new(a, b, c) {
        const ret = _bindingsMjs.C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(a == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(a) & -2, b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b) & -2, c == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(c) & -2);
        const ret_hu_conv = new ThreeTuple_ChannelAnnouncementChannelUpdateChannelUpdateZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"../structs/ChannelUpdate.mjs":"kLaF6","../structs/ChannelAnnouncement.mjs":"5JqYl","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"csQwF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Error for PeerManager errors. If you get one of these, you must disconnect the socket and
 * generate no further read_event/write_buffer_space_avail/socket_disconnected calls for the
 * descriptor.
 */ parcelHelpers.export(exports, "PeerHandleError", ()=>PeerHandleError
) //# sourceMappingURL=PeerHandleError.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class PeerHandleError extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.PeerHandleError_free);
    }
    /**
     * Used to indicate that we probably can't make any future connections to this peer, implying
     * we should go ahead and force-close any channels we have with it.
     */ get_no_connection_possible() {
        const ret = _bindingsMjs.PeerHandleError_get_no_connection_possible(this.ptr);
        return ret;
    }
    /**
     * Used to indicate that we probably can't make any future connections to this peer, implying
     * we should go ahead and force-close any channels we have with it.
     */ set_no_connection_possible(val) {
        _bindingsMjs.PeerHandleError_set_no_connection_possible(this.ptr, val);
    }
    /**
     * Constructs a new PeerHandleError given each field
     */ static constructor_new(no_connection_possible_arg) {
        const ret = _bindingsMjs.PeerHandleError_new(no_connection_possible_arg);
        const ret_hu_conv = new PeerHandleError(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.PeerHandleError_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the PeerHandleError
     */ clone() {
        const ret = _bindingsMjs.PeerHandleError_clone(this.ptr);
        const ret_hu_conv = new PeerHandleError(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"82ISC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_CVec_u8ZPeerHandleErrorZ", ()=>Result_CVec_u8ZPeerHandleErrorZ
);
parcelHelpers.export(exports, "Result_CVec_u8ZPeerHandleErrorZ_OK", ()=>Result_CVec_u8ZPeerHandleErrorZ_OK
);
parcelHelpers.export(exports, "Result_CVec_u8ZPeerHandleErrorZ_Err", ()=>Result_CVec_u8ZPeerHandleErrorZ_Err
) //# sourceMappingURL=Result_CVec_u8ZPeerHandleErrorZ.mjs.map
;
var _peerHandleErrorMjs = require("../structs/PeerHandleError.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_CVec_u8ZPeerHandleErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_CVec_u8ZPeerHandleErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_CVec_u8ZPeerHandleErrorZ_is_ok(ptr)) return new Result_CVec_u8ZPeerHandleErrorZ_OK(null, ptr);
        else return new Result_CVec_u8ZPeerHandleErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_CVec_u8ZPeerHandleErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_CVec_u8ZPeerHandleErrorZ_ok(_bindingsMjs.encodeUint8Array(o));
        const ret_hu_conv = Result_CVec_u8ZPeerHandleErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_CVec_u8ZPeerHandleErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_CVec_u8ZPeerHandleErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_CVec_u8ZPeerHandleErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_CVec_u8ZPeerHandleErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_CVec_u8ZPeerHandleErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_CVec_u8ZPeerHandleErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_CVec_u8ZPeerHandleErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_CVec_u8ZPeerHandleErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_CVec_u8ZPeerHandleErrorZ_OK extends Result_CVec_u8ZPeerHandleErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_CVec_u8ZPeerHandleErrorZ_get_ok(ptr);
        const res_conv = _bindingsMjs.decodeUint8Array(res);
        this.res = res_conv;
    }
}
class Result_CVec_u8ZPeerHandleErrorZ_Err extends Result_CVec_u8ZPeerHandleErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_CVec_u8ZPeerHandleErrorZ_get_err(ptr);
        const err_hu_conv = new _peerHandleErrorMjs.PeerHandleError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/PeerHandleError.mjs":"csQwF","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dB41b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_NonePeerHandleErrorZ", ()=>Result_NonePeerHandleErrorZ
);
parcelHelpers.export(exports, "Result_NonePeerHandleErrorZ_OK", ()=>Result_NonePeerHandleErrorZ_OK
);
parcelHelpers.export(exports, "Result_NonePeerHandleErrorZ_Err", ()=>Result_NonePeerHandleErrorZ_Err
) //# sourceMappingURL=Result_NonePeerHandleErrorZ.mjs.map
;
var _peerHandleErrorMjs = require("../structs/PeerHandleError.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_NonePeerHandleErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_NonePeerHandleErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_NonePeerHandleErrorZ_is_ok(ptr)) return new Result_NonePeerHandleErrorZ_OK(null, ptr);
        else return new Result_NonePeerHandleErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_NonePeerHandleErrorZ in the success state.
     */ static constructor_ok() {
        const ret = _bindingsMjs.CResult_NonePeerHandleErrorZ_ok();
        const ret_hu_conv = Result_NonePeerHandleErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_NonePeerHandleErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_NonePeerHandleErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_NonePeerHandleErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_NonePeerHandleErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_NonePeerHandleErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_NonePeerHandleErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_NonePeerHandleErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_NonePeerHandleErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_NonePeerHandleErrorZ_OK extends Result_NonePeerHandleErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}
class Result_NonePeerHandleErrorZ_Err extends Result_NonePeerHandleErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_NonePeerHandleErrorZ_get_err(ptr);
        const err_hu_conv = new _peerHandleErrorMjs.PeerHandleError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/PeerHandleError.mjs":"csQwF","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aFPZ5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_boolPeerHandleErrorZ", ()=>Result_boolPeerHandleErrorZ
);
parcelHelpers.export(exports, "Result_boolPeerHandleErrorZ_OK", ()=>Result_boolPeerHandleErrorZ_OK
);
parcelHelpers.export(exports, "Result_boolPeerHandleErrorZ_Err", ()=>Result_boolPeerHandleErrorZ_Err
) //# sourceMappingURL=Result_boolPeerHandleErrorZ.mjs.map
;
var _peerHandleErrorMjs = require("../structs/PeerHandleError.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_boolPeerHandleErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_boolPeerHandleErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_boolPeerHandleErrorZ_is_ok(ptr)) return new Result_boolPeerHandleErrorZ_OK(null, ptr);
        else return new Result_boolPeerHandleErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_boolPeerHandleErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_boolPeerHandleErrorZ_ok(o);
        const ret_hu_conv = Result_boolPeerHandleErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_boolPeerHandleErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_boolPeerHandleErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_boolPeerHandleErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_boolPeerHandleErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_boolPeerHandleErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_boolPeerHandleErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_boolPeerHandleErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_boolPeerHandleErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_boolPeerHandleErrorZ_OK extends Result_boolPeerHandleErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        this.res = _bindingsMjs.CResult_boolPeerHandleErrorZ_get_ok(ptr);
    }
}
class Result_boolPeerHandleErrorZ_Err extends Result_boolPeerHandleErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_boolPeerHandleErrorZ_get_err(ptr);
        const err_hu_conv = new _peerHandleErrorMjs.PeerHandleError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/PeerHandleError.mjs":"csQwF","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"61a3E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_TxOutAccessErrorZ", ()=>Result_TxOutAccessErrorZ
);
parcelHelpers.export(exports, "Result_TxOutAccessErrorZ_OK", ()=>Result_TxOutAccessErrorZ_OK
);
parcelHelpers.export(exports, "Result_TxOutAccessErrorZ_Err", ()=>Result_TxOutAccessErrorZ_Err
) //# sourceMappingURL=Result_TxOutAccessErrorZ.mjs.map
;
var _txOutMjs = require("../structs/TxOut.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_TxOutAccessErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_TxOutAccessErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_TxOutAccessErrorZ_is_ok(ptr)) return new Result_TxOutAccessErrorZ_OK(null, ptr);
        else return new Result_TxOutAccessErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_TxOutAccessErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_TxOutAccessErrorZ_ok(_commonBaseMjsDefault.default.get_ptr_of(o));
        const ret_hu_conv = Result_TxOutAccessErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_TxOutAccessErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_TxOutAccessErrorZ_err(e);
        const ret_hu_conv = Result_TxOutAccessErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_TxOutAccessErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_TxOutAccessErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_TxOutAccessErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_TxOutAccessErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_TxOutAccessErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_TxOutAccessErrorZ_OK extends Result_TxOutAccessErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_TxOutAccessErrorZ_get_ok(ptr);
        const res_conv = new _txOutMjs.TxOut(null, res);
        this.res = res_conv;
    }
}
class Result_TxOutAccessErrorZ_Err extends Result_TxOutAccessErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        this.err = _bindingsMjs.CResult_TxOutAccessErrorZ_get_err(ptr);
    }
}

},{"../structs/TxOut.mjs":"3syDw","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"icmE6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_NoneChannelMonitorUpdateErrZ", ()=>Result_NoneChannelMonitorUpdateErrZ
);
parcelHelpers.export(exports, "Result_NoneChannelMonitorUpdateErrZ_OK", ()=>Result_NoneChannelMonitorUpdateErrZ_OK
);
parcelHelpers.export(exports, "Result_NoneChannelMonitorUpdateErrZ_Err", ()=>Result_NoneChannelMonitorUpdateErrZ_Err
) //# sourceMappingURL=Result_NoneChannelMonitorUpdateErrZ.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_NoneChannelMonitorUpdateErrZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_NoneChannelMonitorUpdateErrZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_NoneChannelMonitorUpdateErrZ_is_ok(ptr)) return new Result_NoneChannelMonitorUpdateErrZ_OK(null, ptr);
        else return new Result_NoneChannelMonitorUpdateErrZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_NoneChannelMonitorUpdateErrZ in the success state.
     */ static constructor_ok() {
        const ret = _bindingsMjs.CResult_NoneChannelMonitorUpdateErrZ_ok();
        const ret_hu_conv = Result_NoneChannelMonitorUpdateErrZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_NoneChannelMonitorUpdateErrZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_NoneChannelMonitorUpdateErrZ_err(e);
        const ret_hu_conv = Result_NoneChannelMonitorUpdateErrZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_NoneChannelMonitorUpdateErrZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_NoneChannelMonitorUpdateErrZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_NoneChannelMonitorUpdateErrZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_NoneChannelMonitorUpdateErrZ_clone(this.ptr);
        const ret_hu_conv = Result_NoneChannelMonitorUpdateErrZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_NoneChannelMonitorUpdateErrZ_OK extends Result_NoneChannelMonitorUpdateErrZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}
class Result_NoneChannelMonitorUpdateErrZ_Err extends Result_NoneChannelMonitorUpdateErrZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        this.err = _bindingsMjs.CResult_NoneChannelMonitorUpdateErrZ_get_err(ptr);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g9upi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An enum which can either contain a crate::c_types::derived::C2Tuple_usizeTransactionZ or not
 */ parcelHelpers.export(exports, "Option_C2Tuple_usizeTransactionZZ", ()=>Option_C2Tuple_usizeTransactionZZ
);
/** A Option_C2Tuple_usizeTransactionZZ of type Some */ parcelHelpers.export(exports, "Option_C2Tuple_usizeTransactionZZ_Some", ()=>Option_C2Tuple_usizeTransactionZZ_Some
);
/** A Option_C2Tuple_usizeTransactionZZ of type None */ parcelHelpers.export(exports, "Option_C2Tuple_usizeTransactionZZ_None", ()=>Option_C2Tuple_usizeTransactionZZ_None
) //# sourceMappingURL=Option_C2Tuple_usizeTransactionZZ.mjs.map
;
var _twoTupleUsizeTransactionZMjs = require("../structs/TwoTuple_usizeTransactionZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Option_C2Tuple_usizeTransactionZZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.COption_C2Tuple_usizeTransactionZZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKCOption_C2Tuple_usizeTransactionZZ_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new Option_C2Tuple_usizeTransactionZZ_Some(ptr);
            case 1:
                return new Option_C2Tuple_usizeTransactionZZ_None(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    /**
     * Constructs a new COption_C2Tuple_usizeTransactionZZ containing a crate::c_types::derived::C2Tuple_usizeTransactionZ
     */ static constructor_some(o) {
        const ret = _bindingsMjs.COption_C2Tuple_usizeTransactionZZ_some(o != null ? _commonBaseMjsDefault.default.get_ptr_of(o) : 0);
        const ret_hu_conv = Option_C2Tuple_usizeTransactionZZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Constructs a new COption_C2Tuple_usizeTransactionZZ containing nothing
     */ static constructor_none() {
        const ret = _bindingsMjs.COption_C2Tuple_usizeTransactionZZ_none();
        const ret_hu_conv = Option_C2Tuple_usizeTransactionZZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.COption_C2Tuple_usizeTransactionZZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new COption_C2Tuple_usizeTransactionZZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.COption_C2Tuple_usizeTransactionZZ_clone(this.ptr);
        const ret_hu_conv = Option_C2Tuple_usizeTransactionZZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
class Option_C2Tuple_usizeTransactionZZ_Some extends Option_C2Tuple_usizeTransactionZZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const some = _bindingsMjs.LDKCOption_C2Tuple_usizeTransactionZZ_Some_get_some(ptr);
        const some_hu_conv = new _twoTupleUsizeTransactionZMjs.TwoTuple_usizeTransactionZ(null, some);
        _commonBaseMjsDefault.default.add_ref_from(some_hu_conv, this);
        this.some = some_hu_conv;
    }
}
class Option_C2Tuple_usizeTransactionZZ_None extends Option_C2Tuple_usizeTransactionZZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}

},{"../structs/TwoTuple_usizeTransactionZ.mjs":"k0qa9","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4nYjo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An enum which can either contain a crate::lightning::util::events::ClosureReason or not
 */ parcelHelpers.export(exports, "Option_ClosureReasonZ", ()=>Option_ClosureReasonZ
);
/** A Option_ClosureReasonZ of type Some */ parcelHelpers.export(exports, "Option_ClosureReasonZ_Some", ()=>Option_ClosureReasonZ_Some
);
/** A Option_ClosureReasonZ of type None */ parcelHelpers.export(exports, "Option_ClosureReasonZ_None", ()=>Option_ClosureReasonZ_None
) //# sourceMappingURL=Option_ClosureReasonZ.mjs.map
;
var _closureReasonMjs = require("../structs/ClosureReason.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Option_ClosureReasonZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.COption_ClosureReasonZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKCOption_ClosureReasonZ_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new Option_ClosureReasonZ_Some(ptr);
            case 1:
                return new Option_ClosureReasonZ_None(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    /**
     * Constructs a new COption_ClosureReasonZ containing a crate::lightning::util::events::ClosureReason
     */ static constructor_some(o) {
        const ret = _bindingsMjs.COption_ClosureReasonZ_some(_commonBaseMjsDefault.default.get_ptr_of(o));
        const ret_hu_conv = Option_ClosureReasonZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Constructs a new COption_ClosureReasonZ containing nothing
     */ static constructor_none() {
        const ret = _bindingsMjs.COption_ClosureReasonZ_none();
        const ret_hu_conv = Option_ClosureReasonZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.COption_ClosureReasonZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new COption_ClosureReasonZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.COption_ClosureReasonZ_clone(this.ptr);
        const ret_hu_conv = Option_ClosureReasonZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
class Option_ClosureReasonZ_Some extends Option_ClosureReasonZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const some = _bindingsMjs.LDKCOption_ClosureReasonZ_Some_get_some(ptr);
        const some_hu_conv = _closureReasonMjs.ClosureReason.constr_from_ptr(some);
        _commonBaseMjsDefault.default.add_ref_from(some_hu_conv, this);
        this.some = some_hu_conv;
    }
}
class Option_ClosureReasonZ_None extends Option_ClosureReasonZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}

},{"../structs/ClosureReason.mjs":"fttbR","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6EKIv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_COption_ClosureReasonZDecodeErrorZ", ()=>Result_COption_ClosureReasonZDecodeErrorZ
);
parcelHelpers.export(exports, "Result_COption_ClosureReasonZDecodeErrorZ_OK", ()=>Result_COption_ClosureReasonZDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_COption_ClosureReasonZDecodeErrorZ_Err", ()=>Result_COption_ClosureReasonZDecodeErrorZ_Err
) //# sourceMappingURL=Result_COption_ClosureReasonZDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _optionClosureReasonZMjs = require("../structs/Option_ClosureReasonZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_COption_ClosureReasonZDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_COption_ClosureReasonZDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(ptr)) return new Result_COption_ClosureReasonZDecodeErrorZ_OK(null, ptr);
        else return new Result_COption_ClosureReasonZDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_COption_ClosureReasonZDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_COption_ClosureReasonZDecodeErrorZ_ok(_commonBaseMjsDefault.default.get_ptr_of(o));
        const ret_hu_conv = Result_COption_ClosureReasonZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_COption_ClosureReasonZDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_COption_ClosureReasonZDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_COption_ClosureReasonZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_COption_ClosureReasonZDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_COption_ClosureReasonZDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_COption_ClosureReasonZDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_COption_ClosureReasonZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_COption_ClosureReasonZDecodeErrorZ_OK extends Result_COption_ClosureReasonZDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_COption_ClosureReasonZDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = _optionClosureReasonZMjs.Option_ClosureReasonZ.constr_from_ptr(res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_COption_ClosureReasonZDecodeErrorZ_Err extends Result_COption_ClosureReasonZDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_COption_ClosureReasonZDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/Option_ClosureReasonZ.mjs":"4nYjo","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h6X8M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An enum which can either contain a crate::lightning::util::events::Event or not
 */ parcelHelpers.export(exports, "Option_EventZ", ()=>Option_EventZ
);
/** A Option_EventZ of type Some */ parcelHelpers.export(exports, "Option_EventZ_Some", ()=>Option_EventZ_Some
);
/** A Option_EventZ of type None */ parcelHelpers.export(exports, "Option_EventZ_None", ()=>Option_EventZ_None
) //# sourceMappingURL=Option_EventZ.mjs.map
;
var _eventMjs = require("../structs/Event.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Option_EventZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.COption_EventZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKCOption_EventZ_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new Option_EventZ_Some(ptr);
            case 1:
                return new Option_EventZ_None(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    /**
     * Constructs a new COption_EventZ containing a crate::lightning::util::events::Event
     */ static constructor_some(o) {
        const ret = _bindingsMjs.COption_EventZ_some(_commonBaseMjsDefault.default.get_ptr_of(o));
        const ret_hu_conv = Option_EventZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Constructs a new COption_EventZ containing nothing
     */ static constructor_none() {
        const ret = _bindingsMjs.COption_EventZ_none();
        const ret_hu_conv = Option_EventZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.COption_EventZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new COption_EventZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.COption_EventZ_clone(this.ptr);
        const ret_hu_conv = Option_EventZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
class Option_EventZ_Some extends Option_EventZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const some = _bindingsMjs.LDKCOption_EventZ_Some_get_some(ptr);
        const some_hu_conv = _eventMjs.Event.constr_from_ptr(some);
        _commonBaseMjsDefault.default.add_ref_from(some_hu_conv, this);
        this.some = some_hu_conv;
    }
}
class Option_EventZ_None extends Option_EventZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}

},{"../structs/Event.mjs":"g2Zcr","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"asgnu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_COption_EventZDecodeErrorZ", ()=>Result_COption_EventZDecodeErrorZ
);
parcelHelpers.export(exports, "Result_COption_EventZDecodeErrorZ_OK", ()=>Result_COption_EventZDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_COption_EventZDecodeErrorZ_Err", ()=>Result_COption_EventZDecodeErrorZ_Err
) //# sourceMappingURL=Result_COption_EventZDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _optionEventZMjs = require("../structs/Option_EventZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_COption_EventZDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_COption_EventZDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_COption_EventZDecodeErrorZ_is_ok(ptr)) return new Result_COption_EventZDecodeErrorZ_OK(null, ptr);
        else return new Result_COption_EventZDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_COption_EventZDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_COption_EventZDecodeErrorZ_ok(_commonBaseMjsDefault.default.get_ptr_of(o));
        const ret_hu_conv = Result_COption_EventZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_COption_EventZDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_COption_EventZDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_COption_EventZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_COption_EventZDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_COption_EventZDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_COption_EventZDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_COption_EventZDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_COption_EventZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_COption_EventZDecodeErrorZ_OK extends Result_COption_EventZDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_COption_EventZDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = _optionEventZMjs.Option_EventZ.constr_from_ptr(res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_COption_EventZDecodeErrorZ_Err extends Result_COption_EventZDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_COption_EventZDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/Option_EventZ.mjs":"h6X8M","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kiqkR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Represents the compressed public key of a node
 */ parcelHelpers.export(exports, "NodeId", ()=>NodeId
) //# sourceMappingURL=NodeId.mjs.map
;
var _resultNodeIdDecodeErrorZMjs = require("../structs/Result_NodeIdDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class NodeId extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.NodeId_free);
    }
    clone_ptr() {
        const ret = _bindingsMjs.NodeId_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the NodeId
     */ clone() {
        const ret = _bindingsMjs.NodeId_clone(this.ptr);
        const ret_hu_conv = new NodeId(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Create a new NodeId from a public key
     */ static constructor_from_pubkey(pubkey) {
        const ret = _bindingsMjs.NodeId_from_pubkey(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(pubkey, 33)));
        const ret_hu_conv = new NodeId(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Get the public key slice from this NodeId
     */ as_slice() {
        const ret = _bindingsMjs.NodeId_as_slice(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Checks if two NodeIds contain equal inner contents.
     */ hash() {
        const ret = _bindingsMjs.NodeId_hash(this.ptr);
        return ret;
    }
    /**
     * Serialize the NodeId object into a byte array which can be read by NodeId_read
     */ write() {
        const ret = _bindingsMjs.NodeId_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a NodeId from a byte array, created by NodeId_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.NodeId_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultNodeIdDecodeErrorZMjs.Result_NodeIdDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_NodeIdDecodeErrorZ.mjs":"jRfFu","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jRfFu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_NodeIdDecodeErrorZ", ()=>Result_NodeIdDecodeErrorZ
);
parcelHelpers.export(exports, "Result_NodeIdDecodeErrorZ_OK", ()=>Result_NodeIdDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_NodeIdDecodeErrorZ_Err", ()=>Result_NodeIdDecodeErrorZ_Err
) //# sourceMappingURL=Result_NodeIdDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _nodeIdMjs = require("../structs/NodeId.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_NodeIdDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_NodeIdDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_NodeIdDecodeErrorZ_is_ok(ptr)) return new Result_NodeIdDecodeErrorZ_OK(null, ptr);
        else return new Result_NodeIdDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_NodeIdDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_NodeIdDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_NodeIdDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_NodeIdDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_NodeIdDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_NodeIdDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_NodeIdDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_NodeIdDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_NodeIdDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_NodeIdDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_NodeIdDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_NodeIdDecodeErrorZ_OK extends Result_NodeIdDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_NodeIdDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _nodeIdMjs.NodeId(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_NodeIdDecodeErrorZ_Err extends Result_NodeIdDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_NodeIdDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/NodeId.mjs":"kiqkR","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lqUkx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_COption_NetworkUpdateZDecodeErrorZ", ()=>Result_COption_NetworkUpdateZDecodeErrorZ
);
parcelHelpers.export(exports, "Result_COption_NetworkUpdateZDecodeErrorZ_OK", ()=>Result_COption_NetworkUpdateZDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_COption_NetworkUpdateZDecodeErrorZ_Err", ()=>Result_COption_NetworkUpdateZDecodeErrorZ_Err
) //# sourceMappingURL=Result_COption_NetworkUpdateZDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _optionNetworkUpdateZMjs = require("../structs/Option_NetworkUpdateZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_COption_NetworkUpdateZDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_COption_NetworkUpdateZDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(ptr)) return new Result_COption_NetworkUpdateZDecodeErrorZ_OK(null, ptr);
        else return new Result_COption_NetworkUpdateZDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_COption_NetworkUpdateZDecodeErrorZ_ok(_commonBaseMjsDefault.default.get_ptr_of(o));
        const ret_hu_conv = Result_COption_NetworkUpdateZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_COption_NetworkUpdateZDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_COption_NetworkUpdateZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_COption_NetworkUpdateZDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_COption_NetworkUpdateZDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_COption_NetworkUpdateZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_COption_NetworkUpdateZDecodeErrorZ_OK extends Result_COption_NetworkUpdateZDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_COption_NetworkUpdateZDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = _optionNetworkUpdateZMjs.Option_NetworkUpdateZ.constr_from_ptr(res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_COption_NetworkUpdateZDecodeErrorZ_Err extends Result_COption_NetworkUpdateZDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_COption_NetworkUpdateZDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/Option_NetworkUpdateZ.mjs":"3mbkX","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"geLNM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The `Access` trait defines behavior for accessing chain data and state, such as blocks and
 * UTXOs.
 */ parcelHelpers.export(exports, "Access", ()=>Access
) //# sourceMappingURL=Access.mjs.map
;
var _resultTxOutAccessErrorZMjs = require("../structs/Result_TxOutAccessErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKAccessHolder {
}
class Access extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Access_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of Access from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKAccessHolder();
        let structImplementation = {
            get_utxo (genesis_hash, short_channel_id) {
                const genesis_hash_conv = _bindingsMjs.decodeUint8Array(genesis_hash);
                const ret = arg.get_utxo(genesis_hash_conv, short_channel_id);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            }
        };
        const ptr = _bindingsMjs.LDKAccess_new(structImplementation);
        impl_holder.held = new Access(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Returns the transaction output of a funding transaction encoded by [`short_channel_id`].
     * Returns an error if `genesis_hash` is for a different chain or if such a transaction output
     * is unknown.
     *
     * [`short_channel_id`]: https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md#definition-of-short_channel_id
     */ get_utxo(genesis_hash, short_channel_id) {
        const ret = _bindingsMjs.Access_get_utxo(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(genesis_hash, 32)), short_channel_id);
        const ret_hu_conv = _resultTxOutAccessErrorZMjs.Result_TxOutAccessErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_TxOutAccessErrorZ.mjs":"61a3E","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8VxOd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An enum which can either contain a crate::lightning::chain::Access or not
 */ parcelHelpers.export(exports, "Option_AccessZ", ()=>Option_AccessZ
);
/** A Option_AccessZ of type Some */ parcelHelpers.export(exports, "Option_AccessZ_Some", ()=>Option_AccessZ_Some
);
/** A Option_AccessZ of type None */ parcelHelpers.export(exports, "Option_AccessZ_None", ()=>Option_AccessZ_None
) //# sourceMappingURL=Option_AccessZ.mjs.map
;
var _accessMjs = require("../structs/Access.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Option_AccessZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.COption_AccessZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKCOption_AccessZ_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new Option_AccessZ_Some(ptr);
            case 1:
                return new Option_AccessZ_None(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    /**
     * Constructs a new COption_AccessZ containing a crate::lightning::chain::Access
     */ static constructor_some(o) {
        const ret = _bindingsMjs.COption_AccessZ_some(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o));
        const ret_hu_conv = Option_AccessZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, o);
        return ret_hu_conv;
    }
    /**
     * Constructs a new COption_AccessZ containing nothing
     */ static constructor_none() {
        const ret = _bindingsMjs.COption_AccessZ_none();
        const ret_hu_conv = Option_AccessZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}
class Option_AccessZ_Some extends Option_AccessZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const some = _bindingsMjs.LDKCOption_AccessZ_Some_get_some(ptr);
        const ret_hu_conv = new _accessMjs.Access(null, some);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        this.some = ret_hu_conv;
    }
}
class Option_AccessZ_None extends Option_AccessZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}

},{"../structs/Access.mjs":"geLNM","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dB08I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Details about one direction of a channel. Received
 * within a channel update.
 */ parcelHelpers.export(exports, "DirectionalChannelInfo", ()=>DirectionalChannelInfo
) //# sourceMappingURL=DirectionalChannelInfo.mjs.map
;
var _optionU64ZMjs = require("../structs/Option_u64Z.mjs");
var _channelUpdateMjs = require("../structs/ChannelUpdate.mjs");
var _resultDirectionalChannelInfoDecodeErrorZMjs = require("../structs/Result_DirectionalChannelInfoDecodeErrorZ.mjs");
var _routingFeesMjs = require("../structs/RoutingFees.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class DirectionalChannelInfo extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.DirectionalChannelInfo_free);
    }
    /**
     * When the last update to the channel direction was issued.
     * Value is opaque, as set in the announcement.
     */ get_last_update() {
        const ret = _bindingsMjs.DirectionalChannelInfo_get_last_update(this.ptr);
        return ret;
    }
    /**
     * When the last update to the channel direction was issued.
     * Value is opaque, as set in the announcement.
     */ set_last_update(val) {
        _bindingsMjs.DirectionalChannelInfo_set_last_update(this.ptr, val);
    }
    /**
     * Whether the channel can be currently used for payments (in this one direction).
     */ get_enabled() {
        const ret = _bindingsMjs.DirectionalChannelInfo_get_enabled(this.ptr);
        return ret;
    }
    /**
     * Whether the channel can be currently used for payments (in this one direction).
     */ set_enabled(val) {
        _bindingsMjs.DirectionalChannelInfo_set_enabled(this.ptr, val);
    }
    /**
     * The difference in CLTV values that you must have when routing through this channel.
     */ get_cltv_expiry_delta() {
        const ret = _bindingsMjs.DirectionalChannelInfo_get_cltv_expiry_delta(this.ptr);
        return ret;
    }
    /**
     * The difference in CLTV values that you must have when routing through this channel.
     */ set_cltv_expiry_delta(val) {
        _bindingsMjs.DirectionalChannelInfo_set_cltv_expiry_delta(this.ptr, val);
    }
    /**
     * The minimum value, which must be relayed to the next hop via the channel
     */ get_htlc_minimum_msat() {
        const ret = _bindingsMjs.DirectionalChannelInfo_get_htlc_minimum_msat(this.ptr);
        return ret;
    }
    /**
     * The minimum value, which must be relayed to the next hop via the channel
     */ set_htlc_minimum_msat(val) {
        _bindingsMjs.DirectionalChannelInfo_set_htlc_minimum_msat(this.ptr, val);
    }
    /**
     * The maximum value which may be relayed to the next hop via the channel.
     */ get_htlc_maximum_msat() {
        const ret = _bindingsMjs.DirectionalChannelInfo_get_htlc_maximum_msat(this.ptr);
        const ret_hu_conv = _optionU64ZMjs.Option_u64Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The maximum value which may be relayed to the next hop via the channel.
     */ set_htlc_maximum_msat(val) {
        _bindingsMjs.DirectionalChannelInfo_set_htlc_maximum_msat(this.ptr, _commonBaseMjsDefault.default.get_ptr_of(val));
    }
    /**
     * Fees charged when the channel is used for routing
     */ get_fees() {
        const ret = _bindingsMjs.DirectionalChannelInfo_get_fees(this.ptr);
        const ret_hu_conv = new _routingFeesMjs.RoutingFees(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Fees charged when the channel is used for routing
     */ set_fees(val) {
        _bindingsMjs.DirectionalChannelInfo_set_fees(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Most recent update for the channel received from the network
     * Mostly redundant with the data we store in fields explicitly.
     * Everything else is useful only for sending out for initial routing sync.
     * Not stored if contains excess data to prevent DoS.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_last_update_message() {
        const ret = _bindingsMjs.DirectionalChannelInfo_get_last_update_message(this.ptr);
        const ret_hu_conv = new _channelUpdateMjs.ChannelUpdate(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Most recent update for the channel received from the network
     * Mostly redundant with the data we store in fields explicitly.
     * Everything else is useful only for sending out for initial routing sync.
     * Not stored if contains excess data to prevent DoS.
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_last_update_message(val) {
        _bindingsMjs.DirectionalChannelInfo_set_last_update_message(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Constructs a new DirectionalChannelInfo given each field
     */ static constructor_new(last_update_arg, enabled_arg, cltv_expiry_delta_arg, htlc_minimum_msat_arg, htlc_maximum_msat_arg, fees_arg, last_update_message_arg) {
        const ret = _bindingsMjs.DirectionalChannelInfo_new(last_update_arg, enabled_arg, cltv_expiry_delta_arg, htlc_minimum_msat_arg, _commonBaseMjsDefault.default.get_ptr_of(htlc_maximum_msat_arg), fees_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(fees_arg) & -2, last_update_message_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(last_update_message_arg) & -2);
        const ret_hu_conv = new DirectionalChannelInfo(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.DirectionalChannelInfo_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the DirectionalChannelInfo
     */ clone() {
        const ret = _bindingsMjs.DirectionalChannelInfo_clone(this.ptr);
        const ret_hu_conv = new DirectionalChannelInfo(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the DirectionalChannelInfo object into a byte array which can be read by DirectionalChannelInfo_read
     */ write() {
        const ret = _bindingsMjs.DirectionalChannelInfo_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a DirectionalChannelInfo from a byte array, created by DirectionalChannelInfo_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.DirectionalChannelInfo_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultDirectionalChannelInfoDecodeErrorZMjs.Result_DirectionalChannelInfoDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Option_u64Z.mjs":"8VC1Q","../structs/ChannelUpdate.mjs":"kLaF6","../structs/Result_DirectionalChannelInfoDecodeErrorZ.mjs":"aIJiV","../structs/RoutingFees.mjs":"7CDJ9","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aIJiV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_DirectionalChannelInfoDecodeErrorZ", ()=>Result_DirectionalChannelInfoDecodeErrorZ
);
parcelHelpers.export(exports, "Result_DirectionalChannelInfoDecodeErrorZ_OK", ()=>Result_DirectionalChannelInfoDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_DirectionalChannelInfoDecodeErrorZ_Err", ()=>Result_DirectionalChannelInfoDecodeErrorZ_Err
) //# sourceMappingURL=Result_DirectionalChannelInfoDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _directionalChannelInfoMjs = require("../structs/DirectionalChannelInfo.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_DirectionalChannelInfoDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_DirectionalChannelInfoDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_DirectionalChannelInfoDecodeErrorZ_is_ok(ptr)) return new Result_DirectionalChannelInfoDecodeErrorZ_OK(null, ptr);
        else return new Result_DirectionalChannelInfoDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_DirectionalChannelInfoDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_DirectionalChannelInfoDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_DirectionalChannelInfoDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_DirectionalChannelInfoDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_DirectionalChannelInfoDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_DirectionalChannelInfoDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_DirectionalChannelInfoDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_DirectionalChannelInfoDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_DirectionalChannelInfoDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_DirectionalChannelInfoDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_DirectionalChannelInfoDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_DirectionalChannelInfoDecodeErrorZ_OK extends Result_DirectionalChannelInfoDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_DirectionalChannelInfoDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _directionalChannelInfoMjs.DirectionalChannelInfo(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_DirectionalChannelInfoDecodeErrorZ_Err extends Result_DirectionalChannelInfoDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_DirectionalChannelInfoDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/DirectionalChannelInfo.mjs":"dB08I","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kbkCq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Details about a channel (both directions).
 * Received within a channel announcement.
 */ parcelHelpers.export(exports, "ChannelInfo", ()=>ChannelInfo
) //# sourceMappingURL=ChannelInfo.mjs.map
;
var _optionU64ZMjs = require("../structs/Option_u64Z.mjs");
var _channelAnnouncementMjs = require("../structs/ChannelAnnouncement.mjs");
var _nodeIdMjs = require("../structs/NodeId.mjs");
var _directionalChannelInfoMjs = require("../structs/DirectionalChannelInfo.mjs");
var _resultChannelInfoDecodeErrorZMjs = require("../structs/Result_ChannelInfoDecodeErrorZ.mjs");
var _channelFeaturesMjs = require("../structs/ChannelFeatures.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelInfo extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelInfo_free);
    }
    /**
     * Protocol features of a channel communicated during its announcement
     */ get_features() {
        const ret = _bindingsMjs.ChannelInfo_get_features(this.ptr);
        const ret_hu_conv = new _channelFeaturesMjs.ChannelFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Protocol features of a channel communicated during its announcement
     */ set_features(val) {
        _bindingsMjs.ChannelInfo_set_features(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Source node of the first direction of a channel
     */ get_node_one() {
        const ret = _bindingsMjs.ChannelInfo_get_node_one(this.ptr);
        const ret_hu_conv = new _nodeIdMjs.NodeId(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Source node of the first direction of a channel
     */ set_node_one(val) {
        _bindingsMjs.ChannelInfo_set_node_one(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Details about the first direction of a channel
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_one_to_two() {
        const ret = _bindingsMjs.ChannelInfo_get_one_to_two(this.ptr);
        const ret_hu_conv = new _directionalChannelInfoMjs.DirectionalChannelInfo(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Details about the first direction of a channel
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_one_to_two(val) {
        _bindingsMjs.ChannelInfo_set_one_to_two(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Source node of the second direction of a channel
     */ get_node_two() {
        const ret = _bindingsMjs.ChannelInfo_get_node_two(this.ptr);
        const ret_hu_conv = new _nodeIdMjs.NodeId(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Source node of the second direction of a channel
     */ set_node_two(val) {
        _bindingsMjs.ChannelInfo_set_node_two(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Details about the second direction of a channel
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_two_to_one() {
        const ret = _bindingsMjs.ChannelInfo_get_two_to_one(this.ptr);
        const ret_hu_conv = new _directionalChannelInfoMjs.DirectionalChannelInfo(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Details about the second direction of a channel
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_two_to_one(val) {
        _bindingsMjs.ChannelInfo_set_two_to_one(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * The channel capacity as seen on-chain, if chain lookup is available.
     */ get_capacity_sats() {
        const ret = _bindingsMjs.ChannelInfo_get_capacity_sats(this.ptr);
        const ret_hu_conv = _optionU64ZMjs.Option_u64Z.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The channel capacity as seen on-chain, if chain lookup is available.
     */ set_capacity_sats(val) {
        _bindingsMjs.ChannelInfo_set_capacity_sats(this.ptr, _commonBaseMjsDefault.default.get_ptr_of(val));
    }
    /**
     * An initial announcement of the channel
     * Mostly redundant with the data we store in fields explicitly.
     * Everything else is useful only for sending out for initial routing sync.
     * Not stored if contains excess data to prevent DoS.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_announcement_message() {
        const ret = _bindingsMjs.ChannelInfo_get_announcement_message(this.ptr);
        const ret_hu_conv = new _channelAnnouncementMjs.ChannelAnnouncement(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * An initial announcement of the channel
     * Mostly redundant with the data we store in fields explicitly.
     * Everything else is useful only for sending out for initial routing sync.
     * Not stored if contains excess data to prevent DoS.
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_announcement_message(val) {
        _bindingsMjs.ChannelInfo_set_announcement_message(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    clone_ptr() {
        const ret = _bindingsMjs.ChannelInfo_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelInfo
     */ clone() {
        const ret = _bindingsMjs.ChannelInfo_clone(this.ptr);
        const ret_hu_conv = new ChannelInfo(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the ChannelInfo object into a byte array which can be read by ChannelInfo_read
     */ write() {
        const ret = _bindingsMjs.ChannelInfo_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ChannelInfo from a byte array, created by ChannelInfo_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ChannelInfo_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultChannelInfoDecodeErrorZMjs.Result_ChannelInfoDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Option_u64Z.mjs":"8VC1Q","../structs/ChannelAnnouncement.mjs":"5JqYl","../structs/NodeId.mjs":"kiqkR","../structs/DirectionalChannelInfo.mjs":"dB08I","../structs/Result_ChannelInfoDecodeErrorZ.mjs":"02iub","../structs/ChannelFeatures.mjs":"89gCD","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"02iub":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ChannelInfoDecodeErrorZ", ()=>Result_ChannelInfoDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ChannelInfoDecodeErrorZ_OK", ()=>Result_ChannelInfoDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ChannelInfoDecodeErrorZ_Err", ()=>Result_ChannelInfoDecodeErrorZ_Err
) //# sourceMappingURL=Result_ChannelInfoDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _channelInfoMjs = require("../structs/ChannelInfo.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ChannelInfoDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ChannelInfoDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ChannelInfoDecodeErrorZ_is_ok(ptr)) return new Result_ChannelInfoDecodeErrorZ_OK(null, ptr);
        else return new Result_ChannelInfoDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ChannelInfoDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ChannelInfoDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ChannelInfoDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ChannelInfoDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ChannelInfoDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ChannelInfoDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ChannelInfoDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_ChannelInfoDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_ChannelInfoDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_ChannelInfoDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_ChannelInfoDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_ChannelInfoDecodeErrorZ_OK extends Result_ChannelInfoDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ChannelInfoDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _channelInfoMjs.ChannelInfo(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ChannelInfoDecodeErrorZ_Err extends Result_ChannelInfoDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ChannelInfoDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/ChannelInfo.mjs":"kbkCq","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dIj09":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An address which can be used to connect to a remote peer
 */ parcelHelpers.export(exports, "NetAddress", ()=>NetAddress
);
/** A NetAddress of type IPv4 */ parcelHelpers.export(exports, "NetAddress_IPv4", ()=>NetAddress_IPv4
);
/** A NetAddress of type IPv6 */ parcelHelpers.export(exports, "NetAddress_IPv6", ()=>NetAddress_IPv6
);
/** A NetAddress of type OnionV2 */ parcelHelpers.export(exports, "NetAddress_OnionV2", ()=>NetAddress_OnionV2
);
/** A NetAddress of type OnionV3 */ parcelHelpers.export(exports, "NetAddress_OnionV3", ()=>NetAddress_OnionV3
) //# sourceMappingURL=NetAddress.mjs.map
;
var _resultNetAddressDecodeErrorZMjs = require("../structs/Result_NetAddressDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class NetAddress extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.NetAddress_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKNetAddress_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new NetAddress_IPv4(ptr);
            case 1:
                return new NetAddress_IPv6(ptr);
            case 2:
                return new NetAddress_OnionV2(ptr);
            case 3:
                return new NetAddress_OnionV3(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = _bindingsMjs.NetAddress_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the NetAddress
     */ clone() {
        const ret = _bindingsMjs.NetAddress_clone(this.ptr);
        const ret_hu_conv = NetAddress.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new IPv4-variant NetAddress
     */ static constructor_ipv4(addr, port) {
        const ret = _bindingsMjs.NetAddress_ipv4(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(addr, 4)), port);
        const ret_hu_conv = NetAddress.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new IPv6-variant NetAddress
     */ static constructor_ipv6(addr, port) {
        const ret = _bindingsMjs.NetAddress_ipv6(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(addr, 16)), port);
        const ret_hu_conv = NetAddress.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new OnionV2-variant NetAddress
     */ static constructor_onion_v2(a) {
        const ret = _bindingsMjs.NetAddress_onion_v2(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(a, 12)));
        const ret_hu_conv = NetAddress.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new OnionV3-variant NetAddress
     */ static constructor_onion_v3(ed25519_pubkey, checksum, version, port) {
        const ret = _bindingsMjs.NetAddress_onion_v3(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(ed25519_pubkey, 32)), checksum, version, port);
        const ret_hu_conv = NetAddress.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Serialize the NetAddress object into a byte array which can be read by NetAddress_read
     */ write() {
        const ret = _bindingsMjs.NetAddress_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a NetAddress from a byte array, created by NetAddress_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.NetAddress_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultNetAddressDecodeErrorZMjs.Result_NetAddressDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class NetAddress_IPv4 extends NetAddress {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const addr = _bindingsMjs.LDKNetAddress_IPv4_get_addr(ptr);
        const addr_conv = _bindingsMjs.decodeUint8Array(addr);
        this.addr = addr_conv;
        this.port = _bindingsMjs.LDKNetAddress_IPv4_get_port(ptr);
    }
}
class NetAddress_IPv6 extends NetAddress {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const addr = _bindingsMjs.LDKNetAddress_IPv6_get_addr(ptr);
        const addr_conv = _bindingsMjs.decodeUint8Array(addr);
        this.addr = addr_conv;
        this.port = _bindingsMjs.LDKNetAddress_IPv6_get_port(ptr);
    }
}
class NetAddress_OnionV2 extends NetAddress {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const onion_v2 = _bindingsMjs.LDKNetAddress_OnionV2_get_onion_v2(ptr);
        const onion_v2_conv = _bindingsMjs.decodeUint8Array(onion_v2);
        this.onion_v2 = onion_v2_conv;
    }
}
class NetAddress_OnionV3 extends NetAddress {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const ed25519_pubkey = _bindingsMjs.LDKNetAddress_OnionV3_get_ed25519_pubkey(ptr);
        const ed25519_pubkey_conv = _bindingsMjs.decodeUint8Array(ed25519_pubkey);
        this.ed25519_pubkey = ed25519_pubkey_conv;
        this.checksum = _bindingsMjs.LDKNetAddress_OnionV3_get_checksum(ptr);
        this.version = _bindingsMjs.LDKNetAddress_OnionV3_get_version(ptr);
        this.port = _bindingsMjs.LDKNetAddress_OnionV3_get_port(ptr);
    }
}

},{"../structs/Result_NetAddressDecodeErrorZ.mjs":"kzql0","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kzql0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_NetAddressDecodeErrorZ", ()=>Result_NetAddressDecodeErrorZ
);
parcelHelpers.export(exports, "Result_NetAddressDecodeErrorZ_OK", ()=>Result_NetAddressDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_NetAddressDecodeErrorZ_Err", ()=>Result_NetAddressDecodeErrorZ_Err
) //# sourceMappingURL=Result_NetAddressDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _netAddressMjs = require("../structs/NetAddress.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_NetAddressDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_NetAddressDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_NetAddressDecodeErrorZ_is_ok(ptr)) return new Result_NetAddressDecodeErrorZ_OK(null, ptr);
        else return new Result_NetAddressDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_NetAddressDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_NetAddressDecodeErrorZ_ok(_commonBaseMjsDefault.default.get_ptr_of(o));
        const ret_hu_conv = Result_NetAddressDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_NetAddressDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_NetAddressDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_NetAddressDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_NetAddressDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_NetAddressDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_NetAddressDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_NetAddressDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_NetAddressDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_NetAddressDecodeErrorZ_OK extends Result_NetAddressDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_NetAddressDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = _netAddressMjs.NetAddress.constr_from_ptr(res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_NetAddressDecodeErrorZ_Err extends Result_NetAddressDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_NetAddressDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/NetAddress.mjs":"dIj09","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1pwML":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Information received in the latest node_announcement from this node.
 */ parcelHelpers.export(exports, "NodeAnnouncementInfo", ()=>NodeAnnouncementInfo
) //# sourceMappingURL=NodeAnnouncementInfo.mjs.map
;
var _nodeAnnouncementMjs = require("../structs/NodeAnnouncement.mjs");
var _resultNodeAnnouncementInfoDecodeErrorZMjs = require("../structs/Result_NodeAnnouncementInfoDecodeErrorZ.mjs");
var _nodeFeaturesMjs = require("../structs/NodeFeatures.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class NodeAnnouncementInfo extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.NodeAnnouncementInfo_free);
    }
    /**
     * Protocol features the node announced support for
     */ get_features() {
        const ret = _bindingsMjs.NodeAnnouncementInfo_get_features(this.ptr);
        const ret_hu_conv = new _nodeFeaturesMjs.NodeFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Protocol features the node announced support for
     */ set_features(val) {
        _bindingsMjs.NodeAnnouncementInfo_set_features(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * When the last known update to the node state was issued.
     * Value is opaque, as set in the announcement.
     */ get_last_update() {
        const ret = _bindingsMjs.NodeAnnouncementInfo_get_last_update(this.ptr);
        return ret;
    }
    /**
     * When the last known update to the node state was issued.
     * Value is opaque, as set in the announcement.
     */ set_last_update(val) {
        _bindingsMjs.NodeAnnouncementInfo_set_last_update(this.ptr, val);
    }
    /**
     * Color assigned to the node
     */ get_rgb() {
        const ret = _bindingsMjs.NodeAnnouncementInfo_get_rgb(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Color assigned to the node
     */ set_rgb(val) {
        _bindingsMjs.NodeAnnouncementInfo_set_rgb(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 3)));
    }
    /**
     * Moniker assigned to the node.
     * May be invalid or malicious (eg control chars),
     * should not be exposed to the user.
     */ get_alias() {
        const ret = _bindingsMjs.NodeAnnouncementInfo_get_alias(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Moniker assigned to the node.
     * May be invalid or malicious (eg control chars),
     * should not be exposed to the user.
     */ set_alias(val) {
        _bindingsMjs.NodeAnnouncementInfo_set_alias(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * Internet-level addresses via which one can connect to the node
     */ set_addresses(val) {
        _bindingsMjs.NodeAnnouncementInfo_set_addresses(this.ptr, _bindingsMjs.encodeUint32Array(val != null ? val.map((val_conv_12)=>_commonBaseMjsDefault.default.get_ptr_of(val_conv_12)
        ) : null));
    }
    /**
     * An initial announcement of the node
     * Mostly redundant with the data we store in fields explicitly.
     * Everything else is useful only for sending out for initial routing sync.
     * Not stored if contains excess data to prevent DoS.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_announcement_message() {
        const ret = _bindingsMjs.NodeAnnouncementInfo_get_announcement_message(this.ptr);
        const ret_hu_conv = new _nodeAnnouncementMjs.NodeAnnouncement(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * An initial announcement of the node
     * Mostly redundant with the data we store in fields explicitly.
     * Everything else is useful only for sending out for initial routing sync.
     * Not stored if contains excess data to prevent DoS.
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_announcement_message(val) {
        _bindingsMjs.NodeAnnouncementInfo_set_announcement_message(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Constructs a new NodeAnnouncementInfo given each field
     */ static constructor_new(features_arg, last_update_arg, rgb_arg, alias_arg, addresses_arg, announcement_message_arg) {
        const ret = _bindingsMjs.NodeAnnouncementInfo_new(features_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(features_arg) & -2, last_update_arg, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(rgb_arg, 3)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(alias_arg, 32)), _bindingsMjs.encodeUint32Array(addresses_arg != null ? addresses_arg.map((addresses_arg_conv_12)=>_commonBaseMjsDefault.default.get_ptr_of(addresses_arg_conv_12)
        ) : null), announcement_message_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(announcement_message_arg) & -2);
        const ret_hu_conv = new NodeAnnouncementInfo(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.NodeAnnouncementInfo_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the NodeAnnouncementInfo
     */ clone() {
        const ret = _bindingsMjs.NodeAnnouncementInfo_clone(this.ptr);
        const ret_hu_conv = new NodeAnnouncementInfo(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the NodeAnnouncementInfo object into a byte array which can be read by NodeAnnouncementInfo_read
     */ write() {
        const ret = _bindingsMjs.NodeAnnouncementInfo_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a NodeAnnouncementInfo from a byte array, created by NodeAnnouncementInfo_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.NodeAnnouncementInfo_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultNodeAnnouncementInfoDecodeErrorZMjs.Result_NodeAnnouncementInfoDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/NodeAnnouncement.mjs":"549dY","../structs/Result_NodeAnnouncementInfoDecodeErrorZ.mjs":"db4MW","../structs/NodeFeatures.mjs":"8eCA6","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"db4MW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_NodeAnnouncementInfoDecodeErrorZ", ()=>Result_NodeAnnouncementInfoDecodeErrorZ
);
parcelHelpers.export(exports, "Result_NodeAnnouncementInfoDecodeErrorZ_OK", ()=>Result_NodeAnnouncementInfoDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_NodeAnnouncementInfoDecodeErrorZ_Err", ()=>Result_NodeAnnouncementInfoDecodeErrorZ_Err
) //# sourceMappingURL=Result_NodeAnnouncementInfoDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _nodeAnnouncementInfoMjs = require("../structs/NodeAnnouncementInfo.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_NodeAnnouncementInfoDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_NodeAnnouncementInfoDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(ptr)) return new Result_NodeAnnouncementInfoDecodeErrorZ_OK(null, ptr);
        else return new Result_NodeAnnouncementInfoDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_NodeAnnouncementInfoDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_NodeAnnouncementInfoDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_NodeAnnouncementInfoDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_NodeAnnouncementInfoDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_NodeAnnouncementInfoDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_NodeAnnouncementInfoDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_NodeAnnouncementInfoDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_NodeAnnouncementInfoDecodeErrorZ_OK extends Result_NodeAnnouncementInfoDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_NodeAnnouncementInfoDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _nodeAnnouncementInfoMjs.NodeAnnouncementInfo(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_NodeAnnouncementInfoDecodeErrorZ_Err extends Result_NodeAnnouncementInfoDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_NodeAnnouncementInfoDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/NodeAnnouncementInfo.mjs":"1pwML","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jcUte":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Details about a node in the network, known from the network announcement.
 */ parcelHelpers.export(exports, "NodeInfo", ()=>NodeInfo
) //# sourceMappingURL=NodeInfo.mjs.map
;
var _routingFeesMjs = require("../structs/RoutingFees.mjs");
var _nodeAnnouncementInfoMjs = require("../structs/NodeAnnouncementInfo.mjs");
var _resultNodeInfoDecodeErrorZMjs = require("../structs/Result_NodeInfoDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class NodeInfo extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.NodeInfo_free);
    }
    /**
     * All valid channels a node has announced
     */ set_channels(val) {
        _bindingsMjs.NodeInfo_set_channels(this.ptr, _bindingsMjs.encodeUint64Array(val));
    }
    /**
     * Lowest fees enabling routing via any of the enabled, known channels to a node.
     * The two fields (flat and proportional fee) are independent,
     * meaning they don't have to refer to the same channel.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_lowest_inbound_channel_fees() {
        const ret = _bindingsMjs.NodeInfo_get_lowest_inbound_channel_fees(this.ptr);
        const ret_hu_conv = new _routingFeesMjs.RoutingFees(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Lowest fees enabling routing via any of the enabled, known channels to a node.
     * The two fields (flat and proportional fee) are independent,
     * meaning they don't have to refer to the same channel.
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_lowest_inbound_channel_fees(val) {
        _bindingsMjs.NodeInfo_set_lowest_inbound_channel_fees(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * More information about a node from node_announcement.
     * Optional because we store a Node entry after learning about it from
     * a channel announcement, but before receiving a node announcement.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_announcement_info() {
        const ret = _bindingsMjs.NodeInfo_get_announcement_info(this.ptr);
        const ret_hu_conv = new _nodeAnnouncementInfoMjs.NodeAnnouncementInfo(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * More information about a node from node_announcement.
     * Optional because we store a Node entry after learning about it from
     * a channel announcement, but before receiving a node announcement.
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_announcement_info(val) {
        _bindingsMjs.NodeInfo_set_announcement_info(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Constructs a new NodeInfo given each field
     */ static constructor_new(channels_arg, lowest_inbound_channel_fees_arg, announcement_info_arg) {
        const ret = _bindingsMjs.NodeInfo_new(_bindingsMjs.encodeUint64Array(channels_arg), lowest_inbound_channel_fees_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(lowest_inbound_channel_fees_arg) & -2, announcement_info_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(announcement_info_arg) & -2);
        const ret_hu_conv = new NodeInfo(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.NodeInfo_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the NodeInfo
     */ clone() {
        const ret = _bindingsMjs.NodeInfo_clone(this.ptr);
        const ret_hu_conv = new NodeInfo(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the NodeInfo object into a byte array which can be read by NodeInfo_read
     */ write() {
        const ret = _bindingsMjs.NodeInfo_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a NodeInfo from a byte array, created by NodeInfo_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.NodeInfo_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultNodeInfoDecodeErrorZMjs.Result_NodeInfoDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/RoutingFees.mjs":"7CDJ9","../structs/NodeAnnouncementInfo.mjs":"1pwML","../structs/Result_NodeInfoDecodeErrorZ.mjs":"eby6q","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eby6q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_NodeInfoDecodeErrorZ", ()=>Result_NodeInfoDecodeErrorZ
);
parcelHelpers.export(exports, "Result_NodeInfoDecodeErrorZ_OK", ()=>Result_NodeInfoDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_NodeInfoDecodeErrorZ_Err", ()=>Result_NodeInfoDecodeErrorZ_Err
) //# sourceMappingURL=Result_NodeInfoDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _nodeInfoMjs = require("../structs/NodeInfo.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_NodeInfoDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_NodeInfoDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_NodeInfoDecodeErrorZ_is_ok(ptr)) return new Result_NodeInfoDecodeErrorZ_OK(null, ptr);
        else return new Result_NodeInfoDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_NodeInfoDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_NodeInfoDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_NodeInfoDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_NodeInfoDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_NodeInfoDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_NodeInfoDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_NodeInfoDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_NodeInfoDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_NodeInfoDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_NodeInfoDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_NodeInfoDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_NodeInfoDecodeErrorZ_OK extends Result_NodeInfoDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_NodeInfoDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _nodeInfoMjs.NodeInfo(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_NodeInfoDecodeErrorZ_Err extends Result_NodeInfoDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_NodeInfoDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/NodeInfo.mjs":"jcUte","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j3hPx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Represents the network as nodes and channels between them
 */ parcelHelpers.export(exports, "NetworkGraph", ()=>NetworkGraph
) //# sourceMappingURL=NetworkGraph.mjs.map
;
var _resultNoneLightningErrorZMjs = require("../structs/Result_NoneLightningErrorZ.mjs");
var _resultNetworkGraphDecodeErrorZMjs = require("../structs/Result_NetworkGraphDecodeErrorZ.mjs");
var _readOnlyNetworkGraphMjs = require("../structs/ReadOnlyNetworkGraph.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class NetworkGraph extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.NetworkGraph_free);
    }
    clone_ptr() {
        const ret = _bindingsMjs.NetworkGraph_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the NetworkGraph
     */ clone() {
        const ret = _bindingsMjs.NetworkGraph_clone(this.ptr);
        const ret_hu_conv = new NetworkGraph(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the NetworkGraph object into a byte array which can be read by NetworkGraph_read
     */ write() {
        const ret = _bindingsMjs.NetworkGraph_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a NetworkGraph from a byte array, created by NetworkGraph_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.NetworkGraph_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultNetworkGraphDecodeErrorZMjs.Result_NetworkGraphDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new, empty, network graph.
     */ static constructor_new(genesis_hash) {
        const ret = _bindingsMjs.NetworkGraph_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(genesis_hash, 32)));
        const ret_hu_conv = new NetworkGraph(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Returns a read-only view of the network graph.
     */ read_only() {
        const ret = _bindingsMjs.NetworkGraph_read_only(this.ptr);
        const ret_hu_conv = new _readOnlyNetworkGraphMjs.ReadOnlyNetworkGraph(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * For an already known node (from channel announcements), update its stored properties from a
     * given node announcement.
     *
     * You probably don't want to call this directly, instead relying on a NetGraphMsgHandler's
     * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
     * routing messages from a source using a protocol other than the lightning P2P protocol.
     */ update_node_from_announcement(msg) {
        const ret = _bindingsMjs.NetworkGraph_update_node_from_announcement(this.ptr, msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = _resultNoneLightningErrorZMjs.Result_NoneLightningErrorZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
        return ret_hu_conv;
    }
    /**
     * For an already known node (from channel announcements), update its stored properties from a
     * given node announcement without verifying the associated signatures. Because we aren't
     * given the associated signatures here we cannot relay the node announcement to any of our
     * peers.
     */ update_node_from_unsigned_announcement(msg) {
        const ret = _bindingsMjs.NetworkGraph_update_node_from_unsigned_announcement(this.ptr, msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = _resultNoneLightningErrorZMjs.Result_NoneLightningErrorZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
        return ret_hu_conv;
    }
    /**
     * Store or update channel info from a channel announcement.
     *
     * You probably don't want to call this directly, instead relying on a NetGraphMsgHandler's
     * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
     * routing messages from a source using a protocol other than the lightning P2P protocol.
     *
     * If a `chain::Access` object is provided via `chain_access`, it will be called to verify
     * the corresponding UTXO exists on chain and is correctly-formatted.
     */ update_channel_from_announcement(msg, chain_access) {
        const ret = _bindingsMjs.NetworkGraph_update_channel_from_announcement(this.ptr, msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2, _commonBaseMjsDefault.default.get_ptr_of(chain_access));
        const ret_hu_conv = _resultNoneLightningErrorZMjs.Result_NoneLightningErrorZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
        _commonBaseMjsDefault.default.add_ref_from(this, chain_access);
        return ret_hu_conv;
    }
    /**
     * Store or update channel info from a channel announcement without verifying the associated
     * signatures. Because we aren't given the associated signatures here we cannot relay the
     * channel announcement to any of our peers.
     *
     * If a `chain::Access` object is provided via `chain_access`, it will be called to verify
     * the corresponding UTXO exists on chain and is correctly-formatted.
     */ update_channel_from_unsigned_announcement(msg, chain_access) {
        const ret = _bindingsMjs.NetworkGraph_update_channel_from_unsigned_announcement(this.ptr, msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2, _commonBaseMjsDefault.default.get_ptr_of(chain_access));
        const ret_hu_conv = _resultNoneLightningErrorZMjs.Result_NoneLightningErrorZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
        _commonBaseMjsDefault.default.add_ref_from(this, chain_access);
        return ret_hu_conv;
    }
    /**
     * Close a channel if a corresponding HTLC fail was sent.
     * If permanent, removes a channel from the local storage.
     * May cause the removal of nodes too, if this was their last channel.
     * If not permanent, makes channels unavailable for routing.
     */ close_channel_from_update(short_channel_id, is_permanent) {
        _bindingsMjs.NetworkGraph_close_channel_from_update(this.ptr, short_channel_id, is_permanent);
    }
    /**
     * Marks a node in the graph as failed.
     */ fail_node(_node_id, is_permanent) {
        _bindingsMjs.NetworkGraph_fail_node(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(_node_id, 33)), is_permanent);
    }
    /**
     * Removes information about channels that we haven't heard any updates about in some time.
     * This can be used regularly to prune the network graph of channels that likely no longer
     * exist.
     *
     * While there is no formal requirement that nodes regularly re-broadcast their channel
     * updates every two weeks, the non-normative section of BOLT 7 currently suggests that
     * pruning occur for updates which are at least two weeks old, which we implement here.
     *
     * This function takes the current unix time as an argument. For users with the `std` feature
     * enabled, [`NetworkGraph::remove_stale_channels`] may be preferable.
     */ remove_stale_channels_with_time(current_time_unix) {
        _bindingsMjs.NetworkGraph_remove_stale_channels_with_time(this.ptr, current_time_unix);
    }
    /**
     * For an already known (from announcement) channel, update info about one of the directions
     * of the channel.
     *
     * You probably don't want to call this directly, instead relying on a NetGraphMsgHandler's
     * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
     * routing messages from a source using a protocol other than the lightning P2P protocol.
     *
     * If built with `no-std`, any updates with a timestamp more than two weeks in the past or
     * materially in the future will be rejected.
     */ update_channel(msg) {
        const ret = _bindingsMjs.NetworkGraph_update_channel(this.ptr, msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = _resultNoneLightningErrorZMjs.Result_NoneLightningErrorZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
        return ret_hu_conv;
    }
    /**
     * For an already known (from announcement) channel, update info about one of the directions
     * of the channel without verifying the associated signatures. Because we aren't given the
     * associated signatures here we cannot relay the channel update to any of our peers.
     *
     * If built with `no-std`, any updates with a timestamp more than two weeks in the past or
     * materially in the future will be rejected.
     */ update_channel_unsigned(msg) {
        const ret = _bindingsMjs.NetworkGraph_update_channel_unsigned(this.ptr, msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = _resultNoneLightningErrorZMjs.Result_NoneLightningErrorZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
        return ret_hu_conv;
    }
}

},{"../structs/Result_NoneLightningErrorZ.mjs":"TA9p3","../structs/Result_NetworkGraphDecodeErrorZ.mjs":"3MMjD","../structs/ReadOnlyNetworkGraph.mjs":"loBye","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3MMjD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_NetworkGraphDecodeErrorZ", ()=>Result_NetworkGraphDecodeErrorZ
);
parcelHelpers.export(exports, "Result_NetworkGraphDecodeErrorZ_OK", ()=>Result_NetworkGraphDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_NetworkGraphDecodeErrorZ_Err", ()=>Result_NetworkGraphDecodeErrorZ_Err
) //# sourceMappingURL=Result_NetworkGraphDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _networkGraphMjs = require("../structs/NetworkGraph.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_NetworkGraphDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_NetworkGraphDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_NetworkGraphDecodeErrorZ_is_ok(ptr)) return new Result_NetworkGraphDecodeErrorZ_OK(null, ptr);
        else return new Result_NetworkGraphDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_NetworkGraphDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_NetworkGraphDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_NetworkGraphDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_NetworkGraphDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_NetworkGraphDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_NetworkGraphDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_NetworkGraphDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_NetworkGraphDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_NetworkGraphDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_NetworkGraphDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_NetworkGraphDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_NetworkGraphDecodeErrorZ_OK extends Result_NetworkGraphDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_NetworkGraphDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _networkGraphMjs.NetworkGraph(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_NetworkGraphDecodeErrorZ_Err extends Result_NetworkGraphDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_NetworkGraphDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/NetworkGraph.mjs":"j3hPx","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"loBye":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A read-only view of [`NetworkGraph`].
 */ parcelHelpers.export(exports, "ReadOnlyNetworkGraph", ()=>ReadOnlyNetworkGraph
) //# sourceMappingURL=ReadOnlyNetworkGraph.mjs.map
;
var _optionCVecNetAddressZZMjs = require("../structs/Option_CVec_NetAddressZZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ReadOnlyNetworkGraph extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ReadOnlyNetworkGraph_free);
    }
    /**
     * Get network addresses by node id.
     * Returns None if the requested node is completely unknown,
     * or if node announcement for the node was never received.
     */ get_addresses(pubkey) {
        const ret = _bindingsMjs.ReadOnlyNetworkGraph_get_addresses(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(pubkey, 33)));
        const ret_hu_conv = _optionCVecNetAddressZZMjs.Option_CVec_NetAddressZZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"../structs/Option_CVec_NetAddressZZ.mjs":"auEdx","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"auEdx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An enum which can either contain a crate::c_types::derived::CVec_NetAddressZ or not
 */ parcelHelpers.export(exports, "Option_CVec_NetAddressZZ", ()=>Option_CVec_NetAddressZZ
);
/** A Option_CVec_NetAddressZZ of type Some */ parcelHelpers.export(exports, "Option_CVec_NetAddressZZ_Some", ()=>Option_CVec_NetAddressZZ_Some
);
/** A Option_CVec_NetAddressZZ of type None */ parcelHelpers.export(exports, "Option_CVec_NetAddressZZ_None", ()=>Option_CVec_NetAddressZZ_None
) //# sourceMappingURL=Option_CVec_NetAddressZZ.mjs.map
;
var _netAddressMjs = require("../structs/NetAddress.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Option_CVec_NetAddressZZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.COption_CVec_NetAddressZZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKCOption_CVec_NetAddressZZ_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new Option_CVec_NetAddressZZ_Some(ptr);
            case 1:
                return new Option_CVec_NetAddressZZ_None(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    /**
     * Constructs a new COption_CVec_NetAddressZZ containing a crate::c_types::derived::CVec_NetAddressZ
     */ static constructor_some(o) {
        const ret = _bindingsMjs.COption_CVec_NetAddressZZ_some(_bindingsMjs.encodeUint32Array(o != null ? o.map((o_conv_12)=>_commonBaseMjsDefault.default.get_ptr_of(o_conv_12)
        ) : null));
        const ret_hu_conv = Option_CVec_NetAddressZZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Constructs a new COption_CVec_NetAddressZZ containing nothing
     */ static constructor_none() {
        const ret = _bindingsMjs.COption_CVec_NetAddressZZ_none();
        const ret_hu_conv = Option_CVec_NetAddressZZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.COption_CVec_NetAddressZZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new COption_CVec_NetAddressZZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.COption_CVec_NetAddressZZ_clone(this.ptr);
        const ret_hu_conv = Option_CVec_NetAddressZZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
class Option_CVec_NetAddressZZ_Some extends Option_CVec_NetAddressZZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const some = _bindingsMjs.LDKCOption_CVec_NetAddressZZ_Some_get_some(ptr);
        const some_conv_12_len = _bindingsMjs.getArrayLength(some);
        const some_conv_12_arr = new Array(some_conv_12_len).fill(null);
        for(var m = 0; m < some_conv_12_len; m++){
            const some_conv_12 = _bindingsMjs.getU32ArrayElem(some, m);
            const some_conv_12_hu_conv = _netAddressMjs.NetAddress.constr_from_ptr(some_conv_12);
            _commonBaseMjsDefault.default.add_ref_from(some_conv_12_hu_conv, this);
            some_conv_12_arr[m] = some_conv_12_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(some);
        this.some = some_conv_12_arr;
    }
}
class Option_CVec_NetAddressZZ_None extends Option_CVec_NetAddressZZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}

},{"../structs/NetAddress.mjs":"dIj09","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lGxgx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Parameters for configuring [`Scorer`].
 */ parcelHelpers.export(exports, "ScoringParameters", ()=>ScoringParameters
) //# sourceMappingURL=ScoringParameters.mjs.map
;
var _resultScoringParametersDecodeErrorZMjs = require("../structs/Result_ScoringParametersDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ScoringParameters extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ScoringParameters_free);
    }
    /**
     * A fixed penalty in msats to apply to each channel.
     *
     * Default value: 500 msat
     */ get_base_penalty_msat() {
        const ret = _bindingsMjs.ScoringParameters_get_base_penalty_msat(this.ptr);
        return ret;
    }
    /**
     * A fixed penalty in msats to apply to each channel.
     *
     * Default value: 500 msat
     */ set_base_penalty_msat(val) {
        _bindingsMjs.ScoringParameters_set_base_penalty_msat(this.ptr, val);
    }
    /**
     * A penalty in msats to apply to a channel upon failing to relay a payment.
     *
     * This accumulates for each failure but may be reduced over time based on
     * [`failure_penalty_half_life`] or when successfully routing through a channel.
     *
     * Default value: 1,024,000 msat
     *
     * [`failure_penalty_half_life`]: Self::failure_penalty_half_life
     */ get_failure_penalty_msat() {
        const ret = _bindingsMjs.ScoringParameters_get_failure_penalty_msat(this.ptr);
        return ret;
    }
    /**
     * A penalty in msats to apply to a channel upon failing to relay a payment.
     *
     * This accumulates for each failure but may be reduced over time based on
     * [`failure_penalty_half_life`] or when successfully routing through a channel.
     *
     * Default value: 1,024,000 msat
     *
     * [`failure_penalty_half_life`]: Self::failure_penalty_half_life
     */ set_failure_penalty_msat(val) {
        _bindingsMjs.ScoringParameters_set_failure_penalty_msat(this.ptr, val);
    }
    /**
     * When the amount being sent over a channel is this many 1024ths of the total channel
     * capacity, we begin applying [`overuse_penalty_msat_per_1024th`].
     *
     * Default value: 128 1024ths (i.e. begin penalizing when an HTLC uses 1/8th of a channel)
     *
     * [`overuse_penalty_msat_per_1024th`]: Self::overuse_penalty_msat_per_1024th
     */ get_overuse_penalty_start_1024th() {
        const ret = _bindingsMjs.ScoringParameters_get_overuse_penalty_start_1024th(this.ptr);
        return ret;
    }
    /**
     * When the amount being sent over a channel is this many 1024ths of the total channel
     * capacity, we begin applying [`overuse_penalty_msat_per_1024th`].
     *
     * Default value: 128 1024ths (i.e. begin penalizing when an HTLC uses 1/8th of a channel)
     *
     * [`overuse_penalty_msat_per_1024th`]: Self::overuse_penalty_msat_per_1024th
     */ set_overuse_penalty_start_1024th(val) {
        _bindingsMjs.ScoringParameters_set_overuse_penalty_start_1024th(this.ptr, val);
    }
    /**
     * A penalty applied, per whole 1024ths of the channel capacity which the amount being sent
     * over the channel exceeds [`overuse_penalty_start_1024th`] by.
     *
     * Default value: 20 msat (i.e. 2560 msat penalty to use 1/4th of a channel, 7680 msat penalty
     * to use half a channel, and 12,560 msat penalty to use 3/4ths of a channel)
     *
     * [`overuse_penalty_start_1024th`]: Self::overuse_penalty_start_1024th
     */ get_overuse_penalty_msat_per_1024th() {
        const ret = _bindingsMjs.ScoringParameters_get_overuse_penalty_msat_per_1024th(this.ptr);
        return ret;
    }
    /**
     * A penalty applied, per whole 1024ths of the channel capacity which the amount being sent
     * over the channel exceeds [`overuse_penalty_start_1024th`] by.
     *
     * Default value: 20 msat (i.e. 2560 msat penalty to use 1/4th of a channel, 7680 msat penalty
     * to use half a channel, and 12,560 msat penalty to use 3/4ths of a channel)
     *
     * [`overuse_penalty_start_1024th`]: Self::overuse_penalty_start_1024th
     */ set_overuse_penalty_msat_per_1024th(val) {
        _bindingsMjs.ScoringParameters_set_overuse_penalty_msat_per_1024th(this.ptr, val);
    }
    /**
     * The time required to elapse before any accumulated [`failure_penalty_msat`] penalties are
     * cut in half.
     *
     * Successfully routing through a channel will immediately cut the penalty in half as well.
     *
     * # Note
     *
     * When built with the `no-std` feature, time will never elapse. Therefore, this penalty will
     * never decay.
     *
     * [`failure_penalty_msat`]: Self::failure_penalty_msat
     */ get_failure_penalty_half_life() {
        const ret = _bindingsMjs.ScoringParameters_get_failure_penalty_half_life(this.ptr);
        return ret;
    }
    /**
     * The time required to elapse before any accumulated [`failure_penalty_msat`] penalties are
     * cut in half.
     *
     * Successfully routing through a channel will immediately cut the penalty in half as well.
     *
     * # Note
     *
     * When built with the `no-std` feature, time will never elapse. Therefore, this penalty will
     * never decay.
     *
     * [`failure_penalty_msat`]: Self::failure_penalty_msat
     */ set_failure_penalty_half_life(val) {
        _bindingsMjs.ScoringParameters_set_failure_penalty_half_life(this.ptr, val);
    }
    /**
     * Constructs a new ScoringParameters given each field
     */ static constructor_new(base_penalty_msat_arg, failure_penalty_msat_arg, overuse_penalty_start_1024th_arg, overuse_penalty_msat_per_1024th_arg, failure_penalty_half_life_arg) {
        const ret = _bindingsMjs.ScoringParameters_new(base_penalty_msat_arg, failure_penalty_msat_arg, overuse_penalty_start_1024th_arg, overuse_penalty_msat_per_1024th_arg, failure_penalty_half_life_arg);
        const ret_hu_conv = new ScoringParameters(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Serialize the ScoringParameters object into a byte array which can be read by ScoringParameters_read
     */ write() {
        const ret = _bindingsMjs.ScoringParameters_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ScoringParameters from a byte array, created by ScoringParameters_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ScoringParameters_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultScoringParametersDecodeErrorZMjs.Result_ScoringParametersDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a "default" ScoringParameters. See struct and individual field documentaiton for details on which values are used.
     */ static constructor_default() {
        const ret = _bindingsMjs.ScoringParameters_default();
        const ret_hu_conv = new ScoringParameters(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"../structs/Result_ScoringParametersDecodeErrorZ.mjs":"flqBk","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"flqBk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ScoringParametersDecodeErrorZ", ()=>Result_ScoringParametersDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ScoringParametersDecodeErrorZ_OK", ()=>Result_ScoringParametersDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ScoringParametersDecodeErrorZ_Err", ()=>Result_ScoringParametersDecodeErrorZ_Err
) //# sourceMappingURL=Result_ScoringParametersDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _scoringParametersMjs = require("../structs/ScoringParameters.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ScoringParametersDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ScoringParametersDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ScoringParametersDecodeErrorZ_is_ok(ptr)) return new Result_ScoringParametersDecodeErrorZ_OK(null, ptr);
        else return new Result_ScoringParametersDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ScoringParametersDecodeErrorZ in the success state.
     */ static constructor_ok(o_base_penalty_msat_arg, o_failure_penalty_msat_arg, o_overuse_penalty_start_1024th_arg, o_overuse_penalty_msat_per_1024th_arg, o_failure_penalty_half_life_arg) {
        const ret = _bindingsMjs.CResult_ScoringParametersDecodeErrorZ_ok(_bindingsMjs.ScoringParameters_new(o_base_penalty_msat_arg, o_failure_penalty_msat_arg, o_overuse_penalty_start_1024th_arg, o_overuse_penalty_msat_per_1024th_arg, o_failure_penalty_half_life_arg));
        const ret_hu_conv = Result_ScoringParametersDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ScoringParametersDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ScoringParametersDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ScoringParametersDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ScoringParametersDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
}
class Result_ScoringParametersDecodeErrorZ_OK extends Result_ScoringParametersDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ScoringParametersDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _scoringParametersMjs.ScoringParameters(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ScoringParametersDecodeErrorZ_Err extends Result_ScoringParametersDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ScoringParametersDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/ScoringParameters.mjs":"lGxgx","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9tT7T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An init message to be sent or received from a peer
 */ parcelHelpers.export(exports, "Init", ()=>Init
) //# sourceMappingURL=Init.mjs.map
;
var _initFeaturesMjs = require("../structs/InitFeatures.mjs");
var _resultInitDecodeErrorZMjs = require("../structs/Result_InitDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Init extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Init_free);
    }
    /**
     * The relevant features which the sender supports
     */ get_features() {
        const ret = _bindingsMjs.Init_get_features(this.ptr);
        const ret_hu_conv = new _initFeaturesMjs.InitFeatures(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The relevant features which the sender supports
     */ set_features(val) {
        _bindingsMjs.Init_set_features(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Constructs a new Init given each field
     */ static constructor_new(features_arg) {
        const ret = _bindingsMjs.Init_new(features_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(features_arg) & -2);
        const ret_hu_conv = new Init(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.Init_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the Init
     */ clone() {
        const ret = _bindingsMjs.Init_clone(this.ptr);
        const ret_hu_conv = new Init(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the Init object into a byte array which can be read by Init_read
     */ write() {
        const ret = _bindingsMjs.Init_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a Init from a byte array, created by Init_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.Init_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultInitDecodeErrorZMjs.Result_InitDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/InitFeatures.mjs":"iilSK","../structs/Result_InitDecodeErrorZ.mjs":"c70DB","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c70DB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_InitDecodeErrorZ", ()=>Result_InitDecodeErrorZ
);
parcelHelpers.export(exports, "Result_InitDecodeErrorZ_OK", ()=>Result_InitDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_InitDecodeErrorZ_Err", ()=>Result_InitDecodeErrorZ_Err
) //# sourceMappingURL=Result_InitDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _initMjs = require("../structs/Init.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_InitDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_InitDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_InitDecodeErrorZ_is_ok(ptr)) return new Result_InitDecodeErrorZ_OK(null, ptr);
        else return new Result_InitDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_InitDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_InitDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_InitDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_InitDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_InitDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_InitDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_InitDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_InitDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_InitDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_InitDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_InitDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_InitDecodeErrorZ_OK extends Result_InitDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_InitDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _initMjs.Init(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_InitDecodeErrorZ_Err extends Result_InitDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_InitDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/Init.mjs":"9tT7T","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4s5GI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A ping message to be sent or received from a peer
 */ parcelHelpers.export(exports, "Ping", ()=>Ping
) //# sourceMappingURL=Ping.mjs.map
;
var _resultPingDecodeErrorZMjs = require("../structs/Result_PingDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Ping extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Ping_free);
    }
    /**
     * The desired response length
     */ get_ponglen() {
        const ret = _bindingsMjs.Ping_get_ponglen(this.ptr);
        return ret;
    }
    /**
     * The desired response length
     */ set_ponglen(val) {
        _bindingsMjs.Ping_set_ponglen(this.ptr, val);
    }
    /**
     * The ping packet size.
     * This field is not sent on the wire. byteslen zeros are sent.
     */ get_byteslen() {
        const ret = _bindingsMjs.Ping_get_byteslen(this.ptr);
        return ret;
    }
    /**
     * The ping packet size.
     * This field is not sent on the wire. byteslen zeros are sent.
     */ set_byteslen(val) {
        _bindingsMjs.Ping_set_byteslen(this.ptr, val);
    }
    /**
     * Constructs a new Ping given each field
     */ static constructor_new(ponglen_arg, byteslen_arg) {
        const ret = _bindingsMjs.Ping_new(ponglen_arg, byteslen_arg);
        const ret_hu_conv = new Ping(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.Ping_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the Ping
     */ clone() {
        const ret = _bindingsMjs.Ping_clone(this.ptr);
        const ret_hu_conv = new Ping(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the Ping object into a byte array which can be read by Ping_read
     */ write() {
        const ret = _bindingsMjs.Ping_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a Ping from a byte array, created by Ping_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.Ping_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultPingDecodeErrorZMjs.Result_PingDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_PingDecodeErrorZ.mjs":"9manO","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9manO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_PingDecodeErrorZ", ()=>Result_PingDecodeErrorZ
);
parcelHelpers.export(exports, "Result_PingDecodeErrorZ_OK", ()=>Result_PingDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_PingDecodeErrorZ_Err", ()=>Result_PingDecodeErrorZ_Err
) //# sourceMappingURL=Result_PingDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _pingMjs = require("../structs/Ping.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_PingDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_PingDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_PingDecodeErrorZ_is_ok(ptr)) return new Result_PingDecodeErrorZ_OK(null, ptr);
        else return new Result_PingDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_PingDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_PingDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_PingDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_PingDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_PingDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_PingDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_PingDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_PingDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_PingDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_PingDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_PingDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_PingDecodeErrorZ_OK extends Result_PingDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_PingDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _pingMjs.Ping(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_PingDecodeErrorZ_Err extends Result_PingDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_PingDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/Ping.mjs":"4s5GI","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1hCvO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A pong message to be sent or received from a peer
 */ parcelHelpers.export(exports, "Pong", ()=>Pong
) //# sourceMappingURL=Pong.mjs.map
;
var _resultPongDecodeErrorZMjs = require("../structs/Result_PongDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Pong extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Pong_free);
    }
    /**
     * The pong packet size.
     * This field is not sent on the wire. byteslen zeros are sent.
     */ get_byteslen() {
        const ret = _bindingsMjs.Pong_get_byteslen(this.ptr);
        return ret;
    }
    /**
     * The pong packet size.
     * This field is not sent on the wire. byteslen zeros are sent.
     */ set_byteslen(val) {
        _bindingsMjs.Pong_set_byteslen(this.ptr, val);
    }
    /**
     * Constructs a new Pong given each field
     */ static constructor_new(byteslen_arg) {
        const ret = _bindingsMjs.Pong_new(byteslen_arg);
        const ret_hu_conv = new Pong(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.Pong_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the Pong
     */ clone() {
        const ret = _bindingsMjs.Pong_clone(this.ptr);
        const ret_hu_conv = new Pong(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the Pong object into a byte array which can be read by Pong_read
     */ write() {
        const ret = _bindingsMjs.Pong_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a Pong from a byte array, created by Pong_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.Pong_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultPongDecodeErrorZMjs.Result_PongDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_PongDecodeErrorZ.mjs":"3JaYG","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3JaYG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_PongDecodeErrorZ", ()=>Result_PongDecodeErrorZ
);
parcelHelpers.export(exports, "Result_PongDecodeErrorZ_OK", ()=>Result_PongDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_PongDecodeErrorZ_Err", ()=>Result_PongDecodeErrorZ_Err
) //# sourceMappingURL=Result_PongDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _pongMjs = require("../structs/Pong.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_PongDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_PongDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_PongDecodeErrorZ_is_ok(ptr)) return new Result_PongDecodeErrorZ_OK(null, ptr);
        else return new Result_PongDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_PongDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_PongDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_PongDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_PongDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_PongDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_PongDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_PongDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_PongDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_PongDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_PongDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_PongDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_PongDecodeErrorZ_OK extends Result_PongDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_PongDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _pongMjs.Pong(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_PongDecodeErrorZ_Err extends Result_PongDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_PongDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/Pong.mjs":"1hCvO","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"02mnG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A reply_short_channel_ids_end message is sent as a reply to a
 * query_short_channel_ids message. The query recipient makes a best
 * effort to respond based on their local network view which may not be
 * a perfect view of the network.
 */ parcelHelpers.export(exports, "ReplyShortChannelIdsEnd", ()=>ReplyShortChannelIdsEnd
) //# sourceMappingURL=ReplyShortChannelIdsEnd.mjs.map
;
var _resultReplyShortChannelIdsEndDecodeErrorZMjs = require("../structs/Result_ReplyShortChannelIdsEndDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ReplyShortChannelIdsEnd extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ReplyShortChannelIdsEnd_free);
    }
    /**
     * The genesis hash of the blockchain that was queried
     */ get_chain_hash() {
        const ret = _bindingsMjs.ReplyShortChannelIdsEnd_get_chain_hash(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The genesis hash of the blockchain that was queried
     */ set_chain_hash(val) {
        _bindingsMjs.ReplyShortChannelIdsEnd_set_chain_hash(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * Indicates if the query recipient maintains up-to-date channel
     * information for the chain_hash
     */ get_full_information() {
        const ret = _bindingsMjs.ReplyShortChannelIdsEnd_get_full_information(this.ptr);
        return ret;
    }
    /**
     * Indicates if the query recipient maintains up-to-date channel
     * information for the chain_hash
     */ set_full_information(val) {
        _bindingsMjs.ReplyShortChannelIdsEnd_set_full_information(this.ptr, val);
    }
    /**
     * Constructs a new ReplyShortChannelIdsEnd given each field
     */ static constructor_new(chain_hash_arg, full_information_arg) {
        const ret = _bindingsMjs.ReplyShortChannelIdsEnd_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(chain_hash_arg, 32)), full_information_arg);
        const ret_hu_conv = new ReplyShortChannelIdsEnd(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ReplyShortChannelIdsEnd_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ReplyShortChannelIdsEnd
     */ clone() {
        const ret = _bindingsMjs.ReplyShortChannelIdsEnd_clone(this.ptr);
        const ret_hu_conv = new ReplyShortChannelIdsEnd(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the ReplyShortChannelIdsEnd object into a byte array which can be read by ReplyShortChannelIdsEnd_read
     */ write() {
        const ret = _bindingsMjs.ReplyShortChannelIdsEnd_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ReplyShortChannelIdsEnd from a byte array, created by ReplyShortChannelIdsEnd_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.ReplyShortChannelIdsEnd_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultReplyShortChannelIdsEndDecodeErrorZMjs.Result_ReplyShortChannelIdsEndDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_ReplyShortChannelIdsEndDecodeErrorZ.mjs":"aHsDd","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aHsDd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_ReplyShortChannelIdsEndDecodeErrorZ", ()=>Result_ReplyShortChannelIdsEndDecodeErrorZ
);
parcelHelpers.export(exports, "Result_ReplyShortChannelIdsEndDecodeErrorZ_OK", ()=>Result_ReplyShortChannelIdsEndDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_ReplyShortChannelIdsEndDecodeErrorZ_Err", ()=>Result_ReplyShortChannelIdsEndDecodeErrorZ_Err
) //# sourceMappingURL=Result_ReplyShortChannelIdsEndDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _replyShortChannelIdsEndMjs = require("../structs/ReplyShortChannelIdsEnd.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_ReplyShortChannelIdsEndDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_ReplyShortChannelIdsEndDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(ptr)) return new Result_ReplyShortChannelIdsEndDecodeErrorZ_OK(null, ptr);
        else return new Result_ReplyShortChannelIdsEndDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_ReplyShortChannelIdsEndDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_ReplyShortChannelIdsEndDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_ReplyShortChannelIdsEndDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_ReplyShortChannelIdsEndDecodeErrorZ_OK extends Result_ReplyShortChannelIdsEndDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _replyShortChannelIdsEndMjs.ReplyShortChannelIdsEnd(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_ReplyShortChannelIdsEndDecodeErrorZ_Err extends Result_ReplyShortChannelIdsEndDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/ReplyShortChannelIdsEnd.mjs":"02mnG","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9UwfR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A gossip_timestamp_filter message is used by a node to request
 * gossip relay for messages in the requested time range when the
 * gossip_queries feature has been negotiated.
 */ parcelHelpers.export(exports, "GossipTimestampFilter", ()=>GossipTimestampFilter
) //# sourceMappingURL=GossipTimestampFilter.mjs.map
;
var _resultGossipTimestampFilterDecodeErrorZMjs = require("../structs/Result_GossipTimestampFilterDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class GossipTimestampFilter extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.GossipTimestampFilter_free);
    }
    /**
     * The genesis hash of the blockchain for channel and node information
     */ get_chain_hash() {
        const ret = _bindingsMjs.GossipTimestampFilter_get_chain_hash(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The genesis hash of the blockchain for channel and node information
     */ set_chain_hash(val) {
        _bindingsMjs.GossipTimestampFilter_set_chain_hash(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The starting unix timestamp
     */ get_first_timestamp() {
        const ret = _bindingsMjs.GossipTimestampFilter_get_first_timestamp(this.ptr);
        return ret;
    }
    /**
     * The starting unix timestamp
     */ set_first_timestamp(val) {
        _bindingsMjs.GossipTimestampFilter_set_first_timestamp(this.ptr, val);
    }
    /**
     * The range of information in seconds
     */ get_timestamp_range() {
        const ret = _bindingsMjs.GossipTimestampFilter_get_timestamp_range(this.ptr);
        return ret;
    }
    /**
     * The range of information in seconds
     */ set_timestamp_range(val) {
        _bindingsMjs.GossipTimestampFilter_set_timestamp_range(this.ptr, val);
    }
    /**
     * Constructs a new GossipTimestampFilter given each field
     */ static constructor_new(chain_hash_arg, first_timestamp_arg, timestamp_range_arg) {
        const ret = _bindingsMjs.GossipTimestampFilter_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(chain_hash_arg, 32)), first_timestamp_arg, timestamp_range_arg);
        const ret_hu_conv = new GossipTimestampFilter(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.GossipTimestampFilter_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the GossipTimestampFilter
     */ clone() {
        const ret = _bindingsMjs.GossipTimestampFilter_clone(this.ptr);
        const ret_hu_conv = new GossipTimestampFilter(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the GossipTimestampFilter object into a byte array which can be read by GossipTimestampFilter_read
     */ write() {
        const ret = _bindingsMjs.GossipTimestampFilter_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a GossipTimestampFilter from a byte array, created by GossipTimestampFilter_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.GossipTimestampFilter_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultGossipTimestampFilterDecodeErrorZMjs.Result_GossipTimestampFilterDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_GossipTimestampFilterDecodeErrorZ.mjs":"b1Rk4","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b1Rk4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_GossipTimestampFilterDecodeErrorZ", ()=>Result_GossipTimestampFilterDecodeErrorZ
);
parcelHelpers.export(exports, "Result_GossipTimestampFilterDecodeErrorZ_OK", ()=>Result_GossipTimestampFilterDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_GossipTimestampFilterDecodeErrorZ_Err", ()=>Result_GossipTimestampFilterDecodeErrorZ_Err
) //# sourceMappingURL=Result_GossipTimestampFilterDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _gossipTimestampFilterMjs = require("../structs/GossipTimestampFilter.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_GossipTimestampFilterDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_GossipTimestampFilterDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_GossipTimestampFilterDecodeErrorZ_is_ok(ptr)) return new Result_GossipTimestampFilterDecodeErrorZ_OK(null, ptr);
        else return new Result_GossipTimestampFilterDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_GossipTimestampFilterDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_GossipTimestampFilterDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_GossipTimestampFilterDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_GossipTimestampFilterDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_GossipTimestampFilterDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_GossipTimestampFilterDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_GossipTimestampFilterDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_GossipTimestampFilterDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_GossipTimestampFilterDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_GossipTimestampFilterDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_GossipTimestampFilterDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_GossipTimestampFilterDecodeErrorZ_OK extends Result_GossipTimestampFilterDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_GossipTimestampFilterDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _gossipTimestampFilterMjs.GossipTimestampFilter(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_GossipTimestampFilterDecodeErrorZ_Err extends Result_GossipTimestampFilterDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_GossipTimestampFilterDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/GossipTimestampFilter.mjs":"9UwfR","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"htjqc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_SignDecodeErrorZ", ()=>Result_SignDecodeErrorZ
);
parcelHelpers.export(exports, "Result_SignDecodeErrorZ_OK", ()=>Result_SignDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_SignDecodeErrorZ_Err", ()=>Result_SignDecodeErrorZ_Err
) //# sourceMappingURL=Result_SignDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _signMjs = require("../structs/Sign.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_SignDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_SignDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_SignDecodeErrorZ_is_ok(ptr)) return new Result_SignDecodeErrorZ_OK(null, ptr);
        else return new Result_SignDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_SignDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_SignDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o));
        const ret_hu_conv = Result_SignDecodeErrorZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, o);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_SignDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_SignDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_SignDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_SignDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_SignDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_SignDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_SignDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_SignDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_SignDecodeErrorZ_OK extends Result_SignDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_SignDecodeErrorZ_get_ok(ptr);
        const ret_hu_conv = new _signMjs.Sign(null, res);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        this.res = ret_hu_conv;
    }
}
class Result_SignDecodeErrorZ_Err extends Result_SignDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_SignDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/Sign.mjs":"jgkjb","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"34rca":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_RecoverableSignatureNoneZ", ()=>Result_RecoverableSignatureNoneZ
);
parcelHelpers.export(exports, "Result_RecoverableSignatureNoneZ_OK", ()=>Result_RecoverableSignatureNoneZ_OK
);
parcelHelpers.export(exports, "Result_RecoverableSignatureNoneZ_Err", ()=>Result_RecoverableSignatureNoneZ_Err
) //# sourceMappingURL=Result_RecoverableSignatureNoneZ.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_RecoverableSignatureNoneZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_RecoverableSignatureNoneZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_RecoverableSignatureNoneZ_is_ok(ptr)) return new Result_RecoverableSignatureNoneZ_OK(null, ptr);
        else return new Result_RecoverableSignatureNoneZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_RecoverableSignatureNoneZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_RecoverableSignatureNoneZ_ok(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(o, 68)));
        const ret_hu_conv = Result_RecoverableSignatureNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_RecoverableSignatureNoneZ in the error state.
     */ static constructor_err() {
        const ret = _bindingsMjs.CResult_RecoverableSignatureNoneZ_err();
        const ret_hu_conv = Result_RecoverableSignatureNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_RecoverableSignatureNoneZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_RecoverableSignatureNoneZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_RecoverableSignatureNoneZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_RecoverableSignatureNoneZ_clone(this.ptr);
        const ret_hu_conv = Result_RecoverableSignatureNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_RecoverableSignatureNoneZ_OK extends Result_RecoverableSignatureNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_RecoverableSignatureNoneZ_get_ok(ptr);
        const res_conv = _bindingsMjs.decodeUint8Array(res);
        this.res = res_conv;
    }
}
class Result_RecoverableSignatureNoneZ_Err extends Result_RecoverableSignatureNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i9PFL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_CVec_CVec_u8ZZNoneZ", ()=>Result_CVec_CVec_u8ZZNoneZ
);
parcelHelpers.export(exports, "Result_CVec_CVec_u8ZZNoneZ_OK", ()=>Result_CVec_CVec_u8ZZNoneZ_OK
);
parcelHelpers.export(exports, "Result_CVec_CVec_u8ZZNoneZ_Err", ()=>Result_CVec_CVec_u8ZZNoneZ_Err
) //# sourceMappingURL=Result_CVec_CVec_u8ZZNoneZ.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_CVec_CVec_u8ZZNoneZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_CVec_CVec_u8ZZNoneZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_CVec_CVec_u8ZZNoneZ_is_ok(ptr)) return new Result_CVec_CVec_u8ZZNoneZ_OK(null, ptr);
        else return new Result_CVec_CVec_u8ZZNoneZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_CVec_CVec_u8ZZNoneZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_CVec_CVec_u8ZZNoneZ_ok(_bindingsMjs.encodeUint32Array(o != null ? o.map((o_conv_12)=>_bindingsMjs.encodeUint8Array(o_conv_12)
        ) : null));
        const ret_hu_conv = Result_CVec_CVec_u8ZZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_CVec_CVec_u8ZZNoneZ in the error state.
     */ static constructor_err() {
        const ret = _bindingsMjs.CResult_CVec_CVec_u8ZZNoneZ_err();
        const ret_hu_conv = Result_CVec_CVec_u8ZZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_CVec_CVec_u8ZZNoneZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_CVec_CVec_u8ZZNoneZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_CVec_CVec_u8ZZNoneZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_CVec_CVec_u8ZZNoneZ_clone(this.ptr);
        const ret_hu_conv = Result_CVec_CVec_u8ZZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_CVec_CVec_u8ZZNoneZ_OK extends Result_CVec_CVec_u8ZZNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_CVec_CVec_u8ZZNoneZ_get_ok(ptr);
        const res_conv_12_len = _bindingsMjs.getArrayLength(res);
        const res_conv_12_arr = new Array(res_conv_12_len).fill(null);
        for(var m = 0; m < res_conv_12_len; m++){
            const res_conv_12 = _bindingsMjs.getU32ArrayElem(res, m);
            const res_conv_12_conv = _bindingsMjs.decodeUint8Array(res_conv_12);
            res_conv_12_arr[m] = res_conv_12_conv;
        }
        _bindingsMjs.freeWasmMemory(res);
        this.res = res_conv_12_arr;
    }
}
class Result_CVec_CVec_u8ZZNoneZ_Err extends Result_CVec_CVec_u8ZZNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3SgwF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A simple implementation of Sign that just keeps the private keys in memory.
 *
 * This implementation performs no policy checks and is insufficient by itself as
 * a secure external signer.
 */ parcelHelpers.export(exports, "InMemorySigner", ()=>InMemorySigner
) //# sourceMappingURL=InMemorySigner.mjs.map
;
var _outPointMjs = require("../structs/OutPoint.mjs");
var _channelPublicKeysMjs = require("../structs/ChannelPublicKeys.mjs");
var _channelTransactionParametersMjs = require("../structs/ChannelTransactionParameters.mjs");
var _baseSignMjs = require("../structs/BaseSign.mjs");
var _signMjs = require("../structs/Sign.mjs");
var _resultCVecCVecU8ZZNoneZMjs = require("../structs/Result_CVec_CVec_u8ZZNoneZ.mjs");
var _resultInMemorySignerDecodeErrorZMjs = require("../structs/Result_InMemorySignerDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class InMemorySigner extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.InMemorySigner_free);
    }
    /**
     * Private key of anchor tx
     */ get_funding_key() {
        const ret = _bindingsMjs.InMemorySigner_get_funding_key(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Private key of anchor tx
     */ set_funding_key(val) {
        _bindingsMjs.InMemorySigner_set_funding_key(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * Holder secret key for blinded revocation pubkey
     */ get_revocation_base_key() {
        const ret = _bindingsMjs.InMemorySigner_get_revocation_base_key(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Holder secret key for blinded revocation pubkey
     */ set_revocation_base_key(val) {
        _bindingsMjs.InMemorySigner_set_revocation_base_key(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * Holder secret key used for our balance in counterparty-broadcasted commitment transactions
     */ get_payment_key() {
        const ret = _bindingsMjs.InMemorySigner_get_payment_key(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Holder secret key used for our balance in counterparty-broadcasted commitment transactions
     */ set_payment_key(val) {
        _bindingsMjs.InMemorySigner_set_payment_key(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * Holder secret key used in HTLC tx
     */ get_delayed_payment_base_key() {
        const ret = _bindingsMjs.InMemorySigner_get_delayed_payment_base_key(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Holder secret key used in HTLC tx
     */ set_delayed_payment_base_key(val) {
        _bindingsMjs.InMemorySigner_set_delayed_payment_base_key(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * Holder htlc secret key used in commitment tx htlc outputs
     */ get_htlc_base_key() {
        const ret = _bindingsMjs.InMemorySigner_get_htlc_base_key(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Holder htlc secret key used in commitment tx htlc outputs
     */ set_htlc_base_key(val) {
        _bindingsMjs.InMemorySigner_set_htlc_base_key(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * Commitment seed
     */ get_commitment_seed() {
        const ret = _bindingsMjs.InMemorySigner_get_commitment_seed(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Commitment seed
     */ set_commitment_seed(val) {
        _bindingsMjs.InMemorySigner_set_commitment_seed(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    clone_ptr() {
        const ret = _bindingsMjs.InMemorySigner_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the InMemorySigner
     */ clone() {
        const ret = _bindingsMjs.InMemorySigner_clone(this.ptr);
        const ret_hu_conv = new InMemorySigner(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Create a new InMemorySigner
     */ static constructor_new(funding_key, revocation_base_key, payment_key, delayed_payment_base_key, htlc_base_key, commitment_seed, channel_value_satoshis, channel_keys_id) {
        const ret = _bindingsMjs.InMemorySigner_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(funding_key, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(revocation_base_key, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_key, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(delayed_payment_base_key, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(htlc_base_key, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(commitment_seed, 32)), channel_value_satoshis, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_keys_id, 32)));
        const ret_hu_conv = new InMemorySigner(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Counterparty pubkeys.
     * Will panic if ready_channel wasn't called.
     */ counterparty_pubkeys() {
        const ret = _bindingsMjs.InMemorySigner_counterparty_pubkeys(this.ptr);
        const ret_hu_conv = new _channelPublicKeysMjs.ChannelPublicKeys(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The contest_delay value specified by our counterparty and applied on holder-broadcastable
     * transactions, ie the amount of time that we have to wait to recover our funds if we
     * broadcast a transaction.
     * Will panic if ready_channel wasn't called.
     */ counterparty_selected_contest_delay() {
        const ret = _bindingsMjs.InMemorySigner_counterparty_selected_contest_delay(this.ptr);
        return ret;
    }
    /**
     * The contest_delay value specified by us and applied on transactions broadcastable
     * by our counterparty, ie the amount of time that they have to wait to recover their funds
     * if they broadcast a transaction.
     * Will panic if ready_channel wasn't called.
     */ holder_selected_contest_delay() {
        const ret = _bindingsMjs.InMemorySigner_holder_selected_contest_delay(this.ptr);
        return ret;
    }
    /**
     * Whether the holder is the initiator
     * Will panic if ready_channel wasn't called.
     */ is_outbound() {
        const ret = _bindingsMjs.InMemorySigner_is_outbound(this.ptr);
        return ret;
    }
    /**
     * Funding outpoint
     * Will panic if ready_channel wasn't called.
     */ funding_outpoint() {
        const ret = _bindingsMjs.InMemorySigner_funding_outpoint(this.ptr);
        const ret_hu_conv = new _outPointMjs.OutPoint(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Obtain a ChannelTransactionParameters for this channel, to be used when verifying or
     * building transactions.
     *
     * Will panic if ready_channel wasn't called.
     */ get_channel_parameters() {
        const ret = _bindingsMjs.InMemorySigner_get_channel_parameters(this.ptr);
        const ret_hu_conv = new _channelTransactionParametersMjs.ChannelTransactionParameters(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Whether anchors should be used.
     * Will panic if ready_channel wasn't called.
     */ opt_anchors() {
        const ret = _bindingsMjs.InMemorySigner_opt_anchors(this.ptr);
        return ret;
    }
    /**
     * Sign the single input of spend_tx at index `input_idx` which spends the output
     * described by descriptor, returning the witness stack for the input.
     *
     * Returns an Err if the input at input_idx does not exist, has a non-empty script_sig,
     * or is not spending the outpoint described by `descriptor.outpoint`.
     */ sign_counterparty_payment_input(spend_tx, input_idx, descriptor) {
        const ret = _bindingsMjs.InMemorySigner_sign_counterparty_payment_input(this.ptr, _bindingsMjs.encodeUint8Array(spend_tx), input_idx, descriptor == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(descriptor) & -2);
        const ret_hu_conv = _resultCVecCVecU8ZZNoneZMjs.Result_CVec_CVec_u8ZZNoneZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, descriptor);
        return ret_hu_conv;
    }
    /**
     * Sign the single input of spend_tx at index `input_idx` which spends the output
     * described by descriptor, returning the witness stack for the input.
     *
     * Returns an Err if the input at input_idx does not exist, has a non-empty script_sig,
     * is not spending the outpoint described by `descriptor.outpoint`, or does not have a
     * sequence set to `descriptor.to_self_delay`.
     */ sign_dynamic_p2wsh_input(spend_tx, input_idx, descriptor) {
        const ret = _bindingsMjs.InMemorySigner_sign_dynamic_p2wsh_input(this.ptr, _bindingsMjs.encodeUint8Array(spend_tx), input_idx, descriptor == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(descriptor) & -2);
        const ret_hu_conv = _resultCVecCVecU8ZZNoneZMjs.Result_CVec_CVec_u8ZZNoneZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, descriptor);
        return ret_hu_conv;
    }
    /**
     * Constructs a new BaseSign which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned BaseSign must be freed before this_arg is
     */ as_BaseSign() {
        const ret = _bindingsMjs.InMemorySigner_as_BaseSign(this.ptr);
        const ret_hu_conv = new _baseSignMjs.BaseSign(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new Sign which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned Sign must be freed before this_arg is
     */ as_Sign() {
        const ret = _bindingsMjs.InMemorySigner_as_Sign(this.ptr);
        const ret_hu_conv = new _signMjs.Sign(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the InMemorySigner object into a byte array which can be read by InMemorySigner_read
     */ write() {
        const ret = _bindingsMjs.InMemorySigner_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a InMemorySigner from a byte array, created by InMemorySigner_write
     */ static constructor_read(ser) {
        const ret = _bindingsMjs.InMemorySigner_read(_bindingsMjs.encodeUint8Array(ser));
        const ret_hu_conv = _resultInMemorySignerDecodeErrorZMjs.Result_InMemorySignerDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/OutPoint.mjs":"9FTof","../structs/ChannelPublicKeys.mjs":"a8cA2","../structs/ChannelTransactionParameters.mjs":"dkG9C","../structs/BaseSign.mjs":"4dNuw","../structs/Sign.mjs":"jgkjb","../structs/Result_CVec_CVec_u8ZZNoneZ.mjs":"i9PFL","../structs/Result_InMemorySignerDecodeErrorZ.mjs":"aBfbh","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aBfbh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_InMemorySignerDecodeErrorZ", ()=>Result_InMemorySignerDecodeErrorZ
);
parcelHelpers.export(exports, "Result_InMemorySignerDecodeErrorZ_OK", ()=>Result_InMemorySignerDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_InMemorySignerDecodeErrorZ_Err", ()=>Result_InMemorySignerDecodeErrorZ_Err
) //# sourceMappingURL=Result_InMemorySignerDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _inMemorySignerMjs = require("../structs/InMemorySigner.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_InMemorySignerDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_InMemorySignerDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_InMemorySignerDecodeErrorZ_is_ok(ptr)) return new Result_InMemorySignerDecodeErrorZ_OK(null, ptr);
        else return new Result_InMemorySignerDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_InMemorySignerDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_InMemorySignerDecodeErrorZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_InMemorySignerDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_InMemorySignerDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_InMemorySignerDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_InMemorySignerDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_InMemorySignerDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_InMemorySignerDecodeErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_InMemorySignerDecodeErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_InMemorySignerDecodeErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_InMemorySignerDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_InMemorySignerDecodeErrorZ_OK extends Result_InMemorySignerDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_InMemorySignerDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _inMemorySignerMjs.InMemorySigner(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_InMemorySignerDecodeErrorZ_Err extends Result_InMemorySignerDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_InMemorySignerDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/InMemorySigner.mjs":"3SgwF","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7rxwz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_TransactionNoneZ", ()=>Result_TransactionNoneZ
);
parcelHelpers.export(exports, "Result_TransactionNoneZ_OK", ()=>Result_TransactionNoneZ_OK
);
parcelHelpers.export(exports, "Result_TransactionNoneZ_Err", ()=>Result_TransactionNoneZ_Err
) //# sourceMappingURL=Result_TransactionNoneZ.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_TransactionNoneZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_TransactionNoneZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_TransactionNoneZ_is_ok(ptr)) return new Result_TransactionNoneZ_OK(null, ptr);
        else return new Result_TransactionNoneZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_TransactionNoneZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_TransactionNoneZ_ok(_bindingsMjs.encodeUint8Array(o));
        const ret_hu_conv = Result_TransactionNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_TransactionNoneZ in the error state.
     */ static constructor_err() {
        const ret = _bindingsMjs.CResult_TransactionNoneZ_err();
        const ret_hu_conv = Result_TransactionNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_TransactionNoneZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_TransactionNoneZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_TransactionNoneZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_TransactionNoneZ_clone(this.ptr);
        const ret_hu_conv = Result_TransactionNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_TransactionNoneZ_OK extends Result_TransactionNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_TransactionNoneZ_get_ok(ptr);
        const res_conv = _bindingsMjs.decodeUint8Array(res);
        this.res = res_conv;
    }
}
class Result_TransactionNoneZ_Err extends Result_TransactionNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1mlut":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A transaction output watched by a [`ChannelMonitor`] for spends on-chain.
 *
 * Used to convey to a [`Filter`] such an output with a given spending condition. Any transaction
 * spending the output must be given to [`ChannelMonitor::block_connected`] either directly or via
 * the return value of [`Filter::register_output`].
 *
 * If `block_hash` is `Some`, this indicates the output was created in the corresponding block and
 * may have been spent there. See [`Filter::register_output`] for details.
 *
 * [`ChannelMonitor`]: channelmonitor::ChannelMonitor
 * [`ChannelMonitor::block_connected`]: channelmonitor::ChannelMonitor::block_connected
 */ parcelHelpers.export(exports, "WatchedOutput", ()=>WatchedOutput
) //# sourceMappingURL=WatchedOutput.mjs.map
;
var _outPointMjs = require("../structs/OutPoint.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class WatchedOutput extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.WatchedOutput_free);
    }
    /**
     * First block where the transaction output may have been spent.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_block_hash() {
        const ret = _bindingsMjs.WatchedOutput_get_block_hash(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * First block where the transaction output may have been spent.
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ set_block_hash(val) {
        _bindingsMjs.WatchedOutput_set_block_hash(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * Outpoint identifying the transaction output.
     */ get_outpoint() {
        const ret = _bindingsMjs.WatchedOutput_get_outpoint(this.ptr);
        const ret_hu_conv = new _outPointMjs.OutPoint(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Outpoint identifying the transaction output.
     */ set_outpoint(val) {
        _bindingsMjs.WatchedOutput_set_outpoint(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Spending condition of the transaction output.
     */ get_script_pubkey() {
        const ret = _bindingsMjs.WatchedOutput_get_script_pubkey(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Spending condition of the transaction output.
     */ set_script_pubkey(val) {
        _bindingsMjs.WatchedOutput_set_script_pubkey(this.ptr, _bindingsMjs.encodeUint8Array(val));
    }
    /**
     * Constructs a new WatchedOutput given each field
     */ static constructor_new(block_hash_arg, outpoint_arg, script_pubkey_arg) {
        const ret = _bindingsMjs.WatchedOutput_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(block_hash_arg, 32)), outpoint_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(outpoint_arg) & -2, _bindingsMjs.encodeUint8Array(script_pubkey_arg));
        const ret_hu_conv = new WatchedOutput(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.WatchedOutput_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the WatchedOutput
     */ clone() {
        const ret = _bindingsMjs.WatchedOutput_clone(this.ptr);
        const ret_hu_conv = new WatchedOutput(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Checks if two WatchedOutputs contain equal inner contents.
     */ hash() {
        const ret = _bindingsMjs.WatchedOutput_hash(this.ptr);
        return ret;
    }
}

},{"../structs/OutPoint.mjs":"9FTof","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jd0MV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The `Filter` trait defines behavior for indicating chain activity of interest pertaining to
 * channels.
 *
 * This is useful in order to have a [`Watch`] implementation convey to a chain source which
 * transactions to be notified of. Notification may take the form of pre-filtering blocks or, in
 * the case of [BIP 157]/[BIP 158], only fetching a block if the compact filter matches. If
 * receiving full blocks from a chain source, any further filtering is unnecessary.
 *
 * After an output has been registered, subsequent block retrievals from the chain source must not
 * exclude any transactions matching the new criteria nor any in-block descendants of such
 * transactions.
 *
 * Note that use as part of a [`Watch`] implementation involves reentrancy. Therefore, the `Filter`
 * should not block on I/O. Implementations should instead queue the newly monitored data to be
 * processed later. Then, in order to block until the data has been processed, any [`Watch`]
 * invocation that has called the `Filter` must return [`TemporaryFailure`].
 *
 * [`TemporaryFailure`]: ChannelMonitorUpdateErr::TemporaryFailure
 * [BIP 157]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
 * [BIP 158]: https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki
 */ parcelHelpers.export(exports, "Filter", ()=>Filter
) //# sourceMappingURL=Filter.mjs.map
;
var _optionC2TupleUsizeTransactionZZMjs = require("../structs/Option_C2Tuple_usizeTransactionZZ.mjs");
var _watchedOutputMjs = require("../structs/WatchedOutput.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKFilterHolder {
}
class Filter extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Filter_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of Filter from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKFilterHolder();
        let structImplementation = {
            register_tx (txid, script_pubkey) {
                const txid_conv = _bindingsMjs.decodeUint8Array(txid);
                const script_pubkey_conv = _bindingsMjs.decodeUint8Array(script_pubkey);
                arg.register_tx(txid_conv, script_pubkey_conv);
            },
            register_output (output) {
                const output_hu_conv = new _watchedOutputMjs.WatchedOutput(null, output);
                _commonBaseMjsDefault.default.add_ref_from(output_hu_conv, this);
                const ret = arg.register_output(output_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            }
        };
        const ptr = _bindingsMjs.LDKFilter_new(structImplementation);
        impl_holder.held = new Filter(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Registers interest in a transaction with `txid` and having an output with `script_pubkey` as
     * a spending condition.
     */ register_tx(txid, script_pubkey) {
        _bindingsMjs.Filter_register_tx(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(txid, 32)), _bindingsMjs.encodeUint8Array(script_pubkey));
    }
    /**
     * Registers interest in spends of a transaction output.
     *
     * Optionally, when `output.block_hash` is set, should return any transaction spending the
     * output that is found in the corresponding block along with its index.
     *
     * This return value is useful for Electrum clients in order to supply in-block descendant
     * transactions which otherwise were not included. This is not necessary for other clients if
     * such descendant transactions were already included (e.g., when a BIP 157 client provides the
     * full block).
     */ register_output(output) {
        const ret = _bindingsMjs.Filter_register_output(this.ptr, output == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(output) & -2);
        const ret_hu_conv = _optionC2TupleUsizeTransactionZZMjs.Option_C2Tuple_usizeTransactionZZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"../structs/Option_C2Tuple_usizeTransactionZZ.mjs":"g9upi","../structs/WatchedOutput.mjs":"1mlut","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dOShc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An enum which can either contain a crate::lightning::chain::Filter or not
 */ parcelHelpers.export(exports, "Option_FilterZ", ()=>Option_FilterZ
);
/** A Option_FilterZ of type Some */ parcelHelpers.export(exports, "Option_FilterZ_Some", ()=>Option_FilterZ_Some
);
/** A Option_FilterZ of type None */ parcelHelpers.export(exports, "Option_FilterZ_None", ()=>Option_FilterZ_None
) //# sourceMappingURL=Option_FilterZ.mjs.map
;
var _filterMjs = require("../structs/Filter.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Option_FilterZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.COption_FilterZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKCOption_FilterZ_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new Option_FilterZ_Some(ptr);
            case 1:
                return new Option_FilterZ_None(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    /**
     * Constructs a new COption_FilterZ containing a crate::lightning::chain::Filter
     */ static constructor_some(o) {
        const ret = _bindingsMjs.COption_FilterZ_some(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o));
        const ret_hu_conv = Option_FilterZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, o);
        return ret_hu_conv;
    }
    /**
     * Constructs a new COption_FilterZ containing nothing
     */ static constructor_none() {
        const ret = _bindingsMjs.COption_FilterZ_none();
        const ret_hu_conv = Option_FilterZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}
class Option_FilterZ_Some extends Option_FilterZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const some = _bindingsMjs.LDKCOption_FilterZ_Some_get_some(ptr);
        const ret_hu_conv = new _filterMjs.Filter(null, some);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        this.some = ret_hu_conv;
    }
}
class Option_FilterZ_None extends Option_FilterZ {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}

},{"../structs/Filter.mjs":"jd0MV","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"49wgo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** XXX: DO NOT USE THIS - it remains locked until the GC runs (if that ever happens */ /**
 * A read-only reference to a current ChannelMonitor.
 *
 * Note that this holds a mutex in [`ChainMonitor`] and may block other events until it is
 * released.
 */ parcelHelpers.export(exports, "LockedChannelMonitor", ()=>LockedChannelMonitor
) //# sourceMappingURL=LockedChannelMonitor.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LockedChannelMonitor extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.LockedChannelMonitor_free);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gIfQI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_LockedChannelMonitorNoneZ", ()=>Result_LockedChannelMonitorNoneZ
);
parcelHelpers.export(exports, "Result_LockedChannelMonitorNoneZ_OK", ()=>Result_LockedChannelMonitorNoneZ_OK
);
parcelHelpers.export(exports, "Result_LockedChannelMonitorNoneZ_Err", ()=>Result_LockedChannelMonitorNoneZ_Err
) //# sourceMappingURL=Result_LockedChannelMonitorNoneZ.mjs.map
;
var _lockedChannelMonitorMjs = require("../structs/LockedChannelMonitor.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_LockedChannelMonitorNoneZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_LockedChannelMonitorNoneZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_LockedChannelMonitorNoneZ_is_ok(ptr)) return new Result_LockedChannelMonitorNoneZ_OK(null, ptr);
        else return new Result_LockedChannelMonitorNoneZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_LockedChannelMonitorNoneZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_LockedChannelMonitorNoneZ_ok(o == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(o) & -2);
        const ret_hu_conv = Result_LockedChannelMonitorNoneZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, o);
        // Due to rust's strict-ownership memory model, in some cases we need to "move"
        // an object to pass exclusive ownership to the function being called.
        // In most cases, we avoid ret_hu_conv being visible in GC'd languages by cloning the object
        // at the FFI layer, creating a new object which Rust can claim ownership of
        // However, in some cases (eg here), there is no way to clone an object, and thus
        // we actually have to pass full ownership to Rust.
        // Thus, after ret_hu_conv call, o is reset to null and is now a dummy object.
        _commonBaseMjsDefault.default.set_null_skip_free(o);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_LockedChannelMonitorNoneZ in the error state.
     */ static constructor_err() {
        const ret = _bindingsMjs.CResult_LockedChannelMonitorNoneZ_err();
        const ret_hu_conv = Result_LockedChannelMonitorNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_LockedChannelMonitorNoneZ_is_ok(this.ptr);
        return ret;
    }
}
class Result_LockedChannelMonitorNoneZ_OK extends Result_LockedChannelMonitorNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_LockedChannelMonitorNoneZ_get_ok(ptr);
        const res_hu_conv = new _lockedChannelMonitorMjs.LockedChannelMonitor(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_LockedChannelMonitorNoneZ_Err extends Result_LockedChannelMonitorNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}

},{"../structs/LockedChannelMonitor.mjs":"49wgo","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8o4gh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Indicates an error on the client's part (usually some variant of attempting to use too-low or
 * too-high values)
 */ parcelHelpers.export(exports, "APIError", ()=>APIError
);
/** A APIError of type APIMisuseError */ parcelHelpers.export(exports, "APIError_APIMisuseError", ()=>APIError_APIMisuseError
);
/** A APIError of type FeeRateTooHigh */ parcelHelpers.export(exports, "APIError_FeeRateTooHigh", ()=>APIError_FeeRateTooHigh
);
/** A APIError of type RouteError */ parcelHelpers.export(exports, "APIError_RouteError", ()=>APIError_RouteError
);
/** A APIError of type ChannelUnavailable */ parcelHelpers.export(exports, "APIError_ChannelUnavailable", ()=>APIError_ChannelUnavailable
);
/** A APIError of type MonitorUpdateFailed */ parcelHelpers.export(exports, "APIError_MonitorUpdateFailed", ()=>APIError_MonitorUpdateFailed
);
/** A APIError of type IncompatibleShutdownScript */ parcelHelpers.export(exports, "APIError_IncompatibleShutdownScript", ()=>APIError_IncompatibleShutdownScript
) //# sourceMappingURL=APIError.mjs.map
;
var _shutdownScriptMjs = require("../structs/ShutdownScript.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class APIError extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.APIError_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKAPIError_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new APIError_APIMisuseError(ptr);
            case 1:
                return new APIError_FeeRateTooHigh(ptr);
            case 2:
                return new APIError_RouteError(ptr);
            case 3:
                return new APIError_ChannelUnavailable(ptr);
            case 4:
                return new APIError_MonitorUpdateFailed(ptr);
            case 5:
                return new APIError_IncompatibleShutdownScript(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = _bindingsMjs.APIError_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the APIError
     */ clone() {
        const ret = _bindingsMjs.APIError_clone(this.ptr);
        const ret_hu_conv = APIError.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new APIMisuseError-variant APIError
     */ static constructor_apimisuse_error(err) {
        const ret = _bindingsMjs.APIError_apimisuse_error(_bindingsMjs.encodeString(err));
        const ret_hu_conv = APIError.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new FeeRateTooHigh-variant APIError
     */ static constructor_fee_rate_too_high(err, feerate) {
        const ret = _bindingsMjs.APIError_fee_rate_too_high(_bindingsMjs.encodeString(err), feerate);
        const ret_hu_conv = APIError.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new RouteError-variant APIError
     */ static constructor_route_error(err) {
        const ret = _bindingsMjs.APIError_route_error(_bindingsMjs.encodeString(err));
        const ret_hu_conv = APIError.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new ChannelUnavailable-variant APIError
     */ static constructor_channel_unavailable(err) {
        const ret = _bindingsMjs.APIError_channel_unavailable(_bindingsMjs.encodeString(err));
        const ret_hu_conv = APIError.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new MonitorUpdateFailed-variant APIError
     */ static constructor_monitor_update_failed() {
        const ret = _bindingsMjs.APIError_monitor_update_failed();
        const ret_hu_conv = APIError.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new IncompatibleShutdownScript-variant APIError
     */ static constructor_incompatible_shutdown_script(script) {
        const ret = _bindingsMjs.APIError_incompatible_shutdown_script(script == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(script) & -2);
        const ret_hu_conv = APIError.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}
class APIError_APIMisuseError extends APIError {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const err = _bindingsMjs.LDKAPIError_APIMisuseError_get_err(ptr);
        const err_conv = _bindingsMjs.decodeString(err);
        this.err = err_conv;
    }
}
class APIError_FeeRateTooHigh extends APIError {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const err = _bindingsMjs.LDKAPIError_FeeRateTooHigh_get_err(ptr);
        const err_conv = _bindingsMjs.decodeString(err);
        this.err = err_conv;
        this.feerate = _bindingsMjs.LDKAPIError_FeeRateTooHigh_get_feerate(ptr);
    }
}
class APIError_RouteError extends APIError {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const err = _bindingsMjs.LDKAPIError_RouteError_get_err(ptr);
        const err_conv = _bindingsMjs.decodeString(err);
        this.err = err_conv;
    }
}
class APIError_ChannelUnavailable extends APIError {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const err = _bindingsMjs.LDKAPIError_ChannelUnavailable_get_err(ptr);
        const err_conv = _bindingsMjs.decodeString(err);
        this.err = err_conv;
    }
}
class APIError_MonitorUpdateFailed extends APIError {
    /* @internal */ constructor(ptr){
        super(null, ptr);
    }
}
class APIError_IncompatibleShutdownScript extends APIError {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const script = _bindingsMjs.LDKAPIError_IncompatibleShutdownScript_get_script(ptr);
        const script_hu_conv = new _shutdownScriptMjs.ShutdownScript(null, script);
        _commonBaseMjsDefault.default.add_ref_from(script_hu_conv, this);
        this.script = script_hu_conv;
    }
}

},{"../structs/ShutdownScript.mjs":"gHaa6","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"56Ohf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_NoneAPIErrorZ", ()=>Result_NoneAPIErrorZ
);
parcelHelpers.export(exports, "Result_NoneAPIErrorZ_OK", ()=>Result_NoneAPIErrorZ_OK
);
parcelHelpers.export(exports, "Result_NoneAPIErrorZ_Err", ()=>Result_NoneAPIErrorZ_Err
) //# sourceMappingURL=Result_NoneAPIErrorZ.mjs.map
;
var _apierrorMjs = require("../structs/APIError.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_NoneAPIErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_NoneAPIErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_NoneAPIErrorZ_is_ok(ptr)) return new Result_NoneAPIErrorZ_OK(null, ptr);
        else return new Result_NoneAPIErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_NoneAPIErrorZ in the success state.
     */ static constructor_ok() {
        const ret = _bindingsMjs.CResult_NoneAPIErrorZ_ok();
        const ret_hu_conv = Result_NoneAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_NoneAPIErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_NoneAPIErrorZ_err(_commonBaseMjsDefault.default.get_ptr_of(e));
        const ret_hu_conv = Result_NoneAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_NoneAPIErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_NoneAPIErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_NoneAPIErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_NoneAPIErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_NoneAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_NoneAPIErrorZ_OK extends Result_NoneAPIErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}
class Result_NoneAPIErrorZ_Err extends Result_NoneAPIErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_NoneAPIErrorZ_get_err(ptr);
        const err_hu_conv = _apierrorMjs.APIError.constr_from_ptr(err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/APIError.mjs":"8o4gh","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fcmUI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result__u832APIErrorZ", ()=>Result__u832APIErrorZ
);
parcelHelpers.export(exports, "Result__u832APIErrorZ_OK", ()=>Result__u832APIErrorZ_OK
);
parcelHelpers.export(exports, "Result__u832APIErrorZ_Err", ()=>Result__u832APIErrorZ_Err
) //# sourceMappingURL=Result__u832APIErrorZ.mjs.map
;
var _apierrorMjs = require("../structs/APIError.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result__u832APIErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult__u832APIErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult__u832APIErrorZ_is_ok(ptr)) return new Result__u832APIErrorZ_OK(null, ptr);
        else return new Result__u832APIErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult__u832APIErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult__u832APIErrorZ_ok(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(o, 32)));
        const ret_hu_conv = Result__u832APIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult__u832APIErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult__u832APIErrorZ_err(_commonBaseMjsDefault.default.get_ptr_of(e));
        const ret_hu_conv = Result__u832APIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult__u832APIErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult__u832APIErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult__u832APIErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult__u832APIErrorZ_clone(this.ptr);
        const ret_hu_conv = Result__u832APIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result__u832APIErrorZ_OK extends Result__u832APIErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult__u832APIErrorZ_get_ok(ptr);
        const res_conv = _bindingsMjs.decodeUint8Array(res);
        this.res = res_conv;
    }
}
class Result__u832APIErrorZ_Err extends Result__u832APIErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult__u832APIErrorZ_get_err(ptr);
        const err_hu_conv = _apierrorMjs.APIError.constr_from_ptr(err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/APIError.mjs":"8o4gh","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hGJR4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * If a payment fails to send, it can be in one of several states. This enum is returned as the
 * Err() type describing which state the payment is in, see the description of individual enum
 * states for more.
 */ parcelHelpers.export(exports, "PaymentSendFailure", ()=>PaymentSendFailure
);
/** A PaymentSendFailure of type ParameterError */ parcelHelpers.export(exports, "PaymentSendFailure_ParameterError", ()=>PaymentSendFailure_ParameterError
);
/** A PaymentSendFailure of type PathParameterError */ parcelHelpers.export(exports, "PaymentSendFailure_PathParameterError", ()=>PaymentSendFailure_PathParameterError
);
/** A PaymentSendFailure of type AllFailedRetrySafe */ parcelHelpers.export(exports, "PaymentSendFailure_AllFailedRetrySafe", ()=>PaymentSendFailure_AllFailedRetrySafe
);
/** A PaymentSendFailure of type PartialFailure */ parcelHelpers.export(exports, "PaymentSendFailure_PartialFailure", ()=>PaymentSendFailure_PartialFailure
) //# sourceMappingURL=PaymentSendFailure.mjs.map
;
var _routeParametersMjs = require("../structs/RouteParameters.mjs");
var _apierrorMjs = require("../structs/APIError.mjs");
var _resultNoneAPIErrorZMjs = require("../structs/Result_NoneAPIErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class PaymentSendFailure extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.PaymentSendFailure_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        const raw_ty = _bindingsMjs.LDKPaymentSendFailure_ty_from_ptr(ptr);
        switch(raw_ty){
            case 0:
                return new PaymentSendFailure_ParameterError(ptr);
            case 1:
                return new PaymentSendFailure_PathParameterError(ptr);
            case 2:
                return new PaymentSendFailure_AllFailedRetrySafe(ptr);
            case 3:
                return new PaymentSendFailure_PartialFailure(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = _bindingsMjs.PaymentSendFailure_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the PaymentSendFailure
     */ clone() {
        const ret = _bindingsMjs.PaymentSendFailure_clone(this.ptr);
        const ret_hu_conv = PaymentSendFailure.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new ParameterError-variant PaymentSendFailure
     */ static constructor_parameter_error(a) {
        const ret = _bindingsMjs.PaymentSendFailure_parameter_error(_commonBaseMjsDefault.default.get_ptr_of(a));
        const ret_hu_conv = PaymentSendFailure.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new PathParameterError-variant PaymentSendFailure
     */ static constructor_path_parameter_error(a) {
        const ret = _bindingsMjs.PaymentSendFailure_path_parameter_error(_bindingsMjs.encodeUint32Array(a != null ? a.map((a_conv_22)=>a_conv_22 != null ? _commonBaseMjsDefault.default.get_ptr_of(a_conv_22) : 0
        ) : null));
        const ret_hu_conv = PaymentSendFailure.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new AllFailedRetrySafe-variant PaymentSendFailure
     */ static constructor_all_failed_retry_safe(a) {
        const ret = _bindingsMjs.PaymentSendFailure_all_failed_retry_safe(_bindingsMjs.encodeUint32Array(a != null ? a.map((a_conv_10)=>_commonBaseMjsDefault.default.get_ptr_of(a_conv_10)
        ) : null));
        const ret_hu_conv = PaymentSendFailure.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new PartialFailure-variant PaymentSendFailure
     */ static constructor_partial_failure(results, failed_paths_retry, payment_id) {
        const ret = _bindingsMjs.PaymentSendFailure_partial_failure(_bindingsMjs.encodeUint32Array(results != null ? results.map((results_conv_22)=>results_conv_22 != null ? _commonBaseMjsDefault.default.get_ptr_of(results_conv_22) : 0
        ) : null), failed_paths_retry == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(failed_paths_retry) & -2, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_id, 32)));
        const ret_hu_conv = PaymentSendFailure.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}
class PaymentSendFailure_ParameterError extends PaymentSendFailure {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const parameter_error = _bindingsMjs.LDKPaymentSendFailure_ParameterError_get_parameter_error(ptr);
        const parameter_error_hu_conv = _apierrorMjs.APIError.constr_from_ptr(parameter_error);
        _commonBaseMjsDefault.default.add_ref_from(parameter_error_hu_conv, this);
        this.parameter_error = parameter_error_hu_conv;
    }
}
class PaymentSendFailure_PathParameterError extends PaymentSendFailure {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const path_parameter_error = _bindingsMjs.LDKPaymentSendFailure_PathParameterError_get_path_parameter_error(ptr);
        const path_parameter_error_conv_22_len = _bindingsMjs.getArrayLength(path_parameter_error);
        const path_parameter_error_conv_22_arr = new Array(path_parameter_error_conv_22_len).fill(null);
        for(var w = 0; w < path_parameter_error_conv_22_len; w++){
            const path_parameter_error_conv_22 = _bindingsMjs.getU32ArrayElem(path_parameter_error, w);
            const path_parameter_error_conv_22_hu_conv = _resultNoneAPIErrorZMjs.Result_NoneAPIErrorZ.constr_from_ptr(path_parameter_error_conv_22);
            path_parameter_error_conv_22_arr[w] = path_parameter_error_conv_22_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(path_parameter_error);
        this.path_parameter_error = path_parameter_error_conv_22_arr;
    }
}
class PaymentSendFailure_AllFailedRetrySafe extends PaymentSendFailure {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const all_failed_retry_safe = _bindingsMjs.LDKPaymentSendFailure_AllFailedRetrySafe_get_all_failed_retry_safe(ptr);
        const all_failed_retry_safe_conv_10_len = _bindingsMjs.getArrayLength(all_failed_retry_safe);
        const all_failed_retry_safe_conv_10_arr = new Array(all_failed_retry_safe_conv_10_len).fill(null);
        for(var k = 0; k < all_failed_retry_safe_conv_10_len; k++){
            const all_failed_retry_safe_conv_10 = _bindingsMjs.getU32ArrayElem(all_failed_retry_safe, k);
            const all_failed_retry_safe_conv_10_hu_conv = _apierrorMjs.APIError.constr_from_ptr(all_failed_retry_safe_conv_10);
            _commonBaseMjsDefault.default.add_ref_from(all_failed_retry_safe_conv_10_hu_conv, this);
            all_failed_retry_safe_conv_10_arr[k] = all_failed_retry_safe_conv_10_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(all_failed_retry_safe);
        this.all_failed_retry_safe = all_failed_retry_safe_conv_10_arr;
    }
}
class PaymentSendFailure_PartialFailure extends PaymentSendFailure {
    /* @internal */ constructor(ptr){
        super(null, ptr);
        const results = _bindingsMjs.LDKPaymentSendFailure_PartialFailure_get_results(ptr);
        const results_conv_22_len = _bindingsMjs.getArrayLength(results);
        const results_conv_22_arr = new Array(results_conv_22_len).fill(null);
        for(var w = 0; w < results_conv_22_len; w++){
            const results_conv_22 = _bindingsMjs.getU32ArrayElem(results, w);
            const results_conv_22_hu_conv = _resultNoneAPIErrorZMjs.Result_NoneAPIErrorZ.constr_from_ptr(results_conv_22);
            results_conv_22_arr[w] = results_conv_22_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(results);
        this.results = results_conv_22_arr;
        const failed_paths_retry = _bindingsMjs.LDKPaymentSendFailure_PartialFailure_get_failed_paths_retry(ptr);
        const failed_paths_retry_hu_conv = new _routeParametersMjs.RouteParameters(null, failed_paths_retry);
        _commonBaseMjsDefault.default.add_ref_from(failed_paths_retry_hu_conv, this);
        this.failed_paths_retry = failed_paths_retry_hu_conv;
        const payment_id = _bindingsMjs.LDKPaymentSendFailure_PartialFailure_get_payment_id(ptr);
        const payment_id_conv = _bindingsMjs.decodeUint8Array(payment_id);
        this.payment_id = payment_id_conv;
    }
}

},{"../structs/RouteParameters.mjs":"2hS5b","../structs/APIError.mjs":"8o4gh","../structs/Result_NoneAPIErrorZ.mjs":"56Ohf","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eQJEs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_PaymentIdPaymentSendFailureZ", ()=>Result_PaymentIdPaymentSendFailureZ
);
parcelHelpers.export(exports, "Result_PaymentIdPaymentSendFailureZ_OK", ()=>Result_PaymentIdPaymentSendFailureZ_OK
);
parcelHelpers.export(exports, "Result_PaymentIdPaymentSendFailureZ_Err", ()=>Result_PaymentIdPaymentSendFailureZ_Err
) //# sourceMappingURL=Result_PaymentIdPaymentSendFailureZ.mjs.map
;
var _paymentSendFailureMjs = require("../structs/PaymentSendFailure.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_PaymentIdPaymentSendFailureZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_PaymentIdPaymentSendFailureZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_PaymentIdPaymentSendFailureZ_is_ok(ptr)) return new Result_PaymentIdPaymentSendFailureZ_OK(null, ptr);
        else return new Result_PaymentIdPaymentSendFailureZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_PaymentIdPaymentSendFailureZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_PaymentIdPaymentSendFailureZ_ok(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(o, 32)));
        const ret_hu_conv = Result_PaymentIdPaymentSendFailureZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_PaymentIdPaymentSendFailureZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_PaymentIdPaymentSendFailureZ_err(_commonBaseMjsDefault.default.get_ptr_of(e));
        const ret_hu_conv = Result_PaymentIdPaymentSendFailureZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_PaymentIdPaymentSendFailureZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_PaymentIdPaymentSendFailureZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_PaymentIdPaymentSendFailureZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_PaymentIdPaymentSendFailureZ_clone(this.ptr);
        const ret_hu_conv = Result_PaymentIdPaymentSendFailureZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_PaymentIdPaymentSendFailureZ_OK extends Result_PaymentIdPaymentSendFailureZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_PaymentIdPaymentSendFailureZ_get_ok(ptr);
        const res_conv = _bindingsMjs.decodeUint8Array(res);
        this.res = res_conv;
    }
}
class Result_PaymentIdPaymentSendFailureZ_Err extends Result_PaymentIdPaymentSendFailureZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_PaymentIdPaymentSendFailureZ_get_err(ptr);
        const err_hu_conv = _paymentSendFailureMjs.PaymentSendFailure.constr_from_ptr(err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/PaymentSendFailure.mjs":"hGJR4","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4uCl5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_NonePaymentSendFailureZ", ()=>Result_NonePaymentSendFailureZ
);
parcelHelpers.export(exports, "Result_NonePaymentSendFailureZ_OK", ()=>Result_NonePaymentSendFailureZ_OK
);
parcelHelpers.export(exports, "Result_NonePaymentSendFailureZ_Err", ()=>Result_NonePaymentSendFailureZ_Err
) //# sourceMappingURL=Result_NonePaymentSendFailureZ.mjs.map
;
var _paymentSendFailureMjs = require("../structs/PaymentSendFailure.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_NonePaymentSendFailureZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_NonePaymentSendFailureZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_NonePaymentSendFailureZ_is_ok(ptr)) return new Result_NonePaymentSendFailureZ_OK(null, ptr);
        else return new Result_NonePaymentSendFailureZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_NonePaymentSendFailureZ in the success state.
     */ static constructor_ok() {
        const ret = _bindingsMjs.CResult_NonePaymentSendFailureZ_ok();
        const ret_hu_conv = Result_NonePaymentSendFailureZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_NonePaymentSendFailureZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_NonePaymentSendFailureZ_err(_commonBaseMjsDefault.default.get_ptr_of(e));
        const ret_hu_conv = Result_NonePaymentSendFailureZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_NonePaymentSendFailureZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_NonePaymentSendFailureZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_NonePaymentSendFailureZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_NonePaymentSendFailureZ_clone(this.ptr);
        const ret_hu_conv = Result_NonePaymentSendFailureZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_NonePaymentSendFailureZ_OK extends Result_NonePaymentSendFailureZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}
class Result_NonePaymentSendFailureZ_Err extends Result_NonePaymentSendFailureZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_NonePaymentSendFailureZ_get_err(ptr);
        const err_hu_conv = _paymentSendFailureMjs.PaymentSendFailure.constr_from_ptr(err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/PaymentSendFailure.mjs":"hGJR4","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iLcVy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Tuple
 */ parcelHelpers.export(exports, "TwoTuple_PaymentHashPaymentIdZ", ()=>TwoTuple_PaymentHashPaymentIdZ
) //# sourceMappingURL=TwoTuple_PaymentHashPaymentIdZ.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class TwoTuple_PaymentHashPaymentIdZ extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.C2Tuple_PaymentHashPaymentIdZ_free);
    }
    /**
     *
     */ get_a() {
        const ret = _bindingsMjs.C2Tuple_PaymentHashPaymentIdZ_get_a(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     *
     */ get_b() {
        const ret = _bindingsMjs.C2Tuple_PaymentHashPaymentIdZ_get_b(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.C2Tuple_PaymentHashPaymentIdZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new tuple which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.C2Tuple_PaymentHashPaymentIdZ_clone(this.ptr);
        const ret_hu_conv = new TwoTuple_PaymentHashPaymentIdZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a new C2Tuple_PaymentHashPaymentIdZ from the contained elements.
     */ static constructor_new(a, b) {
        const ret = _bindingsMjs.C2Tuple_PaymentHashPaymentIdZ_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(a, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(b, 32)));
        const ret_hu_conv = new TwoTuple_PaymentHashPaymentIdZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jM82N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ", ()=>Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ
);
parcelHelpers.export(exports, "Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_OK", ()=>Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_OK
);
parcelHelpers.export(exports, "Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_Err", ()=>Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_Err
) //# sourceMappingURL=Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ.mjs.map
;
var _paymentSendFailureMjs = require("../structs/PaymentSendFailure.mjs");
var _twoTuplePaymentHashPaymentIdZMjs = require("../structs/TwoTuple_PaymentHashPaymentIdZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok(ptr)) return new Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_OK(null, ptr);
        else return new Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok(o != null ? _commonBaseMjsDefault.default.get_ptr_of(o) : 0);
        const ret_hu_conv = Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err(_commonBaseMjsDefault.default.get_ptr_of(e));
        const ret_hu_conv = Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone(this.ptr);
        const ret_hu_conv = Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_OK extends Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_ok(ptr);
        const res_hu_conv = new _twoTuplePaymentHashPaymentIdZMjs.TwoTuple_PaymentHashPaymentIdZ(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_Err extends Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_err(ptr);
        const err_hu_conv = _paymentSendFailureMjs.PaymentSendFailure.constr_from_ptr(err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/PaymentSendFailure.mjs":"hGJR4","../structs/TwoTuple_PaymentHashPaymentIdZ.mjs":"iLcVy","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bXLDZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Tuple
 */ parcelHelpers.export(exports, "TwoTuple_PaymentHashPaymentSecretZ", ()=>TwoTuple_PaymentHashPaymentSecretZ
) //# sourceMappingURL=TwoTuple_PaymentHashPaymentSecretZ.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class TwoTuple_PaymentHashPaymentSecretZ extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.C2Tuple_PaymentHashPaymentSecretZ_free);
    }
    /**
     *
     */ get_a() {
        const ret = _bindingsMjs.C2Tuple_PaymentHashPaymentSecretZ_get_a(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     *
     */ get_b() {
        const ret = _bindingsMjs.C2Tuple_PaymentHashPaymentSecretZ_get_b(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.C2Tuple_PaymentHashPaymentSecretZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new tuple which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.C2Tuple_PaymentHashPaymentSecretZ_clone(this.ptr);
        const ret_hu_conv = new TwoTuple_PaymentHashPaymentSecretZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a new C2Tuple_PaymentHashPaymentSecretZ from the contained elements.
     */ static constructor_new(a, b) {
        const ret = _bindingsMjs.C2Tuple_PaymentHashPaymentSecretZ_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(a, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(b, 32)));
        const ret_hu_conv = new TwoTuple_PaymentHashPaymentSecretZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f6YT4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_C2Tuple_PaymentHashPaymentSecretZNoneZ", ()=>Result_C2Tuple_PaymentHashPaymentSecretZNoneZ
);
parcelHelpers.export(exports, "Result_C2Tuple_PaymentHashPaymentSecretZNoneZ_OK", ()=>Result_C2Tuple_PaymentHashPaymentSecretZNoneZ_OK
);
parcelHelpers.export(exports, "Result_C2Tuple_PaymentHashPaymentSecretZNoneZ_Err", ()=>Result_C2Tuple_PaymentHashPaymentSecretZNoneZ_Err
) //# sourceMappingURL=Result_C2Tuple_PaymentHashPaymentSecretZNoneZ.mjs.map
;
var _twoTuplePaymentHashPaymentSecretZMjs = require("../structs/TwoTuple_PaymentHashPaymentSecretZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_C2Tuple_PaymentHashPaymentSecretZNoneZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok(ptr)) return new Result_C2Tuple_PaymentHashPaymentSecretZNoneZ_OK(null, ptr);
        else return new Result_C2Tuple_PaymentHashPaymentSecretZNoneZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok(o != null ? _commonBaseMjsDefault.default.get_ptr_of(o) : 0);
        const ret_hu_conv = Result_C2Tuple_PaymentHashPaymentSecretZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ in the error state.
     */ static constructor_err() {
        const ret = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err();
        const ret_hu_conv = Result_C2Tuple_PaymentHashPaymentSecretZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone(this.ptr);
        const ret_hu_conv = Result_C2Tuple_PaymentHashPaymentSecretZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_C2Tuple_PaymentHashPaymentSecretZNoneZ_OK extends Result_C2Tuple_PaymentHashPaymentSecretZNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_ok(ptr);
        const res_hu_conv = new _twoTuplePaymentHashPaymentSecretZMjs.TwoTuple_PaymentHashPaymentSecretZ(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_C2Tuple_PaymentHashPaymentSecretZNoneZ_Err extends Result_C2Tuple_PaymentHashPaymentSecretZNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}

},{"../structs/TwoTuple_PaymentHashPaymentSecretZ.mjs":"bXLDZ","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dwFq0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ", ()=>Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ
);
parcelHelpers.export(exports, "Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_OK", ()=>Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_OK
);
parcelHelpers.export(exports, "Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_Err", ()=>Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_Err
) //# sourceMappingURL=Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ.mjs.map
;
var _apierrorMjs = require("../structs/APIError.mjs");
var _twoTuplePaymentHashPaymentSecretZMjs = require("../structs/TwoTuple_PaymentHashPaymentSecretZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_ok(ptr)) return new Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_OK(null, ptr);
        else return new Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_ok(o != null ? _commonBaseMjsDefault.default.get_ptr_of(o) : 0);
        const ret_hu_conv = Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_err(_commonBaseMjsDefault.default.get_ptr_of(e));
        const ret_hu_conv = Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_OK extends Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_ok(ptr);
        const res_hu_conv = new _twoTuplePaymentHashPaymentSecretZMjs.TwoTuple_PaymentHashPaymentSecretZ(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_Err extends Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_err(ptr);
        const err_hu_conv = _apierrorMjs.APIError.constr_from_ptr(err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/APIError.mjs":"8o4gh","../structs/TwoTuple_PaymentHashPaymentSecretZ.mjs":"bXLDZ","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2khSV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_PaymentSecretNoneZ", ()=>Result_PaymentSecretNoneZ
);
parcelHelpers.export(exports, "Result_PaymentSecretNoneZ_OK", ()=>Result_PaymentSecretNoneZ_OK
);
parcelHelpers.export(exports, "Result_PaymentSecretNoneZ_Err", ()=>Result_PaymentSecretNoneZ_Err
) //# sourceMappingURL=Result_PaymentSecretNoneZ.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_PaymentSecretNoneZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_PaymentSecretNoneZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_PaymentSecretNoneZ_is_ok(ptr)) return new Result_PaymentSecretNoneZ_OK(null, ptr);
        else return new Result_PaymentSecretNoneZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_PaymentSecretNoneZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_PaymentSecretNoneZ_ok(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(o, 32)));
        const ret_hu_conv = Result_PaymentSecretNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_PaymentSecretNoneZ in the error state.
     */ static constructor_err() {
        const ret = _bindingsMjs.CResult_PaymentSecretNoneZ_err();
        const ret_hu_conv = Result_PaymentSecretNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_PaymentSecretNoneZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_PaymentSecretNoneZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_PaymentSecretNoneZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_PaymentSecretNoneZ_clone(this.ptr);
        const ret_hu_conv = Result_PaymentSecretNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_PaymentSecretNoneZ_OK extends Result_PaymentSecretNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_PaymentSecretNoneZ_get_ok(ptr);
        const res_conv = _bindingsMjs.decodeUint8Array(res);
        this.res = res_conv;
    }
}
class Result_PaymentSecretNoneZ_Err extends Result_PaymentSecretNoneZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ggvA5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_PaymentSecretAPIErrorZ", ()=>Result_PaymentSecretAPIErrorZ
);
parcelHelpers.export(exports, "Result_PaymentSecretAPIErrorZ_OK", ()=>Result_PaymentSecretAPIErrorZ_OK
);
parcelHelpers.export(exports, "Result_PaymentSecretAPIErrorZ_Err", ()=>Result_PaymentSecretAPIErrorZ_Err
) //# sourceMappingURL=Result_PaymentSecretAPIErrorZ.mjs.map
;
var _apierrorMjs = require("../structs/APIError.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_PaymentSecretAPIErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_PaymentSecretAPIErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_PaymentSecretAPIErrorZ_is_ok(ptr)) return new Result_PaymentSecretAPIErrorZ_OK(null, ptr);
        else return new Result_PaymentSecretAPIErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_PaymentSecretAPIErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_PaymentSecretAPIErrorZ_ok(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(o, 32)));
        const ret_hu_conv = Result_PaymentSecretAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_PaymentSecretAPIErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_PaymentSecretAPIErrorZ_err(_commonBaseMjsDefault.default.get_ptr_of(e));
        const ret_hu_conv = Result_PaymentSecretAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_PaymentSecretAPIErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_PaymentSecretAPIErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_PaymentSecretAPIErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_PaymentSecretAPIErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_PaymentSecretAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_PaymentSecretAPIErrorZ_OK extends Result_PaymentSecretAPIErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_PaymentSecretAPIErrorZ_get_ok(ptr);
        const res_conv = _bindingsMjs.decodeUint8Array(res);
        this.res = res_conv;
    }
}
class Result_PaymentSecretAPIErrorZ_Err extends Result_PaymentSecretAPIErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_PaymentSecretAPIErrorZ_get_err(ptr);
        const err_hu_conv = _apierrorMjs.APIError.constr_from_ptr(err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/APIError.mjs":"8o4gh","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"17jBi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_PaymentPreimageAPIErrorZ", ()=>Result_PaymentPreimageAPIErrorZ
);
parcelHelpers.export(exports, "Result_PaymentPreimageAPIErrorZ_OK", ()=>Result_PaymentPreimageAPIErrorZ_OK
);
parcelHelpers.export(exports, "Result_PaymentPreimageAPIErrorZ_Err", ()=>Result_PaymentPreimageAPIErrorZ_Err
) //# sourceMappingURL=Result_PaymentPreimageAPIErrorZ.mjs.map
;
var _apierrorMjs = require("../structs/APIError.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_PaymentPreimageAPIErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_PaymentPreimageAPIErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_PaymentPreimageAPIErrorZ_is_ok(ptr)) return new Result_PaymentPreimageAPIErrorZ_OK(null, ptr);
        else return new Result_PaymentPreimageAPIErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_PaymentPreimageAPIErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_PaymentPreimageAPIErrorZ_ok(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(o, 32)));
        const ret_hu_conv = Result_PaymentPreimageAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_PaymentPreimageAPIErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_PaymentPreimageAPIErrorZ_err(_commonBaseMjsDefault.default.get_ptr_of(e));
        const ret_hu_conv = Result_PaymentPreimageAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_PaymentPreimageAPIErrorZ_is_ok(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.CResult_PaymentPreimageAPIErrorZ_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a new CResult_PaymentPreimageAPIErrorZ which has the same data as `orig`
     * but with all dynamically-allocated buffers duplicated in new buffers.
     */ clone() {
        const ret = _bindingsMjs.CResult_PaymentPreimageAPIErrorZ_clone(this.ptr);
        const ret_hu_conv = Result_PaymentPreimageAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
class Result_PaymentPreimageAPIErrorZ_OK extends Result_PaymentPreimageAPIErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_PaymentPreimageAPIErrorZ_get_ok(ptr);
        const res_conv = _bindingsMjs.decodeUint8Array(res);
        this.res = res_conv;
    }
}
class Result_PaymentPreimageAPIErrorZ_Err extends Result_PaymentPreimageAPIErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_PaymentPreimageAPIErrorZ_get_err(ptr);
        const err_hu_conv = _apierrorMjs.APIError.constr_from_ptr(err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/APIError.mjs":"8o4gh","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2Clil":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The `Watch` trait defines behavior for watching on-chain activity pertaining to channels as
 * blocks are connected and disconnected.
 *
 * Each channel is associated with a [`ChannelMonitor`]. Implementations of this trait are
 * responsible for maintaining a set of monitors such that they can be updated accordingly as
 * channel state changes and HTLCs are resolved. See method documentation for specific
 * requirements.
 *
 * Implementations **must** ensure that updates are successfully applied and persisted upon method
 * completion. If an update fails with a [`PermanentFailure`], then it must immediately shut down
 * without taking any further action such as persisting the current state.
 *
 * If an implementation maintains multiple instances of a channel's monitor (e.g., by storing
 * backup copies), then it must ensure that updates are applied across all instances. Otherwise, it
 * could result in a revoked transaction being broadcast, allowing the counterparty to claim all
 * funds in the channel. See [`ChannelMonitorUpdateErr`] for more details about how to handle
 * multiple instances.
 *
 * [`PermanentFailure`]: ChannelMonitorUpdateErr::PermanentFailure
 */ parcelHelpers.export(exports, "Watch", ()=>Watch
) //# sourceMappingURL=Watch.mjs.map
;
var _outPointMjs = require("../structs/OutPoint.mjs");
var _channelMonitorUpdateMjs = require("../structs/ChannelMonitorUpdate.mjs");
var _monitorEventMjs = require("../structs/MonitorEvent.mjs");
var _channelMonitorMjs = require("../structs/ChannelMonitor.mjs");
var _resultNoneChannelMonitorUpdateErrZMjs = require("../structs/Result_NoneChannelMonitorUpdateErrZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKWatchHolder {
}
class Watch extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Watch_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of Watch from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKWatchHolder();
        let structImplementation = {
            watch_channel (funding_txo, monitor) {
                const funding_txo_hu_conv = new _outPointMjs.OutPoint(null, funding_txo);
                _commonBaseMjsDefault.default.add_ref_from(funding_txo_hu_conv, this);
                const monitor_hu_conv = new _channelMonitorMjs.ChannelMonitor(null, monitor);
                _commonBaseMjsDefault.default.add_ref_from(monitor_hu_conv, this);
                const ret = arg.watch_channel(funding_txo_hu_conv, monitor_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            update_channel (funding_txo, update) {
                const funding_txo_hu_conv = new _outPointMjs.OutPoint(null, funding_txo);
                _commonBaseMjsDefault.default.add_ref_from(funding_txo_hu_conv, this);
                const update_hu_conv = new _channelMonitorUpdateMjs.ChannelMonitorUpdate(null, update);
                _commonBaseMjsDefault.default.add_ref_from(update_hu_conv, this);
                const ret = arg.update_channel(funding_txo_hu_conv, update_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            release_pending_monitor_events () {
                const ret = arg.release_pending_monitor_events();
                const result = _bindingsMjs.encodeUint32Array(ret != null ? ret.map((ret_conv_14)=>ret_conv_14 == null ? 0 : ret_conv_14.clone_ptr()
                ) : null);
                return result;
            }
        };
        const ptr = _bindingsMjs.LDKWatch_new(structImplementation);
        impl_holder.held = new Watch(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Watches a channel identified by `funding_txo` using `monitor`.
     *
     * Implementations are responsible for watching the chain for the funding transaction along
     * with any spends of outputs returned by [`get_outputs_to_watch`]. In practice, this means
     * calling [`block_connected`] and [`block_disconnected`] on the monitor.
     *
     * Note: this interface MUST error with `ChannelMonitorUpdateErr::PermanentFailure` if
     * the given `funding_txo` has previously been registered via `watch_channel`.
     *
     * [`get_outputs_to_watch`]: channelmonitor::ChannelMonitor::get_outputs_to_watch
     * [`block_connected`]: channelmonitor::ChannelMonitor::block_connected
     * [`block_disconnected`]: channelmonitor::ChannelMonitor::block_disconnected
     */ watch_channel(funding_txo, monitor) {
        const ret = _bindingsMjs.Watch_watch_channel(this.ptr, funding_txo == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(funding_txo) & -2, monitor == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(monitor) & -2);
        const ret_hu_conv = _resultNoneChannelMonitorUpdateErrZMjs.Result_NoneChannelMonitorUpdateErrZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Updates a channel identified by `funding_txo` by applying `update` to its monitor.
     *
     * Implementations must call [`update_monitor`] with the given update. See
     * [`ChannelMonitorUpdateErr`] for invariants around returning an error.
     *
     * [`update_monitor`]: channelmonitor::ChannelMonitor::update_monitor
     */ update_channel(funding_txo, update) {
        const ret = _bindingsMjs.Watch_update_channel(this.ptr, funding_txo == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(funding_txo) & -2, update == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(update) & -2);
        const ret_hu_conv = _resultNoneChannelMonitorUpdateErrZMjs.Result_NoneChannelMonitorUpdateErrZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Returns any monitor events since the last call. Subsequent calls must only return new
     * events.
     *
     * Note that after any block- or transaction-connection calls to a [`ChannelMonitor`], no
     * further events may be returned here until the [`ChannelMonitor`] has been fully persisted
     * to disk.
     *
     * For details on asynchronous [`ChannelMonitor`] updating and returning
     * [`MonitorEvent::UpdateCompleted`] here, see [`ChannelMonitorUpdateErr::TemporaryFailure`].
     */ release_pending_monitor_events() {
        const ret = _bindingsMjs.Watch_release_pending_monitor_events(this.ptr);
        const ret_conv_14_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_14_arr = new Array(ret_conv_14_len).fill(null);
        for(var o = 0; o < ret_conv_14_len; o++){
            const ret_conv_14 = _bindingsMjs.getU32ArrayElem(ret, o);
            const ret_conv_14_hu_conv = _monitorEventMjs.MonitorEvent.constr_from_ptr(ret_conv_14);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_14_hu_conv, this);
            ret_conv_14_arr[o] = ret_conv_14_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_14_arr;
    }
}

},{"../structs/OutPoint.mjs":"9FTof","../structs/ChannelMonitorUpdate.mjs":"gEeSd","../structs/MonitorEvent.mjs":"jGH1U","../structs/ChannelMonitor.mjs":"ebdYy","../structs/Result_NoneChannelMonitorUpdateErrZ.mjs":"icmE6","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6EF7s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An interface to send a transaction to the Bitcoin network.
 */ parcelHelpers.export(exports, "BroadcasterInterface", ()=>BroadcasterInterface
) //# sourceMappingURL=BroadcasterInterface.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKBroadcasterInterfaceHolder {
}
class BroadcasterInterface extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.BroadcasterInterface_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of BroadcasterInterface from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKBroadcasterInterfaceHolder();
        let structImplementation = {
            broadcast_transaction (tx) {
                const tx_conv = _bindingsMjs.decodeUint8Array(tx);
                arg.broadcast_transaction(tx_conv);
            }
        };
        const ptr = _bindingsMjs.LDKBroadcasterInterface_new(structImplementation);
        impl_holder.held = new BroadcasterInterface(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Sends a transaction out to (hopefully) be mined.
     */ broadcast_transaction(tx) {
        _bindingsMjs.BroadcasterInterface_broadcast_transaction(this.ptr, _bindingsMjs.encodeUint8Array(tx));
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2q459":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A trait to describe an object which can get user secrets and key material.
 */ parcelHelpers.export(exports, "KeysInterface", ()=>KeysInterface
) //# sourceMappingURL=KeysInterface.mjs.map
;
var _shutdownScriptMjs = require("../structs/ShutdownScript.mjs");
var _signMjs = require("../structs/Sign.mjs");
var _resultSignDecodeErrorZMjs = require("../structs/Result_SignDecodeErrorZ.mjs");
var _resultRecoverableSignatureNoneZMjs = require("../structs/Result_RecoverableSignatureNoneZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKKeysInterfaceHolder {
}
class KeysInterface extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.KeysInterface_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of KeysInterface from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKKeysInterfaceHolder();
        let structImplementation = {
            get_node_secret () {
                const ret = arg.get_node_secret();
                const result = _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(ret, 32));
                return result;
            },
            get_destination_script () {
                const ret = arg.get_destination_script();
                const result = _bindingsMjs.encodeUint8Array(ret);
                return result;
            },
            get_shutdown_scriptpubkey () {
                const ret = arg.get_shutdown_scriptpubkey();
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            get_channel_signer (inbound, channel_value_satoshis) {
                const ret = arg.get_channel_signer(inbound, channel_value_satoshis);
                const result = ret == null ? 0 : ret.clone_ptr();
                _commonBaseMjsDefault.default.add_ref_from(impl_holder.held, ret);
                return result;
            },
            get_secure_random_bytes () {
                const ret = arg.get_secure_random_bytes();
                const result = _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(ret, 32));
                return result;
            },
            read_chan_signer (reader) {
                const reader_conv = _bindingsMjs.decodeUint8Array(reader);
                const ret = arg.read_chan_signer(reader_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            sign_invoice (invoice_preimage) {
                const invoice_preimage_conv = _bindingsMjs.decodeUint8Array(invoice_preimage);
                const ret = arg.sign_invoice(invoice_preimage_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            get_inbound_payment_key_material () {
                const ret = arg.get_inbound_payment_key_material();
                const result = _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(ret, 32));
                return result;
            }
        };
        const ptr = _bindingsMjs.LDKKeysInterface_new(structImplementation);
        impl_holder.held = new KeysInterface(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Get node secret key (aka node_id or network_key).
     *
     * This method must return the same value each time it is called.
     */ get_node_secret() {
        const ret = _bindingsMjs.KeysInterface_get_node_secret(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Get a script pubkey which we send funds to when claiming on-chain contestable outputs.
     *
     * This method should return a different value each time it is called, to avoid linking
     * on-chain funds across channels as controlled to the same user.
     */ get_destination_script() {
        const ret = _bindingsMjs.KeysInterface_get_destination_script(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Get a script pubkey which we will send funds to when closing a channel.
     *
     * This method should return a different value each time it is called, to avoid linking
     * on-chain funds across channels as controlled to the same user.
     */ get_shutdown_scriptpubkey() {
        const ret = _bindingsMjs.KeysInterface_get_shutdown_scriptpubkey(this.ptr);
        const ret_hu_conv = new _shutdownScriptMjs.ShutdownScript(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Get a new set of Sign for per-channel secrets. These MUST be unique even if you
     * restarted with some stale data!
     *
     * This method must return a different value each time it is called.
     */ get_channel_signer(inbound, channel_value_satoshis) {
        const ret = _bindingsMjs.KeysInterface_get_channel_signer(this.ptr, inbound, channel_value_satoshis);
        const ret_hu_conv = new _signMjs.Sign(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Gets a unique, cryptographically-secure, random 32 byte value. This is used for encrypting
     * onion packets and for temporary channel IDs. There is no requirement that these be
     * persisted anywhere, though they must be unique across restarts.
     *
     * This method must return a different value each time it is called.
     */ get_secure_random_bytes() {
        const ret = _bindingsMjs.KeysInterface_get_secure_random_bytes(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Reads a `Signer` for this `KeysInterface` from the given input stream.
     * This is only called during deserialization of other objects which contain
     * `Sign`-implementing objects (ie `ChannelMonitor`s and `ChannelManager`s).
     * The bytes are exactly those which `<Self::Signer as Writeable>::write()` writes, and
     * contain no versioning scheme. You may wish to include your own version prefix and ensure
     * you've read all of the provided bytes to ensure no corruption occurred.
     */ read_chan_signer(reader) {
        const ret = _bindingsMjs.KeysInterface_read_chan_signer(this.ptr, _bindingsMjs.encodeUint8Array(reader));
        const ret_hu_conv = _resultSignDecodeErrorZMjs.Result_SignDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Sign an invoice's preimage (note that this is the preimage of the invoice, not the HTLC's
     * preimage). By parameterizing by the preimage instead of the hash, we allow implementors of
     * this trait to parse the invoice and make sure they're signing what they expect, rather than
     * blindly signing the hash.
     */ sign_invoice(invoice_preimage) {
        const ret = _bindingsMjs.KeysInterface_sign_invoice(this.ptr, _bindingsMjs.encodeUint8Array(invoice_preimage));
        const ret_hu_conv = _resultRecoverableSignatureNoneZMjs.Result_RecoverableSignatureNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Get secret key material as bytes for use in encrypting and decrypting inbound payment data.
     *
     * This method must return the same value each time it is called.
     */ get_inbound_payment_key_material() {
        const ret = _bindingsMjs.KeysInterface_get_inbound_payment_key_material(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
}

},{"../structs/ShutdownScript.mjs":"gHaa6","../structs/Sign.mjs":"jgkjb","../structs/Result_SignDecodeErrorZ.mjs":"htjqc","../structs/Result_RecoverableSignatureNoneZ.mjs":"34rca","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b4XTq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A trait which should be implemented to provide feerate information on a number of time
 * horizons.
 *
 * Note that all of the functions implemented here *must* be reentrant-safe (obviously - they're
 * called from inside the library in response to chain events, P2P events, or timer events).
 */ parcelHelpers.export(exports, "FeeEstimator", ()=>FeeEstimator
) //# sourceMappingURL=FeeEstimator.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKFeeEstimatorHolder {
}
class FeeEstimator extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.FeeEstimator_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of FeeEstimator from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKFeeEstimatorHolder();
        let structImplementation = {
            get_est_sat_per_1000_weight (confirmation_target) {
                const ret = arg.get_est_sat_per_1000_weight(confirmation_target);
                return ret;
            }
        };
        const ptr = _bindingsMjs.LDKFeeEstimator_new(structImplementation);
        impl_holder.held = new FeeEstimator(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Gets estimated satoshis of fee required per 1000 Weight-Units.
     *
     * Must return a value no smaller than 253 (ie 1 satoshi-per-byte rounded up to ensure later
     * round-downs don't put us below 1 satoshi-per-byte).
     *
     * This method can be implemented with the following unit conversions:
     * max(satoshis-per-byte * 250, 253)
     * max(satoshis-per-kbyte / 4, 253)
     */ get_est_sat_per_1000_weight(confirmation_target) {
        const ret = _bindingsMjs.FeeEstimator_get_est_sat_per_1000_weight(this.ptr, confirmation_target);
        return ret;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"goJtG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Record, unit of logging output with Metadata to enable filtering
 * Module_path, file, line to inform on log's source
 */ parcelHelpers.export(exports, "Record", ()=>Record
) //# sourceMappingURL=Record.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Record extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Record_free);
    }
    /**
     * The verbosity level of the message.
     */ get_level() {
        const ret = _bindingsMjs.Record_get_level(this.ptr);
        return ret;
    }
    /**
     * The verbosity level of the message.
     */ set_level(val) {
        _bindingsMjs.Record_set_level(this.ptr, val);
    }
    /**
     * The message body.
     */ get_args() {
        const ret = _bindingsMjs.Record_get_args(this.ptr);
        const ret_conv = _bindingsMjs.decodeString(ret);
        return ret_conv;
    }
    /**
     * The message body.
     */ set_args(val) {
        _bindingsMjs.Record_set_args(this.ptr, _bindingsMjs.encodeString(val));
    }
    /**
     * The module path of the message.
     */ get_module_path() {
        const ret = _bindingsMjs.Record_get_module_path(this.ptr);
        const ret_conv = _bindingsMjs.decodeString(ret);
        return ret_conv;
    }
    /**
     * The module path of the message.
     */ set_module_path(val) {
        _bindingsMjs.Record_set_module_path(this.ptr, _bindingsMjs.encodeString(val));
    }
    /**
     * The source file containing the message.
     */ get_file() {
        const ret = _bindingsMjs.Record_get_file(this.ptr);
        const ret_conv = _bindingsMjs.decodeString(ret);
        return ret_conv;
    }
    /**
     * The source file containing the message.
     */ set_file(val) {
        _bindingsMjs.Record_set_file(this.ptr, _bindingsMjs.encodeString(val));
    }
    /**
     * The line containing the message.
     */ get_line() {
        const ret = _bindingsMjs.Record_get_line(this.ptr);
        return ret;
    }
    /**
     * The line containing the message.
     */ set_line(val) {
        _bindingsMjs.Record_set_line(this.ptr, val);
    }
    clone_ptr() {
        const ret = _bindingsMjs.Record_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the Record
     */ clone() {
        const ret = _bindingsMjs.Record_clone(this.ptr);
        const ret_hu_conv = new Record(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2M89o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A trait encapsulating the operations required of a logger
 */ parcelHelpers.export(exports, "Logger", ()=>Logger
) //# sourceMappingURL=Logger.mjs.map
;
var _recordMjs = require("../structs/Record.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKLoggerHolder {
}
class Logger extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Logger_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of Logger from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKLoggerHolder();
        let structImplementation = {
            log (record) {
                const record_hu_conv = new _recordMjs.Record(null, record);
                arg.log(record_hu_conv);
            }
        };
        const ptr = _bindingsMjs.LDKLogger_new(structImplementation);
        impl_holder.held = new Logger(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
}

},{"../structs/Record.mjs":"goJtG","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7XhoG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Manager which keeps track of a number of channels and sends messages to the appropriate
 * channel, also tracking HTLC preimages and forwarding onion packets appropriately.
 *
 * Implements ChannelMessageHandler, handling the multi-channel parts and passing things through
 * to individual Channels.
 *
 * Implements Writeable to write out all channel state to disk. Implies peer_disconnected() for
 * all peers during write/read (though does not modify this instance, only the instance being
 * serialized). This will result in any channels which have not yet exchanged funding_created (ie
 * called funding_transaction_generated for outbound channels).
 *
 * Note that you can be a bit lazier about writing out ChannelManager than you can be with
 * ChannelMonitors. With ChannelMonitors you MUST write each monitor update out to disk before
 * returning from chain::Watch::watch_/update_channel, with ChannelManagers, writing updates
 * happens out-of-band (and will prevent any other ChannelManager operations from occurring during
 * the serialization process). If the deserialized version is out-of-date compared to the
 * ChannelMonitors passed by reference to read(), those channels will be force-closed based on the
 * ChannelMonitor state and no funds will be lost (mod on-chain transaction fees).
 *
 * Note that the deserializer is only implemented for (BlockHash, ChannelManager), which
 * tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
 * the \"reorg path\" (ie call block_disconnected() until you get to a common block and then call
 * block_connected() to step towards your best block) upon deserialization before using the
 * object!
 *
 * Note that ChannelManager is responsible for tracking liveness of its channels and generating
 * ChannelUpdate messages informing peers that the channel is temporarily disabled. To avoid
 * spam due to quick disconnection/reconnection, updates are not sent until the channel has been
 * offline for a full minute. In order to track this, you must call
 * timer_tick_occurred roughly once per minute, though it doesn't have to be perfect.
 *
 * Rather than using a plain ChannelManager, it is preferable to use either a SimpleArcChannelManager
 * a SimpleRefChannelManager, for conciseness. See their documentation for more details, but
 * essentially you should default to using a SimpleRefChannelManager, and use a
 * SimpleArcChannelManager when you require a ChannelManager with a static lifetime, such as when
 * you're using lightning-net-tokio.
 */ parcelHelpers.export(exports, "ChannelManager", ()=>ChannelManager
) //# sourceMappingURL=ChannelManager.mjs.map
;
var _channelDetailsMjs = require("../structs/ChannelDetails.mjs");
var _resultNoneAPIErrorZMjs = require("../structs/Result_NoneAPIErrorZ.mjs");
var _resultU832APIErrorZMjs = require("../structs/Result__u832APIErrorZ.mjs");
var _resultPaymentIdPaymentSendFailureZMjs = require("../structs/Result_PaymentIdPaymentSendFailureZ.mjs");
var _resultNonePaymentSendFailureZMjs = require("../structs/Result_NonePaymentSendFailureZ.mjs");
var _resultC2TuplePaymentHashPaymentIdZPaymentSendFailureZMjs = require("../structs/Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ.mjs");
var _resultC2TuplePaymentHashPaymentSecretZNoneZMjs = require("../structs/Result_C2Tuple_PaymentHashPaymentSecretZNoneZ.mjs");
var _resultC2TuplePaymentHashPaymentSecretZAPIErrorZMjs = require("../structs/Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ.mjs");
var _resultPaymentSecretNoneZMjs = require("../structs/Result_PaymentSecretNoneZ.mjs");
var _resultPaymentSecretAPIErrorZMjs = require("../structs/Result_PaymentSecretAPIErrorZ.mjs");
var _resultPaymentPreimageAPIErrorZMjs = require("../structs/Result_PaymentPreimageAPIErrorZ.mjs");
var _messageSendEventsProviderMjs = require("../structs/MessageSendEventsProvider.mjs");
var _eventsProviderMjs = require("../structs/EventsProvider.mjs");
var _userConfigMjs = require("../structs/UserConfig.mjs");
var _bestBlockMjs = require("../structs/BestBlock.mjs");
var _listenMjs = require("../structs/Listen.mjs");
var _confirmMjs = require("../structs/Confirm.mjs");
var _channelMessageHandlerMjs = require("../structs/ChannelMessageHandler.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelManager extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelManager_free);
    }
    /**
     * Constructs a new ChannelManager to hold several channels and route between them.
     *
     * This is the main \"logic hub\" for all channel-related actions, and implements
     * ChannelMessageHandler.
     *
     * Non-proportional fees are fixed according to our risk using the provided fee estimator.
     *
     * panics if channel_value_satoshis is >= `MAX_FUNDING_SATOSHIS`!
     *
     * Users need to notify the new ChannelManager when a new block is connected or
     * disconnected using its `block_connected` and `block_disconnected` methods, starting
     * from after `params.latest_hash`.
     */ static constructor_new(fee_est, chain_monitor, tx_broadcaster, logger, keys_manager, config, params) {
        const ret = _bindingsMjs.ChannelManager_new(fee_est == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(fee_est), chain_monitor == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(chain_monitor), tx_broadcaster == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(tx_broadcaster), logger == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(logger), keys_manager == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(keys_manager), config == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(config) & -2, params == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(params) & -2);
        const ret_hu_conv = new ChannelManager(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, fee_est);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, chain_monitor);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, tx_broadcaster);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, logger);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, keys_manager);
        return ret_hu_conv;
    }
    /**
     * Gets the current configuration applied to all new channels,  as
     */ get_current_default_configuration() {
        const ret = _bindingsMjs.ChannelManager_get_current_default_configuration(this.ptr);
        const ret_hu_conv = new _userConfigMjs.UserConfig(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a new outbound channel to the given remote node and with the given value.
     *
     * `user_channel_id` will be provided back as in
     * [`Event::FundingGenerationReady::user_channel_id`] to allow tracking of which events
     * correspond with which `create_channel` call. Note that the `user_channel_id` defaults to 0
     * for inbound channels, so you may wish to avoid using 0 for `user_channel_id` here.
     * `user_channel_id` has no meaning inside of LDK, it is simply copied to events and otherwise
     * ignored.
     *
     * Raises [`APIError::APIMisuseError`] when `channel_value_satoshis` > 2**24 or `push_msat` is
     * greater than `channel_value_satoshis * 1k` or `channel_value_satoshis < 1000`.
     *
     * Note that we do not check if you are currently connected to the given peer. If no
     * connection is available, the outbound `open_channel` message may fail to send, resulting in
     * the channel eventually being silently forgotten (dropped on reload).
     *
     * Returns the new Channel's temporary `channel_id`. This ID will appear as
     * [`Event::FundingGenerationReady::temporary_channel_id`] and in
     * [`ChannelDetails::channel_id`] until after
     * [`ChannelManager::funding_transaction_generated`] is called, swapping the Channel's ID for
     * one derived from the funding transaction's TXID. If the counterparty rejects the channel
     * immediately, this temporary ID will appear in [`Event::ChannelClosed::channel_id`].
     *
     * [`Event::FundingGenerationReady::user_channel_id`]: events::Event::FundingGenerationReady::user_channel_id
     * [`Event::FundingGenerationReady::temporary_channel_id`]: events::Event::FundingGenerationReady::temporary_channel_id
     * [`Event::ChannelClosed::channel_id`]: events::Event::ChannelClosed::channel_id
     *
     * Note that override_config (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ create_channel(their_network_key, channel_value_satoshis, push_msat, user_channel_id, override_config) {
        const ret = _bindingsMjs.ChannelManager_create_channel(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_network_key, 33)), channel_value_satoshis, push_msat, user_channel_id, override_config == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(override_config) & -2);
        const ret_hu_conv = _resultU832APIErrorZMjs.Result__u832APIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Gets the list of open channels, in random order. See ChannelDetail field documentation for
     * more information.
     */ list_channels() {
        const ret = _bindingsMjs.ChannelManager_list_channels(this.ptr);
        const ret_conv_16_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_16_arr = new Array(ret_conv_16_len).fill(null);
        for(var q = 0; q < ret_conv_16_len; q++){
            const ret_conv_16 = _bindingsMjs.getU32ArrayElem(ret, q);
            const ret_conv_16_hu_conv = new _channelDetailsMjs.ChannelDetails(null, ret_conv_16);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_16_hu_conv, this);
            ret_conv_16_arr[q] = ret_conv_16_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_16_arr;
    }
    /**
     * Gets the list of usable channels, in random order. Useful as an argument to
     * get_route to ensure non-announced channels are used.
     *
     * These are guaranteed to have their [`ChannelDetails::is_usable`] value set to true, see the
     * documentation for [`ChannelDetails::is_usable`] for more info on exactly what the criteria
     * are.
     */ list_usable_channels() {
        const ret = _bindingsMjs.ChannelManager_list_usable_channels(this.ptr);
        const ret_conv_16_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_16_arr = new Array(ret_conv_16_len).fill(null);
        for(var q = 0; q < ret_conv_16_len; q++){
            const ret_conv_16 = _bindingsMjs.getU32ArrayElem(ret, q);
            const ret_conv_16_hu_conv = new _channelDetailsMjs.ChannelDetails(null, ret_conv_16);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_16_hu_conv, this);
            ret_conv_16_arr[q] = ret_conv_16_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_16_arr;
    }
    /**
     * Begins the process of closing a channel. After this call (plus some timeout), no new HTLCs
     * will be accepted on the given channel, and after additional timeout/the closing of all
     * pending HTLCs, the channel will be closed on chain.
     *
     * If we are the channel initiator, we will pay between our [`Background`] and
     * [`ChannelConfig::force_close_avoidance_max_fee_satoshis`] plus our [`Normal`] fee
     * estimate.
     * If our counterparty is the channel initiator, we will require a channel closing
     * transaction feerate of at least our [`Background`] feerate or the feerate which
     * would appear on a force-closure transaction, whichever is lower. We will allow our
     * counterparty to pay as much fee as they'd like, however.
     *
     * May generate a SendShutdown message event on success, which should be relayed.
     *
     * [`ChannelConfig::force_close_avoidance_max_fee_satoshis`]: crate::util::config::ChannelConfig::force_close_avoidance_max_fee_satoshis
     * [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
     * [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
     */ close_channel(channel_id) {
        const ret = _bindingsMjs.ChannelManager_close_channel(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_id, 32)));
        const ret_hu_conv = _resultNoneAPIErrorZMjs.Result_NoneAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Begins the process of closing a channel. After this call (plus some timeout), no new HTLCs
     * will be accepted on the given channel, and after additional timeout/the closing of all
     * pending HTLCs, the channel will be closed on chain.
     *
     * `target_feerate_sat_per_1000_weight` has different meanings depending on if we initiated
     * the channel being closed or not:
     * If we are the channel initiator, we will pay at least this feerate on the closing
     * transaction. The upper-bound is set by
     * [`ChannelConfig::force_close_avoidance_max_fee_satoshis`] plus our [`Normal`] fee
     * estimate (or `target_feerate_sat_per_1000_weight`, if it is greater).
     * If our counterparty is the channel initiator, we will refuse to accept a channel closure
     * transaction feerate below `target_feerate_sat_per_1000_weight` (or the feerate which
     * will appear on a force-closure transaction, whichever is lower).
     *
     * May generate a SendShutdown message event on success, which should be relayed.
     *
     * [`ChannelConfig::force_close_avoidance_max_fee_satoshis`]: crate::util::config::ChannelConfig::force_close_avoidance_max_fee_satoshis
     * [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
     * [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
     */ close_channel_with_target_feerate(channel_id, target_feerate_sats_per_1000_weight) {
        const ret = _bindingsMjs.ChannelManager_close_channel_with_target_feerate(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_id, 32)), target_feerate_sats_per_1000_weight);
        const ret_hu_conv = _resultNoneAPIErrorZMjs.Result_NoneAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Force closes a channel, immediately broadcasting the latest local commitment transaction to
     * the chain and rejecting new HTLCs on the given channel. Fails if channel_id is unknown to the manager.
     */ force_close_channel(channel_id) {
        const ret = _bindingsMjs.ChannelManager_force_close_channel(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(channel_id, 32)));
        const ret_hu_conv = _resultNoneAPIErrorZMjs.Result_NoneAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Force close all channels, immediately broadcasting the latest local commitment transaction
     * for each to the chain and rejecting new HTLCs on each.
     */ force_close_all_channels() {
        _bindingsMjs.ChannelManager_force_close_all_channels(this.ptr);
    }
    /**
     * Sends a payment along a given route.
     *
     * Value parameters are provided via the last hop in route, see documentation for RouteHop
     * fields for more info.
     *
     * Note that if the payment_hash already exists elsewhere (eg you're sending a duplicative
     * payment), we don't do anything to stop you! We always try to ensure that if the provided
     * next hop knows the preimage to payment_hash they can claim an additional amount as
     * specified in the last hop in the route! Thus, you should probably do your own
     * payment_preimage tracking (which you should already be doing as they represent \"proof of
     * payment\") and prevent double-sends yourself.
     *
     * May generate SendHTLCs message(s) event on success, which should be relayed.
     *
     * Each path may have a different return value, and PaymentSendValue may return a Vec with
     * each entry matching the corresponding-index entry in the route paths, see
     * PaymentSendFailure for more info.
     *
     * In general, a path may raise:
     * APIError::RouteError when an invalid route or forwarding parameter (cltv_delta, fee,
     * node public key) is specified.
     * APIError::ChannelUnavailable if the next-hop channel is not available for updates
     * (including due to previous monitor update failure or new permanent monitor update
     * failure).
     * APIError::MonitorUpdateFailed if a new monitor update failure prevented sending the
     * relevant updates.
     *
     * Note that depending on the type of the PaymentSendFailure the HTLC may have been
     * irrevocably committed to on our end. In such a case, do NOT retry the payment with a
     * different route unless you intend to pay twice!
     *
     * payment_secret is unrelated to payment_hash (or PaymentPreimage) and exists to authenticate
     * the sender to the recipient and prevent payment-probing (deanonymization) attacks. For
     * newer nodes, it will be provided to you in the invoice. If you do not have one, the Route
     * must not contain multiple paths as multi-path payments require a recipient-provided
     * payment_secret.
     * If a payment_secret *is* provided, we assume that the invoice had the payment_secret feature
     * bit set (either as required or as available). If multiple paths are present in the Route,
     * we assume the invoice had the basic_mpp feature set.
     *
     * Note that payment_secret (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ send_payment(route, payment_hash, payment_secret) {
        const ret = _bindingsMjs.ChannelManager_send_payment(this.ptr, route == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(route) & -2, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_hash, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_secret, 32)));
        const ret_hu_conv = _resultPaymentIdPaymentSendFailureZMjs.Result_PaymentIdPaymentSendFailureZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, route);
        return ret_hu_conv;
    }
    /**
     * Retries a payment along the given [`Route`].
     *
     * Errors returned are a superset of those returned from [`send_payment`], so see
     * [`send_payment`] documentation for more details on errors. This method will also error if the
     * retry amount puts the payment more than 10% over the payment's total amount, if the payment
     * for the given `payment_id` cannot be found (likely due to timeout or success), or if
     * further retries have been disabled with [`abandon_payment`].
     *
     * [`send_payment`]: [`ChannelManager::send_payment`]
     * [`abandon_payment`]: [`ChannelManager::abandon_payment`]
     */ retry_payment(route, payment_id) {
        const ret = _bindingsMjs.ChannelManager_retry_payment(this.ptr, route == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(route) & -2, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_id, 32)));
        const ret_hu_conv = _resultNonePaymentSendFailureZMjs.Result_NonePaymentSendFailureZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, route);
        return ret_hu_conv;
    }
    /**
     * Signals that no further retries for the given payment will occur.
     *
     * After this method returns, any future calls to [`retry_payment`] for the given `payment_id`
     * will fail with [`PaymentSendFailure::ParameterError`]. If no such event has been generated,
     * an [`Event::PaymentFailed`] event will be generated as soon as there are no remaining
     * pending HTLCs for this payment.
     *
     * Note that calling this method does *not* prevent a payment from succeeding. You must still
     * wait until you receive either a [`Event::PaymentFailed`] or [`Event::PaymentSent`] event to
     * determine the ultimate status of a payment.
     *
     * [`retry_payment`]: Self::retry_payment
     * [`Event::PaymentFailed`]: events::Event::PaymentFailed
     * [`Event::PaymentSent`]: events::Event::PaymentSent
     */ abandon_payment(payment_id) {
        _bindingsMjs.ChannelManager_abandon_payment(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_id, 32)));
    }
    /**
     * Send a spontaneous payment, which is a payment that does not require the recipient to have
     * generated an invoice. Optionally, you may specify the preimage. If you do choose to specify
     * the preimage, it must be a cryptographically secure random value that no intermediate node
     * would be able to guess -- otherwise, an intermediate node may claim the payment and it will
     * never reach the recipient.
     *
     * See [`send_payment`] documentation for more details on the return value of this function.
     *
     * Similar to regular payments, you MUST NOT reuse a `payment_preimage` value. See
     * [`send_payment`] for more information about the risks of duplicate preimage usage.
     *
     * Note that `route` must have exactly one path.
     *
     * [`send_payment`]: Self::send_payment
     *
     * Note that payment_preimage (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ send_spontaneous_payment(route, payment_preimage) {
        const ret = _bindingsMjs.ChannelManager_send_spontaneous_payment(this.ptr, route == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(route) & -2, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_preimage, 32)));
        const ret_hu_conv = _resultC2TuplePaymentHashPaymentIdZPaymentSendFailureZMjs.Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, route);
        return ret_hu_conv;
    }
    /**
     * Call this upon creation of a funding transaction for the given channel.
     *
     * Returns an [`APIError::APIMisuseError`] if the funding_transaction spent non-SegWit outputs
     * or if no output was found which matches the parameters in [`Event::FundingGenerationReady`].
     *
     * Returns [`APIError::ChannelUnavailable`] if a funding transaction has already been provided
     * for the channel or if the channel has been closed as indicated by [`Event::ChannelClosed`].
     *
     * May panic if the output found in the funding transaction is duplicative with some other
     * channel (note that this should be trivially prevented by using unique funding transaction
     * keys per-channel).
     *
     * Do NOT broadcast the funding transaction yourself. When we have safely received our
     * counterparty's signature the funding transaction will automatically be broadcast via the
     * [`BroadcasterInterface`] provided when this `ChannelManager` was constructed.
     *
     * Note that this includes RBF or similar transaction replacement strategies - lightning does
     * not currently support replacing a funding transaction on an existing channel. Instead,
     * create a new channel with a conflicting funding transaction.
     *
     * [`Event::FundingGenerationReady`]: crate::util::events::Event::FundingGenerationReady
     * [`Event::ChannelClosed`]: crate::util::events::Event::ChannelClosed
     */ funding_transaction_generated(temporary_channel_id, funding_transaction) {
        const ret = _bindingsMjs.ChannelManager_funding_transaction_generated(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(temporary_channel_id, 32)), _bindingsMjs.encodeUint8Array(funding_transaction));
        const ret_hu_conv = _resultNoneAPIErrorZMjs.Result_NoneAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Regenerates channel_announcements and generates a signed node_announcement from the given
     * arguments, providing them in corresponding events via
     * [`get_and_clear_pending_msg_events`], if at least one public channel has been confirmed
     * on-chain. This effectively re-broadcasts all channel announcements and sends our node
     * announcement to ensure that the lightning P2P network is aware of the channels we have and
     * our network addresses.
     *
     * `rgb` is a node \"color\" and `alias` is a printable human-readable string to describe this
     * node to humans. They carry no in-protocol meaning.
     *
     * `addresses` represent the set (possibly empty) of socket addresses on which this node
     * accepts incoming connections. These will be included in the node_announcement, publicly
     * tying these addresses together and to this node. If you wish to preserve user privacy,
     * addresses should likely contain only Tor Onion addresses.
     *
     * Panics if `addresses` is absurdly large (more than 500).
     *
     * [`get_and_clear_pending_msg_events`]: MessageSendEventsProvider::get_and_clear_pending_msg_events
     */ broadcast_node_announcement(rgb, alias, addresses) {
        _bindingsMjs.ChannelManager_broadcast_node_announcement(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(rgb, 3)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(alias, 32)), _bindingsMjs.encodeUint32Array(addresses != null ? addresses.map((addresses_conv_12)=>_commonBaseMjsDefault.default.get_ptr_of(addresses_conv_12)
        ) : null));
    }
    /**
     * Processes HTLCs which are pending waiting on random forward delay.
     *
     * Should only really ever be called in response to a PendingHTLCsForwardable event.
     * Will likely generate further events.
     */ process_pending_htlc_forwards() {
        _bindingsMjs.ChannelManager_process_pending_htlc_forwards(this.ptr);
    }
    /**
     * Performs actions which should happen on startup and roughly once per minute thereafter.
     *
     * This currently includes:
     * Increasing or decreasing the on-chain feerate estimates for our outbound channels,
     * Broadcasting `ChannelUpdate` messages if we've been disconnected from our peer for more
     * than a minute, informing the network that they should no longer attempt to route over
     * the channel.
     *
     * Note that this may cause reentrancy through `chain::Watch::update_channel` calls or feerate
     * estimate fetches.
     */ timer_tick_occurred() {
        _bindingsMjs.ChannelManager_timer_tick_occurred(this.ptr);
    }
    /**
     * Indicates that the preimage for payment_hash is unknown or the received amount is incorrect
     * after a PaymentReceived event, failing the HTLC back to its origin and freeing resources
     * along the path (including in our own channel on which we received it).
     * Returns false if no payment was found to fail backwards, true if the process of failing the
     * HTLC backwards has been started.
     */ fail_htlc_backwards(payment_hash) {
        const ret = _bindingsMjs.ChannelManager_fail_htlc_backwards(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_hash, 32)));
        return ret;
    }
    /**
     * Provides a payment preimage in response to [`Event::PaymentReceived`], generating any
     * [`MessageSendEvent`]s needed to claim the payment.
     *
     * Note that if you did not set an `amount_msat` when calling [`create_inbound_payment`] or
     * [`create_inbound_payment_for_hash`] you must check that the amount in the `PaymentReceived`
     * event matches your expectation. If you fail to do so and call this method, you may provide
     * the sender \"proof-of-payment\" when they did not fulfill the full expected payment.
     *
     * Returns whether any HTLCs were claimed, and thus if any new [`MessageSendEvent`]s are now
     * pending for processing via [`get_and_clear_pending_msg_events`].
     *
     * [`Event::PaymentReceived`]: crate::util::events::Event::PaymentReceived
     * [`create_inbound_payment`]: Self::create_inbound_payment
     * [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
     * [`get_and_clear_pending_msg_events`]: MessageSendEventsProvider::get_and_clear_pending_msg_events
     */ claim_funds(payment_preimage) {
        const ret = _bindingsMjs.ChannelManager_claim_funds(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_preimage, 32)));
        return ret;
    }
    /**
     * Gets the node_id held by this ChannelManager
     */ get_our_node_id() {
        const ret = _bindingsMjs.ChannelManager_get_our_node_id(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Gets a payment secret and payment hash for use in an invoice given to a third party wishing
     * to pay us.
     *
     * This differs from [`create_inbound_payment_for_hash`] only in that it generates the
     * [`PaymentHash`] and [`PaymentPreimage`] for you.
     *
     * The [`PaymentPreimage`] will ultimately be returned to you in the [`PaymentReceived`], which
     * will have the [`PaymentReceived::payment_preimage`] field filled in. That should then be
     * passed directly to [`claim_funds`].
     *
     * See [`create_inbound_payment_for_hash`] for detailed documentation on behavior and requirements.
     *
     * Note that a malicious eavesdropper can intuit whether an inbound payment was created by
     * `create_inbound_payment` or `create_inbound_payment_for_hash` based on runtime.
     *
     * # Note
     *
     * If you register an inbound payment with this method, then serialize the `ChannelManager`, then
     * deserialize it with a node running 0.0.103 and earlier, the payment will fail to be received.
     *
     * Errors if `min_value_msat` is greater than total bitcoin supply.
     *
     * [`claim_funds`]: Self::claim_funds
     * [`PaymentReceived`]: events::Event::PaymentReceived
     * [`PaymentReceived::payment_preimage`]: events::Event::PaymentReceived::payment_preimage
     * [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
     */ create_inbound_payment(min_value_msat, invoice_expiry_delta_secs) {
        const ret = _bindingsMjs.ChannelManager_create_inbound_payment(this.ptr, _commonBaseMjsDefault.default.get_ptr_of(min_value_msat), invoice_expiry_delta_secs);
        const ret_hu_conv = _resultC2TuplePaymentHashPaymentSecretZNoneZMjs.Result_C2Tuple_PaymentHashPaymentSecretZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Legacy version of [`create_inbound_payment`]. Use this method if you wish to share
     * serialized state with LDK node(s) running 0.0.103 and earlier.
     *
     * # Note
     * This method is deprecated and will be removed soon.
     *
     * [`create_inbound_payment`]: Self::create_inbound_payment
     */ create_inbound_payment_legacy(min_value_msat, invoice_expiry_delta_secs) {
        const ret = _bindingsMjs.ChannelManager_create_inbound_payment_legacy(this.ptr, _commonBaseMjsDefault.default.get_ptr_of(min_value_msat), invoice_expiry_delta_secs);
        const ret_hu_conv = _resultC2TuplePaymentHashPaymentSecretZAPIErrorZMjs.Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Gets a [`PaymentSecret`] for a given [`PaymentHash`], for which the payment preimage is
     * stored external to LDK.
     *
     * A [`PaymentReceived`] event will only be generated if the [`PaymentSecret`] matches a
     * payment secret fetched via this method or [`create_inbound_payment`], and which is at least
     * the `min_value_msat` provided here, if one is provided.
     *
     * The [`PaymentHash`] (and corresponding [`PaymentPreimage`]) should be globally unique, though
     * note that LDK will not stop you from registering duplicate payment hashes for inbound
     * payments.
     *
     * `min_value_msat` should be set if the invoice being generated contains a value. Any payment
     * received for the returned [`PaymentHash`] will be required to be at least `min_value_msat`
     * before a [`PaymentReceived`] event will be generated, ensuring that we do not provide the
     * sender \"proof-of-payment\" unless they have paid the required amount.
     *
     * `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
     * in excess of the current time. This should roughly match the expiry time set in the invoice.
     * After this many seconds, we will remove the inbound payment, resulting in any attempts to
     * pay the invoice failing. The BOLT spec suggests 3,600 secs as a default validity time for
     * invoices when no timeout is set.
     *
     * Note that we use block header time to time-out pending inbound payments (with some margin
     * to compensate for the inaccuracy of block header timestamps). Thus, in practice we will
     * accept a payment and generate a [`PaymentReceived`] event for some time after the expiry.
     * If you need exact expiry semantics, you should enforce them upon receipt of
     * [`PaymentReceived`].
     *
     * May panic if `invoice_expiry_delta_secs` is greater than one year.
     *
     * Note that invoices generated for inbound payments should have their `min_final_cltv_expiry`
     * set to at least [`MIN_FINAL_CLTV_EXPIRY`].
     *
     * Note that a malicious eavesdropper can intuit whether an inbound payment was created by
     * `create_inbound_payment` or `create_inbound_payment_for_hash` based on runtime.
     *
     * # Note
     *
     * If you register an inbound payment with this method, then serialize the `ChannelManager`, then
     * deserialize it with a node running 0.0.103 and earlier, the payment will fail to be received.
     *
     * Errors if `min_value_msat` is greater than total bitcoin supply.
     *
     * [`create_inbound_payment`]: Self::create_inbound_payment
     * [`PaymentReceived`]: events::Event::PaymentReceived
     */ create_inbound_payment_for_hash(payment_hash, min_value_msat, invoice_expiry_delta_secs) {
        const ret = _bindingsMjs.ChannelManager_create_inbound_payment_for_hash(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_hash, 32)), _commonBaseMjsDefault.default.get_ptr_of(min_value_msat), invoice_expiry_delta_secs);
        const ret_hu_conv = _resultPaymentSecretNoneZMjs.Result_PaymentSecretNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Legacy version of [`create_inbound_payment_for_hash`]. Use this method if you wish to share
     * serialized state with LDK node(s) running 0.0.103 and earlier.
     *
     * # Note
     * This method is deprecated and will be removed soon.
     *
     * [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
     */ create_inbound_payment_for_hash_legacy(payment_hash, min_value_msat, invoice_expiry_delta_secs) {
        const ret = _bindingsMjs.ChannelManager_create_inbound_payment_for_hash_legacy(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_hash, 32)), _commonBaseMjsDefault.default.get_ptr_of(min_value_msat), invoice_expiry_delta_secs);
        const ret_hu_conv = _resultPaymentSecretAPIErrorZMjs.Result_PaymentSecretAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Gets an LDK-generated payment preimage from a payment hash and payment secret that were
     * previously returned from [`create_inbound_payment`].
     *
     * [`create_inbound_payment`]: Self::create_inbound_payment
     */ get_payment_preimage(payment_hash, payment_secret) {
        const ret = _bindingsMjs.ChannelManager_get_payment_preimage(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_hash, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(payment_secret, 32)));
        const ret_hu_conv = _resultPaymentPreimageAPIErrorZMjs.Result_PaymentPreimageAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
     */ as_MessageSendEventsProvider() {
        const ret = _bindingsMjs.ChannelManager_as_MessageSendEventsProvider(this.ptr);
        const ret_hu_conv = new _messageSendEventsProviderMjs.MessageSendEventsProvider(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new EventsProvider which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
     */ as_EventsProvider() {
        const ret = _bindingsMjs.ChannelManager_as_EventsProvider(this.ptr);
        const ret_hu_conv = new _eventsProviderMjs.EventsProvider(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new Listen which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
     */ as_Listen() {
        const ret = _bindingsMjs.ChannelManager_as_Listen(this.ptr);
        const ret_hu_conv = new _listenMjs.Listen(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new Confirm which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned Confirm must be freed before this_arg is
     */ as_Confirm() {
        const ret = _bindingsMjs.ChannelManager_as_Confirm(this.ptr);
        const ret_hu_conv = new _confirmMjs.Confirm(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Blocks until ChannelManager needs to be persisted. Only one listener on
     * `await_persistable_update` or `await_persistable_update_timeout` is guaranteed to be woken
     * up.
     */ await_persistable_update() {
        _bindingsMjs.ChannelManager_await_persistable_update(this.ptr);
    }
    /**
     * Gets the latest best block which was connected either via the [`chain::Listen`] or
     * [`chain::Confirm`] interfaces.
     */ current_best_block() {
        const ret = _bindingsMjs.ChannelManager_current_best_block(this.ptr);
        const ret_hu_conv = new _bestBlockMjs.BestBlock(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
     */ as_ChannelMessageHandler() {
        const ret = _bindingsMjs.ChannelManager_as_ChannelMessageHandler(this.ptr);
        const ret_hu_conv = new _channelMessageHandlerMjs.ChannelMessageHandler(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the ChannelManager object into a byte array which can be read by ChannelManager_read
     */ write() {
        const ret = _bindingsMjs.ChannelManager_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
}

},{"../structs/ChannelDetails.mjs":"bIXdf","../structs/Result_NoneAPIErrorZ.mjs":"56Ohf","../structs/Result__u832APIErrorZ.mjs":"fcmUI","../structs/Result_PaymentIdPaymentSendFailureZ.mjs":"eQJEs","../structs/Result_NonePaymentSendFailureZ.mjs":"4uCl5","../structs/Result_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ.mjs":"jM82N","../structs/Result_C2Tuple_PaymentHashPaymentSecretZNoneZ.mjs":"f6YT4","../structs/Result_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ.mjs":"dwFq0","../structs/Result_PaymentSecretNoneZ.mjs":"2khSV","../structs/Result_PaymentSecretAPIErrorZ.mjs":"ggvA5","../structs/Result_PaymentPreimageAPIErrorZ.mjs":"17jBi","../structs/MessageSendEventsProvider.mjs":"U83N1","../structs/EventsProvider.mjs":"9x0e4","../structs/UserConfig.mjs":"io87u","../structs/BestBlock.mjs":"1czxO","../structs/Listen.mjs":"7mGRx","../structs/Confirm.mjs":"gHOTY","../structs/ChannelMessageHandler.mjs":"dr4Tk","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"U83N1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A trait indicating an object may generate message send events
 */ parcelHelpers.export(exports, "MessageSendEventsProvider", ()=>MessageSendEventsProvider
) //# sourceMappingURL=MessageSendEventsProvider.mjs.map
;
var _messageSendEventMjs = require("../structs/MessageSendEvent.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKMessageSendEventsProviderHolder {
}
class MessageSendEventsProvider extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.MessageSendEventsProvider_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of MessageSendEventsProvider from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKMessageSendEventsProviderHolder();
        let structImplementation = {
            get_and_clear_pending_msg_events () {
                const ret = arg.get_and_clear_pending_msg_events();
                const result = _bindingsMjs.encodeUint32Array(ret != null ? ret.map((ret_conv_18)=>ret_conv_18 == null ? 0 : ret_conv_18.clone_ptr()
                ) : null);
                return result;
            }
        };
        const ptr = _bindingsMjs.LDKMessageSendEventsProvider_new(structImplementation);
        impl_holder.held = new MessageSendEventsProvider(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Gets the list of pending events which were generated by previous actions, clearing the list
     * in the process.
     */ get_and_clear_pending_msg_events() {
        const ret = _bindingsMjs.MessageSendEventsProvider_get_and_clear_pending_msg_events(this.ptr);
        const ret_conv_18_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_18_arr = new Array(ret_conv_18_len).fill(null);
        for(var s = 0; s < ret_conv_18_len; s++){
            const ret_conv_18 = _bindingsMjs.getU32ArrayElem(ret, s);
            const ret_conv_18_hu_conv = _messageSendEventMjs.MessageSendEvent.constr_from_ptr(ret_conv_18);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_18_hu_conv, this);
            ret_conv_18_arr[s] = ret_conv_18_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_18_arr;
    }
}

},{"../structs/MessageSendEvent.mjs":"hFzDz","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9x0e4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A trait indicating an object may generate events.
 *
 * Events are processed by passing an [`EventHandler`] to [`process_pending_events`].
 *
 * # Requirements
 *
 * See [`process_pending_events`] for requirements around event processing.
 *
 * When using this trait, [`process_pending_events`] will call [`handle_event`] for each pending
 * event since the last invocation. The handler must either act upon the event immediately
 * or preserve it for later handling.
 *
 * Note, handlers may call back into the provider and thus deadlocking must be avoided. Be sure to
 * consult the provider's documentation on the implication of processing events and how a handler
 * may safely use the provider (e.g., see [`ChannelManager::process_pending_events`] and
 * [`ChainMonitor::process_pending_events`]).
 *
 * (C-not implementable) As there is likely no reason for a user to implement this trait on their
 * own type(s).
 *
 * [`process_pending_events`]: Self::process_pending_events
 * [`handle_event`]: EventHandler::handle_event
 * [`ChannelManager::process_pending_events`]: crate::ln::channelmanager::ChannelManager#method.process_pending_events
 * [`ChainMonitor::process_pending_events`]: crate::chain::chainmonitor::ChainMonitor#method.process_pending_events
 */ parcelHelpers.export(exports, "EventsProvider", ()=>EventsProvider
) //# sourceMappingURL=EventsProvider.mjs.map
;
var _eventHandlerMjs = require("../structs/EventHandler.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKEventsProviderHolder {
}
class EventsProvider extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.EventsProvider_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of EventsProvider from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKEventsProviderHolder();
        let structImplementation = {
            process_pending_events (handler) {
                const ret_hu_conv = new _eventHandlerMjs.EventHandler(null, handler);
                _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
                arg.process_pending_events(ret_hu_conv);
            }
        };
        const ptr = _bindingsMjs.LDKEventsProvider_new(structImplementation);
        impl_holder.held = new EventsProvider(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Processes any events generated since the last call using the given event handler.
     *
     * Subsequent calls must only process new events. However, handlers must be capable of handling
     * duplicate events across process restarts. This may occur if the provider was recovered from
     * an old state (i.e., it hadn't been successfully persisted after processing pending events).
     */ process_pending_events(handler) {
        _bindingsMjs.EventsProvider_process_pending_events(this.ptr, handler == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(handler));
        _commonBaseMjsDefault.default.add_ref_from(this, handler);
    }
}

},{"../structs/EventHandler.mjs":"iL3gQ","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iL3gQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A trait implemented for objects handling events from [`EventsProvider`].
 */ parcelHelpers.export(exports, "EventHandler", ()=>EventHandler
) //# sourceMappingURL=EventHandler.mjs.map
;
var _eventMjs = require("../structs/Event.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKEventHandlerHolder {
}
class EventHandler extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.EventHandler_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of EventHandler from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKEventHandlerHolder();
        let structImplementation = {
            handle_event (event) {
                const event_hu_conv = _eventMjs.Event.constr_from_ptr(event);
                arg.handle_event(event_hu_conv);
            }
        };
        const ptr = _bindingsMjs.LDKEventHandler_new(structImplementation);
        impl_holder.held = new EventHandler(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Handles the given [`Event`].
     *
     * See [`EventsProvider`] for details that must be considered when implementing this method.
     */ handle_event(event) {
        _bindingsMjs.EventHandler_handle_event(this.ptr, event == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(event) & -2);
    }
}

},{"../structs/Event.mjs":"g2Zcr","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"io87u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Top-level config which holds ChannelHandshakeLimits and ChannelConfig.
 *
 * Default::default() provides sane defaults for most configurations
 * (but currently with 0 relay fees!)
 */ parcelHelpers.export(exports, "UserConfig", ()=>UserConfig
) //# sourceMappingURL=UserConfig.mjs.map
;
var _channelConfigMjs = require("../structs/ChannelConfig.mjs");
var _channelHandshakeConfigMjs = require("../structs/ChannelHandshakeConfig.mjs");
var _channelHandshakeLimitsMjs = require("../structs/ChannelHandshakeLimits.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class UserConfig extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.UserConfig_free);
    }
    /**
     * Channel config that we propose to our counterparty.
     */ get_own_channel_config() {
        const ret = _bindingsMjs.UserConfig_get_own_channel_config(this.ptr);
        const ret_hu_conv = new _channelHandshakeConfigMjs.ChannelHandshakeConfig(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Channel config that we propose to our counterparty.
     */ set_own_channel_config(val) {
        _bindingsMjs.UserConfig_set_own_channel_config(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Limits applied to our counterparty's proposed channel config settings.
     */ get_peer_channel_config_limits() {
        const ret = _bindingsMjs.UserConfig_get_peer_channel_config_limits(this.ptr);
        const ret_hu_conv = new _channelHandshakeLimitsMjs.ChannelHandshakeLimits(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Limits applied to our counterparty's proposed channel config settings.
     */ set_peer_channel_config_limits(val) {
        _bindingsMjs.UserConfig_set_peer_channel_config_limits(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Channel config which affects behavior during channel lifetime.
     */ get_channel_options() {
        const ret = _bindingsMjs.UserConfig_get_channel_options(this.ptr);
        const ret_hu_conv = new _channelConfigMjs.ChannelConfig(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Channel config which affects behavior during channel lifetime.
     */ set_channel_options(val) {
        _bindingsMjs.UserConfig_set_channel_options(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * If this is set to false, we will reject any HTLCs which were to be forwarded over private
     * channels. This prevents us from taking on HTLC-forwarding risk when we intend to run as a
     * node which is not online reliably.
     *
     * For nodes which are not online reliably, you should set all channels to *not* be announced
     * (using [`ChannelConfig::announced_channel`] and
     * [`ChannelHandshakeLimits::force_announced_channel_preference`]) and set this to false to
     * ensure you are not exposed to any forwarding risk.
     *
     * Note that because you cannot change a channel's announced state after creation, there is no
     * way to disable forwarding on public channels retroactively. Thus, in order to change a node
     * from a publicly-announced forwarding node to a private non-forwarding node you must close
     * all your channels and open new ones. For privacy, you should also change your node_id
     * (swapping all private and public key material for new ones) at that time.
     *
     * Default value: false.
     */ get_accept_forwards_to_priv_channels() {
        const ret = _bindingsMjs.UserConfig_get_accept_forwards_to_priv_channels(this.ptr);
        return ret;
    }
    /**
     * If this is set to false, we will reject any HTLCs which were to be forwarded over private
     * channels. This prevents us from taking on HTLC-forwarding risk when we intend to run as a
     * node which is not online reliably.
     *
     * For nodes which are not online reliably, you should set all channels to *not* be announced
     * (using [`ChannelConfig::announced_channel`] and
     * [`ChannelHandshakeLimits::force_announced_channel_preference`]) and set this to false to
     * ensure you are not exposed to any forwarding risk.
     *
     * Note that because you cannot change a channel's announced state after creation, there is no
     * way to disable forwarding on public channels retroactively. Thus, in order to change a node
     * from a publicly-announced forwarding node to a private non-forwarding node you must close
     * all your channels and open new ones. For privacy, you should also change your node_id
     * (swapping all private and public key material for new ones) at that time.
     *
     * Default value: false.
     */ set_accept_forwards_to_priv_channels(val) {
        _bindingsMjs.UserConfig_set_accept_forwards_to_priv_channels(this.ptr, val);
    }
    /**
     * If this is set to false, we do not accept inbound requests to open a new channel.
     * Default value: true.
     */ get_accept_inbound_channels() {
        const ret = _bindingsMjs.UserConfig_get_accept_inbound_channels(this.ptr);
        return ret;
    }
    /**
     * If this is set to false, we do not accept inbound requests to open a new channel.
     * Default value: true.
     */ set_accept_inbound_channels(val) {
        _bindingsMjs.UserConfig_set_accept_inbound_channels(this.ptr, val);
    }
    /**
     * Constructs a new UserConfig given each field
     */ static constructor_new(own_channel_config_arg, peer_channel_config_limits_arg, channel_options_arg, accept_forwards_to_priv_channels_arg, accept_inbound_channels_arg) {
        const ret = _bindingsMjs.UserConfig_new(own_channel_config_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(own_channel_config_arg) & -2, peer_channel_config_limits_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(peer_channel_config_limits_arg) & -2, channel_options_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(channel_options_arg) & -2, accept_forwards_to_priv_channels_arg, accept_inbound_channels_arg);
        const ret_hu_conv = new UserConfig(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.UserConfig_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the UserConfig
     */ clone() {
        const ret = _bindingsMjs.UserConfig_clone(this.ptr);
        const ret_hu_conv = new UserConfig(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a "default" UserConfig. See struct and individual field documentaiton for details on which values are used.
     */ static constructor_default() {
        const ret = _bindingsMjs.UserConfig_default();
        const ret_hu_conv = new UserConfig(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"../structs/ChannelConfig.mjs":"VmnNM","../structs/ChannelHandshakeConfig.mjs":"dYMV3","../structs/ChannelHandshakeLimits.mjs":"lB06s","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dYMV3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Configuration we set when applicable.
 *
 * Default::default() provides sane defaults.
 */ parcelHelpers.export(exports, "ChannelHandshakeConfig", ()=>ChannelHandshakeConfig
) //# sourceMappingURL=ChannelHandshakeConfig.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelHandshakeConfig extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelHandshakeConfig_free);
    }
    /**
     * Confirmations we will wait for before considering the channel locked in.
     * Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the
     * equivalent limit applied to outbound channels).
     *
     * Default value: 6.
     */ get_minimum_depth() {
        const ret = _bindingsMjs.ChannelHandshakeConfig_get_minimum_depth(this.ptr);
        return ret;
    }
    /**
     * Confirmations we will wait for before considering the channel locked in.
     * Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the
     * equivalent limit applied to outbound channels).
     *
     * Default value: 6.
     */ set_minimum_depth(val) {
        _bindingsMjs.ChannelHandshakeConfig_set_minimum_depth(this.ptr, val);
    }
    /**
     * Set to the number of blocks we require our counterparty to wait to claim their money (ie
     * the number of blocks we have to punish our counterparty if they broadcast a revoked
     * transaction).
     *
     * This is one of the main parameters of our security model. We (or one of our watchtowers) MUST
     * be online to check for revoked transactions on-chain at least once every our_to_self_delay
     * blocks (minus some margin to allow us enough time to broadcast and confirm a transaction,
     * possibly with time in between to RBF the spending transaction).
     *
     * Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in
     * case of an honest unilateral channel close, which implicitly decrease the economic value of
     * our channel.
     *
     * Default value: [`BREAKDOWN_TIMEOUT`], we enforce it as a minimum at channel opening so you
     * can tweak config to ask for more security, not less.
     */ get_our_to_self_delay() {
        const ret = _bindingsMjs.ChannelHandshakeConfig_get_our_to_self_delay(this.ptr);
        return ret;
    }
    /**
     * Set to the number of blocks we require our counterparty to wait to claim their money (ie
     * the number of blocks we have to punish our counterparty if they broadcast a revoked
     * transaction).
     *
     * This is one of the main parameters of our security model. We (or one of our watchtowers) MUST
     * be online to check for revoked transactions on-chain at least once every our_to_self_delay
     * blocks (minus some margin to allow us enough time to broadcast and confirm a transaction,
     * possibly with time in between to RBF the spending transaction).
     *
     * Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in
     * case of an honest unilateral channel close, which implicitly decrease the economic value of
     * our channel.
     *
     * Default value: [`BREAKDOWN_TIMEOUT`], we enforce it as a minimum at channel opening so you
     * can tweak config to ask for more security, not less.
     */ set_our_to_self_delay(val) {
        _bindingsMjs.ChannelHandshakeConfig_set_our_to_self_delay(this.ptr, val);
    }
    /**
     * Set to the smallest value HTLC we will accept to process.
     *
     * This value is sent to our counterparty on channel-open and we close the channel any time
     * our counterparty misbehaves by sending us an HTLC with a value smaller than this.
     *
     * Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required
     * by the protocol.
     */ get_our_htlc_minimum_msat() {
        const ret = _bindingsMjs.ChannelHandshakeConfig_get_our_htlc_minimum_msat(this.ptr);
        return ret;
    }
    /**
     * Set to the smallest value HTLC we will accept to process.
     *
     * This value is sent to our counterparty on channel-open and we close the channel any time
     * our counterparty misbehaves by sending us an HTLC with a value smaller than this.
     *
     * Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required
     * by the protocol.
     */ set_our_htlc_minimum_msat(val) {
        _bindingsMjs.ChannelHandshakeConfig_set_our_htlc_minimum_msat(this.ptr, val);
    }
    /**
     * Constructs a new ChannelHandshakeConfig given each field
     */ static constructor_new(minimum_depth_arg, our_to_self_delay_arg, our_htlc_minimum_msat_arg) {
        const ret = _bindingsMjs.ChannelHandshakeConfig_new(minimum_depth_arg, our_to_self_delay_arg, our_htlc_minimum_msat_arg);
        const ret_hu_conv = new ChannelHandshakeConfig(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ChannelHandshakeConfig_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelHandshakeConfig
     */ clone() {
        const ret = _bindingsMjs.ChannelHandshakeConfig_clone(this.ptr);
        const ret_hu_conv = new ChannelHandshakeConfig(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a "default" ChannelHandshakeConfig. See struct and individual field documentaiton for details on which values are used.
     */ static constructor_default() {
        const ret = _bindingsMjs.ChannelHandshakeConfig_default();
        const ret_hu_conv = new ChannelHandshakeConfig(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lB06s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Optional channel limits which are applied during channel creation.
 *
 * These limits are only applied to our counterparty's limits, not our own.
 *
 * Use 0/<type>::max_value() as appropriate to skip checking.
 *
 * Provides sane defaults for most configurations.
 *
 * Most additional limits are disabled except those with which specify a default in individual
 * field documentation. Note that this may result in barely-usable channels, but since they
 * are applied mostly only to incoming channels that's not much of a problem.
 */ parcelHelpers.export(exports, "ChannelHandshakeLimits", ()=>ChannelHandshakeLimits
) //# sourceMappingURL=ChannelHandshakeLimits.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelHandshakeLimits extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelHandshakeLimits_free);
    }
    /**
     * Minimum allowed satoshis when a channel is funded, this is supplied by the sender and so
     * only applies to inbound channels.
     *
     * Default value: 0.
     */ get_min_funding_satoshis() {
        const ret = _bindingsMjs.ChannelHandshakeLimits_get_min_funding_satoshis(this.ptr);
        return ret;
    }
    /**
     * Minimum allowed satoshis when a channel is funded, this is supplied by the sender and so
     * only applies to inbound channels.
     *
     * Default value: 0.
     */ set_min_funding_satoshis(val) {
        _bindingsMjs.ChannelHandshakeLimits_set_min_funding_satoshis(this.ptr, val);
    }
    /**
     * The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows
     * you to limit the maximum minimum-size they can require.
     *
     * Default value: u64::max_value.
     */ get_max_htlc_minimum_msat() {
        const ret = _bindingsMjs.ChannelHandshakeLimits_get_max_htlc_minimum_msat(this.ptr);
        return ret;
    }
    /**
     * The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows
     * you to limit the maximum minimum-size they can require.
     *
     * Default value: u64::max_value.
     */ set_max_htlc_minimum_msat(val) {
        _bindingsMjs.ChannelHandshakeLimits_set_max_htlc_minimum_msat(this.ptr, val);
    }
    /**
     * The remote node sets a limit on the maximum value of pending HTLCs to them at any given
     * time to limit their funds exposure to HTLCs. This allows you to set a minimum such value.
     *
     * Default value: 0.
     */ get_min_max_htlc_value_in_flight_msat() {
        const ret = _bindingsMjs.ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(this.ptr);
        return ret;
    }
    /**
     * The remote node sets a limit on the maximum value of pending HTLCs to them at any given
     * time to limit their funds exposure to HTLCs. This allows you to set a minimum such value.
     *
     * Default value: 0.
     */ set_min_max_htlc_value_in_flight_msat(val) {
        _bindingsMjs.ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(this.ptr, val);
    }
    /**
     * The remote node will require we keep a certain amount in direct payment to ourselves at all
     * time, ensuring that we are able to be punished if we broadcast an old state. This allows to
     * you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs).
     *
     * Default value: u64::max_value.
     */ get_max_channel_reserve_satoshis() {
        const ret = _bindingsMjs.ChannelHandshakeLimits_get_max_channel_reserve_satoshis(this.ptr);
        return ret;
    }
    /**
     * The remote node will require we keep a certain amount in direct payment to ourselves at all
     * time, ensuring that we are able to be punished if we broadcast an old state. This allows to
     * you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs).
     *
     * Default value: u64::max_value.
     */ set_max_channel_reserve_satoshis(val) {
        _bindingsMjs.ChannelHandshakeLimits_set_max_channel_reserve_satoshis(this.ptr, val);
    }
    /**
     * The remote node sets a limit on the maximum number of pending HTLCs to them at any given
     * time. This allows you to set a minimum such value.
     *
     * Default value: 0.
     */ get_min_max_accepted_htlcs() {
        const ret = _bindingsMjs.ChannelHandshakeLimits_get_min_max_accepted_htlcs(this.ptr);
        return ret;
    }
    /**
     * The remote node sets a limit on the maximum number of pending HTLCs to them at any given
     * time. This allows you to set a minimum such value.
     *
     * Default value: 0.
     */ set_min_max_accepted_htlcs(val) {
        _bindingsMjs.ChannelHandshakeLimits_set_min_max_accepted_htlcs(this.ptr, val);
    }
    /**
     * Before a channel is usable the funding transaction will need to be confirmed by at least a
     * certain number of blocks, specified by the node which is not the funder (as the funder can
     * assume they aren't going to double-spend themselves).
     * This config allows you to set a limit on the maximum amount of time to wait.
     *
     * Default value: 144, or roughly one day and only applies to outbound channels.
     */ get_max_minimum_depth() {
        const ret = _bindingsMjs.ChannelHandshakeLimits_get_max_minimum_depth(this.ptr);
        return ret;
    }
    /**
     * Before a channel is usable the funding transaction will need to be confirmed by at least a
     * certain number of blocks, specified by the node which is not the funder (as the funder can
     * assume they aren't going to double-spend themselves).
     * This config allows you to set a limit on the maximum amount of time to wait.
     *
     * Default value: 144, or roughly one day and only applies to outbound channels.
     */ set_max_minimum_depth(val) {
        _bindingsMjs.ChannelHandshakeLimits_set_max_minimum_depth(this.ptr, val);
    }
    /**
     * Set to force an incoming channel to match our announced channel preference in
     * [`ChannelConfig::announced_channel`].
     *
     * For a node which is not online reliably, this should be set to true and
     * [`ChannelConfig::announced_channel`] set to false, ensuring that no announced (aka public)
     * channels will ever be opened.
     *
     * Default value: true.
     */ get_force_announced_channel_preference() {
        const ret = _bindingsMjs.ChannelHandshakeLimits_get_force_announced_channel_preference(this.ptr);
        return ret;
    }
    /**
     * Set to force an incoming channel to match our announced channel preference in
     * [`ChannelConfig::announced_channel`].
     *
     * For a node which is not online reliably, this should be set to true and
     * [`ChannelConfig::announced_channel`] set to false, ensuring that no announced (aka public)
     * channels will ever be opened.
     *
     * Default value: true.
     */ set_force_announced_channel_preference(val) {
        _bindingsMjs.ChannelHandshakeLimits_set_force_announced_channel_preference(this.ptr, val);
    }
    /**
     * Set to the amount of time we're willing to wait to claim money back to us.
     *
     * Not checking this value would be a security issue, as our peer would be able to set it to
     * max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time.
     *
     * Default value: 2016, which we also enforce as a maximum value so you can tweak config to
     * reduce the loss of having useless locked funds (if your peer accepts)
     */ get_their_to_self_delay() {
        const ret = _bindingsMjs.ChannelHandshakeLimits_get_their_to_self_delay(this.ptr);
        return ret;
    }
    /**
     * Set to the amount of time we're willing to wait to claim money back to us.
     *
     * Not checking this value would be a security issue, as our peer would be able to set it to
     * max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time.
     *
     * Default value: 2016, which we also enforce as a maximum value so you can tweak config to
     * reduce the loss of having useless locked funds (if your peer accepts)
     */ set_their_to_self_delay(val) {
        _bindingsMjs.ChannelHandshakeLimits_set_their_to_self_delay(this.ptr, val);
    }
    /**
     * Constructs a new ChannelHandshakeLimits given each field
     */ static constructor_new(min_funding_satoshis_arg, max_htlc_minimum_msat_arg, min_max_htlc_value_in_flight_msat_arg, max_channel_reserve_satoshis_arg, min_max_accepted_htlcs_arg, max_minimum_depth_arg, force_announced_channel_preference_arg, their_to_self_delay_arg) {
        const ret = _bindingsMjs.ChannelHandshakeLimits_new(min_funding_satoshis_arg, max_htlc_minimum_msat_arg, min_max_htlc_value_in_flight_msat_arg, max_channel_reserve_satoshis_arg, min_max_accepted_htlcs_arg, max_minimum_depth_arg, force_announced_channel_preference_arg, their_to_self_delay_arg);
        const ret_hu_conv = new ChannelHandshakeLimits(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ChannelHandshakeLimits_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelHandshakeLimits
     */ clone() {
        const ret = _bindingsMjs.ChannelHandshakeLimits_clone(this.ptr);
        const ret_hu_conv = new ChannelHandshakeLimits(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a "default" ChannelHandshakeLimits. See struct and individual field documentaiton for details on which values are used.
     */ static constructor_default() {
        const ret = _bindingsMjs.ChannelHandshakeLimits_default();
        const ret_hu_conv = new ChannelHandshakeLimits(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7mGRx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The `Listen` trait is used to notify when blocks have been connected or disconnected from the
 * chain.
 *
 * Useful when needing to replay chain data upon startup or as new chain events occur. Clients
 * sourcing chain data using a block-oriented API should prefer this interface over [`Confirm`].
 * Such clients fetch the entire header chain whereas clients using [`Confirm`] only fetch headers
 * when needed.
 */ parcelHelpers.export(exports, "Listen", ()=>Listen
) //# sourceMappingURL=Listen.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKListenHolder {
}
class Listen extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Listen_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of Listen from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKListenHolder();
        let structImplementation = {
            block_connected (block, height) {
                const block_conv = _bindingsMjs.decodeUint8Array(block);
                arg.block_connected(block_conv, height);
            },
            block_disconnected (header, height) {
                const header_conv = _bindingsMjs.decodeUint8Array(header);
                arg.block_disconnected(header_conv, height);
            }
        };
        const ptr = _bindingsMjs.LDKListen_new(structImplementation);
        impl_holder.held = new Listen(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Notifies the listener that a block was added at the given height.
     */ block_connected(block, height) {
        _bindingsMjs.Listen_block_connected(this.ptr, _bindingsMjs.encodeUint8Array(block), height);
    }
    /**
     * Notifies the listener that a block was removed at the given height.
     */ block_disconnected(header, height) {
        _bindingsMjs.Listen_block_disconnected(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(header, 80)), height);
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gHOTY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The `Confirm` trait is used to notify when transactions have been confirmed on chain or
 * unconfirmed during a chain reorganization.
 *
 * Clients sourcing chain data using a transaction-oriented API should prefer this interface over
 * [`Listen`]. For instance, an Electrum client may implement [`Filter`] by subscribing to activity
 * related to registered transactions and outputs. Upon notification, it would pass along the
 * matching transactions using this interface.
 *
 * # Use
 *
 * The intended use is as follows:
 * - Call [`transactions_confirmed`] to process any on-chain activity of interest.
 * - Call [`transaction_unconfirmed`] to process any transaction returned by [`get_relevant_txids`]
 * that has been reorganized out of the chain.
 * - Call [`best_block_updated`] whenever a new chain tip becomes available.
 *
 * # Order
 *
 * Clients must call these methods in chain order. Specifically:
 * - Transactions confirmed in a block must be given before transactions confirmed in a later
 * block.
 * - Dependent transactions within the same block must be given in topological order, possibly in
 * separate calls.
 * - Unconfirmed transactions must be given after the original confirmations and before any
 * reconfirmation.
 *
 * See individual method documentation for further details.
 *
 * [`transactions_confirmed`]: Self::transactions_confirmed
 * [`transaction_unconfirmed`]: Self::transaction_unconfirmed
 * [`best_block_updated`]: Self::best_block_updated
 * [`get_relevant_txids`]: Self::get_relevant_txids
 */ parcelHelpers.export(exports, "Confirm", ()=>Confirm
) //# sourceMappingURL=Confirm.mjs.map
;
var _twoTupleUsizeTransactionZMjs = require("../structs/TwoTuple_usizeTransactionZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKConfirmHolder {
}
class Confirm extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Confirm_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of Confirm from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKConfirmHolder();
        let structImplementation = {
            transactions_confirmed (header, txdata, height) {
                const header_conv = _bindingsMjs.decodeUint8Array(header);
                const txdata_conv_28_len = _bindingsMjs.getArrayLength(txdata);
                const txdata_conv_28_arr = new Array(txdata_conv_28_len).fill(null);
                for(var c = 0; c < txdata_conv_28_len; c++){
                    const txdata_conv_28 = _bindingsMjs.getU32ArrayElem(txdata, c);
                    const txdata_conv_28_hu_conv = new _twoTupleUsizeTransactionZMjs.TwoTuple_usizeTransactionZ(null, txdata_conv_28);
                    _commonBaseMjsDefault.default.add_ref_from(txdata_conv_28_hu_conv, this);
                    txdata_conv_28_arr[c] = txdata_conv_28_hu_conv;
                }
                _bindingsMjs.freeWasmMemory(txdata);
                arg.transactions_confirmed(header_conv, txdata_conv_28_arr, height);
            },
            transaction_unconfirmed (txid) {
                const txid_conv = _bindingsMjs.decodeUint8Array(txid);
                arg.transaction_unconfirmed(txid_conv);
            },
            best_block_updated (header, height) {
                const header_conv = _bindingsMjs.decodeUint8Array(header);
                arg.best_block_updated(header_conv, height);
            },
            get_relevant_txids () {
                const ret = arg.get_relevant_txids();
                const result = _bindingsMjs.encodeUint32Array(ret != null ? ret.map((ret_conv_12)=>_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(ret_conv_12, 32))
                ) : null);
                return result;
            }
        };
        const ptr = _bindingsMjs.LDKConfirm_new(structImplementation);
        impl_holder.held = new Confirm(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Processes transactions confirmed in a block with a given header and height.
     *
     * Should be called for any transactions registered by [`Filter::register_tx`] or any
     * transactions spending an output registered by [`Filter::register_output`]. Such transactions
     * appearing in the same block do not need to be included in the same call; instead, multiple
     * calls with additional transactions may be made so long as they are made in [chain order].
     *
     * May be called before or after [`best_block_updated`] for the corresponding block. However,
     * in the event of a chain reorganization, it must not be called with a `header` that is no
     * longer in the chain as of the last call to [`best_block_updated`].
     *
     * [chain order]: Confirm#Order
     * [`best_block_updated`]: Self::best_block_updated
     */ transactions_confirmed(header, txdata, height) {
        _bindingsMjs.Confirm_transactions_confirmed(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(header, 80)), _bindingsMjs.encodeUint32Array(txdata != null ? txdata.map((txdata_conv_28)=>txdata_conv_28 != null ? _commonBaseMjsDefault.default.get_ptr_of(txdata_conv_28) : 0
        ) : null), height);
    }
    /**
     * Processes a transaction that is no longer confirmed as result of a chain reorganization.
     *
     * Should be called for any transaction returned by [`get_relevant_txids`] if it has been
     * reorganized out of the best chain. Once called, the given transaction should not be returned
     * by [`get_relevant_txids`] unless it has been reconfirmed via [`transactions_confirmed`].
     *
     * [`get_relevant_txids`]: Self::get_relevant_txids
     * [`transactions_confirmed`]: Self::transactions_confirmed
     */ transaction_unconfirmed(txid) {
        _bindingsMjs.Confirm_transaction_unconfirmed(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(txid, 32)));
    }
    /**
     * Processes an update to the best header connected at the given height.
     *
     * Should be called when a new header is available but may be skipped for intermediary blocks
     * if they become available at the same time.
     */ best_block_updated(header, height) {
        _bindingsMjs.Confirm_best_block_updated(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(header, 80)), height);
    }
    /**
     * Returns transactions that should be monitored for reorganization out of the chain.
     *
     * Should include any transactions passed to [`transactions_confirmed`] that have insufficient
     * confirmations to be safe from a chain reorganization. Should not include any transactions
     * passed to [`transaction_unconfirmed`] unless later reconfirmed.
     *
     * May be called to determine the subset of transactions that must still be monitored for
     * reorganization. Will be idempotent between calls but may change as a result of calls to the
     * other interface methods. Thus, this is useful to determine which transactions may need to be
     * given to [`transaction_unconfirmed`].
     *
     * [`transactions_confirmed`]: Self::transactions_confirmed
     * [`transaction_unconfirmed`]: Self::transaction_unconfirmed
     */ get_relevant_txids() {
        const ret = _bindingsMjs.Confirm_get_relevant_txids(this.ptr);
        const ret_conv_12_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_12_arr = new Array(ret_conv_12_len).fill(null);
        for(var m = 0; m < ret_conv_12_len; m++){
            const ret_conv_12 = _bindingsMjs.getU32ArrayElem(ret, m);
            const ret_conv_12_conv = _bindingsMjs.decodeUint8Array(ret_conv_12);
            ret_conv_12_arr[m] = ret_conv_12_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_12_arr;
    }
}

},{"../structs/TwoTuple_usizeTransactionZ.mjs":"k0qa9","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dr4Tk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A trait to describe an object which can receive channel messages.
 *
 * Messages MAY be called in parallel when they originate from different their_node_ids, however
 * they MUST NOT be called in parallel when the two calls have the same their_node_id.
 */ parcelHelpers.export(exports, "ChannelMessageHandler", ()=>ChannelMessageHandler
) //# sourceMappingURL=ChannelMessageHandler.mjs.map
;
var _channelUpdateMjs = require("../structs/ChannelUpdate.mjs");
var _acceptChannelMjs = require("../structs/AcceptChannel.mjs");
var _openChannelMjs = require("../structs/OpenChannel.mjs");
var _fundingCreatedMjs = require("../structs/FundingCreated.mjs");
var _fundingSignedMjs = require("../structs/FundingSigned.mjs");
var _fundingLockedMjs = require("../structs/FundingLocked.mjs");
var _announcementSignaturesMjs = require("../structs/AnnouncementSignatures.mjs");
var _revokeAndACKMjs = require("../structs/RevokeAndACK.mjs");
var _closingSignedMjs = require("../structs/ClosingSigned.mjs");
var _shutdownMjs = require("../structs/Shutdown.mjs");
var _channelReestablishMjs = require("../structs/ChannelReestablish.mjs");
var _errorMessageMjs = require("../structs/ErrorMessage.mjs");
var _initFeaturesMjs = require("../structs/InitFeatures.mjs");
var _updateAddHTLCMjs = require("../structs/UpdateAddHTLC.mjs");
var _updateFulfillHTLCMjs = require("../structs/UpdateFulfillHTLC.mjs");
var _updateFailHTLCMjs = require("../structs/UpdateFailHTLC.mjs");
var _updateFailMalformedHTLCMjs = require("../structs/UpdateFailMalformedHTLC.mjs");
var _commitmentSignedMjs = require("../structs/CommitmentSigned.mjs");
var _initMjs = require("../structs/Init.mjs");
var _updateFeeMjs = require("../structs/UpdateFee.mjs");
var _messageSendEventsProviderMjs = require("../structs/MessageSendEventsProvider.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKChannelMessageHandlerHolder {
}
class ChannelMessageHandler extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelMessageHandler_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of ChannelMessageHandler from a given implementation */ static new_impl(arg, messageSendEventsProvider_impl) {
        const impl_holder = new LDKChannelMessageHandlerHolder();
        let structImplementation = {
            handle_open_channel (their_node_id, their_features, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const their_features_hu_conv = new _initFeaturesMjs.InitFeatures(null, their_features);
                _commonBaseMjsDefault.default.add_ref_from(their_features_hu_conv, this);
                const msg_hu_conv = new _openChannelMjs.OpenChannel(null, msg);
                arg.handle_open_channel(their_node_id_conv, their_features_hu_conv, msg_hu_conv);
            },
            handle_accept_channel (their_node_id, their_features, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const their_features_hu_conv = new _initFeaturesMjs.InitFeatures(null, their_features);
                _commonBaseMjsDefault.default.add_ref_from(their_features_hu_conv, this);
                const msg_hu_conv = new _acceptChannelMjs.AcceptChannel(null, msg);
                arg.handle_accept_channel(their_node_id_conv, their_features_hu_conv, msg_hu_conv);
            },
            handle_funding_created (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _fundingCreatedMjs.FundingCreated(null, msg);
                arg.handle_funding_created(their_node_id_conv, msg_hu_conv);
            },
            handle_funding_signed (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _fundingSignedMjs.FundingSigned(null, msg);
                arg.handle_funding_signed(their_node_id_conv, msg_hu_conv);
            },
            handle_funding_locked (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _fundingLockedMjs.FundingLocked(null, msg);
                arg.handle_funding_locked(their_node_id_conv, msg_hu_conv);
            },
            handle_shutdown (their_node_id, their_features, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const their_features_hu_conv = new _initFeaturesMjs.InitFeatures(null, their_features);
                const msg_hu_conv = new _shutdownMjs.Shutdown(null, msg);
                arg.handle_shutdown(their_node_id_conv, their_features_hu_conv, msg_hu_conv);
            },
            handle_closing_signed (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _closingSignedMjs.ClosingSigned(null, msg);
                arg.handle_closing_signed(their_node_id_conv, msg_hu_conv);
            },
            handle_update_add_htlc (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _updateAddHTLCMjs.UpdateAddHTLC(null, msg);
                arg.handle_update_add_htlc(their_node_id_conv, msg_hu_conv);
            },
            handle_update_fulfill_htlc (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _updateFulfillHTLCMjs.UpdateFulfillHTLC(null, msg);
                arg.handle_update_fulfill_htlc(their_node_id_conv, msg_hu_conv);
            },
            handle_update_fail_htlc (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _updateFailHTLCMjs.UpdateFailHTLC(null, msg);
                arg.handle_update_fail_htlc(their_node_id_conv, msg_hu_conv);
            },
            handle_update_fail_malformed_htlc (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _updateFailMalformedHTLCMjs.UpdateFailMalformedHTLC(null, msg);
                arg.handle_update_fail_malformed_htlc(their_node_id_conv, msg_hu_conv);
            },
            handle_commitment_signed (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _commitmentSignedMjs.CommitmentSigned(null, msg);
                arg.handle_commitment_signed(their_node_id_conv, msg_hu_conv);
            },
            handle_revoke_and_ack (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _revokeAndACKMjs.RevokeAndACK(null, msg);
                arg.handle_revoke_and_ack(their_node_id_conv, msg_hu_conv);
            },
            handle_update_fee (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _updateFeeMjs.UpdateFee(null, msg);
                arg.handle_update_fee(their_node_id_conv, msg_hu_conv);
            },
            handle_announcement_signatures (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _announcementSignaturesMjs.AnnouncementSignatures(null, msg);
                arg.handle_announcement_signatures(their_node_id_conv, msg_hu_conv);
            },
            peer_disconnected (their_node_id, no_connection_possible) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                arg.peer_disconnected(their_node_id_conv, no_connection_possible);
            },
            peer_connected (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _initMjs.Init(null, msg);
                arg.peer_connected(their_node_id_conv, msg_hu_conv);
            },
            handle_channel_reestablish (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _channelReestablishMjs.ChannelReestablish(null, msg);
                arg.handle_channel_reestablish(their_node_id_conv, msg_hu_conv);
            },
            handle_channel_update (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _channelUpdateMjs.ChannelUpdate(null, msg);
                arg.handle_channel_update(their_node_id_conv, msg_hu_conv);
            },
            handle_error (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _errorMessageMjs.ErrorMessage(null, msg);
                arg.handle_error(their_node_id_conv, msg_hu_conv);
            }
        };
        const messageSendEventsProvider = _messageSendEventsProviderMjs.MessageSendEventsProvider.new_impl(messageSendEventsProvider_impl);
        const ptr = _bindingsMjs.LDKChannelMessageHandler_new(structImplementation, messageSendEventsProvider.bindings_instance);
        impl_holder.held = new ChannelMessageHandler(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        impl_holder.held.ptrs_to.push(messageSendEventsProvider);
        return impl_holder.held;
    }
    /**
     * Handle an incoming open_channel message from the given peer.
     */ handle_open_channel(their_node_id, their_features, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_open_channel(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), their_features == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(their_features) & -2, msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming accept_channel message from the given peer.
     */ handle_accept_channel(their_node_id, their_features, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_accept_channel(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), their_features == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(their_features) & -2, msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming funding_created message from the given peer.
     */ handle_funding_created(their_node_id, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_funding_created(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming funding_signed message from the given peer.
     */ handle_funding_signed(their_node_id, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_funding_signed(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming funding_locked message from the given peer.
     */ handle_funding_locked(their_node_id, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_funding_locked(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming shutdown message from the given peer.
     */ handle_shutdown(their_node_id, their_features, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_shutdown(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), their_features == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(their_features) & -2, msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, their_features);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming closing_signed message from the given peer.
     */ handle_closing_signed(their_node_id, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_closing_signed(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming update_add_htlc message from the given peer.
     */ handle_update_add_htlc(their_node_id, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_update_add_htlc(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming update_fulfill_htlc message from the given peer.
     */ handle_update_fulfill_htlc(their_node_id, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_update_fulfill_htlc(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming update_fail_htlc message from the given peer.
     */ handle_update_fail_htlc(their_node_id, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_update_fail_htlc(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming update_fail_malformed_htlc message from the given peer.
     */ handle_update_fail_malformed_htlc(their_node_id, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_update_fail_malformed_htlc(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming commitment_signed message from the given peer.
     */ handle_commitment_signed(their_node_id, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_commitment_signed(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming revoke_and_ack message from the given peer.
     */ handle_revoke_and_ack(their_node_id, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_revoke_and_ack(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming update_fee message from the given peer.
     */ handle_update_fee(their_node_id, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_update_fee(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming announcement_signatures message from the given peer.
     */ handle_announcement_signatures(their_node_id, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_announcement_signatures(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Indicates a connection to the peer failed/an existing connection was lost. If no connection
     * is believed to be possible in the future (eg they're sending us messages we don't
     * understand or indicate they require unknown feature bits), no_connection_possible is set
     * and any outstanding channels should be failed.
     */ peer_disconnected(their_node_id, no_connection_possible) {
        _bindingsMjs.ChannelMessageHandler_peer_disconnected(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), no_connection_possible);
    }
    /**
     * Handle a peer reconnecting, possibly generating channel_reestablish message(s).
     */ peer_connected(their_node_id, msg) {
        _bindingsMjs.ChannelMessageHandler_peer_connected(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming channel_reestablish message from the given peer.
     */ handle_channel_reestablish(their_node_id, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_channel_reestablish(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming channel update from the given peer.
     */ handle_channel_update(their_node_id, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_channel_update(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming error message from the given peer.
     */ handle_error(their_node_id, msg) {
        _bindingsMjs.ChannelMessageHandler_handle_error(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
    }
}

},{"../structs/ChannelUpdate.mjs":"kLaF6","../structs/AcceptChannel.mjs":"7niKR","../structs/OpenChannel.mjs":"36LuB","../structs/FundingCreated.mjs":"5WOqU","../structs/FundingSigned.mjs":"jlNPc","../structs/FundingLocked.mjs":"kN90K","../structs/AnnouncementSignatures.mjs":"lrgLp","../structs/RevokeAndACK.mjs":"hocx7","../structs/ClosingSigned.mjs":"drMrL","../structs/Shutdown.mjs":"3oLVK","../structs/ChannelReestablish.mjs":"1pMS7","../structs/ErrorMessage.mjs":"9WeY0","../structs/InitFeatures.mjs":"iilSK","../structs/UpdateAddHTLC.mjs":"9vrgO","../structs/UpdateFulfillHTLC.mjs":"cr92W","../structs/UpdateFailHTLC.mjs":"4WevC","../structs/UpdateFailMalformedHTLC.mjs":"jLR8a","../structs/CommitmentSigned.mjs":"fowBl","../structs/Init.mjs":"9tT7T","../structs/UpdateFee.mjs":"8XTZ4","../structs/MessageSendEventsProvider.mjs":"U83N1","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3cHhx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Tuple
 */ parcelHelpers.export(exports, "TwoTuple_BlockHashChannelManagerZ", ()=>TwoTuple_BlockHashChannelManagerZ
) //# sourceMappingURL=TwoTuple_BlockHashChannelManagerZ.mjs.map
;
var _channelManagerMjs = require("../structs/ChannelManager.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class TwoTuple_BlockHashChannelManagerZ extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.C2Tuple_BlockHashChannelManagerZ_free);
    }
    /**
     *
     */ get_a() {
        const ret = _bindingsMjs.C2Tuple_BlockHashChannelManagerZ_get_a(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     *
     */ get_b() {
        const ret = _bindingsMjs.C2Tuple_BlockHashChannelManagerZ_get_b(this.ptr);
        const ret_hu_conv = new _channelManagerMjs.ChannelManager(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a new C2Tuple_BlockHashChannelManagerZ from the contained elements.
     */ static constructor_new(a, b_fee_est, b_chain_monitor, b_tx_broadcaster, b_logger, b_keys_manager, b_config, b_params) {
        const ret = _bindingsMjs.C2Tuple_BlockHashChannelManagerZ_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(a, 32)), _bindingsMjs.ChannelManager_new(b_fee_est == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b_fee_est), b_chain_monitor == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b_chain_monitor), b_tx_broadcaster == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b_tx_broadcaster), b_logger == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b_logger), b_keys_manager == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b_keys_manager), b_config == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b_config) & -2, b_params == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b_params) & -2));
        const ret_hu_conv = new TwoTuple_BlockHashChannelManagerZ(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, b_fee_est);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, b_chain_monitor);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, b_tx_broadcaster);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, b_logger);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, b_keys_manager);
        return ret_hu_conv;
    }
}

},{"../structs/ChannelManager.mjs":"7XhoG","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gOv1Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ", ()=>Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ
);
parcelHelpers.export(exports, "Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_OK", ()=>Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_OK
);
parcelHelpers.export(exports, "Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_Err", ()=>Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_Err
) //# sourceMappingURL=Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ.mjs.map
;
var _decodeErrorMjs = require("../structs/DecodeError.mjs");
var _twoTupleBlockHashChannelManagerZMjs = require("../structs/TwoTuple_BlockHashChannelManagerZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ extends _commonBaseMjsDefault.default {
    constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free);
    }
    /* @internal */ static constr_from_ptr(ptr) {
        if (_bindingsMjs.CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok(ptr)) return new Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_OK(null, ptr);
        else return new Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_Err(null, ptr);
    }
    /**
     * Creates a new CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ in the success state.
     */ static constructor_ok(o) {
        const ret = _bindingsMjs.CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(o != null ? _commonBaseMjsDefault.default.get_ptr_of(o) : 0);
        const ret_hu_conv = Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a new CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ in the error state.
     */ static constructor_err(e) {
        const ret = _bindingsMjs.CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(e == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(e) & -2);
        const ret_hu_conv = Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks if the given object is currently in the success state
     */ is_ok() {
        const ret = _bindingsMjs.CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok(this.ptr);
        return ret;
    }
}
class Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_OK extends Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const res = _bindingsMjs.CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_ok(ptr);
        const res_hu_conv = new _twoTupleBlockHashChannelManagerZMjs.TwoTuple_BlockHashChannelManagerZ(null, res);
        _commonBaseMjsDefault.default.add_ref_from(res_hu_conv, this);
        this.res = res_hu_conv;
    }
}
class Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_Err extends Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ {
    /* @internal */ constructor(_dummy, ptr){
        super(_dummy, ptr);
        const err = _bindingsMjs.CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_err(ptr);
        const err_hu_conv = new _decodeErrorMjs.DecodeError(null, err);
        _commonBaseMjsDefault.default.add_ref_from(err_hu_conv, this);
        this.err = err_hu_conv;
    }
}

},{"../structs/DecodeError.mjs":"5KlBi","../structs/TwoTuple_BlockHashChannelManagerZ.mjs":"3cHhx","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"oIO2x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An opaque identifier describing a specific [`Persist`] method call.
 */ parcelHelpers.export(exports, "MonitorUpdateId", ()=>MonitorUpdateId
) //# sourceMappingURL=MonitorUpdateId.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class MonitorUpdateId extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.MonitorUpdateId_free);
    }
    clone_ptr() {
        const ret = _bindingsMjs.MonitorUpdateId_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the MonitorUpdateId
     */ clone() {
        const ret = _bindingsMjs.MonitorUpdateId_clone(this.ptr);
        const ret_hu_conv = new MonitorUpdateId(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Checks if two MonitorUpdateIds contain equal inner contents.
     */ hash() {
        const ret = _bindingsMjs.MonitorUpdateId_hash(this.ptr);
        return ret;
    }
    /**
     * Checks if two MonitorUpdateIds contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */ eq(b) {
        const ret = _bindingsMjs.MonitorUpdateId_eq(this.ptr, b == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(b) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, b);
        return ret;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fLLJT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * `Persist` defines behavior for persisting channel monitors: this could mean
 * writing once to disk, and/or uploading to one or more backup services.
 *
 * Each method can return three possible values:
 * If persistence (including any relevant `fsync()` calls) happens immediately, the
 * implementation should return `Ok(())`, indicating normal channel operation should continue.
 * If persistence happens asynchronously, implementations should first ensure the
 * [`ChannelMonitor`] or [`ChannelMonitorUpdate`] are written durably to disk, and then return
 * `Err(ChannelMonitorUpdateErr::TemporaryFailure)` while the update continues in the
 * background. Once the update completes, [`ChainMonitor::channel_monitor_updated`] should be
 * called with the corresponding [`MonitorUpdateId`].
 *
 * Note that unlike the direct [`chain::Watch`] interface,
 * [`ChainMonitor::channel_monitor_updated`] must be called once for *each* update which occurs.
 *
 * If persistence fails for some reason, implementations should return
 * `Err(ChannelMonitorUpdateErr::PermanentFailure)`, in which case the channel will likely be
 * closed without broadcasting the latest state. See
 * [`ChannelMonitorUpdateErr::PermanentFailure`] for more details.
 */ parcelHelpers.export(exports, "Persist", ()=>Persist
) //# sourceMappingURL=Persist.mjs.map
;
var _outPointMjs = require("../structs/OutPoint.mjs");
var _channelMonitorUpdateMjs = require("../structs/ChannelMonitorUpdate.mjs");
var _channelMonitorMjs = require("../structs/ChannelMonitor.mjs");
var _resultNoneChannelMonitorUpdateErrZMjs = require("../structs/Result_NoneChannelMonitorUpdateErrZ.mjs");
var _monitorUpdateIdMjs = require("../structs/MonitorUpdateId.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKPersistHolder {
}
class Persist extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Persist_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of Persist from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKPersistHolder();
        let structImplementation = {
            persist_new_channel (channel_id, data, update_id) {
                const channel_id_hu_conv = new _outPointMjs.OutPoint(null, channel_id);
                _commonBaseMjsDefault.default.add_ref_from(channel_id_hu_conv, this);
                const data_hu_conv = new _channelMonitorMjs.ChannelMonitor(null, data);
                const update_id_hu_conv = new _monitorUpdateIdMjs.MonitorUpdateId(null, update_id);
                _commonBaseMjsDefault.default.add_ref_from(update_id_hu_conv, this);
                const ret = arg.persist_new_channel(channel_id_hu_conv, data_hu_conv, update_id_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            update_persisted_channel (channel_id, update, data, update_id) {
                const channel_id_hu_conv = new _outPointMjs.OutPoint(null, channel_id);
                _commonBaseMjsDefault.default.add_ref_from(channel_id_hu_conv, this);
                const update_hu_conv = new _channelMonitorUpdateMjs.ChannelMonitorUpdate(null, update);
                const data_hu_conv = new _channelMonitorMjs.ChannelMonitor(null, data);
                const update_id_hu_conv = new _monitorUpdateIdMjs.MonitorUpdateId(null, update_id);
                _commonBaseMjsDefault.default.add_ref_from(update_id_hu_conv, this);
                const ret = arg.update_persisted_channel(channel_id_hu_conv, update_hu_conv, data_hu_conv, update_id_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            }
        };
        const ptr = _bindingsMjs.LDKPersist_new(structImplementation);
        impl_holder.held = new Persist(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Persist a new channel's data in response to a [`chain::Watch::watch_channel`] call. This is
     * called by [`ChannelManager`] for new channels, or may be called directly, e.g. on startup.
     *
     * The data can be stored any way you want, but the identifier provided by LDK is the
     * channel's outpoint (and it is up to you to maintain a correct mapping between the outpoint
     * and the stored channel data). Note that you **must** persist every new monitor to disk.
     *
     * The `update_id` is used to identify this call to [`ChainMonitor::channel_monitor_updated`],
     * if you return [`ChannelMonitorUpdateErr::TemporaryFailure`].
     *
     * See [`Writeable::write`] on [`ChannelMonitor`] for writing out a `ChannelMonitor`
     * and [`ChannelMonitorUpdateErr`] for requirements when returning errors.
     *
     * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
     * [`Writeable::write`]: crate::util::ser::Writeable::write
     */ persist_new_channel(channel_id, data, update_id) {
        const ret = _bindingsMjs.Persist_persist_new_channel(this.ptr, channel_id == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(channel_id) & -2, data == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(data) & -2, update_id == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(update_id) & -2);
        const ret_hu_conv = _resultNoneChannelMonitorUpdateErrZMjs.Result_NoneChannelMonitorUpdateErrZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, data);
        return ret_hu_conv;
    }
    /**
     * Update one channel's data. The provided [`ChannelMonitor`] has already applied the given
     * update.
     *
     * Note that on every update, you **must** persist either the [`ChannelMonitorUpdate`] or the
     * updated monitor itself to disk/backups. See the [`Persist`] trait documentation for more
     * details.
     *
     * During blockchain synchronization operations, this may be called with no
     * [`ChannelMonitorUpdate`], in which case the full [`ChannelMonitor`] needs to be persisted.
     * Note that after the full [`ChannelMonitor`] is persisted any previous
     * [`ChannelMonitorUpdate`]s which were persisted should be discarded - they can no longer be
     * applied to the persisted [`ChannelMonitor`] as they were already applied.
     *
     * If an implementer chooses to persist the updates only, they need to make
     * sure that all the updates are applied to the `ChannelMonitors` *before
     * the set of channel monitors is given to the `ChannelManager`
     * deserialization routine. See [`ChannelMonitor::update_monitor`] for
     * applying a monitor update to a monitor. If full `ChannelMonitors` are
     * persisted, then there is no need to persist individual updates.
     *
     * Note that there could be a performance tradeoff between persisting complete
     * channel monitors on every update vs. persisting only updates and applying
     * them in batches. The size of each monitor grows `O(number of state updates)`
     * whereas updates are small and `O(1)`.
     *
     * The `update_id` is used to identify this call to [`ChainMonitor::channel_monitor_updated`],
     * if you return [`ChannelMonitorUpdateErr::TemporaryFailure`].
     *
     * See [`Writeable::write`] on [`ChannelMonitor`] for writing out a `ChannelMonitor`,
     * [`Writeable::write`] on [`ChannelMonitorUpdate`] for writing out an update, and
     * [`ChannelMonitorUpdateErr`] for requirements when returning errors.
     *
     * [`Writeable::write`]: crate::util::ser::Writeable::write
     *
     * Note that update (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ update_persisted_channel(channel_id, update, data, update_id) {
        const ret = _bindingsMjs.Persist_update_persisted_channel(this.ptr, channel_id == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(channel_id) & -2, update == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(update) & -2, data == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(data) & -2, update_id == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(update_id) & -2);
        const ret_hu_conv = _resultNoneChannelMonitorUpdateErrZMjs.Result_NoneChannelMonitorUpdateErrZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, update);
        _commonBaseMjsDefault.default.add_ref_from(this, data);
        return ret_hu_conv;
    }
}

},{"../structs/OutPoint.mjs":"9FTof","../structs/ChannelMonitorUpdate.mjs":"gEeSd","../structs/ChannelMonitor.mjs":"ebdYy","../structs/Result_NoneChannelMonitorUpdateErrZ.mjs":"icmE6","../structs/MonitorUpdateId.mjs":"oIO2x","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jDiTx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An implementation of [`chain::Watch`] for monitoring channels.
 *
 * Connected and disconnected blocks must be provided to `ChainMonitor` as documented by
 * [`chain::Watch`]. May be used in conjunction with [`ChannelManager`] to monitor channels locally
 * or used independently to monitor channels remotely. See the [module-level documentation] for
 * details.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [module-level documentation]: crate::chain::chainmonitor
 */ parcelHelpers.export(exports, "ChainMonitor", ()=>ChainMonitor
) //# sourceMappingURL=ChainMonitor.mjs.map
;
var _outPointMjs = require("../structs/OutPoint.mjs");
var _balanceMjs = require("../structs/Balance.mjs");
var _resultLockedChannelMonitorNoneZMjs = require("../structs/Result_LockedChannelMonitorNoneZ.mjs");
var _resultNoneAPIErrorZMjs = require("../structs/Result_NoneAPIErrorZ.mjs");
var _watchMjs = require("../structs/Watch.mjs");
var _eventsProviderMjs = require("../structs/EventsProvider.mjs");
var _listenMjs = require("../structs/Listen.mjs");
var _confirmMjs = require("../structs/Confirm.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChainMonitor extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChainMonitor_free);
    }
    /**
     * Creates a new `ChainMonitor` used to watch on-chain activity pertaining to channels.
     *
     * When an optional chain source implementing [`chain::Filter`] is provided, the chain monitor
     * will call back to it indicating transactions and outputs of interest. This allows clients to
     * pre-filter blocks or only fetch blocks matching a compact filter. Otherwise, clients may
     * always need to fetch full blocks absent another means for determining which blocks contain
     * transactions relevant to the watched channels.
     */ static constructor_new(chain_source, broadcaster, logger, feeest, persister) {
        const ret = _bindingsMjs.ChainMonitor_new(_commonBaseMjsDefault.default.get_ptr_of(chain_source), broadcaster == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(broadcaster), logger == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(logger), feeest == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(feeest), persister == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(persister));
        const ret_hu_conv = new ChainMonitor(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, chain_source);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, broadcaster);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, logger);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, feeest);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, persister);
        return ret_hu_conv;
    }
    /**
     * Gets the balances in the contained [`ChannelMonitor`]s which are claimable on-chain or
     * claims which are awaiting confirmation.
     *
     * Includes the balances from each [`ChannelMonitor`] *except* those included in
     * `ignored_channels`, allowing you to filter out balances from channels which are still open
     * (and whose balance should likely be pulled from the [`ChannelDetails`]).
     *
     * See [`ChannelMonitor::get_claimable_balances`] for more details on the exact criteria for
     * inclusion in the return value.
     */ get_claimable_balances(ignored_channels) {
        const ret = _bindingsMjs.ChainMonitor_get_claimable_balances(this.ptr, _bindingsMjs.encodeUint32Array(ignored_channels != null ? ignored_channels.map((ignored_channels_conv_16)=>ignored_channels_conv_16 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(ignored_channels_conv_16) & -2
        ) : null));
        const ret_conv_9_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_9_arr = new Array(ret_conv_9_len).fill(null);
        for(var j = 0; j < ret_conv_9_len; j++){
            const ret_conv_9 = _bindingsMjs.getU32ArrayElem(ret, j);
            const ret_conv_9_hu_conv = _balanceMjs.Balance.constr_from_ptr(ret_conv_9);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_9_hu_conv, this);
            ret_conv_9_arr[j] = ret_conv_9_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_9_arr;
    }
    /**
     * Gets the [`LockedChannelMonitor`] for a given funding outpoint, returning an `Err` if no
     * such [`ChannelMonitor`] is currently being monitored for.
     *
     * Note that the result holds a mutex over our monitor set, and should not be held
     * indefinitely.
     */ get_monitor(funding_txo) {
        const ret = _bindingsMjs.ChainMonitor_get_monitor(this.ptr, funding_txo == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(funding_txo) & -2);
        const ret_hu_conv = _resultLockedChannelMonitorNoneZMjs.Result_LockedChannelMonitorNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Lists the funding outpoint of each [`ChannelMonitor`] being monitored.
     *
     * Note that [`ChannelMonitor`]s are not removed when a channel is closed as they are always
     * monitoring for on-chain state resolutions.
     */ list_monitors() {
        const ret = _bindingsMjs.ChainMonitor_list_monitors(this.ptr);
        const ret_conv_10_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_10_arr = new Array(ret_conv_10_len).fill(null);
        for(var k = 0; k < ret_conv_10_len; k++){
            const ret_conv_10 = _bindingsMjs.getU32ArrayElem(ret, k);
            const ret_conv_10_hu_conv = new _outPointMjs.OutPoint(null, ret_conv_10);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_10_hu_conv, this);
            ret_conv_10_arr[k] = ret_conv_10_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_10_arr;
    }
    /**
     * Indicates the persistence of a [`ChannelMonitor`] has completed after
     * [`ChannelMonitorUpdateErr::TemporaryFailure`] was returned from an update operation.
     *
     * Thus, the anticipated use is, at a high level:
     * 1) This [`ChainMonitor`] calls [`Persist::update_persisted_channel`] which stores the
     * update to disk and begins updating any remote (e.g. watchtower/backup) copies,
     * returning [`ChannelMonitorUpdateErr::TemporaryFailure`],
     * 2) once all remote copies are updated, you call this function with the
     * `completed_update_id` that completed, and once all pending updates have completed the
     * channel will be re-enabled.
     *
     * Returns an [`APIError::APIMisuseError`] if `funding_txo` does not match any currently
     * registered [`ChannelMonitor`]s.
     */ channel_monitor_updated(funding_txo, completed_update_id) {
        const ret = _bindingsMjs.ChainMonitor_channel_monitor_updated(this.ptr, funding_txo == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(funding_txo) & -2, completed_update_id == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(completed_update_id) & -2);
        const ret_hu_conv = _resultNoneAPIErrorZMjs.Result_NoneAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Constructs a new Listen which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
     */ as_Listen() {
        const ret = _bindingsMjs.ChainMonitor_as_Listen(this.ptr);
        const ret_hu_conv = new _listenMjs.Listen(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new Confirm which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned Confirm must be freed before this_arg is
     */ as_Confirm() {
        const ret = _bindingsMjs.ChainMonitor_as_Confirm(this.ptr);
        const ret_hu_conv = new _confirmMjs.Confirm(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new Watch which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned Watch must be freed before this_arg is
     */ as_Watch() {
        const ret = _bindingsMjs.ChainMonitor_as_Watch(this.ptr);
        const ret_hu_conv = new _watchMjs.Watch(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new EventsProvider which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
     */ as_EventsProvider() {
        const ret = _bindingsMjs.ChainMonitor_as_EventsProvider(this.ptr);
        const ret_hu_conv = new _eventsProviderMjs.EventsProvider(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"../structs/OutPoint.mjs":"9FTof","../structs/Balance.mjs":"jbcIa","../structs/Result_LockedChannelMonitorNoneZ.mjs":"gIfQI","../structs/Result_NoneAPIErrorZ.mjs":"56Ohf","../structs/Watch.mjs":"2Clil","../structs/EventsProvider.mjs":"9x0e4","../structs/Listen.mjs":"7mGRx","../structs/Confirm.mjs":"gHOTY","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7PYeI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Simple KeysInterface implementor that takes a 32-byte seed for use as a BIP 32 extended key
 * and derives keys from that.
 *
 * Your node_id is seed/0'
 * ChannelMonitor closes may use seed/1'
 * Cooperative closes may use seed/2'
 * The two close keys may be needed to claim on-chain funds!
 */ parcelHelpers.export(exports, "KeysManager", ()=>KeysManager
) //# sourceMappingURL=KeysManager.mjs.map
;
var _inMemorySignerMjs = require("../structs/InMemorySigner.mjs");
var _resultTransactionNoneZMjs = require("../structs/Result_TransactionNoneZ.mjs");
var _keysInterfaceMjs = require("../structs/KeysInterface.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class KeysManager extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.KeysManager_free);
    }
    /**
     * Constructs a KeysManager from a 32-byte seed. If the seed is in some way biased (eg your
     * CSRNG is busted) this may panic (but more importantly, you will possibly lose funds).
     * starting_time isn't strictly required to actually be a time, but it must absolutely,
     * without a doubt, be unique to this instance. ie if you start multiple times with the same
     * seed, starting_time must be unique to each run. Thus, the easiest way to achieve this is to
     * simply use the current time (with very high precision).
     *
     * The seed MUST be backed up safely prior to use so that the keys can be re-created, however,
     * obviously, starting_time should be unique every time you reload the library - it is only
     * used to generate new ephemeral key data (which will be stored by the individual channel if
     * necessary).
     *
     * Note that the seed is required to recover certain on-chain funds independent of
     * ChannelMonitor data, though a current copy of ChannelMonitor data is also required for any
     * channel, and some on-chain during-closing funds.
     *
     * Note that until the 0.1 release there is no guarantee of backward compatibility between
     * versions. Once the library is more fully supported, the docs will be updated to include a
     * detailed description of the guarantee.
     */ static constructor_new(seed, starting_time_secs, starting_time_nanos) {
        const ret = _bindingsMjs.KeysManager_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(seed, 32)), starting_time_secs, starting_time_nanos);
        const ret_hu_conv = new KeysManager(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Derive an old Sign containing per-channel secrets based on a key derivation parameters.
     *
     * Key derivation parameters are accessible through a per-channel secrets
     * Sign::channel_keys_id and is provided inside DynamicOuputP2WSH in case of
     * onchain output detection for which a corresponding delayed_payment_key must be derived.
     */ derive_channel_keys(channel_value_satoshis, params) {
        const ret = _bindingsMjs.KeysManager_derive_channel_keys(this.ptr, channel_value_satoshis, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(params, 32)));
        const ret_hu_conv = new _inMemorySignerMjs.InMemorySigner(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a Transaction which spends the given descriptors to the given outputs, plus an
     * output to the given change destination (if sufficient change value remains). The
     * transaction will have a feerate, at least, of the given value.
     *
     * Returns `Err(())` if the output value is greater than the input value minus required fee or
     * if a descriptor was duplicated.
     *
     * We do not enforce that outputs meet the dust limit or that any output scripts are standard.
     *
     * May panic if the `SpendableOutputDescriptor`s were not generated by Channels which used
     * this KeysManager or one of the `InMemorySigner` created by this KeysManager.
     */ spend_spendable_outputs(descriptors, outputs, change_destination_script, feerate_sat_per_1000_weight) {
        const ret = _bindingsMjs.KeysManager_spend_spendable_outputs(this.ptr, _bindingsMjs.encodeUint32Array(descriptors != null ? descriptors.map((descriptors_conv_27)=>_commonBaseMjsDefault.default.get_ptr_of(descriptors_conv_27)
        ) : null), _bindingsMjs.encodeUint32Array(outputs != null ? outputs.map((outputs_conv_7)=>_commonBaseMjsDefault.default.get_ptr_of(outputs_conv_7)
        ) : null), _bindingsMjs.encodeUint8Array(change_destination_script), feerate_sat_per_1000_weight);
        const ret_hu_conv = _resultTransactionNoneZMjs.Result_TransactionNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Constructs a new KeysInterface which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned KeysInterface must be freed before this_arg is
     */ as_KeysInterface() {
        const ret = _bindingsMjs.KeysManager_as_KeysInterface(this.ptr);
        const ret_hu_conv = new _keysInterfaceMjs.KeysInterface(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"../structs/InMemorySigner.mjs":"3SgwF","../structs/Result_TransactionNoneZ.mjs":"7rxwz","../structs/KeysInterface.mjs":"2q459","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fBsTy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Chain-related parameters used to construct a new `ChannelManager`.
 *
 * Typically, the block-specific parameters are derived from the best block hash for the network,
 * as a newly constructed `ChannelManager` will not have created any channels yet. These parameters
 * are not needed when deserializing a previously constructed `ChannelManager`.
 */ parcelHelpers.export(exports, "ChainParameters", ()=>ChainParameters
) //# sourceMappingURL=ChainParameters.mjs.map
;
var _bestBlockMjs = require("../structs/BestBlock.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChainParameters extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChainParameters_free);
    }
    /**
     * The network for determining the `chain_hash` in Lightning messages.
     */ get_network() {
        const ret = _bindingsMjs.ChainParameters_get_network(this.ptr);
        return ret;
    }
    /**
     * The network for determining the `chain_hash` in Lightning messages.
     */ set_network(val) {
        _bindingsMjs.ChainParameters_set_network(this.ptr, val);
    }
    /**
     * The hash and height of the latest block successfully connected.
     *
     * Used to track on-chain channel funding outputs and send payments with reliable timelocks.
     */ get_best_block() {
        const ret = _bindingsMjs.ChainParameters_get_best_block(this.ptr);
        const ret_hu_conv = new _bestBlockMjs.BestBlock(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The hash and height of the latest block successfully connected.
     *
     * Used to track on-chain channel funding outputs and send payments with reliable timelocks.
     */ set_best_block(val) {
        _bindingsMjs.ChainParameters_set_best_block(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Constructs a new ChainParameters given each field
     */ static constructor_new(network_arg, best_block_arg) {
        const ret = _bindingsMjs.ChainParameters_new(network_arg, best_block_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(best_block_arg) & -2);
        const ret_hu_conv = new ChainParameters(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.ChainParameters_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChainParameters
     */ clone() {
        const ret = _bindingsMjs.ChainParameters_clone(this.ptr);
        const ret_hu_conv = new ChainParameters(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"../structs/BestBlock.mjs":"1czxO","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1uaUq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Arguments for the creation of a ChannelManager that are not deserialized.
 *
 * At a high-level, the process for deserializing a ChannelManager and resuming normal operation
 * is:
 * 1) Deserialize all stored [`ChannelMonitor`]s.
 * 2) Deserialize the [`ChannelManager`] by filling in this struct and calling:
 * `<(BlockHash, ChannelManager)>::read(reader, args)`
 * This may result in closing some channels if the [`ChannelMonitor`] is newer than the stored
 * [`ChannelManager`] state to ensure no loss of funds. Thus, transactions may be broadcasted.
 * 3) If you are not fetching full blocks, register all relevant [`ChannelMonitor`] outpoints the
 * same way you would handle a [`chain::Filter`] call using
 * [`ChannelMonitor::get_outputs_to_watch`] and [`ChannelMonitor::get_funding_txo`].
 * 4) Reconnect blocks on your [`ChannelMonitor`]s.
 * 5) Disconnect/connect blocks on the [`ChannelManager`].
 * 6) Re-persist the [`ChannelMonitor`]s to ensure the latest state is on disk.
 * Note that if you're using a [`ChainMonitor`] for your [`chain::Watch`] implementation, you
 * will likely accomplish this as a side-effect of calling [`chain::Watch::watch_channel`] in
 * the next step.
 * 7) Move the [`ChannelMonitor`]s into your local [`chain::Watch`]. If you're using a
 * [`ChainMonitor`], this is done by calling [`chain::Watch::watch_channel`].
 *
 * Note that the ordering of #4-7 is not of importance, however all four must occur before you
 * call any other methods on the newly-deserialized [`ChannelManager`].
 *
 * Note that because some channels may be closed during deserialization, it is critical that you
 * always deserialize only the latest version of a ChannelManager and ChannelMonitors available to
 * you. If you deserialize an old ChannelManager (during which force-closure transactions may be
 * broadcast), and then later deserialize a newer version of the same ChannelManager (which will
 * not force-close the same channels but consider them live), you may end up revoking a state for
 * which you've already broadcasted the transaction.
 *
 * [`ChainMonitor`]: crate::chain::chainmonitor::ChainMonitor
 */ parcelHelpers.export(exports, "ChannelManagerReadArgs", ()=>ChannelManagerReadArgs
) //# sourceMappingURL=ChannelManagerReadArgs.mjs.map
;
var _watchMjs = require("../structs/Watch.mjs");
var _broadcasterInterfaceMjs = require("../structs/BroadcasterInterface.mjs");
var _keysInterfaceMjs = require("../structs/KeysInterface.mjs");
var _feeEstimatorMjs = require("../structs/FeeEstimator.mjs");
var _loggerMjs = require("../structs/Logger.mjs");
var _userConfigMjs = require("../structs/UserConfig.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ChannelManagerReadArgs extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ChannelManagerReadArgs_free);
    }
    /**
     * The keys provider which will give us relevant keys. Some keys will be loaded during
     * deserialization and KeysInterface::read_chan_signer will be used to read per-Channel
     * signing data.
     */ get_keys_manager() {
        const ret = _bindingsMjs.ChannelManagerReadArgs_get_keys_manager(this.ptr);
        const ret_hu_conv = new _keysInterfaceMjs.KeysInterface(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The keys provider which will give us relevant keys. Some keys will be loaded during
     * deserialization and KeysInterface::read_chan_signer will be used to read per-Channel
     * signing data.
     */ set_keys_manager(val) {
        _bindingsMjs.ChannelManagerReadArgs_set_keys_manager(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val));
        _commonBaseMjsDefault.default.add_ref_from(this, val);
    }
    /**
     * The fee_estimator for use in the ChannelManager in the future.
     *
     * No calls to the FeeEstimator will be made during deserialization.
     */ get_fee_estimator() {
        const ret = _bindingsMjs.ChannelManagerReadArgs_get_fee_estimator(this.ptr);
        const ret_hu_conv = new _feeEstimatorMjs.FeeEstimator(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The fee_estimator for use in the ChannelManager in the future.
     *
     * No calls to the FeeEstimator will be made during deserialization.
     */ set_fee_estimator(val) {
        _bindingsMjs.ChannelManagerReadArgs_set_fee_estimator(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val));
        _commonBaseMjsDefault.default.add_ref_from(this, val);
    }
    /**
     * The chain::Watch for use in the ChannelManager in the future.
     *
     * No calls to the chain::Watch will be made during deserialization. It is assumed that
     * you have deserialized ChannelMonitors separately and will add them to your
     * chain::Watch after deserializing this ChannelManager.
     */ get_chain_monitor() {
        const ret = _bindingsMjs.ChannelManagerReadArgs_get_chain_monitor(this.ptr);
        const ret_hu_conv = new _watchMjs.Watch(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The chain::Watch for use in the ChannelManager in the future.
     *
     * No calls to the chain::Watch will be made during deserialization. It is assumed that
     * you have deserialized ChannelMonitors separately and will add them to your
     * chain::Watch after deserializing this ChannelManager.
     */ set_chain_monitor(val) {
        _bindingsMjs.ChannelManagerReadArgs_set_chain_monitor(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val));
        _commonBaseMjsDefault.default.add_ref_from(this, val);
    }
    /**
     * The BroadcasterInterface which will be used in the ChannelManager in the future and may be
     * used to broadcast the latest local commitment transactions of channels which must be
     * force-closed during deserialization.
     */ get_tx_broadcaster() {
        const ret = _bindingsMjs.ChannelManagerReadArgs_get_tx_broadcaster(this.ptr);
        const ret_hu_conv = new _broadcasterInterfaceMjs.BroadcasterInterface(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The BroadcasterInterface which will be used in the ChannelManager in the future and may be
     * used to broadcast the latest local commitment transactions of channels which must be
     * force-closed during deserialization.
     */ set_tx_broadcaster(val) {
        _bindingsMjs.ChannelManagerReadArgs_set_tx_broadcaster(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val));
        _commonBaseMjsDefault.default.add_ref_from(this, val);
    }
    /**
     * The Logger for use in the ChannelManager and which may be used to log information during
     * deserialization.
     */ get_logger() {
        const ret = _bindingsMjs.ChannelManagerReadArgs_get_logger(this.ptr);
        const ret_hu_conv = new _loggerMjs.Logger(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The Logger for use in the ChannelManager and which may be used to log information during
     * deserialization.
     */ set_logger(val) {
        _bindingsMjs.ChannelManagerReadArgs_set_logger(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val));
        _commonBaseMjsDefault.default.add_ref_from(this, val);
    }
    /**
     * Default settings used for new channels. Any existing channels will continue to use the
     * runtime settings which were stored when the ChannelManager was serialized.
     */ get_default_config() {
        const ret = _bindingsMjs.ChannelManagerReadArgs_get_default_config(this.ptr);
        const ret_hu_conv = new _userConfigMjs.UserConfig(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Default settings used for new channels. Any existing channels will continue to use the
     * runtime settings which were stored when the ChannelManager was serialized.
     */ set_default_config(val) {
        _bindingsMjs.ChannelManagerReadArgs_set_default_config(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val) & -2);
    }
    /**
     * Simple utility function to create a ChannelManagerReadArgs which creates the monitor
     * HashMap for you. This is primarily useful for C bindings where it is not practical to
     * populate a HashMap directly from C.
     */ static constructor_new(keys_manager, fee_estimator, chain_monitor, tx_broadcaster, logger, default_config, channel_monitors) {
        const ret = _bindingsMjs.ChannelManagerReadArgs_new(keys_manager == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(keys_manager), fee_estimator == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(fee_estimator), chain_monitor == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(chain_monitor), tx_broadcaster == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(tx_broadcaster), logger == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(logger), default_config == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(default_config) & -2, _bindingsMjs.encodeUint32Array(channel_monitors != null ? channel_monitors.map((channel_monitors_conv_16)=>channel_monitors_conv_16 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(channel_monitors_conv_16) & -2
        ) : null));
        const ret_hu_conv = new ChannelManagerReadArgs(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, keys_manager);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, fee_estimator);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, chain_monitor);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, tx_broadcaster);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, logger);
        channel_monitors.forEach((channel_monitors_conv_16)=>{
            _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, channel_monitors_conv_16);
        });
        return ret_hu_conv;
    }
}

},{"../structs/Watch.mjs":"2Clil","../structs/BroadcasterInterface.mjs":"6EF7s","../structs/KeysInterface.mjs":"2q459","../structs/FeeEstimator.mjs":"b4XTq","../structs/Logger.mjs":"2M89o","../structs/UserConfig.mjs":"io87u","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f6CxA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Proof that the sender knows the per-commitment secret of the previous commitment transaction.
 * This is used to convince the recipient that the channel is at a certain commitment
 * number even if they lost that data due to a local failure.  Of course, the peer may lie
 * and even later commitments may have been revoked.
 */ parcelHelpers.export(exports, "DataLossProtect", ()=>DataLossProtect
) //# sourceMappingURL=DataLossProtect.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class DataLossProtect extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.DataLossProtect_free);
    }
    /**
     * Proof that the sender knows the per-commitment secret of a specific commitment transaction
     * belonging to the recipient
     */ get_your_last_per_commitment_secret() {
        const ret = _bindingsMjs.DataLossProtect_get_your_last_per_commitment_secret(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Proof that the sender knows the per-commitment secret of a specific commitment transaction
     * belonging to the recipient
     */ set_your_last_per_commitment_secret(val) {
        _bindingsMjs.DataLossProtect_set_your_last_per_commitment_secret(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 32)));
    }
    /**
     * The sender's per-commitment point for their current commitment transaction
     */ get_my_current_per_commitment_point() {
        const ret = _bindingsMjs.DataLossProtect_get_my_current_per_commitment_point(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The sender's per-commitment point for their current commitment transaction
     */ set_my_current_per_commitment_point(val) {
        _bindingsMjs.DataLossProtect_set_my_current_per_commitment_point(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(val, 33)));
    }
    /**
     * Constructs a new DataLossProtect given each field
     */ static constructor_new(your_last_per_commitment_secret_arg, my_current_per_commitment_point_arg) {
        const ret = _bindingsMjs.DataLossProtect_new(_bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(your_last_per_commitment_secret_arg, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(my_current_per_commitment_point_arg, 33)));
        const ret_hu_conv = new DataLossProtect(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = _bindingsMjs.DataLossProtect_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the DataLossProtect
     */ clone() {
        const ret = _bindingsMjs.DataLossProtect_clone(this.ptr);
        const ret_hu_conv = new DataLossProtect(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fuLD4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A trait to describe an object which can receive routing messages.
 *
 * # Implementor DoS Warnings
 *
 * For `gossip_queries` messages there are potential DoS vectors when handling
 * inbound queries. Implementors using an on-disk network graph should be aware of
 * repeated disk I/O for queries accessing different parts of the network graph.
 */ parcelHelpers.export(exports, "RoutingMessageHandler", ()=>RoutingMessageHandler
) //# sourceMappingURL=RoutingMessageHandler.mjs.map
;
var _channelUpdateMjs = require("../structs/ChannelUpdate.mjs");
var _resultNoneLightningErrorZMjs = require("../structs/Result_NoneLightningErrorZ.mjs");
var _channelAnnouncementMjs = require("../structs/ChannelAnnouncement.mjs");
var _nodeAnnouncementMjs = require("../structs/NodeAnnouncement.mjs");
var _queryChannelRangeMjs = require("../structs/QueryChannelRange.mjs");
var _queryShortChannelIdsMjs = require("../structs/QueryShortChannelIds.mjs");
var _replyChannelRangeMjs = require("../structs/ReplyChannelRange.mjs");
var _resultBoolLightningErrorZMjs = require("../structs/Result_boolLightningErrorZ.mjs");
var _threeTupleChannelAnnouncementChannelUpdateChannelUpdateZMjs = require("../structs/ThreeTuple_ChannelAnnouncementChannelUpdateChannelUpdateZ.mjs");
var _initMjs = require("../structs/Init.mjs");
var _replyShortChannelIdsEndMjs = require("../structs/ReplyShortChannelIdsEnd.mjs");
var _messageSendEventsProviderMjs = require("../structs/MessageSendEventsProvider.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKRoutingMessageHandlerHolder {
}
class RoutingMessageHandler extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.RoutingMessageHandler_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of RoutingMessageHandler from a given implementation */ static new_impl(arg, messageSendEventsProvider_impl) {
        const impl_holder = new LDKRoutingMessageHandlerHolder();
        let structImplementation = {
            handle_node_announcement (msg) {
                const msg_hu_conv = new _nodeAnnouncementMjs.NodeAnnouncement(null, msg);
                const ret = arg.handle_node_announcement(msg_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            handle_channel_announcement (msg) {
                const msg_hu_conv = new _channelAnnouncementMjs.ChannelAnnouncement(null, msg);
                const ret = arg.handle_channel_announcement(msg_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            handle_channel_update (msg) {
                const msg_hu_conv = new _channelUpdateMjs.ChannelUpdate(null, msg);
                const ret = arg.handle_channel_update(msg_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            get_next_channel_announcements (starting_point, batch_amount) {
                const ret = arg.get_next_channel_announcements(starting_point, batch_amount);
                const result = _bindingsMjs.encodeUint32Array(ret != null ? ret.map((ret_conv_59)=>ret_conv_59 == null ? 0 : ret_conv_59.clone_ptr()
                ) : null);
                return result;
            },
            get_next_node_announcements (starting_point, batch_amount) {
                const starting_point_conv = _bindingsMjs.decodeUint8Array(starting_point);
                const ret = arg.get_next_node_announcements(starting_point_conv, batch_amount);
                const result = _bindingsMjs.encodeUint32Array(ret != null ? ret.map((ret_conv_18)=>ret_conv_18 == null ? 0 : ret_conv_18.clone_ptr()
                ) : null);
                return result;
            },
            sync_routing_table (their_node_id, init) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const init_hu_conv = new _initMjs.Init(null, init);
                arg.sync_routing_table(their_node_id_conv, init_hu_conv);
            },
            handle_reply_channel_range (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _replyChannelRangeMjs.ReplyChannelRange(null, msg);
                _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
                const ret = arg.handle_reply_channel_range(their_node_id_conv, msg_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            handle_reply_short_channel_ids_end (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _replyShortChannelIdsEndMjs.ReplyShortChannelIdsEnd(null, msg);
                _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
                const ret = arg.handle_reply_short_channel_ids_end(their_node_id_conv, msg_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            handle_query_channel_range (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _queryChannelRangeMjs.QueryChannelRange(null, msg);
                _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
                const ret = arg.handle_query_channel_range(their_node_id_conv, msg_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            handle_query_short_channel_ids (their_node_id, msg) {
                const their_node_id_conv = _bindingsMjs.decodeUint8Array(their_node_id);
                const msg_hu_conv = new _queryShortChannelIdsMjs.QueryShortChannelIds(null, msg);
                _commonBaseMjsDefault.default.add_ref_from(msg_hu_conv, this);
                const ret = arg.handle_query_short_channel_ids(their_node_id_conv, msg_hu_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            }
        };
        const messageSendEventsProvider = _messageSendEventsProviderMjs.MessageSendEventsProvider.new_impl(messageSendEventsProvider_impl);
        const ptr = _bindingsMjs.LDKRoutingMessageHandler_new(structImplementation, messageSendEventsProvider.bindings_instance);
        impl_holder.held = new RoutingMessageHandler(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        impl_holder.held.ptrs_to.push(messageSendEventsProvider);
        return impl_holder.held;
    }
    /**
     * Handle an incoming node_announcement message, returning true if it should be forwarded on,
     * false or returning an Err otherwise.
     */ handle_node_announcement(msg) {
        const ret = _bindingsMjs.RoutingMessageHandler_handle_node_announcement(this.ptr, msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = _resultBoolLightningErrorZMjs.Result_boolLightningErrorZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
        return ret_hu_conv;
    }
    /**
     * Handle a channel_announcement message, returning true if it should be forwarded on, false
     * or returning an Err otherwise.
     */ handle_channel_announcement(msg) {
        const ret = _bindingsMjs.RoutingMessageHandler_handle_channel_announcement(this.ptr, msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = _resultBoolLightningErrorZMjs.Result_boolLightningErrorZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
        return ret_hu_conv;
    }
    /**
     * Handle an incoming channel_update message, returning true if it should be forwarded on,
     * false or returning an Err otherwise.
     */ handle_channel_update(msg) {
        const ret = _bindingsMjs.RoutingMessageHandler_handle_channel_update(this.ptr, msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = _resultBoolLightningErrorZMjs.Result_boolLightningErrorZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
        return ret_hu_conv;
    }
    /**
     * Gets a subset of the channel announcements and updates required to dump our routing table
     * to a remote node, starting at the short_channel_id indicated by starting_point and
     * including the batch_amount entries immediately higher in numerical value than starting_point.
     */ get_next_channel_announcements(starting_point, batch_amount) {
        const ret = _bindingsMjs.RoutingMessageHandler_get_next_channel_announcements(this.ptr, starting_point, batch_amount);
        const ret_conv_59_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_59_arr = new Array(ret_conv_59_len).fill(null);
        for(var h = 0; h < ret_conv_59_len; h++){
            const ret_conv_59 = _bindingsMjs.getU32ArrayElem(ret, h);
            const ret_conv_59_hu_conv = new _threeTupleChannelAnnouncementChannelUpdateChannelUpdateZMjs.ThreeTuple_ChannelAnnouncementChannelUpdateChannelUpdateZ(null, ret_conv_59);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_59_hu_conv, this);
            ret_conv_59_arr[h] = ret_conv_59_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_59_arr;
    }
    /**
     * Gets a subset of the node announcements required to dump our routing table to a remote node,
     * starting at the node *after* the provided publickey and including batch_amount entries
     * immediately higher (as defined by <PublicKey as Ord>::cmp) than starting_point.
     * If None is provided for starting_point, we start at the first node.
     *
     * Note that starting_point (or a relevant inner pointer) may be NULL or all-0s to represent None
     */ get_next_node_announcements(starting_point, batch_amount) {
        const ret = _bindingsMjs.RoutingMessageHandler_get_next_node_announcements(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(starting_point, 33)), batch_amount);
        const ret_conv_18_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_18_arr = new Array(ret_conv_18_len).fill(null);
        for(var s = 0; s < ret_conv_18_len; s++){
            const ret_conv_18 = _bindingsMjs.getU32ArrayElem(ret, s);
            const ret_conv_18_hu_conv = new _nodeAnnouncementMjs.NodeAnnouncement(null, ret_conv_18);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_18_hu_conv, this);
            ret_conv_18_arr[s] = ret_conv_18_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_18_arr;
    }
    /**
     * Called when a connection is established with a peer. This can be used to
     * perform routing table synchronization using a strategy defined by the
     * implementor.
     */ sync_routing_table(their_node_id, init) {
        _bindingsMjs.RoutingMessageHandler_sync_routing_table(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), init == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(init) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, init);
    }
    /**
     * Handles the reply of a query we initiated to learn about channels
     * for a given range of blocks. We can expect to receive one or more
     * replies to a single query.
     */ handle_reply_channel_range(their_node_id, msg) {
        const ret = _bindingsMjs.RoutingMessageHandler_handle_reply_channel_range(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = _resultNoneLightningErrorZMjs.Result_NoneLightningErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Handles the reply of a query we initiated asking for routing gossip
     * messages for a list of channels. We should receive this message when
     * a node has completed its best effort to send us the pertaining routing
     * gossip messages.
     */ handle_reply_short_channel_ids_end(their_node_id, msg) {
        const ret = _bindingsMjs.RoutingMessageHandler_handle_reply_short_channel_ids_end(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = _resultNoneLightningErrorZMjs.Result_NoneLightningErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Handles when a peer asks us to send a list of short_channel_ids
     * for the requested range of blocks.
     */ handle_query_channel_range(their_node_id, msg) {
        const ret = _bindingsMjs.RoutingMessageHandler_handle_query_channel_range(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = _resultNoneLightningErrorZMjs.Result_NoneLightningErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Handles when a peer asks us to send routing gossip messages for a
     * list of short_channel_ids.
     */ handle_query_short_channel_ids(their_node_id, msg) {
        const ret = _bindingsMjs.RoutingMessageHandler_handle_query_short_channel_ids(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg) & -2);
        const ret_hu_conv = _resultNoneLightningErrorZMjs.Result_NoneLightningErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/ChannelUpdate.mjs":"kLaF6","../structs/Result_NoneLightningErrorZ.mjs":"TA9p3","../structs/ChannelAnnouncement.mjs":"5JqYl","../structs/NodeAnnouncement.mjs":"549dY","../structs/QueryChannelRange.mjs":"83Xki","../structs/QueryShortChannelIds.mjs":"1G6O6","../structs/ReplyChannelRange.mjs":"l9iKG","../structs/Result_boolLightningErrorZ.mjs":"9hmM8","../structs/ThreeTuple_ChannelAnnouncementChannelUpdateChannelUpdateZ.mjs":"jVg18","../structs/Init.mjs":"9tT7T","../structs/ReplyShortChannelIdsEnd.mjs":"02mnG","../structs/MessageSendEventsProvider.mjs":"U83N1","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4zR6V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Trait to be implemented by custom message (unrelated to the channel/gossip LN layers)
 * decoders.
 */ parcelHelpers.export(exports, "CustomMessageReader", ()=>CustomMessageReader
) //# sourceMappingURL=CustomMessageReader.mjs.map
;
var _resultCOptionTypeZDecodeErrorZMjs = require("../structs/Result_COption_TypeZDecodeErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKCustomMessageReaderHolder {
}
class CustomMessageReader extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CustomMessageReader_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of CustomMessageReader from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKCustomMessageReaderHolder();
        let structImplementation = {
            read (message_type, buffer) {
                const buffer_conv = _bindingsMjs.decodeUint8Array(buffer);
                const ret = arg.read(message_type, buffer_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            }
        };
        const ptr = _bindingsMjs.LDKCustomMessageReader_new(structImplementation);
        impl_holder.held = new CustomMessageReader(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Decodes a custom message to `CustomMessageType`. If the given message type is known to the
     * implementation and the message could be decoded, must return `Ok(Some(message))`. If the
     * message type is unknown to the implementation, must return `Ok(None)`. If a decoding error
     * occur, must return `Err(DecodeError::X)` where `X` details the encountered error.
     */ read(message_type, buffer) {
        const ret = _bindingsMjs.CustomMessageReader_read(this.ptr, message_type, _bindingsMjs.encodeUint8Array(buffer));
        const ret_hu_conv = _resultCOptionTypeZDecodeErrorZMjs.Result_COption_TypeZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}

},{"../structs/Result_COption_TypeZDecodeErrorZ.mjs":"72w3O","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"go7eV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Handler for BOLT1-compliant messages.
 */ parcelHelpers.export(exports, "CustomMessageHandler", ()=>CustomMessageHandler
) //# sourceMappingURL=CustomMessageHandler.mjs.map
;
var _typeMjs = require("../structs/Type.mjs");
var _resultNoneLightningErrorZMjs = require("../structs/Result_NoneLightningErrorZ.mjs");
var _twoTuplePublicKeyTypeZMjs = require("../structs/TwoTuple_PublicKeyTypeZ.mjs");
var _customMessageReaderMjs = require("../structs/CustomMessageReader.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKCustomMessageHandlerHolder {
}
class CustomMessageHandler extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.CustomMessageHandler_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of CustomMessageHandler from a given implementation */ static new_impl(arg, customMessageReader_impl) {
        const impl_holder = new LDKCustomMessageHandlerHolder();
        let structImplementation = {
            handle_custom_message (msg, sender_node_id) {
                const ret_hu_conv = new _typeMjs.Type(null, msg);
                _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
                const sender_node_id_conv = _bindingsMjs.decodeUint8Array(sender_node_id);
                const ret = arg.handle_custom_message(ret_hu_conv, sender_node_id_conv);
                const result = ret == null ? 0 : ret.clone_ptr();
                return result;
            },
            get_and_clear_pending_msg () {
                const ret = arg.get_and_clear_pending_msg();
                const result = _bindingsMjs.encodeUint32Array(ret != null ? ret.map((ret_conv_25)=>ret_conv_25 == null ? 0 : ret_conv_25.clone_ptr()
                ) : null);
                return result;
            }
        };
        const customMessageReader = _customMessageReaderMjs.CustomMessageReader.new_impl(customMessageReader_impl);
        const ptr = _bindingsMjs.LDKCustomMessageHandler_new(structImplementation, customMessageReader.bindings_instance);
        impl_holder.held = new CustomMessageHandler(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        impl_holder.held.ptrs_to.push(customMessageReader);
        return impl_holder.held;
    }
    /**
     * Called with the message type that was received and the buffer to be read.
     * Can return a `MessageHandlingError` if the message could not be handled.
     */ handle_custom_message(msg, sender_node_id) {
        const ret = _bindingsMjs.CustomMessageHandler_handle_custom_message(this.ptr, msg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(msg), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(sender_node_id, 33)));
        const ret_hu_conv = _resultNoneLightningErrorZMjs.Result_NoneLightningErrorZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, msg);
        return ret_hu_conv;
    }
    /**
     * Gets the list of pending messages which were generated by the custom message
     * handler, clearing the list in the process. The first tuple element must
     * correspond to the intended recipients node ids. If no connection to one of the
     * specified node does not exist, the message is simply not sent to it.
     */ get_and_clear_pending_msg() {
        const ret = _bindingsMjs.CustomMessageHandler_get_and_clear_pending_msg(this.ptr);
        const ret_conv_25_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_25_arr = new Array(ret_conv_25_len).fill(null);
        for(var z = 0; z < ret_conv_25_len; z++){
            const ret_conv_25 = _bindingsMjs.getU32ArrayElem(ret, z);
            const ret_conv_25_hu_conv = new _twoTuplePublicKeyTypeZMjs.TwoTuple_PublicKeyTypeZ(null, ret_conv_25);
            _commonBaseMjsDefault.default.add_ref_from(ret_conv_25_hu_conv, this);
            ret_conv_25_arr[z] = ret_conv_25_hu_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_25_arr;
    }
}

},{"../structs/Type.mjs":"co77s","../structs/Result_NoneLightningErrorZ.mjs":"TA9p3","../structs/TwoTuple_PublicKeyTypeZ.mjs":"cA97j","../structs/CustomMessageReader.mjs":"4zR6V","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4poqg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A dummy struct which implements `RoutingMessageHandler` without storing any routing information
 * or doing any processing. You can provide one of these as the route_handler in a MessageHandler.
 */ parcelHelpers.export(exports, "IgnoringMessageHandler", ()=>IgnoringMessageHandler
) //# sourceMappingURL=IgnoringMessageHandler.mjs.map
;
var _messageSendEventsProviderMjs = require("../structs/MessageSendEventsProvider.mjs");
var _routingMessageHandlerMjs = require("../structs/RoutingMessageHandler.mjs");
var _customMessageReaderMjs = require("../structs/CustomMessageReader.mjs");
var _customMessageHandlerMjs = require("../structs/CustomMessageHandler.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class IgnoringMessageHandler extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.IgnoringMessageHandler_free);
    }
    /**
     * Constructs a new IgnoringMessageHandler given each field
     */ static constructor_new() {
        const ret = _bindingsMjs.IgnoringMessageHandler_new();
        const ret_hu_conv = new IgnoringMessageHandler(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
     */ as_MessageSendEventsProvider() {
        const ret = _bindingsMjs.IgnoringMessageHandler_as_MessageSendEventsProvider(this.ptr);
        const ret_hu_conv = new _messageSendEventsProviderMjs.MessageSendEventsProvider(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new RoutingMessageHandler which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned RoutingMessageHandler must be freed before this_arg is
     */ as_RoutingMessageHandler() {
        const ret = _bindingsMjs.IgnoringMessageHandler_as_RoutingMessageHandler(this.ptr);
        const ret_hu_conv = new _routingMessageHandlerMjs.RoutingMessageHandler(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new CustomMessageReader which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned CustomMessageReader must be freed before this_arg is
     */ as_CustomMessageReader() {
        const ret = _bindingsMjs.IgnoringMessageHandler_as_CustomMessageReader(this.ptr);
        const ret_hu_conv = new _customMessageReaderMjs.CustomMessageReader(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new CustomMessageHandler which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned CustomMessageHandler must be freed before this_arg is
     */ as_CustomMessageHandler() {
        const ret = _bindingsMjs.IgnoringMessageHandler_as_CustomMessageHandler(this.ptr);
        const ret_hu_conv = new _customMessageHandlerMjs.CustomMessageHandler(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"../structs/MessageSendEventsProvider.mjs":"U83N1","../structs/RoutingMessageHandler.mjs":"fuLD4","../structs/CustomMessageReader.mjs":"4zR6V","../structs/CustomMessageHandler.mjs":"go7eV","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6dE1s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A dummy struct which implements `ChannelMessageHandler` without having any channels.
 * You can provide one of these as the route_handler in a MessageHandler.
 */ parcelHelpers.export(exports, "ErroringMessageHandler", ()=>ErroringMessageHandler
) //# sourceMappingURL=ErroringMessageHandler.mjs.map
;
var _messageSendEventsProviderMjs = require("../structs/MessageSendEventsProvider.mjs");
var _channelMessageHandlerMjs = require("../structs/ChannelMessageHandler.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class ErroringMessageHandler extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.ErroringMessageHandler_free);
    }
    /**
     * Constructs a new ErroringMessageHandler
     */ static constructor_new() {
        const ret = _bindingsMjs.ErroringMessageHandler_new();
        const ret_hu_conv = new ErroringMessageHandler(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
     */ as_MessageSendEventsProvider() {
        const ret = _bindingsMjs.ErroringMessageHandler_as_MessageSendEventsProvider(this.ptr);
        const ret_hu_conv = new _messageSendEventsProviderMjs.MessageSendEventsProvider(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
     */ as_ChannelMessageHandler() {
        const ret = _bindingsMjs.ErroringMessageHandler_as_ChannelMessageHandler(this.ptr);
        const ret_hu_conv = new _channelMessageHandlerMjs.ChannelMessageHandler(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"../structs/MessageSendEventsProvider.mjs":"U83N1","../structs/ChannelMessageHandler.mjs":"dr4Tk","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9A6Xs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Provides references to trait impls which handle different types of messages.
 */ parcelHelpers.export(exports, "MessageHandler", ()=>MessageHandler
) //# sourceMappingURL=MessageHandler.mjs.map
;
var _channelMessageHandlerMjs = require("../structs/ChannelMessageHandler.mjs");
var _routingMessageHandlerMjs = require("../structs/RoutingMessageHandler.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class MessageHandler extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.MessageHandler_free);
    }
    /**
     * A message handler which handles messages specific to channels. Usually this is just a
     * [`ChannelManager`] object or an [`ErroringMessageHandler`].
     *
     * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
     */ get_chan_handler() {
        const ret = _bindingsMjs.MessageHandler_get_chan_handler(this.ptr);
        const ret_hu_conv = new _channelMessageHandlerMjs.ChannelMessageHandler(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * A message handler which handles messages specific to channels. Usually this is just a
     * [`ChannelManager`] object or an [`ErroringMessageHandler`].
     *
     * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
     */ set_chan_handler(val) {
        _bindingsMjs.MessageHandler_set_chan_handler(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val));
        _commonBaseMjsDefault.default.add_ref_from(this, val);
    }
    /**
     * A message handler which handles messages updating our knowledge of the network channel
     * graph. Usually this is just a [`NetGraphMsgHandler`] object or an
     * [`IgnoringMessageHandler`].
     *
     * [`NetGraphMsgHandler`]: crate::routing::network_graph::NetGraphMsgHandler
     */ get_route_handler() {
        const ret = _bindingsMjs.MessageHandler_get_route_handler(this.ptr);
        const ret_hu_conv = new _routingMessageHandlerMjs.RoutingMessageHandler(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * A message handler which handles messages updating our knowledge of the network channel
     * graph. Usually this is just a [`NetGraphMsgHandler`] object or an
     * [`IgnoringMessageHandler`].
     *
     * [`NetGraphMsgHandler`]: crate::routing::network_graph::NetGraphMsgHandler
     */ set_route_handler(val) {
        _bindingsMjs.MessageHandler_set_route_handler(this.ptr, val == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(val));
        _commonBaseMjsDefault.default.add_ref_from(this, val);
    }
    /**
     * Constructs a new MessageHandler given each field
     */ static constructor_new(chan_handler_arg, route_handler_arg) {
        const ret = _bindingsMjs.MessageHandler_new(chan_handler_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(chan_handler_arg), route_handler_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(route_handler_arg));
        const ret_hu_conv = new MessageHandler(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, chan_handler_arg);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, route_handler_arg);
        return ret_hu_conv;
    }
}

},{"../structs/ChannelMessageHandler.mjs":"dr4Tk","../structs/RoutingMessageHandler.mjs":"fuLD4","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iE7AM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Provides an object which can be used to send data to and which uniquely identifies a connection
 * to a remote host. You will need to be able to generate multiple of these which meet Eq and
 * implement Hash to meet the PeerManager API.
 *
 * For efficiency, Clone should be relatively cheap for this type.
 *
 * Two descriptors may compare equal (by [`cmp::Eq`] and [`hash::Hash`]) as long as the original
 * has been disconnected, the [`PeerManager`] has been informed of the disconnection (either by it
 * having triggered the disconnection or a call to [`PeerManager::socket_disconnected`]), and no
 * further calls to the [`PeerManager`] related to the original socket occur. This allows you to
 * use a file descriptor for your SocketDescriptor directly, however for simplicity you may wish
 * to simply use another value which is guaranteed to be globally unique instead.
 */ parcelHelpers.export(exports, "SocketDescriptor", ()=>SocketDescriptor
) //# sourceMappingURL=SocketDescriptor.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKSocketDescriptorHolder {
}
class SocketDescriptor extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.SocketDescriptor_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of SocketDescriptor from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKSocketDescriptorHolder();
        let structImplementation = {
            send_data (data, resume_read) {
                const data_conv = _bindingsMjs.decodeUint8Array(data);
                const ret = arg.send_data(data_conv, resume_read);
                return ret;
            },
            disconnect_socket () {
                arg.disconnect_socket();
            },
            eq (other_arg) {
                const ret_hu_conv = new SocketDescriptor(null, other_arg);
                _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
                const ret = arg.eq(ret_hu_conv);
                return ret;
            },
            hash () {
                const ret = arg.hash();
                return ret;
            }
        };
        const ptr = _bindingsMjs.LDKSocketDescriptor_new(structImplementation);
        impl_holder.held = new SocketDescriptor(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Attempts to send some data from the given slice to the peer.
     *
     * Returns the amount of data which was sent, possibly 0 if the socket has since disconnected.
     * Note that in the disconnected case, [`PeerManager::socket_disconnected`] must still be
     * called and further write attempts may occur until that time.
     *
     * If the returned size is smaller than `data.len()`, a
     * [`PeerManager::write_buffer_space_avail`] call must be made the next time more data can be
     * written. Additionally, until a `send_data` event completes fully, no further
     * [`PeerManager::read_event`] calls should be made for the same peer! Because this is to
     * prevent denial-of-service issues, you should not read or buffer any data from the socket
     * until then.
     *
     * If a [`PeerManager::read_event`] call on this descriptor had previously returned true
     * (indicating that read events should be paused to prevent DoS in the send buffer),
     * `resume_read` may be set indicating that read events on this descriptor should resume. A
     * `resume_read` of false carries no meaning, and should not cause any action.
     */ send_data(data, resume_read) {
        const ret = _bindingsMjs.SocketDescriptor_send_data(this.ptr, _bindingsMjs.encodeUint8Array(data), resume_read);
        return ret;
    }
    /**
     * Disconnect the socket pointed to by this SocketDescriptor.
     *
     * You do *not* need to call [`PeerManager::socket_disconnected`] with this socket after this
     * call (doing so is a noop).
     */ disconnect_socket() {
        _bindingsMjs.SocketDescriptor_disconnect_socket(this.ptr);
    }
    /**
     * Calculate a succinct non-cryptographic hash for an object given its this_arg pointer.
     * This is used, for example, for inclusion of this object in a hash map.
     */ hash() {
        const ret = _bindingsMjs.SocketDescriptor_hash(this.ptr);
        return ret;
    }
    clone_ptr() {
        const ret = _bindingsMjs.SocketDescriptor_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of a SocketDescriptor
     */ clone() {
        const ret = _bindingsMjs.SocketDescriptor_clone(this.ptr);
        const ret_hu_conv = new SocketDescriptor(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1i5fd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A PeerManager manages a set of peers, described by their [`SocketDescriptor`] and marshalls
 * socket events into messages which it passes on to its [`MessageHandler`].
 *
 * Locks are taken internally, so you must never assume that reentrancy from a
 * [`SocketDescriptor`] call back into [`PeerManager`] methods will not deadlock.
 *
 * Calls to [`read_event`] will decode relevant messages and pass them to the
 * [`ChannelMessageHandler`], likely doing message processing in-line. Thus, the primary form of
 * parallelism in Rust-Lightning is in calls to [`read_event`]. Note, however, that calls to any
 * [`PeerManager`] functions related to the same connection must occur only in serial, making new
 * calls only after previous ones have returned.
 *
 * Rather than using a plain PeerManager, it is preferable to use either a SimpleArcPeerManager
 * a SimpleRefPeerManager, for conciseness. See their documentation for more details, but
 * essentially you should default to using a SimpleRefPeerManager, and use a
 * SimpleArcPeerManager when you require a PeerManager with a static lifetime, such as when
 * you're using lightning-net-tokio.
 *
 * [`read_event`]: PeerManager::read_event
 */ parcelHelpers.export(exports, "PeerManager", ()=>PeerManager
) //# sourceMappingURL=PeerManager.mjs.map
;
var _resultCVecU8ZPeerHandleErrorZMjs = require("../structs/Result_CVec_u8ZPeerHandleErrorZ.mjs");
var _resultNonePeerHandleErrorZMjs = require("../structs/Result_NonePeerHandleErrorZ.mjs");
var _resultBoolPeerHandleErrorZMjs = require("../structs/Result_boolPeerHandleErrorZ.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class PeerManager extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.PeerManager_free);
    }
    /**
     * Constructs a new PeerManager with the given message handlers and node_id secret key
     * ephemeral_random_data is used to derive per-connection ephemeral keys and must be
     * cryptographically secure random bytes.
     */ static constructor_new(message_handler_chan_handler_arg, message_handler_route_handler_arg, our_node_secret, ephemeral_random_data, logger, custom_message_handler) {
        const ret = _bindingsMjs.PeerManager_new(_bindingsMjs.MessageHandler_new(message_handler_chan_handler_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(message_handler_chan_handler_arg), message_handler_route_handler_arg == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(message_handler_route_handler_arg)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(our_node_secret, 32)), _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(ephemeral_random_data, 32)), logger == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(logger), custom_message_handler == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(custom_message_handler));
        const ret_hu_conv = new PeerManager(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, message_handler_chan_handler_arg);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, message_handler_route_handler_arg);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, logger);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, custom_message_handler);
        return ret_hu_conv;
    }
    /**
     * Get the list of node ids for peers which have completed the initial handshake.
     *
     * For outbound connections, this will be the same as the their_node_id parameter passed in to
     * new_outbound_connection, however entries will only appear once the initial handshake has
     * completed and we are sure the remote peer has the private key for the given node_id.
     */ get_peer_node_ids() {
        const ret = _bindingsMjs.PeerManager_get_peer_node_ids(this.ptr);
        const ret_conv_12_len = _bindingsMjs.getArrayLength(ret);
        const ret_conv_12_arr = new Array(ret_conv_12_len).fill(null);
        for(var m = 0; m < ret_conv_12_len; m++){
            const ret_conv_12 = _bindingsMjs.getU32ArrayElem(ret, m);
            const ret_conv_12_conv = _bindingsMjs.decodeUint8Array(ret_conv_12);
            ret_conv_12_arr[m] = ret_conv_12_conv;
        }
        _bindingsMjs.freeWasmMemory(ret);
        return ret_conv_12_arr;
    }
    /**
     * Indicates a new outbound connection has been established to a node with the given node_id.
     * Note that if an Err is returned here you MUST NOT call socket_disconnected for the new
     * descriptor but must disconnect the connection immediately.
     *
     * Returns a small number of bytes to send to the remote node (currently always 50).
     *
     * Panics if descriptor is duplicative with some other descriptor which has not yet been
     * [`socket_disconnected()`].
     *
     * [`socket_disconnected()`]: PeerManager::socket_disconnected
     */ new_outbound_connection(their_node_id, descriptor) {
        const ret = _bindingsMjs.PeerManager_new_outbound_connection(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(their_node_id, 33)), descriptor == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(descriptor));
        const ret_hu_conv = _resultCVecU8ZPeerHandleErrorZMjs.Result_CVec_u8ZPeerHandleErrorZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, descriptor);
        return ret_hu_conv;
    }
    /**
     * Indicates a new inbound connection has been established.
     *
     * May refuse the connection by returning an Err, but will never write bytes to the remote end
     * (outbound connector always speaks first). Note that if an Err is returned here you MUST NOT
     * call socket_disconnected for the new descriptor but must disconnect the connection
     * immediately.
     *
     * Panics if descriptor is duplicative with some other descriptor which has not yet been
     * [`socket_disconnected()`].
     *
     * [`socket_disconnected()`]: PeerManager::socket_disconnected
     */ new_inbound_connection(descriptor) {
        const ret = _bindingsMjs.PeerManager_new_inbound_connection(this.ptr, descriptor == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(descriptor));
        const ret_hu_conv = _resultNonePeerHandleErrorZMjs.Result_NonePeerHandleErrorZ.constr_from_ptr(ret);
        _commonBaseMjsDefault.default.add_ref_from(this, descriptor);
        return ret_hu_conv;
    }
    /**
     * Indicates that there is room to write data to the given socket descriptor.
     *
     * May return an Err to indicate that the connection should be closed.
     *
     * May call [`send_data`] on the descriptor passed in (or an equal descriptor) before
     * returning. Thus, be very careful with reentrancy issues! The invariants around calling
     * [`write_buffer_space_avail`] in case a write did not fully complete must still hold - be
     * ready to call `[write_buffer_space_avail`] again if a write call generated here isn't
     * sufficient!
     *
     * [`send_data`]: SocketDescriptor::send_data
     * [`write_buffer_space_avail`]: PeerManager::write_buffer_space_avail
     */ write_buffer_space_avail(descriptor) {
        const ret = _bindingsMjs.PeerManager_write_buffer_space_avail(this.ptr, descriptor == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(descriptor));
        const ret_hu_conv = _resultNonePeerHandleErrorZMjs.Result_NonePeerHandleErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Indicates that data was read from the given socket descriptor.
     *
     * May return an Err to indicate that the connection should be closed.
     *
     * Will *not* call back into [`send_data`] on any descriptors to avoid reentrancy complexity.
     * Thus, however, you should call [`process_events`] after any `read_event` to generate
     * [`send_data`] calls to handle responses.
     *
     * If `Ok(true)` is returned, further read_events should not be triggered until a
     * [`send_data`] call on this descriptor has `resume_read` set (preventing DoS issues in the
     * send buffer).
     *
     * [`send_data`]: SocketDescriptor::send_data
     * [`process_events`]: PeerManager::process_events
     */ read_event(peer_descriptor, data) {
        const ret = _bindingsMjs.PeerManager_read_event(this.ptr, peer_descriptor == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(peer_descriptor), _bindingsMjs.encodeUint8Array(data));
        const ret_hu_conv = _resultBoolPeerHandleErrorZMjs.Result_boolPeerHandleErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Checks for any events generated by our handlers and processes them. Includes sending most
     * response messages as well as messages generated by calls to handler functions directly (eg
     * functions like [`ChannelManager::process_pending_htlc_forwards`] or [`send_payment`]).
     *
     * May call [`send_data`] on [`SocketDescriptor`]s. Thus, be very careful with reentrancy
     * issues!
     *
     * You don't have to call this function explicitly if you are using [`lightning-net-tokio`]
     * or one of the other clients provided in our language bindings.
     *
     * [`send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
     * [`ChannelManager::process_pending_htlc_forwards`]: crate::ln::channelmanager::ChannelManager::process_pending_htlc_forwards
     * [`send_data`]: SocketDescriptor::send_data
     */ process_events() {
        _bindingsMjs.PeerManager_process_events(this.ptr);
    }
    /**
     * Indicates that the given socket descriptor's connection is now closed.
     */ socket_disconnected(descriptor) {
        _bindingsMjs.PeerManager_socket_disconnected(this.ptr, descriptor == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(descriptor));
    }
    /**
     * Disconnect a peer given its node id.
     *
     * Set `no_connection_possible` to true to prevent any further connection with this peer,
     * force-closing any channels we have with it.
     *
     * If a peer is connected, this will call [`disconnect_socket`] on the descriptor for the
     * peer. Thus, be very careful about reentrancy issues.
     *
     * [`disconnect_socket`]: SocketDescriptor::disconnect_socket
     */ disconnect_by_node_id(node_id, no_connection_possible) {
        _bindingsMjs.PeerManager_disconnect_by_node_id(this.ptr, _bindingsMjs.encodeUint8Array(_bindingsMjs.check_arr_len(node_id, 33)), no_connection_possible);
    }
    /**
     * Disconnects all currently-connected peers. This is useful on platforms where there may be
     * an indication that TCP sockets have stalled even if we weren't around to time them out
     * using regular ping/pongs.
     */ disconnect_all_peers() {
        _bindingsMjs.PeerManager_disconnect_all_peers(this.ptr);
    }
    /**
     * Send pings to each peer and disconnect those which did not respond to the last round of
     * pings.
     *
     * This may be called on any timescale you want, however, roughly once every five to ten
     * seconds is preferred. The call rate determines both how often we send a ping to our peers
     * and how much time they have to respond before we disconnect them.
     *
     * May call [`send_data`] on all [`SocketDescriptor`]s. Thus, be very careful with reentrancy
     * issues!
     *
     * [`send_data`]: SocketDescriptor::send_data
     */ timer_tick_occurred() {
        _bindingsMjs.PeerManager_timer_tick_occurred(this.ptr);
    }
}

},{"../structs/Result_CVec_u8ZPeerHandleErrorZ.mjs":"82ISC","../structs/Result_NonePeerHandleErrorZ.mjs":"dB41b","../structs/Result_boolPeerHandleErrorZ.mjs":"aFPZ5","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gfr2u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Receives and validates network updates from peers,
 * stores authentic and relevant data as a network graph.
 * This network graph is then used for routing payments.
 * Provides interface to help with initial routing sync by
 * serving historical announcements.
 *
 * Serves as an [`EventHandler`] for applying updates from [`Event::PaymentPathFailed`] to the
 * [`NetworkGraph`].
 */ parcelHelpers.export(exports, "NetGraphMsgHandler", ()=>NetGraphMsgHandler
) //# sourceMappingURL=NetGraphMsgHandler.mjs.map
;
var _messageSendEventsProviderMjs = require("../structs/MessageSendEventsProvider.mjs");
var _eventHandlerMjs = require("../structs/EventHandler.mjs");
var _routingMessageHandlerMjs = require("../structs/RoutingMessageHandler.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class NetGraphMsgHandler extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.NetGraphMsgHandler_free);
    }
    /**
     * Constructs a new EventHandler which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned EventHandler must be freed before this_arg is
     */ as_EventHandler() {
        const ret = _bindingsMjs.NetGraphMsgHandler_as_EventHandler(this.ptr);
        const ret_hu_conv = new _eventHandlerMjs.EventHandler(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a new tracker of the actual state of the network of channels and nodes,
     * assuming an existing Network Graph.
     * Chain monitor is used to make sure announced channels exist on-chain,
     * channel data is correct, and that the announcement is signed with
     * channel owners' keys.
     */ static constructor_new(network_graph, chain_access, logger) {
        const ret = _bindingsMjs.NetGraphMsgHandler_new(network_graph == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(network_graph) & -2, _commonBaseMjsDefault.default.get_ptr_of(chain_access), logger == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(logger));
        const ret_hu_conv = new NetGraphMsgHandler(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, network_graph);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, chain_access);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, logger);
        return ret_hu_conv;
    }
    /**
     * Adds a provider used to check new announcements. Does not affect
     * existing announcements unless they are updated.
     * Add, update or remove the provider would replace the current one.
     */ add_chain_access(chain_access) {
        _bindingsMjs.NetGraphMsgHandler_add_chain_access(this.ptr, _commonBaseMjsDefault.default.get_ptr_of(chain_access));
        _commonBaseMjsDefault.default.add_ref_from(this, chain_access);
    }
    /**
     * Constructs a new RoutingMessageHandler which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned RoutingMessageHandler must be freed before this_arg is
     */ as_RoutingMessageHandler() {
        const ret = _bindingsMjs.NetGraphMsgHandler_as_RoutingMessageHandler(this.ptr);
        const ret_hu_conv = new _routingMessageHandlerMjs.RoutingMessageHandler(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
     */ as_MessageSendEventsProvider() {
        const ret = _bindingsMjs.NetGraphMsgHandler_as_MessageSendEventsProvider(this.ptr);
        const ret_hu_conv = new _messageSendEventsProviderMjs.MessageSendEventsProvider(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"../structs/MessageSendEventsProvider.mjs":"U83N1","../structs/EventHandler.mjs":"iL3gQ","../structs/RoutingMessageHandler.mjs":"fuLD4","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2lXHD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An interface used to score payment channels for path finding.
 *
 * \tScoring is in terms of fees willing to be paid in order to avoid routing through a channel.
 */ parcelHelpers.export(exports, "Score", ()=>Score
) //# sourceMappingURL=Score.mjs.map
;
var _optionU64ZMjs = require("../structs/Option_u64Z.mjs");
var _routeHopMjs = require("../structs/RouteHop.mjs");
var _nodeIdMjs = require("../structs/NodeId.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKScoreHolder {
}
class Score extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.Score_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of Score from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKScoreHolder();
        let structImplementation = {
            channel_penalty_msat (short_channel_id, send_amt_msat, channel_capacity_msat, source, target) {
                const channel_capacity_msat_hu_conv = _optionU64ZMjs.Option_u64Z.constr_from_ptr(channel_capacity_msat);
                _commonBaseMjsDefault.default.add_ref_from(channel_capacity_msat_hu_conv, this);
                const source_hu_conv = new _nodeIdMjs.NodeId(null, source);
                const target_hu_conv = new _nodeIdMjs.NodeId(null, target);
                const ret = arg.channel_penalty_msat(short_channel_id, send_amt_msat, channel_capacity_msat_hu_conv, source_hu_conv, target_hu_conv);
                return ret;
            },
            payment_path_failed (path, short_channel_id) {
                const path_conv_10_len = _bindingsMjs.getArrayLength(path);
                const path_conv_10_arr = new Array(path_conv_10_len).fill(null);
                for(var k = 0; k < path_conv_10_len; k++){
                    const path_conv_10 = _bindingsMjs.getU32ArrayElem(path, k);
                    const path_conv_10_hu_conv = new _routeHopMjs.RouteHop(null, path_conv_10);
                    _commonBaseMjsDefault.default.add_ref_from(path_conv_10_hu_conv, this);
                    path_conv_10_arr[k] = path_conv_10_hu_conv;
                }
                _bindingsMjs.freeWasmMemory(path);
                arg.payment_path_failed(path_conv_10_arr, short_channel_id);
            },
            payment_path_successful (path) {
                const path_conv_10_len = _bindingsMjs.getArrayLength(path);
                const path_conv_10_arr = new Array(path_conv_10_len).fill(null);
                for(var k = 0; k < path_conv_10_len; k++){
                    const path_conv_10 = _bindingsMjs.getU32ArrayElem(path, k);
                    const path_conv_10_hu_conv = new _routeHopMjs.RouteHop(null, path_conv_10);
                    _commonBaseMjsDefault.default.add_ref_from(path_conv_10_hu_conv, this);
                    path_conv_10_arr[k] = path_conv_10_hu_conv;
                }
                _bindingsMjs.freeWasmMemory(path);
                arg.payment_path_successful(path_conv_10_arr);
            },
            write () {
                const ret = arg.write();
                const result = _bindingsMjs.encodeUint8Array(ret);
                return result;
            }
        };
        const ptr = _bindingsMjs.LDKScore_new(structImplementation);
        impl_holder.held = new Score(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Returns the fee in msats willing to be paid to avoid routing `send_amt_msat` through the
     * given channel in the direction from `source` to `target`.
     *
     * The channel's capacity (less any other MPP parts which are also being considered for use in
     * the same payment) is given by `channel_capacity_msat`. It may be guessed from various
     * sources or assumed from no data at all.
     *
     * For hints provided in the invoice, we assume the channel has sufficient capacity to accept
     * the invoice's full amount, and provide a `channel_capacity_msat` of `None`. In all other
     * cases it is set to `Some`, even if we're guessing at the channel value.
     *
     * Your code should be overflow-safe through a `channel_capacity_msat` of 21 million BTC.
     */ channel_penalty_msat(short_channel_id, send_amt_msat, channel_capacity_msat, source, target) {
        const ret = _bindingsMjs.Score_channel_penalty_msat(this.ptr, short_channel_id, send_amt_msat, _commonBaseMjsDefault.default.get_ptr_of(channel_capacity_msat), source == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(source) & -2, target == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(target) & -2);
        _commonBaseMjsDefault.default.add_ref_from(this, source);
        _commonBaseMjsDefault.default.add_ref_from(this, target);
        return ret;
    }
    /**
     * Handles updating channel penalties after failing to route through a channel.
     */ payment_path_failed(path, short_channel_id) {
        _bindingsMjs.Score_payment_path_failed(this.ptr, _bindingsMjs.encodeUint32Array(path != null ? path.map((path_conv_10)=>path_conv_10 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(path_conv_10) & -2
        ) : null), short_channel_id);
    }
    /**
     * Handles updating channel penalties after successfully routing along a path.
     */ payment_path_successful(path) {
        _bindingsMjs.Score_payment_path_successful(this.ptr, _bindingsMjs.encodeUint32Array(path != null ? path.map((path_conv_10)=>path_conv_10 == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(path_conv_10) & -2
        ) : null));
    }
    /**
     * Serialize the object into a byte array
     */ write() {
        const ret = _bindingsMjs.Score_write(this.ptr);
        const ret_conv = _bindingsMjs.decodeUint8Array(ret);
        return ret_conv;
    }
}

},{"../structs/Option_u64Z.mjs":"8VC1Q","../structs/RouteHop.mjs":"hQQ4g","../structs/NodeId.mjs":"kiqkR","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9DVut":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A scorer that is accessed under a lock.
 *
 * Needed so that calls to [`Score::channel_penalty_msat`] in [`find_route`] can be made while
 * having shared ownership of a scorer but without requiring internal locking in [`Score`]
 * implementations. Internal locking would be detrimental to route finding performance and could
 * result in [`Score::channel_penalty_msat`] returning a different value for the same channel.
 *
 * [`find_route`]: crate::routing::router::find_route
 */ parcelHelpers.export(exports, "LockableScore", ()=>LockableScore
) //# sourceMappingURL=LockableScore.mjs.map
;
var _scoreMjs = require("../structs/Score.mjs");
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class LDKLockableScoreHolder {
}
class LockableScore extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.LockableScore_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of LockableScore from a given implementation */ static new_impl(arg) {
        const impl_holder = new LDKLockableScoreHolder();
        let structImplementation = {
            lock () {
                const ret = arg.lock();
                const result = ret == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(ret);
                _commonBaseMjsDefault.default.add_ref_from(impl_holder.held, ret);
                return result;
            }
        };
        const ptr = _bindingsMjs.LDKLockableScore_new(structImplementation);
        impl_holder.held = new LockableScore(null, ptr);
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Returns the locked scorer.
     */ lock() {
        const ret = _bindingsMjs.LockableScore_lock(this.ptr);
        const ret_hu_conv = new _scoreMjs.Score(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}

},{"../structs/Score.mjs":"2lXHD","./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2o3PR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A concrete implementation of [`LockableScore`] which supports multi-threading.
 */ parcelHelpers.export(exports, "MultiThreadedLockableScore", ()=>MultiThreadedLockableScore
) //# sourceMappingURL=MultiThreadedLockableScore.mjs.map
;
var _commonBaseMjs = require("./CommonBase.mjs");
var _commonBaseMjsDefault = parcelHelpers.interopDefault(_commonBaseMjs);
var _bindingsMjs = require("../bindings.mjs");
class MultiThreadedLockableScore extends _commonBaseMjsDefault.default {
    /* @internal */ constructor(_dummy, ptr){
        super(ptr, _bindingsMjs.MultiThreadedLockableScore_free);
    }
    /**
     * Creates a new [`MultiThreadedLockableScore`] given an underlying [`Score`].
     */ static constructor_new(score) {
        const ret = _bindingsMjs.MultiThreadedLockableScore_new(score == null ? 0 : _commonBaseMjsDefault.default.get_ptr_of(score));
        const ret_hu_conv = new MultiThreadedLockableScore(null, ret);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, ret_hu_conv);
        _commonBaseMjsDefault.default.add_ref_from(ret_hu_conv, score);
        return ret_hu_conv;
    }
}

},{"./CommonBase.mjs":"6QyPK","../bindings.mjs":"eLHXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["kn9T2","7nZVA","8lqZg"], "8lqZg", "parcelRequirea42a")

//# sourceMappingURL=index.975ef6c8.js.map
